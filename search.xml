<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2022/08/02/SSM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: SSM</span><br><span class="line">date: 2022-01-01 00:00:00</span><br><span class="line">tags: SSM</span><br><span class="line">categories: SSM</span><br><span class="line">comment</span><br></pre></td></tr></table></figure>



<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>ORM（Object Relational Mapping）： 对象关系映射，指的是持久化数据和实体对象的映射模式，解决面向对象与关系型数据库存在的互不匹配的现象</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-ORM%E4%BB%8B%E7%BB%8D.png"></p>
<p><strong>MyBatis</strong>：</p>
<ul>
<li><p>MyBatis 是一个优秀的基于 Java 的持久层框架，它内部封装了 JDBC，使开发者只需关注 SQL 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 Statement 等过程。</p>
</li>
<li><p>MyBatis 通过 XML 或注解的方式将要执行的各种 Statement 配置起来，并通过 Java 对象和 Statement 中 SQL 的动态参数进行映射生成最终执行的 SQL 语句。</p>
</li>
<li><p>MyBatis 框架执行 SQL 并将结果映射为 Java 对象并返回。采用 ORM 思想解决了实体和数据库映射的问题，对 JDBC 进行了封装，屏蔽了 JDBC 底层 API 的调用细节，使我们不用操作 JDBC API，就可以完成对数据库的持久化操作。</p>
</li>
</ul>
<p>MyBatis 官网地址：<a href="http://www.mybatis.org/mybatis-3/">http://www.mybatis.org/mybatis-3/</a></p>
<p>参考视频：<a href="https://space.bilibili.com/37974444/">https://space.bilibili.com/37974444/</a></p>
<hr>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><p>Resources：加载资源的工具类</p>
<ul>
<li><code>InputStream getResourceAsStream(String fileName)</code>：通过类加载器返回指定资源的字节流<ul>
<li>参数 fileName 是放在 src 的核心配置文件名：MyBatisConfig.xml</li>
</ul>
</li>
</ul>
<p>SqlSessionFactoryBuilder：构建器，用来获取 SqlSessionFactory 工厂对象</p>
<ul>
<li><code>SqlSessionFactory build(InputStream is)</code>：通过指定资源的字节输入流获取 SqlSession 工厂对象</li>
</ul>
<p>SqlSessionFactory：获取 SqlSession 构建者对象的工厂接口</p>
<ul>
<li><code>SqlSession openSession()</code>：获取 SqlSession 构建者对象，并开启手动提交事务</li>
<li><code>SqlSession openSession(boolean)</code>：获取 SqlSession 构建者对象，参数为 true 开启自动提交事务</li>
</ul>
<p>SqlSession：构建者对象接口，用于执行 SQL、管理事务、接口代理</p>
<ul>
<li>SqlSession <strong>代表和数据库的一次会话</strong>，用完必须关闭</li>
<li>SqlSession 和 Connection 一样都是非线程安全，每次使用都应该去获取新的对象</li>
</ul>
<p>注：<strong>update 数据需要提交事务，或开启默认提交</strong></p>
<p>SqlSession 常用 API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>List<E> selectList(String statement,Object parameter)</E></td>
<td>执行查询语句，返回List集合</td>
</tr>
<tr>
<td>T selectOne(String statement,Object parameter)</td>
<td>执行查询语句，返回一个结果对象</td>
</tr>
<tr>
<td>int insert(String statement,Object parameter)</td>
<td>执行新增语句，返回影响行数</td>
</tr>
<tr>
<td>int update(String statement,Object parameter)</td>
<td>执行删除语句，返回影响行数</td>
</tr>
<tr>
<td>int delete(String statement,Object parameter)</td>
<td>执行修改语句，返回影响行数</td>
</tr>
<tr>
<td>void commit()</td>
<td>提交事务</td>
</tr>
<tr>
<td>void rollback()</td>
<td>回滚事务</td>
</tr>
<tr>
<td>T getMapper(Class<T> cls)</T></td>
<td>获取指定接口的代理实现类对象</td>
</tr>
<tr>
<td>void close()</td>
<td>释放资源</td>
</tr>
</tbody></table>
<hr>
<h3 id="映射配置"><a href="#映射配置" class="headerlink" title="映射配置"></a>映射配置</h3><p>映射配置文件包含了数据和对象之间的映射关系以及要执行的 SQL 语句，放在 src 目录下</p>
<p>命名：StudentMapper.xml</p>
<ul>
<li><p>映射配置文件的文件头：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根标签：</p>
<ul>
<li><mapper>：核心根标签</mapper></li>
<li>namespace：属性，名称空间</li>
</ul>
</li>
<li><p>功能标签：</p>
<ul>
<li>&lt; select &gt;：查询功能标签</li>
<li><insert>：新增功能标签</insert></li>
<li><update>：修改功能标签</update></li>
<li><delete>：删除功能标签<ul>
<li>id：属性，唯一标识，配合名称空间使用</li>
<li>resultType：指定结果映射对象类型，和对应的方法的返回值类型（全限定名）保持一致，但是如果返回值是 List 则和其泛型保持一致</li>
<li>parameterType：指定参数映射对象类型，必须和对应的方法的参数类型（全限定名）保持一致</li>
<li><strong>statementType</strong>：可选 STATEMENT，PREPARED 或 CALLABLE，默认值：PREPARED<ul>
<li>STATEMENT：直接操作 SQL，使用 Statement 不进行预编译，获取数据：$</li>
<li>PREPARED：预处理参数，使用 PreparedStatement 进行预编译，获取数据：#</li>
<li>CALLABLE：执行存储过程，CallableStatement</li>
</ul>
</li>
</ul>
</delete></li>
</ul>
</li>
<li><p>参数获取方式：</p>
<ul>
<li><p>SQL 获取参数：<code>#&#123;属性名&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;StudentMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;selectById&quot; resultType=&quot;student&quot; parameterType=&quot;int&quot;&gt;</span><br><span class="line">		SELECT * FROM student WHERE id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;mapper/&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>强烈推荐官方文档：<a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html">https://mybatis.org/mybatis-3/zh/sqlmap-xml.html</a></p>
<hr>
<h3 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h3><p>核心配置文件包含了 MyBatis 最核心的设置和属性信息，如数据库的连接、事务、连接池信息等</p>
<p>命名：MyBatisConfig.xml</p>
<ul>
<li><p>核心配置文件的文件头：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根标签：</p>
<ul>
<li><configuration>：核心根标签</configuration></li>
</ul>
</li>
<li><p>引入连接配置文件：</p>
<ul>
<li><p><properties>： 引入数据库连接配置文件标签</properties></p>
<ul>
<li>resource：属性，指定配置文件名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;properties resource=&quot;jdbc.properties&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>调整设置</p>
<ul>
<li><settings>：可以改变 Mybatis 运行时行为</settings></li>
</ul>
</li>
<li><p>起别名：</p>
<ul>
<li><p><typeAliases>：为全类名起别名的父标签</typeAliases></p>
<ul>
<li><p><typeAlias>：为全类名起别名的子标签</typeAlias></p>
<ul>
<li>type：指定全类名      </li>
<li>alias：指定别名</li>
</ul>
</li>
<li><p><package>：为指定包下所有类起别名的子标签，别名就是类名，首字母小写</package></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--起别名--&gt;</span><br><span class="line">&lt;typeAliases&gt;</span><br><span class="line">	&lt;typeAlias type=&quot;bean.Student&quot; alias=&quot;student&quot;/&gt;</span><br><span class="line">	&lt;package name=&quot;com.seazean.bean&quot;/&gt;</span><br><span class="line">		&lt;!--二选一--&gt;</span><br><span class="line">&lt;/typeAliase&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自带别名：</p>
<table>
<thead>
<tr>
<th>别名</th>
<th>数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>java.lang.String</td>
</tr>
<tr>
<td>long</td>
<td>java.lang.Lang</td>
</tr>
<tr>
<td>int</td>
<td>java.lang.Integer</td>
</tr>
<tr>
<td>double</td>
<td>java.lang.Double</td>
</tr>
<tr>
<td>boolean</td>
<td>java.lang.Boolean</td>
</tr>
<tr>
<td>….</td>
<td>……</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>配置环境，可以配置多个标签</p>
<ul>
<li><environments>：配置数据库环境标签，default 属性指定哪个 environment</environments></li>
<li><environment>：配置数据库环境子标签，id 属性是唯一标识，与 default 对应</environment></li>
<li><transactionManager>：事务管理标签，type 属性默认 JDBC 事务</transactionManager></li>
<li><dataSoure>：数据源标签<ul>
<li>type 属性：POOLED 使用连接池（MyBatis 内置），UNPOOLED 不使用连接池</li>
</ul>
</dataSoure></li>
<li><property>：数据库连接信息标签。<ul>
<li>name 属性取值：driver，url，username，password</li>
<li>value 属性取值：与 name 对应</li>
</ul>
</property></li>
</ul>
</li>
<li><p>引入映射配置文件</p>
<ul>
<li><mappers>：引入映射配置文件标签</mappers></li>
<li><mapper>：引入映射配置文件子标签<ul>
<li>resource：属性指定映射配置文件的名称</li>
<li>url：引用网路路径或者磁盘路径下的 sql 映射文件</li>
<li>class：指定映射配置类</li>
</ul>
</mapper></li>
<li><package>：批量注册</package></li>
</ul>
</li>
</ul>
<p>参考官方文档：<a href="https://mybatis.org/mybatis-3/zh/configuration.html">https://mybatis.org/mybatis-3/zh/configuration.html</a></p>
<hr>
<h3 id="和"><a href="#和" class="headerlink" title="#{}和${}"></a>#{}和${}</h3><p><strong>#{}：</strong>占位符，传入的内容会作为字符串<strong>加上引号</strong>，以<strong>预编译</strong>的方式传入，将 sql 中的 #{} 替换为 ? 号，调用 PreparedStatement 的 set 方法来赋值，有效的防止 SQL 注入，提高系统安全性</p>
<p><strong>${}：</strong>拼接符，传入的内容会<strong>直接替换</strong>拼接，不会加上引号，可能存在 sql 注入的安全隐患</p>
<ul>
<li><p>能用 #{} 的地方就用 #{}，不用或少用 ${}</p>
</li>
<li><p>必须使用 ${} 的情况：</p>
<ul>
<li>表名作参数时，如：<code>SELECT * FROM $&#123;tableName&#125;</code></li>
<li>order by 时，如：<code>SELECT * FROM t_user ORDER BY $&#123;columnName&#125;</code></li>
</ul>
</li>
<li><p>sql 语句使用 #{}，properties 文件内容获取使用 ${}</p>
</li>
</ul>
<hr>
<h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>在日常开发过程中，排查问题时需要输出 MyBatis 真正执行的 SQL 语句、参数、结果等信息，就可以借助 log4j 的功能来实现执行信息的输出。</p>
<ul>
<li><p>在核心配置文件根标签内配置 log4j</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置LOG4J--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;log4j&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 src 目录下创建 log4j.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Global logging configuration</span></span><br><span class="line"><span class="attr">log4j.rootLogger</span>=<span class="string">DEBUG, stdout</span></span><br><span class="line"><span class="comment"># Console output...</span></span><br><span class="line"><span class="attr">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%5p [%t] - %m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#输出到日志文件</span></span><br><span class="line"><span class="comment">  #log4j.appender.file=org.apache.log4j.FileAppender</span></span><br><span class="line"><span class="comment">  #log4j.appender.file.File=../logs/iask.log</span></span><br><span class="line"><span class="comment">  #log4j.appender.file.layout=org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="comment">  #log4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125;  %l  %m%n</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li><p>实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>StudentMapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询全部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Student&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id查询</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Student <span class="title function_">selectById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">insert</span><span class="params">(Student stu)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">update</span><span class="params">(Student stu)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>config.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://192.168.2.184:3306/db1</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>MyBatisConfig.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--核心根标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入数据库连接的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--配置LOG4J--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;log4j&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--起别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;bean.Student&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;student&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;package name=&quot;bean&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置数据库环境，可以多个环境，default指定哪个--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--id属性唯一标识--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--事务管理，type属性，默认JDBC事务--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--数据源信息   type属性连接池--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--property获取数据库连接的配置信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--引入映射配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mapper引入指定的映射配置 resource属性执行的映射配置文件的名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;StudentMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>StudentMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;StudentMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;student&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM student WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO student VALUES (#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        UPDATE student SET name = #&#123;name&#125;, age = #&#123;age&#125; WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        DELETE FROM student WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>控制层测试代码：根据 id 查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectById</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.加载核心配置文件</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;MyBatisConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.获取SqlSession工厂对象</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">ssf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通过工厂对象获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> ssf.openSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.执行映射配置文件中的sql语句，并接收结果</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> sqlSession.selectOne(<span class="string">&quot;StudentMapper.selectById&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.处理结果</span></span><br><span class="line">    System.out.println(stu);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">    is.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制层测试代码：新增功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.加载核心配置文件</span></span><br><span class="line">    <span class="comment">//2.获取SqlSession工厂对象</span></span><br><span class="line">    <span class="comment">//3.通过工厂对象获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.执行映射配置文件中的sql语句，并接收结果</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">5</span>, <span class="string">&quot;周七&quot;</span>, <span class="number">27</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> sqlSession.insert(<span class="string">&quot;StudentMapper.insert&quot;</span>, stu);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.提交事务</span></span><br><span class="line">    <span class="comment">//sqlSession.commit();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.处理结果</span></span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">    is.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><p>三种方式实现批量操作：</p>
<ul>
<li><p><settings> 标签属性：这种方式属于<strong>全局批量</strong></settings></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;BATCH&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>defaultExecutorType：配置默认的执行器</p>
<ul>
<li>SIMPLE 就是普通的执行器（默认，每次执行都要重新设置参数）</li>
<li>REUSE 执行器会重用预处理语句（只预设置一次参数，多次执行）</li>
<li>BATCH 执行器不仅重用语句还会执行批量更新（只针对<strong>修改操作</strong>）</li>
</ul>
</li>
<li><p>SqlSession <strong>会话内批量</strong>操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> getSqlSessionFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以执行批量操作的sqlSession</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">openSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">EmployeeMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> openSession.getMapper(EmployeeMapper.class);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            mapper.addEmp(<span class="keyword">new</span> <span class="title class_">Employee</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>), <span class="string">&quot;b&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        openSession.commit();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 批量：（预编译sql一次==&gt;设置参数===&gt;10000次===&gt;执行1次（类似管道））</span></span><br><span class="line">        <span class="comment">// 非批量：（预编译sql=设置参数=执行）==》10000   耗时更多</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行时长：&quot;</span> + (end - start));</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring 配置文件方式（applicationContext.xml）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置一个可以进行批量执行的sqlSession  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactoryBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;executorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;BATCH&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SqlSession sqlSession;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="代理开发"><a href="#代理开发" class="headerlink" title="代理开发"></a>代理开发</h2><h3 id="代理规则"><a href="#代理规则" class="headerlink" title="代理规则"></a>代理规则</h3><p>分层思想：控制层（controller）、业务层（service）、持久层（dao）</p>
<p>调用流程：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/%E5%88%86%E5%B1%82%E6%80%9D%E6%83%B3%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png"></p>
<p>传统方式实现 DAO 层，需要写接口和实现类。采用 Mybatis 的代理开发方式实现 DAO 层的开发，只需要编写 Mapper 接口（相当于 Dao 接口），由 Mybatis 框架根据接口定义创建接口的<strong>动态代理对象</strong></p>
<p>接口开发方式：</p>
<ol>
<li>定义接口</li>
<li>操作数据库，MyBatis 框架根据接口，通过动态代理的方式生成代理对象，负责数据库的操作</li>
</ol>
<p>Mapper 接口开发需要遵循以下规范：</p>
<ul>
<li><p>Mapper.xml 文件中的 namespace 与 DAO 层 mapper 接口的全类名相同</p>
</li>
<li><p>Mapper.xml 文件中的增删改查标签的id属性和 DAO 层 Mapper 接口方法名相同</p>
</li>
<li><p>Mapper.xml 文件中的增删改查标签的 parameterType 属性和 DAO 层 Mapper 接口方法的参数相同</p>
</li>
<li><p>Mapper.xml 文件中的增删改查标签的 resultType 属性和 DAO 层 Mapper 接口方法的返回值相同</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0DAO%E5%B1%82.png"></p>
</li>
</ul>
<hr>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>通过动态代理开发模式，只编写一个接口不写实现类，通过 <strong>getMapper()</strong> 方法最终获取到 MapperProxy 代理对象，而这个代理对象是 MyBatis 使用了 JDK 的动态代理技术生成的</p>
<p>动态代理实现类对象在执行方法时最终调用了 <strong>MapperMethod.execute()</strong> 方法，这个方法中通过 switch case 语句根据操作类型来判断是新增、修改、删除、查询操作，最后一步回到了 MyBatis 最原生的 <strong>SqlSession 方式来执行增删改查</strong></p>
<ul>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Student <span class="title function_">selectById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//1.加载核心配置文件</span></span><br><span class="line">        is = Resources.getResourceAsStream(<span class="string">&quot;MyBatisConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取SqlSession工厂对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过工厂对象获取SqlSession对象</span></span><br><span class="line">        sqlSession = s.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(StudentMapper.class); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.通过实现类对象调用方法，接收结果</span></span><br><span class="line">        stu = mapper.selectById(id);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.getMessage();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//6.释放资源</span></span><br><span class="line">        <span class="keyword">if</span>(sqlSession != <span class="literal">null</span>) &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.返回结果</span></span><br><span class="line">    <span class="keyword">return</span> stu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="结果映射"><a href="#结果映射" class="headerlink" title="结果映射"></a>结果映射</h2><h3 id="相关标签"><a href="#相关标签" class="headerlink" title="相关标签"></a>相关标签</h3><p><resultType>：返回结果映射对象类型，和对应方法的返回值类型保持一致，但是如果返回值是 List 则和其泛型保持一致</resultType></p>
<p><resultMap>：返回一条记录的 Map，key 是列名，value 是对应的值，用来配置<strong>字段和对象属性</strong>的映射关系标签，结果映射（和 resultType 二选一）</resultMap></p>
<ul>
<li>id 属性：唯一标识</li>
<li>type 属性：实体对象类型</li>
<li>autoMapping 属性：结果自动映射</li>
</ul>
<p><resultMap> 内的核心配置文件标签：</resultMap></p>
<ul>
<li><p><id>：配置主键映射关系标签</id></p>
</li>
<li><p><result>：配置非主键映射关系标签</result></p>
<ul>
<li>column 属性：表中字段名称</li>
<li>property 属性： 实体对象变量名称</li>
</ul>
</li>
<li><p><association>：配置被包含<strong>单个对象</strong>的映射关系标签，嵌套封装结果集（多对一、一对一）</association></p>
<ul>
<li>property 属性：被包含对象的变量名，要进行映射的属性名</li>
<li>javaType 属性：被包含对象的数据类型，要进行映射的属性的类型（Java 中的 Bean 类）</li>
<li>select 属性：加载复杂类型属性的映射语句的 ID，会从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句</li>
</ul>
</li>
<li><p><collection>：配置被包含<strong>集合对象</strong>的映射关系标签，嵌套封装结果集（一对多、多对多）</collection></p>
<ul>
<li>property 属性：被包含集合对象的变量名</li>
<li>ofType 属性：集合中保存的对象数据类型</li>
</ul>
</li>
<li><p><discriminator>：鉴别器，用来判断某列的值，根据得到某列的不同值做出不同自定义的封装行为</discriminator></p>
</li>
</ul>
<p>自定义封装规则可以将数据库中比较复杂的数据类型映射为 JavaBean 中的属性</p>
<hr>
<h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>子查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Author author;</span><br><span class="line">    <span class="comment">// set + get</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">autoMapping</span> = <span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectAuthor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM BLOG WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAuthor&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Author&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>循环引用：通过缓存解决</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">autoMapping</span> = <span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;comment&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Comment&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;blog&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>/&gt;</span><span class="comment">&lt;!--y--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">&lt;/resultMap</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>一对一实现：</p>
<ul>
<li><p>数据准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE person(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	name VARCHAR(20),</span><br><span class="line">	age INT</span><br><span class="line">);</span><br><span class="line">INSERT INTO person VALUES (NULL,&#x27;张三&#x27;,23),(NULL,&#x27;李四&#x27;,24),(NULL,&#x27;王五&#x27;,25);</span><br><span class="line"></span><br><span class="line">CREATE TABLE card(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	number VARCHAR(30),</span><br><span class="line">	pid INT,</span><br><span class="line">	CONSTRAINT cp_fk FOREIGN KEY (pid) REFERENCES person(id)</span><br><span class="line">);</span><br><span class="line">INSERT INTO card VALUES (NULL,&#x27;12345&#x27;,1),(NULL,&#x27;23456&#x27;,2),(NULL,&#x27;34567&#x27;,3);</span><br></pre></td></tr></table></figure>
</li>
<li><p>bean 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Card</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;     <span class="comment">//主键id</span></span><br><span class="line">    <span class="keyword">private</span> String number;  <span class="comment">//身份证号</span></span><br><span class="line">    <span class="keyword">private</span> Person p;       <span class="comment">//所属人的对象</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;     <span class="comment">//主键id</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//人的姓名</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;    <span class="comment">//人的年龄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件 OneToOneMapper.xml，MyBatisConfig.xml 需要引入（可以把 bean 包下起别名）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;OneToOneMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置字段和实体对象属性的映射关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;oneToOne&quot;</span> <span class="attr">type</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">       	<span class="comment">&lt;!--column 表中字段名称，property 实体对象变量名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;number&quot;</span> <span class="attr">property</span>=<span class="string">&quot;number&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            association：配置被包含对象的映射关系</span></span><br><span class="line"><span class="comment">            property：被包含对象的变量名</span></span><br><span class="line"><span class="comment">            javaType：被包含对象的数据类型</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;p&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;bean.Person&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;pid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;oneToOne&quot;</span>&gt;</span> <span class="comment">&lt;!--SQL--&gt;</span></span><br><span class="line">        SELECT c.id cid,number,pid,NAME,age FROM card c,person p WHERE c.pid=p.id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>核心配置文件 MyBatisConfig.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mappers引入映射配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;one_to_one/OneToOneMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;one_to_many/OneToManyMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;many_to_many/ManyToManyMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.加载核心配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;MyBatisConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取SqlSession工厂对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">ssf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过工厂对象获取SqlSession对象</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> ssf.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取OneToOneMapper接口的实现类对象</span></span><br><span class="line">        <span class="type">OneToOneMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(OneToOneMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.调用实现类的方法，接收结果</span></span><br><span class="line">        List&lt;Card&gt; list = mapper.selectAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.处理结果</span></span><br><span class="line">        <span class="keyword">for</span> (Card c : list) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>一对多实现：</p>
<ul>
<li><p>数据准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE classes(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line">INSERT INTO classes VALUES (NULL,&#x27;程序一班&#x27;),(NULL,&#x27;程序二班&#x27;)</span><br><span class="line"></span><br><span class="line">CREATE TABLE student(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	name VARCHAR(30),</span><br><span class="line">	age INT,</span><br><span class="line">	cid INT,</span><br><span class="line">	CONSTRAINT cs_fk FOREIGN KEY (cid) REFERENCES classes(id)</span><br><span class="line">);</span><br><span class="line">INSERT INTO student VALUES (NULL,&#x27;张三&#x27;,23,1),(NULL,&#x27;李四&#x27;,24,1),(NULL,&#x27;王五&#x27;,25,2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>bean 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Classes</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;     <span class="comment">//主键id</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//班级名称</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students; <span class="comment">//班级中所有学生对象</span></span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;     <span class="comment">//主键id</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//学生姓名</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;    <span class="comment">//学生年龄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>映射配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;OneToManyMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;oneToMany&quot;</span> <span class="attr">type</span>=<span class="string">&quot;bean.Classes&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--collection：配置被包含的集合对象映射关系--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;bean.Student&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sage&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;oneToMany&quot;</span>&gt;</span> <span class="comment">&lt;!--SQL--&gt;</span></span><br><span class="line">        SELECT c.id cid,c.name cname,s.id sid,s.name sname,s.age sage FROM classes c,student s WHERE c.id=s.cid</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码实现片段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4.获取OneToManyMapper接口的实现类对象</span></span><br><span class="line"><span class="type">OneToManyMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(OneToManyMapper.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.调用实现类的方法，接收结果</span></span><br><span class="line">List&lt;Classes&gt; classes = mapper.selectAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.处理结果</span></span><br><span class="line"><span class="keyword">for</span> (Classes cls : classes) &#123;</span><br><span class="line">    System.out.println(cls.getId() + <span class="string">&quot;,&quot;</span> + cls.getName());</span><br><span class="line">    List&lt;Student&gt; students = cls.getStudents();</span><br><span class="line">    <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\t&quot;</span> + student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>学生课程例子，中间表不需要 bean 实体类</p>
<ul>
<li><p>数据准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE course(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line">INSERT INTO course VALUES (NULL,&#x27;语文&#x27;),(NULL,&#x27;数学&#x27;);</span><br><span class="line"></span><br><span class="line">CREATE TABLE stu_cr(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	sid INT,</span><br><span class="line">	cid INT,</span><br><span class="line">	CONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id),</span><br><span class="line">	CONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id)</span><br><span class="line">);</span><br><span class="line">INSERT INTO stu_cr VALUES (NULL,1,1),(NULL,1,2),(NULL,2,1),(NULL,2,2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>bean类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;     <span class="comment">//主键id</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//学生姓名</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;    <span class="comment">//学生年龄</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Course&gt; courses;   <span class="comment">// 学生所选择的课程集合</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Course</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;     <span class="comment">//主键id</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//课程名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;ManyToManyMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;manyToMany&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Bean.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sage&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;courses&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Bean.Course&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;cid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;manyToMany&quot;</span>&gt;</span> <span class="comment">&lt;!--SQL--&gt;</span></span><br><span class="line">        SELECT sc.sid,s.name sname,s.age sage,sc.cid,c.name cname FROM student s,course c,stu_cr sc WHERE sc.sid=s.id AND sc.cid=c.id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="鉴别器"><a href="#鉴别器" class="headerlink" title="鉴别器"></a>鉴别器</h3><p>需求：如果查询结果是女性，则把部门信息查询出来，否则不查询 ；如果是男性，把 last_name 这一列的值赋值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    column：指定要判断的列名 </span></span><br><span class="line"><span class="comment">    javaType：列值对应的java类型</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 女生 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- resultType不可缺少，也可以使用resutlMap --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">select</span>=<span class="string">&quot;com.dao.DepartmentMapper.getDeptById&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 男生 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br></pre></td></tr></table></figure>





<hr>
<h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><h4 id="两种加载"><a href="#两种加载" class="headerlink" title="两种加载"></a>两种加载</h4><p>立即加载：只要调用方法，马上发起查询</p>
<p>延迟加载：在需要用到数据时才进行加载，不需要用到数据时就不加载数据，延迟加载也称懒加载</p>
<p>优点： 先从单表查询，需要时再从关联表去关联查询，提高数据库性能，因为查询单表要比关联查询多张表速度要快，节省资源</p>
<p>坏处：只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降</p>
<p>核心配置文件：</p>
<table>
<thead>
<tr>
<th>标签名</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>lazyLoadingEnabled</td>
<td>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载，特定关联关系中可通过设置 <code>fetchType</code> 属性来覆盖该项的开关状态。</td>
<td>false</td>
</tr>
<tr>
<td>aggressiveLazyLoading</td>
<td>开启时，任一方法的调用都会加载该对象的所有延迟加载属性。否则每个延迟加载属性会按需加载（参考 lazyLoadTriggerMethods）</td>
<td>false</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="assocation"><a href="#assocation" class="headerlink" title="assocation"></a>assocation</h4><p>分布查询：先按照身份 id 查询所属人的 id、然后根据所属人的 id 去查询人的全部信息，这就是分步查询</p>
<ul>
<li><p>映射配置文件 OneToOneMapper.xml </p>
<p>一对一映射：</p>
<ul>
<li>column 属性表示给要调用的其它的 select 标签传入的参数</li>
<li>select 属性表示调用其它的 select 标签</li>
<li>fetchType&#x3D;”lazy” 表示延迟加载（局部配置，只有配置了这个的地方才会延迟加载）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;OneToOneMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置字段和实体对象属性的映射关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;oneToOne&quot;</span> <span class="attr">type</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;number&quot;</span> <span class="attr">property</span>=<span class="string">&quot;number&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;p&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;bean.Person&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">column</span>=<span class="string">&quot;pid&quot;</span> </span></span><br><span class="line"><span class="tag">                     <span class="attr">select</span>=<span class="string">&quot;one_to_one.PersonMapper.findPersonByid&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>&gt;</span></span><br><span class="line">            		<span class="comment">&lt;!--需要配置新的映射文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;oneToOne&quot;</span>&gt;</span> </span><br><span class="line">        SELECT * FROM card <span class="comment">&lt;!--查询全部，负责根据条件直接全部加载--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>PersonMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;one_to_one.PersonMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findPersonByid&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM person WHERE id=#&#123;pid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>PersonMapper.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">findPersonByid</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;MyBatisConfig.xml&quot;</span>);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">ssf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> ssf.openSession(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">OneToOneMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(OneToOneMapper.class);</span><br><span class="line">        <span class="comment">// 调用实现类的方法，接收结果</span></span><br><span class="line">        List&lt;Card&gt; list = mapper.selectAll();</span><br><span class="line">        </span><br><span class="line">      	<span class="comment">// 不能遍历，遍历就是相当于使用了该数据，需要加载，不遍历就是没有使用。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h4><p>同样在一对多关系配置的 <collection> 结点中配置延迟加载策略，<collection> 结点中也有 select 属性和 column 属性</collection></collection></p>
<ul>
<li><p>映射配置文件 OneToManyMapper.xml</p>
<p>一对多映射：</p>
<ul>
<li>column 是用于指定使用哪个字段的值作为条件查询</li>
<li>select 是用于指定查询账户的唯一标识（账户的 dao 全限定类名加上方法名称）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;OneToManyMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;oneToMany&quot;</span> <span class="attr">type</span>=<span class="string">&quot;bean.Classes&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--collection：配置被包含的集合对象映射关系--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;bean.Student&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> </span></span><br><span class="line"><span class="tag">                    <span class="attr">select</span>=<span class="string">&quot;one_to_one.StudentMapper.findStudentByCid&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;oneToMany&quot;</span>&gt;</span></span><br><span class="line">      SELECT * FROM classes</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>StudentMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;one_to_one.StudentMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findPersonByCid&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM person WHERE cid=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><h3 id="单表操作"><a href="#单表操作" class="headerlink" title="单表操作"></a>单表操作</h3><p>注解可以简化开发操作，省略映射配置文件的编写</p>
<p>常用注解：</p>
<ul>
<li>@Select(“查询的 SQL 语句”)：执行查询操作注解</li>
<li>@Insert(“插入的 SQL 语句”)：执行新增操作注解</li>
<li>@Update(“修改的 SQL 语句”)：执行修改操作注解</li>
<li>@Delete(“删除的 SQL 语句”)：执行删除操作注解</li>
</ul>
<p>参数注解：</p>
<ul>
<li>@Param：当 SQL 语句需要<strong>多个（大于1）参数</strong>时，用来指定参数的对应规则</li>
</ul>
<p>核心配置文件配置映射关系：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;使用了注解的Mapper接口所在包&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--或者--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;包名.Mapper名&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基本增删改查：</p>
<ul>
<li><p>创建 Mapper 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mapper;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询全部</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM student&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Student&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增数据</span></span><br><span class="line">    <span class="meta">@Insert(&quot;INSERT INTO student VALUES (#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">insert</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改操作</span></span><br><span class="line">    <span class="meta">@Update(&quot;UPDATE student SET name=#&#123;name&#125;,age=#&#123;age&#125; WHERE id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">update</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">    <span class="meta">@Delete(&quot;DELETE FROM student WHERE id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 MyBatis 的核心配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>bean类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.加载核心配置文件</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;MyBatisConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.获取SqlSession工厂对象</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">ssf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通过工厂对象获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> ssf.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line">    <span class="type">StudentMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.调用实现类对象中的方法，接收结果</span></span><br><span class="line">    List&lt;Student&gt; list = mapper.selectAll();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.处理结果</span></span><br><span class="line">    <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7.释放资源</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">    is.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h3><h4 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h4><p>实现复杂关系映射之前我们可以在映射文件中通过配置 <resultMap> 来实现，使用注解开发后，可以使用 @Results 注解，@Result 注解，@One 注解，@Many 注解组合完成复杂关系的配置</resultMap></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Results</td>
<td>代替 <resultMap> 标签，注解中使用单个 @Result 注解或者 @Result 集合<br>使用格式：@Results({ @Result(), @Result() })或@Results({ @Result() })</resultMap></td>
</tr>
<tr>
<td>@Result</td>
<td>代替&lt; id&gt; 和 <result> 标签，@Result 中属性介绍：<br>column：数据库的列名      property：封装类的变量名<br>one：需要使用 @One 注解（@Result(one &#x3D; @One)）<br>Many：需要使用 @Many 注解（@Result(many&#x3D; @Many)）</result></td>
</tr>
<tr>
<td>@One(一对一)</td>
<td>代替 <association> 标签，多表查询的关键，用来指定子查询返回单一对象<br>select：指定调用 Mapper 接口中的某个方法<br>使用格式：@Result(column&#x3D;””, property&#x3D;””, one&#x3D;@One(select&#x3D;””))</association></td>
</tr>
<tr>
<td>@Many(多对一)</td>
<td>代替 <collection> 标签，多表查询的关键，用来指定子查询返回对象集合<br>select：指定调用 Mapper 接口中的某个方法<br>使用格式：@Result(column&#x3D;””, property&#x3D;””, many&#x3D;@Many(select&#x3D;””))</collection></td>
</tr>
</tbody></table>
<hr>
<h4 id="一对一-1"><a href="#一对一-1" class="headerlink" title="一对一"></a>一对一</h4><p>身份证对人</p>
<ul>
<li><p>PersonMapper 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonMapper</span> &#123;</span><br><span class="line">    <span class="comment">//根据id查询</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM person WHERE id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Person <span class="title function_">selectById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CardMapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CardMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询全部</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM card&quot;)</span></span><br><span class="line">    <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;id&quot;,property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;number&quot;,property = &quot;number&quot;),</span></span><br><span class="line"><span class="meta">            @Result(</span></span><br><span class="line"><span class="meta">                    property = &quot;p&quot;,             // 被包含对象的变量名</span></span><br><span class="line"><span class="meta">                    javaType = Person.class,    // 被包含对象的实际数据类型</span></span><br><span class="line"><span class="meta">                    column = &quot;pid&quot;,  // 根据查询出的card表中的pid字段来查询person表</span></span><br><span class="line"><span class="meta">                     /* </span></span><br><span class="line"><span class="meta">                     	one、@One 一对一固定写法</span></span><br><span class="line"><span class="meta">                        select属性：指定调用哪个接口中的哪个方法</span></span><br><span class="line"><span class="meta">                     */</span></span><br><span class="line"><span class="meta">                    one = @One(select = &quot;one_to_one.PersonMapper.selectById&quot;)</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Card&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类（详细代码参考单表操作）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.加载核心配置文件</span></span><br><span class="line"><span class="comment">//2.获取SqlSession工厂对象</span></span><br><span class="line"><span class="comment">//3.通过工厂对象获取SqlSession对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line"><span class="type">CardMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(CardMapper.class);</span><br><span class="line"><span class="comment">//5.调用实现类对象中的方法，接收结果</span></span><br><span class="line">List&lt;Card&gt; list = mapper.selectAll();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="一对多-1"><a href="#一对多-1" class="headerlink" title="一对多"></a>一对多</h4><p>班级和学生</p>
<ul>
<li><p>StudentMapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    <span class="comment">//根据cid查询student表  cid是外键约束列</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM student WHERE cid=#&#123;cid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Student&gt; <span class="title function_">selectByCid</span><span class="params">(Integer cid)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ClassesMapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClassesMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询全部</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM classes&quot;)</span></span><br><span class="line">    <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;name&quot;, property = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">            @Result(</span></span><br><span class="line"><span class="meta">                    property = &quot;students&quot;,  //被包含对象的变量名</span></span><br><span class="line"><span class="meta">                    javaType = List.class,  //被包含对象的实际数据类型</span></span><br><span class="line"><span class="meta">                    column = &quot;id&quot;,          //根据id字段查询student表</span></span><br><span class="line"><span class="meta">                    many = @Many(select = &quot;one_to_many.StudentMapper.selectByCid&quot;)</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Classes&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line"><span class="type">ClassesMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ClassesMapper.class);</span><br><span class="line"><span class="comment">//5.调用实现类对象中的方法，接收结果</span></span><br><span class="line">List&lt;Classes&gt; classes = mapper.selectAll();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="多对多-1"><a href="#多对多-1" class="headerlink" title="多对多"></a>多对多</h4><p>学生和课程</p>
<ul>
<li><p>SQL 查询语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.id</span><br><span class="line">SELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#&#123;id&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CourseMapper 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CourseMapper</span> &#123;</span><br><span class="line">    <span class="comment">//根据学生id查询所选课程</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Course&gt; <span class="title function_">selectBySid</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>StudentMapper 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询全部</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.id&quot;)</span></span><br><span class="line">    <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;id&quot;,property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;name&quot;,property = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">            @Result(column = &quot;age&quot;,property = &quot;age&quot;),</span></span><br><span class="line"><span class="meta">            @Result(</span></span><br><span class="line"><span class="meta">                    property = &quot;courses&quot;,    //被包含对象的变量名</span></span><br><span class="line"><span class="meta">                    javaType = List.class,  //被包含对象的实际数据类型</span></span><br><span class="line"><span class="meta">                    column = &quot;id&quot;, //根据查询出的student表中的id字段查询中间表和课程表</span></span><br><span class="line"><span class="meta">                    many = @Many(select = &quot;many_to_many.CourseMapper.selectBySid&quot;)</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Student&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line"><span class="type">StudentMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(StudentMapper.class);</span><br><span class="line"><span class="comment">//5.调用实现类对象中的方法，接收结果</span></span><br><span class="line">List&lt;Student&gt; students = mapper.selectAll();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><h3 id="缓存概述"><a href="#缓存概述" class="headerlink" title="缓存概述"></a>缓存概述</h3><p>缓存：缓存就是一块内存空间，保存临时数据</p>
<p>作用：将数据源（数据库或者文件）中的数据读取出来存放到缓存中，再次获取时直接从缓存中获取，可以减少和数据库交互的次数，提升程序的性能</p>
<p>缓存适用：</p>
<ul>
<li>适用于缓存的：经常查询但不经常修改的，数据的正确与否对最终结果影响不大的</li>
<li>不适用缓存的：经常改变的数据 , 敏感数据（例如：股市的牌价，银行的汇率，银行卡里面的钱）等等</li>
</ul>
<p>缓存类别：</p>
<ul>
<li>一级缓存：SqlSession 级别的缓存，又叫本地会话缓存，自带的（不需要配置），一级缓存的生命周期与 SqlSession 一致。在操作数据库时需要构造 SqlSession 对象，<strong>在对象中有一个数据结构（HashMap）用于存储缓存数据</strong>，不同的 SqlSession 之间的缓存数据区域是互相不影响的</li>
<li>二级缓存：mapper（namespace）级别的缓存，二级缓存的使用，需要手动开启（需要配置）。多个 SqlSession 去操作同一个 Mapper 的 SQL 可以共用二级缓存，二级缓存是跨 SqlSession 的</li>
</ul>
<p>开启缓存：配置核心配置文件中 <settings> 标签</settings></p>
<ul>
<li>cacheEnabled：true 表示全局性地开启所有映射器配置文件中已配置的任何缓存，默认 true</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png"></p>
<p>参考文章：<a href="https://www.cnblogs.com/ysocean/p/7342498.html">https://www.cnblogs.com/ysocean/p/7342498.html</a></p>
<hr>
<h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>一级缓存是 SqlSession 级别的缓存</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-一级缓存.png" style="zoom: 67%;">

<p>工作流程：第一次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，如果没有，从数据库查询用户信息，得到用户信息，将用户信息存储到一级缓存中；第二次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，缓存中有，直接从缓存中获取用户信息。</p>
<p>一级缓存的失效：</p>
<ul>
<li>SqlSession 不同</li>
<li>SqlSession 相同，查询条件不同时（还未缓存该数据）</li>
<li>SqlSession 相同，手动清除了一级缓存，调用 <code>sqlSession.clearCache()</code></li>
<li>SqlSession 相同，执行 commit 操作或者执行插入、更新、删除，清空 SqlSession 中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，<strong>避免脏读</strong></li>
</ul>
<p>Spring 整合 MyBatis 后，一级缓存作用：</p>
<ul>
<li>未开启事务的情况，每次查询 Spring 都会创建新的 SqlSession，因此一级缓存失效</li>
<li>开启事务的情况，Spring 使用 ThreadLocal 获取当前资源绑定同一个 SqlSession，因此此时一级缓存是有效的</li>
</ul>
<p>测试一级缓存存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFirstLevelCache</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取sqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionFactoryUtils.openSession();</span><br><span class="line">    <span class="comment">//2. 通过sqlSession对象获取UserDao接口的代理对象</span></span><br><span class="line">    <span class="type">UserDao</span> <span class="variable">userDao1</span> <span class="operator">=</span> sqlSession.getMapper(UserDao.class);</span><br><span class="line">    <span class="comment">//3. 调用UserDao接口的代理对象的findById方法获取信息</span></span><br><span class="line">	<span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userDao1.findById(<span class="number">1</span>);</span><br><span class="line">	System.out.println(user1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//sqlSession.clearCache() 清空缓存</span></span><br><span class="line">    </span><br><span class="line">   	<span class="type">UserDao</span> <span class="variable">userDao2</span> <span class="operator">=</span> sqlSession.getMapper(UserDao.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDao.findById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.测试两次结果是否一样</span></span><br><span class="line">    System.out.println(user1 == user2);<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 提交事务关闭资源</span></span><br><span class="line">    SqlSessionFactoryUtils.commitAndClose(sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>二级缓存是 mapper 的缓存，只要是同一个命名空间（namespace）的 SqlSession 就共享二级缓存的内容，并且可以操作二级缓存</p>
<p>作用：作用范围是整个应用，可以跨线程使用，适合缓存一些修改较少的数据</p>
<p>工作流程：一个会话查询数据，这个数据就会被放在当前会话的一级缓存中，如果<strong>会话关闭或提交</strong>一级缓存中的数据会保存到二级缓存</p>
<p>二级缓存的基本使用：</p>
<ol>
<li><p>在 MyBatisConfig.xml 文件开启二级缓存，<strong>cacheEnabled 默认值为 true</strong>，所以这一步可以省略不配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置开启二级缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 Mapper 映射文件</p>
<p><code>&lt;cache&gt;</code> 标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;dao.UserDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启user支持二级缓存--&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">&quot;FIFO&quot;</span> <span class="attr">flushInterval</span>=<span class="string">&quot;6000&quot;</span> <span class="attr">readOnly</span>=<span class="string">&quot;&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1024&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span> <span class="comment">&lt;!--则表示所有属性使用默认值--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>eviction（清除策略）：</p>
<ul>
<li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象，默认</li>
<li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们</li>
<li><code>SOFT</code> – 软引用：基于垃圾回收器状态和软引用规则移除对象</li>
<li><code>WEAK</code> – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象</li>
</ul>
<p>flushInterval（刷新间隔）：可以设置为任意的正整数， 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新</p>
<p>size（引用数目）：缓存存放多少元素，默认值是 1024</p>
<p>readOnly（只读）：可以被设置为 true 或 false</p>
<ul>
<li>只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，促进了性能提升</li>
<li>可读写的缓存会（通过序列化）返回缓存对象的拷贝， 速度上会慢一些，但是更安全，因此默认值是 false</li>
</ul>
<p>type：指定自定义缓存的全类名，实现 Cache 接口即可</p>
</li>
<li><p>要进行二级缓存的类必须实现 java.io.Serializable 接口，可以使用序列化方式来保存对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h4><ol>
<li><p>select 标签的 useCache 属性</p>
<p>映射文件中的 <code>&lt;select&gt;</code> 标签中设置 <code>useCache=&quot;true&quot;</code> 代表当前 statement 要使用二级缓存（默认）</p>
<p>注意：如果每次查询都需要最新的数据 sql，要设置成 useCache&#x3D;false，禁用二级缓存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>每个增删改标签都有 flushCache 属性，默认为 true，代表在<strong>执行增删改之后就会清除一、二级缓存</strong>，保证缓存的一致性；而查询标签默认值为 false，所以查询不会清空缓存</p>
</li>
<li><p>localCacheScope：本地缓存作用域，<settings> 中的配置项，默认值为 SESSION，当前会话的所有数据保存在会话缓存中，设置为 STATEMENT 禁用一级缓存</settings></p>
</li>
</ol>
<hr>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>事务提交二级缓存才生效：DefaultSqlSession 调用 commit() 时会回调 <code>executor.commit()</code></p>
<ul>
<li><p>CachingExecutor#query()：执行查询方法，查询出的数据会先放入 entriesToAddOnCommit 集合暂存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从二缓存中获取数据，获取不到去一级缓存获取</span></span><br><span class="line">List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line"><span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 回调 BaseExecutor#query</span></span><br><span class="line">    list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    <span class="comment">// 将数据放入 entriesToAddOnCommit 集合暂存，此时还没放入二级缓存</span></span><br><span class="line">    tcm.putObject(cache, key, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>commit()：事务提交，<strong>清空一级缓存，放入二级缓存</strong>，二级缓存使用 TransactionalCacheManager（tcm）管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">boolean</span> required)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">// 首先调用 BaseExecutor#commit 方法，【清空一级缓存】</span></span><br><span class="line">    delegate.commit(required);</span><br><span class="line">    tcm.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>TransactionalCacheManager#commit：查询出的数据放入二级缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取所有的缓存事务，挨着进行提交</span></span><br><span class="line">    <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">        txCache.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">        delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 entriesToAddOnCommit 中的数据放入二级缓存</span></span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    <span class="comment">// 清空相关集合</span></span><br><span class="line">    reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flushPendingEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 将数据放入二级缓存</span></span><br><span class="line">        delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>增删改操作会清空缓存：</p>
<ul>
<li><p>update()：CachingExecutor 的更新操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="comment">// 回调 BaseExecutor#update 方法，也会清空一级缓存</span></span><br><span class="line">    <span class="keyword">return</span> delegate.update(ms, parameterObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>flushCacheIfRequired()：判断是否需要清空二级缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> &#123;</span><br><span class="line">    <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> ms.getCache();</span><br><span class="line">    <span class="comment">// 判断二级缓存是否存在，然后判断标签的 flushCache 的值，增删改操作的 flushCache 属性默认为 true</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">        <span class="comment">// 清空二级缓存</span></span><br><span class="line">        tcm.clear(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>自定义缓存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;com.domain.something.MyCustomCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>type 属性指定的类必须实现 org.apache.ibatis.cache.Cache 接口，且提供一个接受 String 参数作为 id 的构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">  String <span class="title function_">getId</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">putObject</span><span class="params">(Object key, Object value)</span>;</span><br><span class="line">  Object <span class="title function_">getObject</span><span class="params">(Object key)</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasKey</span><span class="params">(Object key)</span>;</span><br><span class="line">  Object <span class="title function_">removeObject</span><span class="params">(Object key)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓存的配置，只需要在缓存实现中添加公有的 JavaBean 属性，然后通过 cache 元素传递属性值，例如在缓存实现上调用一个名为 <code>setCacheFile(String file)</code> 的方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;com.domain.something.MyCustomCache&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cacheFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/tmp/my-custom-cache.tmp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用所有简单类型作为 JavaBean 属性的类型，MyBatis 会进行转换。</li>
<li>可以使用占位符（如 <code>$&#123;cache.file&#125;</code>），以便替换成在配置文件属性中定义的值</li>
</ul>
<p>MyBatis 支持在所有属性设置完毕之后，调用一个初始化方法， 如果想要使用这个特性，可以在自定义缓存类里实现 <code>org.apache.ibatis.builder.InitializingObject</code> 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InitializingObject</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：对缓存的配置（如清除策略、可读或可读写等），不能应用于自定义缓存</p>
<p>对某一命名空间的语句，只会使用该命名空间的缓存进行缓存或刷新，在多个命名空间中共享相同的缓存配置和实例，可以使用 cache-ref 元素来引用另一个缓存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">&quot;com.someone.application.data.SomeMapper&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="构造语句"><a href="#构造语句" class="headerlink" title="构造语句"></a>构造语句</h2><h3 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>动态 SQL 是 MyBatis 强大特性之一，逻辑复杂时，MyBatis 映射配置文件中，SQL 是动态变化的，所以引入动态 SQL 简化拼装 SQL 的操作</p>
<p>DynamicSQL 包含的标签：</p>
<ul>
<li>if</li>
<li>where</li>
<li>set</li>
<li>choose (when、otherwise)</li>
<li>trim</li>
<li>foreach</li>
</ul>
<p>各个标签都可以进行灵活嵌套和组合</p>
<p>OGNL：Object Graphic Navigation Language（对象图导航语言），用于对数据进行访问</p>
<p>参考文章：<a href="https://www.cnblogs.com/ysocean/p/7289529.html">https://www.cnblogs.com/ysocean/p/7289529.html</a></p>
<hr>
<h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><p><where>：条件标签，有动态条件则使用该标签代替 WHERE 关键字，封装查询条件</where></p>
<p>作用：如果标签返回的内容是以 AND 或 OR 开头的，标签内会剔除掉</p>
<p>表结构：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E5%8A%A8%E6%80%81sql%E7%94%A8%E6%88%B7%E8%A1%A8.png"></p>
<hr>
<h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>基本格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">“条件判断”</span>&gt;</span></span><br><span class="line">	查询条件拼接</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们根据实体类的不同取值，使用不同的 SQL 语句来进行查询。比如在 id 如果不为空时可以根据 id 查询，如果username 不同空时还要加入用户名作为条件，这种情况在我们的多条件组合查询中经常会碰到。</p>
<ul>
<li><p>UserMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null &quot;</span>&gt;</span></span><br><span class="line">                id = #&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null &quot;</span>&gt;</span></span><br><span class="line">                AND username = #&#123;username&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null &quot;</span>&gt;</span></span><br><span class="line">                AND sex = #&#123;sex&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span>	</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>MyBatisConfig.xml，引入映射配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mapper引入指定的映射配置 resource属性执行的映射配置文件的名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>DAO 层 Mapper 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">//多条件查询</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;User&gt; <span class="title function_">selectCondition</span><span class="params">(Student stu)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectCondition</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.加载核心配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;MyBatisConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取SqlSession工厂对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">ssf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过工厂对象获取SqlSession对象</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> ssf.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">2</span>);</span><br><span class="line">        user.setUsername(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="comment">//user.setSex(男); AND 后会自动剔除</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.调用实现类的方法，接收结果</span></span><br><span class="line">        List&lt;Student&gt; list = mapper.selectCondition(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.处理结果</span></span><br><span class="line">        <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p><set>：进行更新操作的时候，含有 set 关键词，使用该标签</set></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据 id 更新 user 表的数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.ys.po.User&quot;</span>&gt;</span></span><br><span class="line">    UPDATE user u</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                u.username = #&#123;username&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                u.sex = #&#123;sex&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">     WHERE id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果第一个条件 username 为空，那么 sql 语句为：update user u set u.sex&#x3D;? where id&#x3D;?</li>
<li>如果第一个条件不为空，那么 sql 语句为：update user u set u.username &#x3D; ? ,u.sex &#x3D; ? where id&#x3D;?</li>
</ul>
<hr>
<h4 id="choose"><a href="#choose" class="headerlink" title="choose"></a>choose</h4><p>假如不想用到所有的查询条件，只要查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句</p>
<p>标签：<when>，<otherwise></otherwise></when></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;id !=&#x27;&#x27; and id != null&quot;</span>&gt;</span></span><br><span class="line">                id=#&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;username !=&#x27;&#x27; and username != null&quot;</span>&gt;</span></span><br><span class="line">                AND username=#&#123;username&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                AND sex=#&#123;sex&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有三个条件，id、username、sex，只能选择一个作为查询条件</p>
<ul>
<li><p>如果 id 不为空，那么查询语句为：select * from user where  id&#x3D;?</p>
</li>
<li><p>如果 id 为空，那么看 username 是否为空</p>
<ul>
<li>如果不为空，那么语句为：select * from user where username&#x3D;?</li>
<li>如果 username 为空，那么查询语句为 select * from user where sex&#x3D;?</li>
</ul>
</li>
</ul>
<hr>
<h4 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h4><p>trim 标记是一个格式化的标记，可以完成 set 或者是 where 标记的功能，自定义字符串截取</p>
<ul>
<li>prefix：给拼串后的整个字符串加一个前缀，trim 标签体中是整个字符串拼串后的结果</li>
<li>prefixOverrides：去掉整个字符串前面多余的字符</li>
<li>suffix：给拼串后的整个字符串加一个后缀</li>
<li>suffixOverrides：去掉整个字符串后面多余的字符</li>
</ul>
<p>改写 if + where 语句：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByUsernameAndSex&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.ys.po.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and | or&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">            AND username=#&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null&quot;</span>&gt;</span></span><br><span class="line">            AND sex=#&#123;sex&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>改写 if + set 语句：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据 id 更新 user 表的数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.ys.po.User&quot;</span>&gt;</span></span><br><span class="line">    UPDATE user u</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;set&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            u.username = #&#123;username&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            u.sex = #&#123;sex&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    WHERE id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>基本格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foreach</span>&gt;</span>：循环遍历标签。适用于多个参数或者的关系。</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">“”open</span>=<span class="string">“”close</span>=<span class="string">“”item</span>=<span class="string">“”separator</span>=<span class="string">“”</span>&gt;</span></span><br><span class="line">		获取参数</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>属性：</p>
<ul>
<li>collection：参数容器类型， (list-集合， array-数组)</li>
<li>open：开始的 SQL 语句</li>
<li>close：结束的 SQL 语句</li>
<li>item：参数变量名</li>
<li>separator：分隔符</li>
</ul>
<p>需求：循环执行 sql 的拼接操作，<code>SELECT * FROM user WHERE id IN (1,2,5)</code></p>
<ul>
<li><p>UserMapper.xml片段</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id IN(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代码片段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//5.调用实现类的方法，接收结果</span></span><br><span class="line">List&lt;User&gt; list = mapper.selectByIds(ids);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h4><p>将一些重复性的 SQL 语句进行抽取，以达到复用的效果</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">“片段唯一标识”</span>&gt;</span>抽取的SQL语句<span class="tag">&lt;/<span class="name">sql</span>&gt;</span>		<span class="comment">&lt;!--抽取标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">“片段唯一标识”/</span>&gt;</span>				<span class="comment">&lt;!--引入标签--&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span>&gt;</span>SELECT * FROM user<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;select&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id IN(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>





<hr>
<h3 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h3><p>MyBatis 逆向工程，可以针对<strong>单表</strong>自动生成 MyBatis 执行所需要的代码（mapper.java、mapper.xml、pojo…）</p>
<p>generatorConfig.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;testTables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatisrelation&quot;</span> <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">password</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL和NUMERIC类型解析为java.math.BigDecimal --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- targetProject:生成PO类的位置！！ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.ys.po&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">&quot;.\src&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- targetProject:mapper映射文件生成的位置！！ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.ys.mapper&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">&quot;.\src&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- targetPackage：mapper接口生成的位置，重要！！ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetPackage</span>=<span class="string">&quot;com.ys.mapper&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">&quot;.\src&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定数据库表，要生成哪些表，就写哪些表，要和数据库中对应，不能写错！ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;items&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;orders&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;orderdetail&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span>       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>生成代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGenerator</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    List&lt;String&gt; warnings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">overwrite</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//指向逆向工程配置文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">configFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(GeneratorTest.class.</span><br><span class="line">                               getResource(<span class="string">&quot;/generatorConfig.xml&quot;</span>).getFile());</span><br><span class="line">    <span class="type">ConfigurationParser</span> <span class="variable">cp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationParser</span>(warnings);</span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> cp.parseConfiguration(configFile);</span><br><span class="line">    <span class="type">DefaultShellCallback</span> <span class="variable">callback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultShellCallback</span>(overwrite);</span><br><span class="line">    <span class="type">MyBatisGenerator</span> <span class="variable">myBatisGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBatisGenerator</span>(config,</span><br><span class="line">                                                             callback, warnings);</span><br><span class="line">    myBatisGenerator.generate(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考文章：<a href="https://www.cnblogs.com/ysocean/p/7360409.html">https://www.cnblogs.com/ysocean/p/7360409.html</a></p>
<hr>
<h3 id="构建-SQL"><a href="#构建-SQL" class="headerlink" title="构建 SQL"></a>构建 SQL</h3><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><p>MyBatis 提供了 org.apache.ibatis.jdbc.SQL 功能类，专门用于构建 SQL 语句    </p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SELECT(String… columns)</td>
<td>根据字段拼接查询语句</td>
</tr>
<tr>
<td>FROM(String… tables)</td>
<td>根据表名拼接语句</td>
</tr>
<tr>
<td>WHERE(String… conditions)</td>
<td>根据条件拼接语句</td>
</tr>
<tr>
<td>INSERT_INTO(String tableName)</td>
<td>根据表名拼接新增语句</td>
</tr>
<tr>
<td>INTO_VALUES(String… values)</td>
<td>根据值拼接新增语句</td>
</tr>
<tr>
<td>UPDATE(String table)</td>
<td>根据表名拼接修改语句</td>
</tr>
<tr>
<td>DELETE_FROM(String table)</td>
<td>根据表名拼接删除语句</td>
</tr>
</tbody></table>
<p>增删改查注解：</p>
<ul>
<li>@SelectProvider：生成查询用的 SQL 语句</li>
<li>@InsertProvider：生成新增用的 SQL 语句</li>
<li>@UpdateProvider：生成修改用的 SQL 语句注解</li>
<li>@DeleteProvider：生成删除用的 SQL 语句注解。<ul>
<li>type 属性：生成 SQL 语句功能类对象 </li>
<li>method 属性：指定调用方法</li>
</ul>
</li>
</ul>
<hr>
<h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li><p>MyBatisConfig.xml 配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- mappers引入映射配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Mapper 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询全部</span></span><br><span class="line">    <span class="meta">@SelectProvider(type = ReturnSql.class, method = &quot;getSelectAll&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Student&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增数据</span></span><br><span class="line">    <span class="meta">@InsertProvider(type = ReturnSql.class, method = &quot;getInsert&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">insert</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改操作</span></span><br><span class="line">    <span class="meta">@UpdateProvider(type = ReturnSql.class, method = &quot;getUpdate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">update</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">    <span class="meta">@DeleteProvider(type = ReturnSql.class, method = &quot;getDelete&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ReturnSQL 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReturnSql</span> &#123;</span><br><span class="line">    <span class="comment">//定义方法，返回查询的sql语句</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSelectAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                SELECT(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                FROM(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义方法，返回新增的sql语句</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInsert</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                INSERT_INTO(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">                INTO_VALUES(<span class="string">&quot;#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义方法，返回修改的sql语句</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUpdate</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                UPDATE(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">                SET(<span class="string">&quot;name=#&#123;name&#125;&quot;</span>,<span class="string">&quot;age=#&#123;age&#125;&quot;</span>);</span><br><span class="line">                WHERE(<span class="string">&quot;id=#&#123;id&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义方法，返回删除的sql语句</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDelete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                DELETE_FROM(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">                WHERE(<span class="string">&quot;id=#&#123;id&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>功能实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlTest</span> &#123;	</span><br><span class="line">	<span class="meta">@Test</span>  <span class="comment">//查询全部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.加载核心配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;MyBatisConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取SqlSession工厂对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过工厂对象获取SqlSession对象</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.调用实现类对象中的方法，接收结果</span></span><br><span class="line">        List&lt;Student&gt; list = mapper.selectAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.处理结果</span></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span>  <span class="comment">//新增</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1 2 3 4获取StudentMapper接口的实现类对象</span></span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.调用实现类对象中的方法，接收结果 -&gt;6 7</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>,<span class="string">&quot;赵六&quot;</span>,<span class="number">26</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> mapper.insert(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">//修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1 2 3 4 5调用实现类对象中的方法，接收结果 -&gt;6 7 </span></span><br><span class="line">		<span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>,<span class="string">&quot;赵六wq&quot;</span>,<span class="number">36</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> mapper.update(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">//删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1 2 3 4 5 6 7</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> mapper.delete(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p>
<p>MyBatis 运行过程：</p>
<ol>
<li><p>加载 MyBatis 全局配置文件，通过 XPath 方式解析 XML 配置文件，首先解析核心配置文件，<settings> 标签中配置属性项有 defaultExecutorType，用来配置指定 Executor 类型，将配置文件的信息填充到 Configuration对象。最后解析映射器配置的映射文件，并<strong>构建 MappedStatement 对象填充至 Configuration</strong>，将解析后的映射器添加到 mapperRegistry 中，用于获取代理</settings></p>
</li>
<li><p>创建一个 DefaultSqlSession 对象，<strong>根据参数创建指定类型的 Executor</strong>，二级缓存默认开启，把 Executor 包装成缓存执行器</p>
</li>
<li><p>DefaulSqlSession 调用 getMapper()，通过 JDK 动态代理获取 Mapper 接口的代理对象 MapperProxy </p>
</li>
<li><p>执行 SQL 语句：</p>
<ul>
<li>MapperProxy.invoke() 执行代理方法，通过 MapperMethod#execute 判断执行的是增删改查中的哪个方法</li>
<li>查询方法调用 sqlSession.selectOne()，从 Configuration 中获取执行者对象 MappedStatement，然后 Executor 调用 executor.query 开始执行查询方法</li>
<li>首先通过 CachingExecutor 去二级缓存查询，查询不到去一级缓存查询，<strong>最后去数据库查询并放入一级缓存</strong></li>
<li>Configuration 对象根据 <select> 标签的 statementType 属性创建 StatementHandler 对象，在 StatementHandler 的构造方法中，创建了 ParameterHandler 和 ResultSetHandler 对象</select></li>
<li>最后获取 <strong>JDBC 原生的</strong> Connection 数据库连接对象，创建 Statement 执行者对象，然后通过 ParameterHandler 设置预编译参数，底层是 TypeHandler#setParameter 方法，然后通过 StatementHandler 回调执行者对象执行增删改查，最后调用 ResultsetHandler 处理查询结果</li>
</ul>
</li>
</ol>
<p><strong>四大对象</strong>：</p>
<ul>
<li>StatementHandler：执行 SQL 语句的对象</li>
<li>ParameterHandler：设置预编译参数用的</li>
<li>ResultHandler：处理结果集</li>
<li>Executor：执行器，真正进行 Java 与数据库交互的对象</li>
</ul>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1mW411M737?p=71">https://www.bilibili.com/video/BV1mW411M737?p=71</a></p>
<hr>
<h3 id="获取工厂"><a href="#获取工厂" class="headerlink" title="获取工厂"></a>获取工厂</h3><p>SqlSessionFactoryBuilder.build(InputStream, String,  Properties)：构建工厂</p>
<p>XMLConfigBuilder.parse()：解析核心配置文件每个标签的信息（<strong>XPath</strong>）</p>
<ul>
<li><p><code>parseConfiguration(parser.evalNode(&quot;/configuration&quot;))</code>：读取节点内数据，<configuration> 是 MyBatis 配置文件中的顶层标签</configuration></p>
<p><code>settings = settingsAsProperties(root.evalNode(&quot;settings&quot;))</code>：读取核心配置文件中的 <settings> 标签</settings></p>
<p><code>settingsElement(settings)</code>：设置框架相关的属性</p>
<ul>
<li><code>configuration.setCacheEnabled()</code>：<strong>设置缓存属性，默认是 true</strong></li>
<li><code>configuration.setDefaultExecutorType()</code>：<strong>设置 Executor 类型到 configuration，默认是 SIMPLE</strong></li>
</ul>
<p><code>mapperElement(root.evalNode(&quot;mappers&quot;))</code>：解析 mappers 信息，分为 package 和 单个注册两种</p>
<ul>
<li><p><code>if...else...</code>：根据映射方法选择合适的读取方式</p>
</li>
<li><p><code>XMLMapperBuilder.parse()</code>：解析 mapper 的标签的信息</p>
<ul>
<li><p><code>configurationElement(parser.evalNode(&quot;/mapper&quot;))</code>：解析 mapper 文件，顶层节点 <mapper></mapper></p>
<ul>
<li><p><code>buildStatementFromContext(context.evalNodes(&quot;select...&quot;))</code>：解析<strong>每个操作标签</strong></p>
<p><code>XMLStatementBuilder.parseStatementNode()</code>：解析<strong>操作标签</strong>的所有的属性</p>
<p><code>builderAssistant.addMappedStatement(...)</code>：<strong>封装成 MappedStatement 对象加入 Configuration 对象</strong>，代表一个增删改查的标签</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass)</code>：加载 Mapper 接口</p>
</li>
<li><p><code>Configuration.addMappers()</code>：将核心配置文件配置的映射器添加到 mapperRegistry 中，用来<strong>获取代理对象</strong></p>
<ul>
<li><p><code>MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type)</code>：创建<strong>注解</strong>解析器</p>
</li>
<li><p><code>parser.parse()</code>：解析 Mapper 接口</p>
<ul>
<li><p><code>SqlSource sqlSource = getSqlSourceFromAnnotations()</code>：获取 SQL 的资源对象</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-SQL%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1.png"></p>
</li>
<li><p><code>builderAssistant.addMappedStatement(...)</code>：封装成 MappedStatement 对象加入 Configuration 对象</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>return configuration</code>：返回配置完成的 configuration 对象</p>
</li>
</ul>
<p>return new DefaultSqlSessionFactory(config)：返回工厂对象，包含 Configuration 对象</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E8%8E%B7%E5%8F%96%E5%B7%A5%E5%8E%82%E5%AF%B9%E8%B1%A1.png"></p>
<p>总结：解析 XML 是对 Configuration 中的属性进行填充，那么可以在一个类中创建 Configuration 对象，自定义其中属性的值来达到配置的效果</p>
<hr>
<h3 id="获取会话"><a href="#获取会话" class="headerlink" title="获取会话"></a>获取会话</h3><p>DefaultSqlSessionFactory.openSession()：获取 Session 对象，并且创建 Executor 对象</p>
<p>DefaultSqlSessionFactory.openSessionFromDataSource(…)：ExecutorType 为 Executor 的类型，TransactionIsolationLevel 为事务隔离级别，autoCommit 是否开启事务</p>
<ul>
<li><p><code>transactionFactory.newTransaction(DataSource, IsolationLevel, boolean</code>：事务对象</p>
</li>
<li><p><code>configuration.newExecutor(tx, execType)</code>：<strong>根据参数创建指定类型的 Executor</strong></p>
<ul>
<li>批量操作笔记的部分有讲解到 <setting> 的属性 defaultExecutorType，根据配置创建对象</setting></li>
<li><strong>二级缓存默认开启</strong>，会包装 Executor 对象 <code>new CachingExecutor(executor)</code></li>
</ul>
</li>
</ul>
<p> return new DefaultSqlSession(configuration, executor, autoCommit)：返回 DefaultSqlSession 对象</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E8%8E%B7%E5%8F%96%E4%BC%9A%E8%AF%9D%E5%AF%B9%E8%B1%A1.png"></p>
<hr>
<h3 id="获取代理"><a href="#获取代理" class="headerlink" title="获取代理"></a>获取代理</h3><p>Configuration.getMapper(Class, SqlSession)：获取代理的 mapper 对象</p>
<p>MapperRegistry.getMapper(Class, SqlSession)：MapperRegistry 是 Configuration 属性，在获取工厂对象时初始化</p>
<ul>
<li><code>(MapperProxyFactory&lt;T&gt;) knownMappers.get(type)</code>：获取接口信息封装为 MapperProxyFactory 对象</li>
<li><code>mapperProxyFactory.newInstance(sqlSession)</code>：<strong>创建代理对象</strong><ul>
<li><code>new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache)</code>：包装对象<ul>
<li>methodCache 是并发安全的 ConcurrentHashMap 集合，存放要执行的方法</li>
<li><code>MapperProxy&lt;T&gt; implements InvocationHandler</code> 说明 MapperProxy 默认是一个 InvocationHandler 对象</li>
</ul>
</li>
<li><code>Proxy.newProxyInstance()</code>：<strong>JDK 动态代理</strong>创建 MapperProxy 对象</li>
</ul>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1.png"></p>
<hr>
<h3 id="执行SQL"><a href="#执行SQL" class="headerlink" title="执行SQL"></a>执行SQL</h3><p>MapperProxy.invoke()：执行 SQL 语句，Object 类的方法直接执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当前方法是否是属于 Object 类中的方法</span></span><br><span class="line">        <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">            <span class="comment">// 当前方法是否是默认方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 包装成一个 MapperMethod 对象并初始化该对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">MapperMethod</span> <span class="variable">mapperMethod</span> <span class="operator">=</span> cachedMapperMethod(method);</span><br><span class="line">    <span class="comment">// 【根据 switch-case 判断使用的什么类型的 SQL 进行逻辑处理】，此处分析查询语句的查询操作</span></span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sqlSession.selectOne(String, Object)：查询数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">// 解析传入的参数</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">    result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DefaultSqlSession.selectList(String, Object)</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取执行者对象</span></span><br><span class="line">    <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(statement);</span><br><span class="line">    <span class="comment">// 开始执行查询语句，参数通过 wrapCollection() 包装成集合类</span></span><br><span class="line">    <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Executor#query()：</p>
<ul>
<li><p><code>CachingExecutor.query()</code>：先执行 CachingExecutor 去二级缓存获取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachingExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executor delegate;		<span class="comment">// 包装了 BaseExecutor，二级缓存不存在数据调用 BaseExecutor 查询</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>MappedStatement.getBoundSql(parameterObject)</code>：<strong>把 parameterObject 封装成 BoundSql</strong></p>
<p>构造函数中有：<code>this.parameterObject = parameterObject</code></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-boundSql%E5%AF%B9%E8%B1%A1.png"></p>
</li>
<li><p><code>CachingExecutor.createCacheKey()</code>：创建缓存对象</p>
</li>
<li><p><code>ms.getCache()</code>：获取二级缓存</p>
</li>
<li><p><code>tcm.getObject(cache, key)</code>：尝试从<strong>二级缓存</strong>中获取数据</p>
</li>
</ul>
</li>
<li><p><code>BaseExecutor.query()</code>：二级缓存不存在该数据，调用该方法</p>
<ul>
<li><code>localCache.getObject(key) </code>：尝试从<strong>本地缓存（一级缓存</strong>）获取数据</li>
</ul>
</li>
<li><p><code>BaseExecutor.queryFromDatabase()</code>：缓存获取数据失败，<strong>开始从数据库获取数据，并放入本地缓存</strong></p>
<ul>
<li><p><code>SimpleExecutor.doQuery()</code>：执行 query</p>
<ul>
<li><p><code>configuration.newStatementHandler()</code>：创建 StatementHandler 对象</p>
<ul>
<li>根据 <select> 标签的 statementType 属性，根据属性选择创建哪种对象</select></li>
<li>判断 BoundSql 是否被创建，没有创建会重新封装参数信息到 BoundSql</li>
<li><strong>StatementHandler 的构造方法中，创建了 ParameterHandler 和 ResultSetHandler 对象</strong></li>
<li><code>interceptorChain.pluginAll(statementHandler)</code>：拦截器链</li>
</ul>
</li>
<li><p><code>prepareStatement()</code>：通过 StatementHandler 创建 JDBC 原生的 Statement 对象</p>
<ul>
<li><code>getConnection()</code>：<strong>获取 JDBC 的 Connection 对象</strong></li>
<li><code>handler.prepare()</code>：初始化 Statement 对象<ul>
<li><code>instantiateStatement(Connection connection)</code>：Connection  中的方法实例化对象<ul>
<li>获取普通执行者对象：<code>Connection.createStatement()</code></li>
<li><strong>获取预编译执行者对象</strong>：<code>Connection.prepareStatement()</code></li>
</ul>
</li>
</ul>
</li>
<li><code>handler.parameterize()</code>：进行参数的设置<ul>
<li><code>ParameterHandler.setParameters()</code>：<strong>通过 ParameterHandler 设置参数</strong><ul>
<li><code>typeHandler.setParameter()</code>：底层通过 TypeHandler 实现，回调 JDBC 的接口进行设置</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>StatementHandler.query()</code>：<strong>调用 JDBC 原生的 PreparedStatement 执行 SQL</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 SQL 语句</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> boundSql.getSql();</span><br><span class="line">    statement.execute(sql);</span><br><span class="line">    <span class="comment">// 通过 ResultSetHandler 对象封装结果集，映射成 JavaBean</span></span><br><span class="line">    <span class="keyword">return</span> resultSetHandler.handleResultSets(statement);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>resultSetHandler.handleResultSets(statement)</code>：处理结果集</p>
<ul>
<li><p><code>handleResultSet(rsw, resultMap, multipleResults, null)</code>：底层回调</p>
<ul>
<li><p><code>handleRowValues()</code>：逐行处理数据，根据是否配置了 <resultMap> 属性选择是否使用简单结果集映射</resultMap></p>
<ul>
<li><p>首先判断数据是否被限制行数，然后进行结果集的映射</p>
</li>
<li><p>最后将数据存入 ResultHandler 对象，底层就是 List 集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultResultHandler</span> <span class="keyword">implements</span> <span class="title class_">ResultHandler</span>&lt;Object&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; list;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleResult</span><span class="params">(ResultContext&lt;?&gt; context)</span> &#123;</span><br><span class="line">    	list.add(context.getResultObject());</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><code>return collapseSingleResultList(multipleResults)</code>：可能存在多个结果集的情况</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>localCache.putObject(key, list)</code>：<strong>放入一级（本地）缓存</strong></p>
</li>
</ul>
</li>
</ul>
<p><code>return list.get(0)</code>：返回结果集的第一个数据</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-%E6%89%A7%E8%A1%8CSQL%E8%BF%87%E7%A8%8B.png"></p>
<hr>
<h2 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h2><h3 id="插件原理"><a href="#插件原理" class="headerlink" title="插件原理"></a>插件原理</h3><p>实现原理：插件是按照插件配置顺序创建层层包装对象，执行目标方法的之后，按照逆向顺序执行（栈）</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/MyBatis-插件原理.png" style="zoom:50%;">

<p>在四大对象创建时：</p>
<ul>
<li>每个创建出来的对象不是直接返回的，而是 <code>interceptorChain.pluginAll(parameterHandler)</code></li>
<li>获取到所有 Interceptor（插件需要实现的接口），调用 <code>interceptor.plugin(target)</code>返回 target 包装后的对象</li>
<li>插件机制可以使用插件为目标对象创建一个代理对象，代理对象可以<strong>拦截到四大对象的每一个执行</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts(</span></span><br><span class="line"><span class="meta">		&#123;</span></span><br><span class="line"><span class="meta">		@Signature(type=StatementHandler.class,method=&quot;parameterize&quot;,args=java.sql.Statement.class)</span></span><br><span class="line"><span class="meta">		&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFirstPlugin</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//intercept：拦截目标对象的目标方法的执行</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;MyFirstPlugin...intercept:&quot;</span> + invocation.getMethod());</span><br><span class="line">		<span class="comment">//动态的改变一下sql运行的参数：以前1号员工，实际从数据库查询11号员工</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> invocation.getTarget();</span><br><span class="line">		System.out.println(<span class="string">&quot;当前拦截到的对象：&quot;</span> + target);</span><br><span class="line">		<span class="comment">//拿到：StatementHandler==&gt;ParameterHandler===&gt;parameterObject</span></span><br><span class="line">		<span class="comment">//拿到target的元数据</span></span><br><span class="line">		<span class="type">MetaObject</span> <span class="variable">metaObject</span> <span class="operator">=</span> SystemMetaObject.forObject(target);</span><br><span class="line">		<span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> metaObject.getValue(<span class="string">&quot;parameterHandler.parameterObject&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;sql语句用的参数是：&quot;</span> + value);</span><br><span class="line">		<span class="comment">//修改完sql语句要用的参数</span></span><br><span class="line">		metaObject.setValue(<span class="string">&quot;parameterHandler.parameterObject&quot;</span>, <span class="number">11</span>);</span><br><span class="line">		<span class="comment">//执行目标方法</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">		<span class="comment">//返回执行后的返回值</span></span><br><span class="line">		<span class="keyword">return</span> proceed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// plugin：包装目标对象的，为目标对象创建一个代理对象</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">plugin</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">		<span class="comment">//可以借助 Plugin 的 wrap 方法来使用当前 Interceptor 包装我们目标对象</span></span><br><span class="line">		System.out.println(<span class="string">&quot;MyFirstPlugin...plugin:mybatis将要包装的对象&quot;</span> + target);</span><br><span class="line">		<span class="type">Object</span> <span class="variable">wrap</span> <span class="operator">=</span> Plugin.wrap(target, <span class="built_in">this</span>);</span><br><span class="line">		<span class="comment">//返回为当前target创建的动态代理</span></span><br><span class="line">		<span class="keyword">return</span> wrap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// setProperties：将插件注册时的property属性设置进来</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;插件配置的信息：&quot;</span> + properties);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--plugins：注册插件  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;mybatis.dao.MyFirstPlugin&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>





<hr>
<h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/%E5%88%86%E9%A1%B5%E4%BB%8B%E7%BB%8D.png"></p>
<ul>
<li>分页可以将很多条结果进行分页显示。如果当前在第一页，则没有上一页。如果当前在最后一页，则没有下一页，需要明确当前是第几页，这一页中显示多少条结果。  </li>
<li>MyBatis 是不带分页功能的，如果想实现分页功能，需要手动编写 LIMIT 语句，不同的数据库实现分页的 SQL 语句也是不同，手写分页 成本较高。</li>
<li>PageHelper：第三方分页助手，将复杂的分页操作进行封装，从而让分页功能变得非常简单</li>
</ul>
<hr>
<h3 id="分页操作"><a href="#分页操作" class="headerlink" title="分页操作"></a>分页操作</h3><p>开发步骤：</p>
<ol>
<li><p>导入 PageHelper 的 Maven 坐标</p>
</li>
<li><p>在 MyBatis 核心配置文件中配置 PageHelper 插件</p>
<p>注意：分页助手的插件配置在通用 Mapper 之前</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定方言 --&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>.........<span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>与 MySQL 分页查询页数计算公式不同</p>
<p><code>static &lt;E&gt; Page&lt;E&gt; startPage(int pageNum, int pageSize)</code>：pageNum第几页，pageSize页面大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//第一页：显示2条数据</span></span><br><span class="line">    PageHelper.startPage(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    List&lt;Student&gt; students = sqlSession.selectList(<span class="string">&quot;StudentMapper.selectAll&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="参数获取"><a href="#参数获取" class="headerlink" title="参数获取"></a>参数获取</h3><p>PageInfo构造方法：</p>
<ul>
<li><code>PageInfo&lt;Student&gt; info = new PageInfo&lt;&gt;(list)</code> : list 是 SQL 执行返回的结果集合，参考上一节</li>
</ul>
<p>PageInfo相关API：</p>
<ol>
<li>startPage()：设置分页参数 </li>
<li>PageInfo：分页相关参数功能类。 </li>
<li>getTotal()：获取总条数 </li>
<li>getPages()：获取总页数</li>
<li>getPageNum()：获取当前页</li>
<li>getPageSize()：获取每页显示条数</li>
<li>getPrePage()：获取上一页 </li>
<li>getNextPage()：获取下一页 </li>
<li>isIsFirstPage()：获取是否是第一页 </li>
<li>isIsLastPage()：获取是否是最后一页</li>
</ol>
<hr>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>框架源自于建筑学，隶属土木工程，后发展到软件工程领域</p>
<p>软件工程框架：经过验证的，具有一定功能的，半成品软件</p>
<ul>
<li><p>经过验证</p>
</li>
<li><p>具有一定功能</p>
</li>
<li><p>半成品</p>
</li>
</ul>
<p>框架作用：</p>
<ul>
<li><p>提高开发效率</p>
</li>
<li><p>增强可重用性</p>
</li>
<li><p>提供编写规范</p>
</li>
<li><p>节约维护成本</p>
</li>
<li><p>解耦底层实现原理</p>
</li>
</ul>
<p>参考视频：<a href="https://space.bilibili.com/37974444">https://space.bilibili.com/37974444</a></p>
<hr>
<h3 id="Spring-1"><a href="#Spring-1" class="headerlink" title="Spring"></a>Spring</h3><p>Spring 是分层的 JavaSE&#x2F;EE 应用 full-stack 轻量级开源框架</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.png"></p>
<p>Spring 优点：</p>
<ul>
<li>方便解耦，简化开发</li>
<li>方便集成各种框架</li>
<li>方便程序测试</li>
<li>AOP 编程难过的支持</li>
<li>声明式事务的支持</li>
<li>降低 JavaEE API 的使用难度</li>
</ul>
<p>体系结构：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"></p>
<hr>
<h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><ul>
<li>IoC（Inversion Of Control）控制反转，Spring 反向控制应用程序所需要使用的外部资源</li>
<li><strong>Spring 控制的资源全部放置在 Spring 容器中，该容器称为 IoC 容器</strong>（存放实例对象）</li>
<li>官方网站：<a href="https://spring.io/">https://spring.io/</a> → Projects → spring-framework → LEARN → Reference Doc</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-IOC%E4%BB%8B%E7%BB%8D.png"></p>
<ul>
<li>耦合（Coupling）：代码编写过程中所使用技术的结合紧密度，用于衡量软件中各个模块之间的互联程度</li>
<li>内聚（Cohesion）：代码编写过程中单个模块内部各组成部分间的联系，用于衡量软件中各个功能模块内部的功能联系</li>
<li>代码编写的目标：高内聚，低耦合。同一个模块内的各个元素之间要高度紧密，各个模块之间的相互依存度不紧密</li>
</ul>
<hr>
<h3 id="入门项目"><a href="#入门项目" class="headerlink" title="入门项目"></a>入门项目</h3><p>模拟三层架构中表现层调用业务层功能</p>
<ul>
<li><p>表现层：UserApp 模拟 UserServlet（使用 main 方法模拟）</p>
</li>
<li><p>业务层：UserService</p>
</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>导入 spring 坐标（5.1.9.release）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写业务层与表现层（模拟）接口与实现类 service.UserService，service.impl.UserServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">	<span class="comment">//业务方法  </span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立 Spring 配置文件：resources.<strong>applicationContext</strong>.xml (名字一般使用该格式)</p>
</li>
<li><p>配置所需资源（Service）为 Spring 控制的资源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.创建spring控制的资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>表现层（App）通过 Spring 获取资源（Service 实例）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//2.加载配置文件</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//3.获取资源</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.save();<span class="comment">//user service running...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-IOC%E5%AE%9E%E7%8E%B0.png"></p>
</li>
</ol>
<hr>
<h3 id="XML开发"><a href="#XML开发" class="headerlink" title="XML开发"></a>XML开发</h3><h4 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h4><h5 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h5><p>标签：<bean> 标签，<beans> 的子标签</beans></bean></p>
<p>作用：定义 Spring 中的资源，受此标签定义的资源将受到 Spring 控制</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基本属性</p>
<ul>
<li>id：bean 的名称，通过 id 值获取 bean (首字母小写)</li>
<li>class：bean 的类型，使用完全限定类名</li>
<li>name：bean 的名称，可以通过 name 值获取 bean，用于多人配合时给 bean 起别名</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanId&quot;</span> <span class="attr">name</span>=<span class="string">&quot;beanName1,beanName2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ClassName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctx.getBean(<span class="string">&quot;beanId&quot;</span>) == ctx.getBean(<span class="string">&quot;beanName1&quot;</span>) == ctx.getBean(<span class="string">&quot;beanName2&quot;</span>)</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h5><p>作用：定义 bean 的作用范围</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>取值：</p>
<ul>
<li>singleton：设定创建出的对象保存在 Spring 容器中，是一个单例的对象</li>
<li>prototype：设定创建出的对象保存在 Spring 容器中，是一个非单例（原型）的对象</li>
<li>request、session、application、 websocket ：设定创建出的对象放置在 web 容器对应的位置</li>
</ul>
<p>Spring 容器中 Bean 的<strong>线程安全</strong>问题：</p>
<ul>
<li><p>原型 Bean，每次创建一个新对象，线程之间并不存在 Bean 共享，所以不会有线程安全的问题</p>
</li>
<li><p>单例 Bean，所有线程共享一个单例实例 Bean，因此是存在资源的竞争，如果单例 Bean是一个<strong>无状态 Bean</strong>，也就是线程中的操作不会对 Bean 的成员执行查询以外的操作，那么这个单例 Bean 是线程安全的</p>
<p>解决方法：开发人员来进行线程安全的保证，最简单的办法就是把 Bean 的作用域 singleton 改为 protopyte</p>
</li>
</ul>
<hr>
<h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p>作用：定义 bean 对象在初始化或销毁时完成的工作</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&gt;&lt;/bean&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>取值：bean 对应的类中对应的具体方法名</p>
<p>实现接口的方式实现初始化，无需配置文件配置 init-method：</p>
<ul>
<li>实现 InitializingBean，定义初始化逻辑</li>
<li>实现 DisposableBean，定义销毁逻辑</li>
</ul>
<p>注意事项：</p>
<ul>
<li>当 scope&#x3D;“singleton” 时，Spring 容器中有且仅有一个对象，init 方法在创建容器时仅执行一次</li>
<li>当 scope&#x3D;“prototype” 时，Spring 容器要创建同一类型的多个对象，init 方法在每个对象创建时均执行一次</li>
<li>当 scope&#x3D;“singleton” 时，关闭容器（<code>.close()</code>）会导致 bean 实例的销毁，调用 destroy 方法一次</li>
<li>当 scope&#x3D;“prototype” 时，对象的销毁由垃圾回收机制 GC 控制，destroy 方法将不会被执行</li>
</ul>
<p>bean 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--init-method和destroy-method用于控制bean的生命周期--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService3&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>业务层实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; constructor is running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService)ctx.getBean(<span class="string">&quot;userService3&quot;</span>);</span><br></pre></td></tr></table></figure>





<hr>
<h5 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h5><ul>
<li><p>静态工厂</p>
<p>作用：定义 bean 对象创建方式，使用静态工厂的形式创建 bean，兼容早期遗留系统的升级工作</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;FactoryClassName&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;factoryMethodName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>取值：工厂 bean 中用于获取对象的静态方法名</p>
<p>注意事项：class 属性必须配置成静态工厂的类名</p>
<p>bean 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--静态工厂创建 bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService4&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.UserServiceFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>工厂类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title function_">getService</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;factory create object...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService)ctx.getBean(<span class="string">&quot;userService4&quot;</span>);</span><br></pre></td></tr></table></figure>


</li>
<li><p>实例工厂</p>
<p>作用：定义 bean 对象创建方式，使用实例工厂的形式创建 bean，兼容早期遗留系统的升级工作</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">factory-bean</span>=<span class="string">&quot;factoryBeanId&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;factoryMethodName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li><p>使用实例工厂创建 bean 首先需要将实例工厂配置 bean，交由 Spring 进行管理</p>
</li>
<li><p>factory-bean 是实例工厂的 Id</p>
</li>
</ul>
<p>bean 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--实例工厂创建 bean，依赖工厂对象对应的 bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;factoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.UserServiceFactory2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService5&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;factoryBean&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>工厂类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceFactory2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">getService</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; instance factory create object...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="获取Bean"><a href="#获取Bean" class="headerlink" title="获取Bean"></a>获取Bean</h5><p>ApplicationContext 子类相关API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String[] getBeanDefinitionNames()</td>
<td>获取 Spring 容器中定义的所有 JavaBean 的名称</td>
</tr>
<tr>
<td>BeanDefinition getBeanDefinition(String beanName)</td>
<td>返回给定 bean 名称的 BeanDefinition</td>
</tr>
<tr>
<td>String[] getBeanNamesForType(Class&lt;?&gt; type)</td>
<td>获取 Spring 容器中指定类型的所有 JavaBean 的名称</td>
</tr>
<tr>
<td>Environment getEnvironment()</td>
<td>获取与此组件关联的环境</td>
</tr>
</tbody></table>
<hr>
<h4 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h4><h5 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h5><ul>
<li><p>IoC（Inversion Of Control）控制翻转，Spring 反向控制应用程序所需要使用的外部资源</p>
</li>
<li><p>DI（Dependency Injection）依赖注入，应用程序运行依赖的资源由 Spring 为其提供，资源进入应用程序的方式称为注入，简单说就是利用反射机制为类的属性赋值的操作</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-DI%E4%BB%8B%E7%BB%8D.png"></p>
</li>
</ul>
<p>IoC 和 DI 的关系：IoC 与 DI 是同一件事站在不同角度看待问题</p>
<hr>
<h5 id="set-注入"><a href="#set-注入" class="headerlink" title="set 注入"></a>set 注入</h5><p>标签：<property> 标签，<bean> 的子标签</bean></property></p>
<p>作用：使用 set 方法的形式为 bean 提供资源</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> /&gt;</span></span><br><span class="line">    .....</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基本属性：</p>
<ul>
<li>name：对应 bean 中的属性名，要注入的变量名，要求该属性必须提供可访问的 set 方法（严格规范此名称是 set 方法对应名称，首字母必须小写）</li>
<li>value：设定非引用类型属性对应的值，<strong>不能与 ref 同时使用</strong></li>
<li>ref：设定引用类型属性对应 bean 的 id ，不能与 value 同时使用</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;propertyName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;propertyValue&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;beanId&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码实现：</p>
<ul>
<li><p>DAO 层：要注入的资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Service 业务层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.对需要进行注入的变量添加set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span> + num);</span><br><span class="line">        userDao.save();</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--2.将要注入的资源声明为bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--3.将要注入的引用类型的变量通过property属性进行注入，--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h5><p>标签：<constructor-arg> 标签，<bean> 的子标签</bean></constructor-arg></p>
<p>作用：使用构造方法的形式为 bean 提供资源，兼容早期遗留系统的升级工作</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> /&gt;</span></span><br><span class="line">    .....<span class="comment">&lt;!--一个bean可以有多个constructor-arg标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>属性：</p>
<ul>
<li>name：对应bean中的构造方法所携带的参数名</li>
<li>value：设定非引用类型构造方法参数对应的值，不能与 ref 同时使用</li>
<li>ref：设定引用类型构造方法参数对应 bean 的 id ，不能与 value 同时使用</li>
<li>type：设定构造方法参数的类型，用于按类型匹配参数或进行类型校验</li>
<li>index：设定构造方法参数的位置，用于按位置匹配参数，参数 index 值从 0 开始计数</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;argsName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;argsValue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;arg-index&quot;</span> <span class="attr">type</span>=<span class="string">&quot;arg-type&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;beanId&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码实现：</p>
<ul>
<li><p>DAO 层：要注入的资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoImpl</span><span class="params">(String driver,String username, String pwd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.driver = driver;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao running...&quot;</span>+username+<span class="string">&quot; &quot;</span>+pwd+<span class="string">&quot; &quot;</span>+driver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Service 业务层：参考 set 注入</p>
</li>
<li><p>配置 applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用构造方法进行注入，需要保障注入的属性与bean中定义的属性一致--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--一致指顺序一致或类型一致或使用index解决该问题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方式二：使用 UserServiceImpl 的构造方法注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666666&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类：参考 set 注入</p>
</li>
</ul>
<hr>
<h5 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h5><p>标签：<array> <list> <set> <map> <props>，<property> 或 <constructor-arg> 标签的子标签</constructor-arg></property></props></map></set></list></array></p>
<p>作用：注入集合数据类型属性</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">list</span>&gt;</span><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码实现：</p>
<ul>
<li><p>DAO 层：要注入的资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList al;</span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> HashSet hs;</span><br><span class="line">    <span class="keyword">private</span> HashMap hm ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAl</span><span class="params">(ArrayList al)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.al = al;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setArr</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHs</span><span class="params">(HashSet hs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hs = hs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHm</span><span class="params">(HashMap hm)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hm = hm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao running...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ArrayList:&quot;</span> + al);</span><br><span class="line">        System.out.println(<span class="string">&quot;Properties:&quot;</span> + properties);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;HashSet:&quot;</span> + hs);</span><br><span class="line">        System.out.println(<span class="string">&quot;HashMap:&quot;</span> + hm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Service 业务层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span> + num);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;al&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>seazean<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>66666<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;name&quot;</span>&gt;</span>seazean666<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;value&quot;</span>&gt;</span>666666<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;arr&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>66666<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hs&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>seazean<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>66666<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;seazean66666&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;value&quot;</span> <span class="attr">value</span>=<span class="string">&quot;6666666666&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="P"><a href="#P" class="headerlink" title="P"></a>P</h4><p>标签：&lt;p:propertyName&gt;，&lt;p:propertyName-ref&gt;</p>
<p>作用：为 bean 注入属性值</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">p:propertyName</span>=<span class="string">&quot;propertyValue&quot;</span> <span class="attr">p:propertyName-ref</span>=<span class="string">&quot;beanId&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>开启 p 命令空间：开启 Spring 对 p 命令空间的的支持，在 beans 标签中添加对应空间支持</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>   		</span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>    </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span>       </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">		http://www.springframework.org/schema/beans     </span></span></span><br><span class="line"><span class="string"><span class="tag">		https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:userDao-ref</span>=<span class="string">&quot;userDao&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:bookDao-ref</span>=<span class="string">&quot;bookDao&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:num</span>=<span class="string">&quot;10&quot;</span></span></span><br><span class="line"><span class="tag">	/&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h4><p>Spring 提供了对 EL 表达式的支持，统一属性注入格式</p>
<p>作用：为 bean 注入属性值</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">value</span>=<span class="string">&quot;EL&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：所有属性值不区分是否引用类型，统一使用value赋值</p>
<p>所有格式统一使用  value&#x3D;“#{}”</p>
<ul>
<li><p>常量  #{10}  #{3.14}  #{2e5}  #{‘it’}</p>
</li>
<li><p>引用 bean  #{beanId}    </p>
</li>
<li><p>引用 bean 属性  #{beanId.propertyName}</p>
</li>
<li><p>引用 bean 方法  beanId.methodName().method2()</p>
</li>
<li><p>引用静态方法  T(java.lang.Math).PI</p>
</li>
<li><p>运算符支持  #{3 lt 4 &#x3D;&#x3D; 4 ge 3}</p>
</li>
<li><p>正则表达式支持  #{user.name matches‘[a-z]{6,}’}</p>
</li>
<li><p>集合支持  #{likes[3]}</p>
</li>
</ul>
<p>实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;userDao&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;bookDao&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;666666666&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h4><p>Spring 提供了读取外部 properties 文件的机制，使用读取到的数据为 bean 的属性赋值</p>
<p>操作步骤：</p>
<ol>
<li><p>准备外部 properties 文件</p>
</li>
<li><p>开启 context 命名空间支持</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        &quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>加载指定的 properties 文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:data.properties&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用加载的数据</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;propertyName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;propertiesName&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>注意：如果需要加载所有的 properties 文件，可以使用 <code>*.properties</code> 表示加载所有的 properties 文件</p>
</li>
<li><p>注意：读取数据使用 <strong>${propertiesName}</strong> 格式进行，其中 propertiesName 指 properties 文件中的属性名</p>
</li>
</ul>
<p>代码实现：</p>
<ul>
<li><p>data.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">pwd</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>DAO 层：注入的资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao running...&quot;</span>+userName+<span class="string">&quot; &quot;</span>+password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Service 业务层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;pwd&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>标签：<import>，<beans>标签的子标签</beans></import></p>
<p>作用：在当前配置文件中导入其他配置文件中的项</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>属性：</p>
<ul>
<li>resource：加载的配置文件名</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">“config2.xml</span>&quot;/&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring 容器加载多个配置文件：</p>
<ul>
<li><p>applicationContext-book.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>applicationContext-user.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;pwd&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;applicationContext-user.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;applicationContext-book.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.seazean.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext-user.xml&quot;</span>,<span class="string">&quot;applicationContext-book.xml&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Spring 容器中的 bean 定义冲突问题</p>
<ul>
<li><p>同 id 的 bean，后定义的覆盖先定义的</p>
</li>
<li><p>导入配置文件可以理解为将导入的配置文件复制粘贴到对应位置，程序执行选择最下面的配置使用</p>
</li>
<li><p>导入配置文件的顺序与位置不同可能会导致最终程序运行结果不同</p>
</li>
</ul>
<hr>
<h4 id="三方资源"><a href="#三方资源" class="headerlink" title="三方资源"></a>三方资源</h4><h5 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h5><p>第三方资源配置</p>
<ul>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载druid资源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://192.168.2.185:3306/spring_db&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>App.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">DruidDataSource</span> <span class="variable">datasource</span> <span class="operator">=</span> (DruidDataSource) ctx.getBean(<span class="string">&quot;datasource&quot;</span>);</span><br><span class="line">System.out.println(datasource);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h5><p>Mybatis 核心配置文件消失</p>
<ul>
<li><p>环境 environment 转换成数据源对象</p>
</li>
<li><p>映射 Mapper 扫描工作交由 Spring 处理</p>
</li>
<li><p>类型别名交由 Spring 处理</p>
</li>
</ul>
<p>DAO 接口不需要创建实现类，MyBatis-Spring 提供了一个动态代理的实现 <strong>MapperFactoryBean</strong>，这个类可以让直接注入数据映射器接口到 service 层 bean 中，底层将会动态代理创建类</p>
<p>整合原理：利用 Spring 框架的 SPI 机制，在 META-INF 目录的 spring.handlers 中给 Spring 容器中导入 NamespaceHandler 类</p>
<ul>
<li><p>NamespaceHandler 的 init 方法注册 bean 信息的解析器 MapperScannerBeanDefinitionParser</p>
</li>
<li><p>解析器在 Spring 容器创建过程中去<strong>解析 mapperScanner 标签</strong>，解析出的属性填充到 MapperScannerConfigurer 中</p>
</li>
<li><p>MapperScannerConfigurer 实现了 BeanDefinitionRegistryPostProcessor 接口，重写 postProcessBeanDefinitionRegistry() 方法，可以扫描到 MyBatis 的 Mapper</p>
</li>
</ul>
<hr>
<h3 id="注解开发-1"><a href="#注解开发-1" class="headerlink" title="注解开发"></a>注解开发</h3><h4 id="注解驱动"><a href="#注解驱动" class="headerlink" title="注解驱动"></a>注解驱动</h4><h5 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h5><p>启动注解扫描，加载类中配置的注解项：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;packageName1,packageName2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>在进行包扫描时，会对配置的包及其子包中所有文件进行扫描，多个包采用<code>,</code>隔开</li>
<li>扫描过程是以文件夹递归迭代的形式进行的</li>
<li>扫描过程仅读取合法的 Java 文件</li>
<li>扫描时仅读取 Spring 可识别的注解</li>
<li>扫描结束后会将可识别的有效注解转化为 Spring 对应的资源加入 IoC 容器</li>
<li>从加载效率上来说注解优于 XML 配置文件</li>
</ul>
<p>注解：启动时使用注解的形式替代 xml 配置，将 Spring 配置文件从工程中消除，简化书写</p>
<p>缺点：为了达成注解驱动的目的，可能会将原先很简单的书写，变的更加复杂。XML 中配置第三方开发的资源是很方便的，但使用注解驱动无法在第三方开发的资源中进行编辑，因此会增大开发工作量</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E7%A4%BA%E4%BE%8B.png"></p>
<hr>
<h5 id="纯注解"><a href="#纯注解" class="headerlink" title="纯注解"></a>纯注解</h5><p>注解配置类</p>
<p>名称：@Configuration、@ComponentScan</p>
<p>类型：类注解</p>
<p>作用：<strong>设置当前类为 Spring 核心配置加载类</strong></p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;scanPackageName1&quot;,&quot;scanPackageName2&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfigClassName</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>核心配合类用于替换 Spring 核心配置文件，此类可以设置空的，不设置变量与属性</li>
<li>bean 扫描工作使用注解 @ComponentScan 替代，多个包用 <code>&#123;&#125; 和 ,</code> 隔开</li>
</ul>
<p>加载纯注解格式上下文对象，需要使用 <strong>AnnotationConfigApplicationContext</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person1</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            		<span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="comment">//方式一：名称对应类名</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(Person.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//方式二：名称对应方法名 </span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">bean1</span> <span class="operator">=</span> (Person) applicationContext.getBean(<span class="string">&quot;person1&quot;</span>);	</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法三：指定名称@Bean(&quot;person2&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="扫描器"><a href="#扫描器" class="headerlink" title="扫描器"></a>扫描器</h5><p>组件扫描过滤器</p>
<p>开发过程中，需要根据需求加载必要的 bean，排除指定 bean</p>
<p>名称：@ComponentScan</p>
<p>类型：<strong>类注解</strong></p>
<p>作用：设置 Spring 配置加载类扫描规则</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    value = &#123;&quot;dao&quot;,&quot;service&quot;&#125;,			//设置基础扫描路径</span></span><br><span class="line"><span class="meta">    excludeFilters =					//设置过滤规则，当前为排除过滤</span></span><br><span class="line"><span class="meta">	@ComponentScan.Filter(				//设置过滤器</span></span><br><span class="line"><span class="meta">	    type= FilterType.ANNOTATION,  	//设置过滤方式为按照注解进行过滤</span></span><br><span class="line"><span class="meta">	    classes = Service.class)     	//设置具体的过滤项，过滤所有@Service修饰的bean</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>属性：</p>
<ul>
<li>includeFilters：设置包含性过滤器 </li>
<li>excludeFilters：设置排除性过滤器</li>
<li>type：设置过滤器类型</li>
</ul>
<hr>
<h4 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h4><h5 id="设置-bean"><a href="#设置-bean" class="headerlink" title="设置 bean"></a>设置 bean</h5><p>名称：@Component、@Controller、@Service、@Repository</p>
<p>类型：类注解，写在类定义上方</p>
<p>作用：设置该类为 Spring 管理的 bean</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>说明：@Controller、@Service 、@Repository 是 @Component 的衍生注解，功能同 @Component</p>
<p>属性：</p>
<ul>
<li>value（默认）：定义 bean 的访问 id</li>
</ul>
<hr>
<h5 id="作用范围-1"><a href="#作用范围-1" class="headerlink" title="作用范围"></a>作用范围</h5><p>名称：@Scope</p>
<p>类型：类注解，写在类定义上方</p>
<p>作用：设置该类作为 bean 对应的 scope 属性</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>相关属性</p>
<ul>
<li>value（默认）：定义 bean 的作用域，默认为 singleton，非单例取值 prototype</li>
</ul>
<hr>
<h5 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h5><p>名称：@PostConstruct、@PreDestroy</p>
<p>类型：方法注解，写在方法定义上方</p>
<p>作用：设置该类作为 bean 对应的生命周期方法</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义bean，后面添加bean的id</span></span><br><span class="line"><span class="meta">@Component(&quot;userService&quot;)</span></span><br><span class="line"><span class="comment">//定义bean的作用域</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//销毁</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service destroy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个对象的执行顺序：Constructor &gt;&gt; @Autowired（注入属性） &gt;&gt; @PostConstruct（初始化逻辑）</p>
<hr>
<h5 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h5><p>名称：@Bean</p>
<p>类型：方法注解</p>
<p>作用：设置该方法的返回值作为 Spring 管理的 bean</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DruidDataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;    <span class="keyword">return</span> ……;    &#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><p>因为第三方 bean 无法在其源码上进行修改，使用 @Bean 解决第三方 bean 的引入问题</p>
</li>
<li><p>该注解用于替代 XML 配置中的静态工厂与实例工厂创建 bean，不区分方法是否为静态或非静态</p>
</li>
<li><p>@Bean 所在的类必须被 Spring 扫描加载，否则该注解无法生效</p>
</li>
</ul>
<p>相关属性</p>
<ul>
<li>value（默认）：定义 bean 的访问 id</li>
<li>initMethod：声明初始化方法</li>
<li>destroyMethod：声明销毁方法</li>
</ul>
<hr>
<h4 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h4><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><p>名称：@Value</p>
<p>类型：属性注解、方法注解</p>
<p>作用：设置对应属性的值或对方法进行传参</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Value(&quot;root&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><p>value 值<strong>仅支持非引用类型数据</strong>，赋值时对方法的所有参数全部赋值</p>
</li>
<li><p>value 值支持读取 properties 文件中的属性值，通过类属性将 properties 中数据传入类中</p>
</li>
<li><p>value 值支持 SpEL</p>
</li>
<li><p>@value 注解如果添加在属性上方，可以省略 set 方法（set 方法的目的是为属性赋值）</p>
</li>
</ul>
<p>相关属性：</p>
<ul>
<li>value（默认）：定义对应的属性值或参数值</li>
</ul>
<hr>
<h5 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h5><h6 id="属性注入-1"><a href="#属性注入-1" class="headerlink" title="属性注入"></a>属性注入</h6><p>名称：@Autowired、@Qualifier</p>
<p>类型：属性注解、方法注解</p>
<p>作用：设置对应属性的对象、对方法进行引用类型传参</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>@Autowired 默认按类型装配，指定 @Qualifier 后可以指定自动装配的 bean 的 id</li>
</ul>
<p>相关属性：</p>
<ul>
<li>required：<strong>为 true （默认）表示注入 bean 时该 bean 必须存在</strong>，不然就会注入失败抛出异常；为 false  表示注入时该 bean 存在就注入，不存在就忽略跳过</li>
</ul>
<p>注意：在使用 @Autowired 时，首先在容器中查询对应类型的 bean，如果查询结果刚好为一个，就将该 bean 装配给 @Autowired 指定的数据，如果查询的结果不止一个，那么 @Autowired 会根据名称来查找，如果查询的结果为空，那么会抛出异常</p>
<p>解决方法：使用 required &#x3D; false</p>
<hr>
<h6 id="优先注入"><a href="#优先注入" class="headerlink" title="优先注入"></a>优先注入</h6><p>名称：@Primary</p>
<p>类型：类注解</p>
<p>作用：设置类对应的 bean 按类型装配时优先装配</p>
<p>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>@Autowired 默认按类型装配，当出现相同类型的 bean，使用 @Primary 提高按类型自动装配的优先级，多个 @Primary 会导致优先级设置无效</li>
</ul>
<hr>
<h6 id="注解对比"><a href="#注解对比" class="headerlink" title="注解对比"></a>注解对比</h6><p>名称：@Inject、@Named、@Resource</p>
<ul>
<li>@Inject 与 @Named 是 JSR330 规范中的注解，功能与 @Autowired 和 @Qualifier 完全相同，适用于不同架构场景</li>
<li>@Resource 是 JSR250 规范中的注解，可以简化书写格式</li>
</ul>
<p>@Resource 相关属性</p>
<ul>
<li><p>name：设置注入的 bean 的 id</p>
</li>
<li><p>type：设置注入的 bean 的类型，接收的参数为 Class 类型</p>
</li>
</ul>
<p>@Autowired 和 @Resource之间的区别：</p>
<ul>
<li><p>@Autowired 默认是<strong>按照类型装配</strong>注入，默认情况下它要求依赖对象必须存在（可以设置 required 属性为 false）</p>
</li>
<li><p>@Resource 默认<strong>按照名称装配</strong>注入，只有当找不到与名称匹配的 bean 才会按照类型来装配注入</p>
</li>
</ul>
<hr>
<h5 id="静态注入"><a href="#静态注入" class="headerlink" title="静态注入"></a>静态注入</h5><p>Spring 容器管理的都是实例对象，**@Autowired 依赖注入的都是容器内的对象实例**，在 Java 中 static 修饰的静态属性（变量和方法）是属于类的，而非属于实例对象</p>
<p>当类加载器加载静态变量时，Spring 上下文尚未加载，所以类加载器不会在 Bean 中正确注入静态类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用静态组件的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        component.callTestMethod()；</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译正常，但运行时报java.lang.NullPointerException，所以在调用testMethod()方法时，component变量还没被初始化</span></span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<ul>
<li><p>@Autowired 注解到<strong>类的构造函数</strong>上，Spring 扫描到 Component 的 Bean，然后赋给静态变量 component</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestClass</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        TestClass.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        component.callTestMethod()；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@Autowired 注解到<strong>静态属性的 setter 方法</strong>上</p>
</li>
<li><p>使用 @PostConstruct 注解一个方法，在方法内为 static 静态成员赋值</p>
</li>
<li><p>使用 Spring 框架工具类获取 bean，定义成局部变量使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">    <span class="comment">// 调用静态组件的方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> SpringApplicationContextUtil.getBean(<span class="string">&quot;component&quot;</span>);</span><br><span class="line">      component.callTestMethod();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>参考文章：<a href="http://jessehzx.top/2018/03/18/spring-autowired-static-field/">http://jessehzx.top/2018/03/18/spring-autowired-static-field/</a></p>
<hr>
<h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>名称：@PropertySource</p>
<p>类型：类注解</p>
<p>作用：加载 properties 文件中的属性值</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:filename.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;propertiesAttributeName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String attributeName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>不支持 * 通配符，加载后，所有 Spring 控制的 bean 中均可使用对应属性值，加载多个需要用 <code>&#123;&#125; 和 ,</code> 隔开</li>
</ul>
<p>相关属性</p>
<ul>
<li><p>value（默认）：设置加载的 properties 文件名</p>
</li>
<li><p>ignoreResourceNotFound：如果资源未找到，是否忽略，默认为 false</p>
</li>
</ul>
<hr>
<h4 id="加载控制"><a href="#加载控制" class="headerlink" title="加载控制"></a>加载控制</h4><h5 id="依赖加载"><a href="#依赖加载" class="headerlink" title="依赖加载"></a>依赖加载</h5><p>@DependsOn</p>
<ul>
<li><p>名称：@DependsOn</p>
</li>
<li><p>类型：类注解、方法注解</p>
</li>
<li><p>作用：控制 bean 的加载顺序，使其在指定 bean 加载完毕后再加载</p>
</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DependsOn(&quot;beanId&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明：</p>
<ul>
<li><p>配置在方法上，使 @DependsOn 指定的 bean 优先于 @Bean 配置的 bean 进行加载</p>
</li>
<li><p>配置在类上，使 @DependsOn 指定的 bean 优先于当前类中所有 @Bean 配置的 bean 进行加载</p>
</li>
<li><p>配置在类上，使 @DependsOn 指定的 bean 优先于 @Component 等配置的 bean 进行加载</p>
</li>
</ul>
</li>
<li><p>相关属性</p>
<ul>
<li>value（默认）：设置当前 bean 所依赖的 bean 的 id</li>
</ul>
</li>
</ul>
<p>@Order</p>
<ul>
<li><p>名称：@Order</p>
</li>
<li><p>类型：<strong>配置类注解</strong></p>
</li>
<li><p>作用：控制配置类的加载顺序，值越小越先加载</p>
</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfigClassName</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>@Lazy</p>
<ul>
<li><p>名称：@Lazy</p>
</li>
<li><p>类型：类注解、方法注解</p>
</li>
<li><p>作用：控制 bean 的加载时机，使其延迟加载，获取的时候加载</p>
</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>@DependsOn</p>
<ul>
<li><p>微信订阅号，发布消息和订阅消息的 bean 的加载顺序控制（先开订阅，再发布）</p>
</li>
<li><p>双 11 活动，零点前是结算策略 A，零点后是结算策略 B，策略 B 操作的数据为促销数据，策略 B 加载顺序与促销数据的加载顺序</p>
</li>
</ul>
<p>@Lazy</p>
<ul>
<li>程序灾难出现后对应的应急预案处理是启动容器时加载时机</li>
</ul>
<p>@Order</p>
<ul>
<li>多个种类的配置出现后，优先加载系统级的，然后加载业务级的，避免细粒度的加载控制</li>
</ul>
<hr>
<h4 id="整合资源"><a href="#整合资源" class="headerlink" title="整合资源"></a>整合资源</h4><h5 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h5><p>名称：@Import</p>
<p>类型：类注解</p>
<p>作用：导入第三方 bean 作为 Spring 控制的资源，这些类都会被 Spring 创建并放入 ioc 容器</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(OtherClassName.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>@Import 注解在同一个类上，仅允许添加一次，如果需要导入多个，使用数组的形式进行设定</li>
<li>在被导入的类中可以继续使用 @Import 导入其他资源</li>
<li>@Bean 所在的类可以使用导入的形式进入 Spring 容器，无需声明为 bean</li>
</ul>
<hr>
<h5 id="Druid-1"><a href="#Druid-1" class="headerlink" title="Druid"></a>Druid</h5><ul>
<li><p>加载资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DruidDataSource <span class="title function_">getDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUrl(<span class="string">&quot;jdbc:mysql://192.168.2.185:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &#123;&quot;service&quot;,&quot;dao&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Import(JDBCConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DruidDataSource) ctx.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line">System.out.println(dataSource);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h5><p>Spring 接管 Junit 的运行权，使用 Spring 专用的 Junit 类加载器，为 Junit 测试用例设定对应的 Spring 容器</p>
<p>注意：</p>
<ul>
<li><p>从 Spring5.0 以后，要求 Junit 的版本必须是4.12及以上</p>
</li>
<li><p>Junit 仅用于单元测试，不能将 Junit 的测试类配置成 Spring 的 bean，否则该配置将会被打包进入工程中</p>
</li>
</ul>
<p>test &#x2F; java &#x2F; service &#x2F; UserServiceTest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设定spring专用的类加载器</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//设定加载的spring上下文对应的配置</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> accountService.findById(<span class="number">1</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;Mike&quot;</span>, account.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>





<hr>
<h3 id="IoC原理"><a href="#IoC原理" class="headerlink" title="IoC原理"></a>IoC原理</h3><h4 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h4><h5 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h5><p>ApplicationContext：</p>
<ol>
<li><p>ApplicationContext 是一个接口，提供了访问 Spring 容器的 API</p>
</li>
<li><p>ClassPathXmlApplicationContext 是一个类，实现了上述功能</p>
</li>
<li><p>ApplicationContext 的顶层接口是 BeanFactory</p>
</li>
<li><p>BeanFactory 定义了 bean 相关的最基本操作</p>
</li>
<li><p>ApplicationContext 在 BeanFactory 基础上追加了若干新功能</p>
</li>
</ol>
<p><strong>ApplicationContext 和 BeanFactory对比：</strong></p>
<ul>
<li><p>BeanFactory 和 ApplicationContext 是 Spring 的两大核心接口，都可以当做 Spring 的容器</p>
</li>
<li><p>BeanFactory 是 Spring 里面最底层的接口，是 IoC 的核心，定义了 IoC 的基本功能，包含了各种 Bean 的定义、加载、实例化，依赖注入和生命周期管理。ApplicationContext 接口作为 BeanFactory 的子类，除了提供 BeanFactory 所具有的功能外，还提供了更完整的框架功能：</p>
<ul>
<li>继承 MessageSource，因此支持国际化</li>
<li>资源文件访问，如 URL 和文件（ResourceLoader）。</li>
<li>载入多个（有继承关系）上下文（即加载多个配置文件） ，使得每一个上下文都专注于一个特定的层次，比如应用的 web 层</li>
<li>提供在监听器中注册 bean 的事件</li>
</ul>
</li>
<li><p>BeanFactory 创建的 bean 采用延迟加载形式，只有在使用到某个 Bean 时（调用 getBean），才对该 Bean 进行加载实例化（Spring 早期使用该方法获取 bean），这样就不能提前发现一些存在的 Spring 的配置问题；ApplicationContext 是在容器启动时，一次性创建了所有的 Bean，容器启动时，就可以发现 Spring 中存在的配置错误，这样有利于检查所依赖属性是否注入</p>
</li>
<li><p>ApplicationContext 启动后预载入所有的单实例 Bean，所以程序启动慢，运行时速度快</p>
</li>
<li><p>两者都支持 BeanPostProcessor、BeanFactoryPostProcessor 的使用，但两者之间的区别是：BeanFactory 需要手动注册，而 ApplicationContext 则是自动注册</p>
</li>
</ul>
<p>FileSystemXmlApplicationContext：加载文件系统中任意位置的配置文件，而 ClassPathXmlAC 只能加载类路径下的配置文件</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-ApplicationContext%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p>BeanFactory 的成员属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">FACTORY_BEAN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;&amp;&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>区分是 FactoryBean 还是创建的 Bean，加上 &amp; 代表是工厂，getBean 将会返回工厂</li>
<li>FactoryBean：如果某个 bean 的配置非常复杂，或者想要使用编码的形式去构建它，可以提供一个构建该 bean 实例的工厂，这个工厂就是 FactoryBean 接口实现类，FactoryBean 接口实现类也是需要 Spring 管理<ul>
<li>这里产生两种对象，一种是 FactoryBean 接口实现类（IOC 管理），另一种是 FactoryBean 接口内部管理的对象</li>
<li>获取 FactoryBean 接口实现类，使用 getBean 时传的 beanName 需要带 &amp; 开头</li>
<li>获取 FactoryBean 内部管理的对象，不需要带 &amp; 开头</li>
</ul>
</li>
</ul>
<p>BeanFactory 的基本使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(res);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService)bf.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h5><p>FactoryBean：对单一的 bean 的初始化过程进行封装，达到简化配置的目的</p>
<p>FactoryBean与 BeanFactory 区别：</p>
<ul>
<li><p>FactoryBean：封装单个 bean 的创建过程，就是工厂的 Bean</p>
</li>
<li><p>BeanFactory：Spring 容器顶层接口，定义了 bean 相关的获取操作</p>
</li>
</ul>
<p>代码实现：</p>
<ul>
<li><p>FactoryBean，实现类一般是 MapperFactoryBean，创建 DAO 层接口的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EquipmentDaoImplFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span>	<span class="comment">//获取Bean</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EquipmentDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>	<span class="comment">//获取bean的类型</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>	<span class="comment">//是否单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MapperFactoryBean 继承 SqlSessionDaoSupport，可以获取 SqlSessionTemplate，完成 MyBatis 的整合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">extends</span> <span class="title class_">DaoSupport</span> &#123;</span><br><span class="line">  	<span class="keyword">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class="line">	<span class="comment">// 获取 SqlSessionTemplate 对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionTemplate == <span class="literal">null</span> || </span><br><span class="line">        	sqlSessionFactory != <span class="built_in">this</span>.sqlSessionTemplate.getSqlSessionFactory()) &#123;</span><br><span class="line">      		<span class="built_in">this</span>.sqlSessionTemplate = createSqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><h5 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h5><ul>
<li><p>DAO 层 UserDao、AccountDao、BookDao、EquipmentDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Service 业务层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;<span class="comment">//...........BookDao等</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="过滤器-1"><a href="#过滤器-1" class="headerlink" title="过滤器"></a>过滤器</h5><p>名称：TypeFilter</p>
<p>类型：<strong>接口</strong></p>
<p>作用：自定义类型过滤器</p>
<p>示例：</p>
<ul>
<li><p>config &#x2F; filter &#x2F; MyTypeFilter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title class_">TypeFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * metadataReader:读取到的当前正在扫描的类的信息</span></span><br><span class="line"><span class="comment">    * metadataReaderFactory:可以获取到任何其他类的信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//加载的类满足要求，匹配成功</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//获取当前类注解的信息</span></span><br><span class="line">		<span class="type">AnnotationMetadata</span> <span class="variable">am</span> <span class="operator">=</span> metadataReader.getAnnotationMetadata();</span><br><span class="line">		<span class="comment">//获取当前正在扫描的类的类信息</span></span><br><span class="line">		<span class="type">ClassMetadata</span> <span class="variable">classMetadata</span> <span class="operator">=</span> metadataReader.getClassMetadata();</span><br><span class="line">		<span class="comment">//获取当前类资源（类的路径）</span></span><br><span class="line">		<span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> metadataReader.getResource();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过类的元数据获取类的名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> classMetadata.getClassName();</span><br><span class="line">        <span class="comment">//如果加载的类名满足过滤器要求，返回匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(className.equals(<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>))&#123;</span><br><span class="line">       	<span class="comment">//返回true表示匹配成功，返回false表示匹配失败。此处仅确认匹配结果，不会确认是排除还是加入，排除/加入由配置项决定，与此处无关</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SpringConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//设置排除bean，排除的规则是自定义规则（FilterType.CUSTOM），具体的规则定义为MyTypeFilter</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;dao&quot;,&quot;service&quot;&#125;,</span></span><br><span class="line"><span class="meta">        excludeFilters = @ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">                type= FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">                classes = MyTypeFilter.class</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="导入器"><a href="#导入器" class="headerlink" title="导入器"></a>导入器</h4><p>bean 只有通过配置才可以进入 Spring 容器，被 Spring 加载并控制</p>
<ul>
<li><p>配置 bean 的方式如下：</p>
<ul>
<li>XML 文件中使用 <bean> 标签配置</bean></li>
<li>使用 @Component 及衍生注解配置</li>
</ul>
</li>
</ul>
<p>导入器可以快速高效导入大量 bean，替代 @Import({a.class,b.class})，无需在每个类上添加 @Bean</p>
<p>名称： ImportSelector</p>
<p>类型：<strong>接口</strong></p>
<p>作用：自定义bean导入器</p>
<ul>
<li><p>selector &#x2F; MyImportSelector</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line"><span class="comment">//      1.编程形式加载一个类</span></span><br><span class="line"><span class="comment">//      return new String[]&#123;&quot;dao.impl.BookDaoImpl&quot;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      2.加载import.properties文件中的单个类名</span></span><br><span class="line"><span class="comment">//      ResourceBundle bundle = ResourceBundle.getBundle(&quot;import&quot;);</span></span><br><span class="line"><span class="comment">//      String className = bundle.getString(&quot;className&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//      3.加载import.properties文件中的多个类名</span></span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;import&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> className.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>import.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#2.加载import.properties文件中的单个类名</span></span><br><span class="line"><span class="comment">#className=dao.impl.BookDaoImpl</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#3.加载import.properties文件中的多个类名</span></span><br><span class="line"><span class="comment">#className=dao.impl.BookDaoImpl,dao.impl.AccountDaoImpl</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#4.导入包中的所有类</span></span><br><span class="line"><span class="attr">path</span>=<span class="string">dao.impl.*</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SpringConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;dao&quot;,&quot;service&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="注册器"><a href="#注册器" class="headerlink" title="注册器"></a>注册器</h4><p>可以取代 ComponentScan 扫描器</p>
<p>名称：ImportBeanDefinitionRegistrar</p>
<p>类型：<strong>接口</strong></p>
<p>作用：自定义 bean 定义注册器</p>
<ul>
<li><p>registrar &#x2F; MyImportBeanDefinitionRegistrar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationMetadata:当前类的注解信息</span></span><br><span class="line"><span class="comment"> * BeanDefinitionRegistry:BeanDefinition注册类，把所有需要添加到容器中的bean调用registerBeanDefinition手工注册进来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//自定义注册器</span></span><br><span class="line">        <span class="comment">//1.开启类路径bean定义扫描器，需要参数bean定义注册器BeanDefinitionRegistry，需要制定是否使用默认类型过滤器</span></span><br><span class="line">        <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(registry,<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//2.添加包含性加载类型过滤器（可选，也可以设置为排除性加载类型过滤器）</span></span><br><span class="line">        scanner.addIncludeFilter(<span class="keyword">new</span> <span class="title class_">TypeFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">//所有匹配全部成功，此处应该添加实际的业务判定条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//设置扫描路径</span></span><br><span class="line">        scanner.addExcludeFilter(tf);<span class="comment">//排除</span></span><br><span class="line">        scanner.scan(<span class="string">&quot;dao&quot;</span>,<span class="string">&quot;service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SpringConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyImportBeanDefinitionRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h4><p>通过创建类<strong>继承相应的处理器的接口</strong>，重写后置处理的方法，来实现<strong>拦截 Bean 的生命周期</strong>来实现自己自定义的逻辑</p>
<p>BeanPostProcessor：bean 后置处理器，bean 创建对象初始化前后进行拦截工作的</p>
<p>BeanFactoryPostProcessor：beanFactory 的后置处理器</p>
<ul>
<li><pre><code>    加载时机：在 BeanFactory 初始化之后调用，来定制和修改 BeanFactory 的内容；所有的 bean 定义已经保存加载到 beanFactory，但是 bean 的实例还未创建
</code></pre>
</li>
<li><pre><code>    执行流程：
</code></pre>
<ul>
<li>ioc 容器创建对象</li>
<li>invokeBeanFactoryPostProcessors(beanFactory)：执行 BeanFactoryPostProcessor<ul>
<li>在 BeanFactory 中找到所有类型是 BeanFactoryPostProcessor 的组件，并执行它们的方法</li>
<li>在初始化创建其他组件前面执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>BeanDefinitionRegistryPostProcessor：</p>
<ul>
<li><p>加载时机：在所有 bean 定义信息将要被加载，但是 bean 实例还未创建，优先于 BeanFactoryPostProcessor 执行；利用 BeanDefinitionRegistryPostProcessor 给容器中再额外添加一些组件</p>
</li>
<li><p>执行流程：</p>
<ul>
<li>ioc 容器创建对象</li>
<li>refresh() → invokeBeanFactoryPostProcessors(beanFactory)</li>
<li>从容器中获取到所有的 BeanDefinitionRegistryPostProcessor 组件<ul>
<li>依次触发所有的 postProcessBeanDefinitionRegistry() 方法</li>
<li>再来触发 postProcessBeanFactory() 方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><h5 id="基本概述-1"><a href="#基本概述-1" class="headerlink" title="基本概述"></a>基本概述</h5><p>ApplicationListener：监听容器中发布的事件，完成事件驱动模型开发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationListener</span>&lt;E <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt;</span><br></pre></td></tr></table></figure>

<p>所以监听 ApplicationEvent 及其下面的子事件</p>
<p>应用监听器步骤：</p>
<ul>
<li><pre><code>  写一个监听器（ApplicationListener实现类）来监听某个事件（ApplicationEvent及其子类）
</code></pre>
</li>
<li><pre><code>  把监听器加入到容器 @Component
</code></pre>
</li>
<li><pre><code>  只要容器中有相关事件的发布，就能监听到这个事件；
* 	  ContextRefreshedEvent：容器刷新完成（所有 bean 都完全创建）会发布这个事件
* 	  ContextClosedEvent：关闭容器会发布这个事件
</code></pre>
</li>
<li><pre><code>  发布一个事件：`applicationContext.publishEvent()`
</code></pre>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationEvent&gt; &#123;</span><br><span class="line">	<span class="comment">//当容器中发布此事件以后，方法触发</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;收到事件：&quot;</span> + event);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h5><p>ContextRefreshedEvent 事件：</p>
<ul>
<li><p>容器初始化过程中执行 <code>initApplicationEventMulticaster()</code>：初始化事件多播器</p>
<ul>
<li>先去容器中查询 <code>id = applicationEventMulticaster</code> 的组件，有直接返回</li>
<li>没有就执行 <code>this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory)</code> 并且加入到容器中</li>
<li>以后在其他组件要派发事件，自动注入这个 applicationEventMulticaster</li>
</ul>
</li>
<li><p>容器初始化过程执行 <strong>registerListeners()</strong> 注册监听器</p>
<ul>
<li>从容器中获取所有监听器：<code>getBeanNamesForType(ApplicationListener.class, true, false)</code></li>
<li>将 listener 注册到 ApplicationEventMulticaster</li>
</ul>
</li>
<li><p>容器刷新完成：finishRefresh() → publishEvent(new ContextRefreshedEvent(this))</p>
<p>发布 ContextRefreshedEvent 事件：</p>
<ul>
<li>获取事件的多播器（派发器）：getApplicationEventMulticaster()</li>
<li>multicastEvent 派发事件<ul>
<li>获取到所有的 ApplicationListener</li>
<li>遍历 ApplicationListener<ul>
<li>如果有 Executor，可以使用 Executor 异步派发 <code>Executor executor = getTaskExecutor()</code></li>
<li>没有就同步执行 listener 方法 <code>invokeListener(listener, event)</code>，拿到 listener 回调 onApplicationEvent</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>容器关闭会发布 ContextClosedEvent</p>
<hr>
<h5 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h5><p>注解：@EventListener</p>
<p>基本使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@EventListener(classes=&#123;ApplicationEvent.class&#125;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">(ApplicationEvent event)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;UserService。。监听到的事件：&quot;</span> + event);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：使用 EventListenerMethodProcessor 处理器来解析方法上的 @EventListener，Spring 扫描使用注解的方法，并为之创建一个监听对象</p>
<p>SmartInitializingSingleton 原理：afterSingletonsInstantiated()</p>
<ul>
<li><pre><code>    IOC 容器创建对象并 refresh()
</code></pre>
</li>
<li><pre><code>    finishBeanFactoryInitialization(beanFactory)：初始化剩下的单实例 bean
</code></pre>
<ul>
<li>先创建所有的单实例 bean：getBean()</li>
<li>获取所有创建好的单实例 bean，判断是否是 SmartInitializingSingleton 类型的，如果是就调用 afterSingletonsInstantiated()</li>
</ul>
</li>
</ul>
<hr>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="基本概述-2"><a href="#基本概述-2" class="headerlink" title="基本概述"></a>基本概述</h3><p>AOP（Aspect Oriented Programing）：面向切面编程，一种编程<strong>范式</strong>，指导开发者如何组织程序结构</p>
<p>AOP 弥补了 OOP 的不足，基于 OOP 基础之上进行横向开发：</p>
<ul>
<li><p>uOOP 规定程序开发以类为主体模型，一切围绕对象进行，完成某个任务先构建模型</p>
</li>
<li><p>uAOP 程序开发主要关注基于 OOP 开发中的共性功能，一切围绕共性功能进行，完成某个任务先构建可能遇到的所有共性功能（当所有功能都开发出来也就没有共性与非共性之分），将软件开发由手工制作走向半自动化&#x2F;全自动化阶段，实现“插拔式组件体系结构”搭建</p>
</li>
</ul>
<p>AOP 作用：</p>
<ul>
<li><p>提高代码的可重用性</p>
</li>
<li><p>业务代码编码更简洁</p>
</li>
<li><p>业务代码维护更高效</p>
</li>
<li><p>业务功能扩展更便捷</p>
</li>
</ul>
<hr>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="概念详解"><a href="#概念详解" class="headerlink" title="概念详解"></a>概念详解</h4><ul>
<li><p>Joinpoint（连接点）：就是方法</p>
</li>
<li><p>Pointcut（切入点）：就是挖掉共性功能的方法</p>
</li>
<li><p>Advice（通知）：就是共性功能，最终以一个方法的形式呈现</p>
</li>
<li><p>Aspect（切面）：就是共性功能与挖的位置的对应关系</p>
</li>
<li><p>Target（目标对象）：就是挖掉功能的方法对应的类产生的对象，这种对象是无法直接完成最终工作的</p>
</li>
<li><p>Weaving（织入）：就是将挖掉的功能回填的动态过程</p>
</li>
<li><p>Proxy（代理）：目标对象无法直接完成工作，需要对其进行功能回填，通过创建原始对象的代理对象实现</p>
</li>
<li><p>Introduction（引入&#x2F;引介）：就是对原始对象无中生有的添加成员变量或成员方法</p>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E8%BF%9E%E6%8E%A5%E7%82%B9.png"></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E5%88%87%E5%85%A5%E7%82%B9%E5%88%87%E9%9D%A2%E9%80%9A%E7%9F%A5.png"></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E7%BB%87%E5%85%A5.png"></p>
<hr>
<h4 id="入门项目-1"><a href="#入门项目-1" class="headerlink" title="入门项目"></a>入门项目</h4><p>开发步骤：</p>
<ul>
<li><p>开发阶段</p>
<ul>
<li><p>制作程序</p>
</li>
<li><p>将非共性功能开发到对应的目标对象类中，并制作成切入点方法</p>
</li>
<li><p>将共性功能独立开发出来，制作成通知</p>
</li>
<li><p>在配置文件中，声明切入点</p>
</li>
<li><p>在配置文件中，声明切入点与通知间的关系（含通知类型），即切面</p>
</li>
</ul>
</li>
<li><p>运行阶段（AOP 完成）</p>
<ul>
<li><p>Spring 容器加载配置文件，监控所有配置的<strong>切入点</strong>方法的执行</p>
</li>
<li><p>当监控到切入点方法被运行，<strong>使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置将通知对应的功能织入</strong>，完成完整的代码逻辑并运行</p>
</li>
</ul>
</li>
</ul>
<ol>
<li><p>导入坐标 pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>业务层抽取通用代码  service &#x2F; UserServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//System.out.println(&quot;共性功能&quot;);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>aop.AOPAdvice</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.制作通知类，在类中定义一个方法用于完成共性功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//共性功能抽取后职称独立的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;共性功能&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把通知加入spring容器管理，配置aop  applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        &quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--原始Spring控制资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>= <span class="string">&quot;service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2.配置共性功能成功spring控制的资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;aop.AOPAdvice&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3.开启AOP命名空间: beans标签内--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--4.配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--5.配置切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--6.配置切面（切入点与通知的关系）--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--7.配置具体的切入点对应通知中那个操作方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;function&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.save();<span class="comment">//先输出共性功能，然后 user service running...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="XML开发-1"><a href="#XML开发-1" class="headerlink" title="XML开发"></a>XML开发</h3><h4 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h4><p>Aspect（切面）用于描述切入点与通知间的关系，是 AOP 编程中的一个概念</p>
<p>AspectJ 是基于 java 语言对 Aspect 的实现</p>
<hr>
<h4 id="AOP-1"><a href="#AOP-1" class="headerlink" title="AOP"></a>AOP</h4><h5 id="config"><a href="#config" class="headerlink" title="config"></a>config</h5><p>标签：<a href="aop:config">aop:config</a>，<beans> 的子标签</beans></p>
<p>作用：设置 AOP</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>……<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>……<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个beans标签中可以配置多个aop:config标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h5 id="pointcut"><a href="#pointcut" class="headerlink" title="pointcut"></a>pointcut</h5><p>标签：<a href="aop:pointcut">aop:pointcut</a>，归属于 aop:config 标签和 aop:aspect 标签</p>
<p>作用：设置切入点</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcutId&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;……&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcutId&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;……&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>一个 aop:config 标签中可以配置多个 aop:pointcut 标签，且该标签可以配置在 aop:aspect 标签内</li>
</ul>
<p>属性：</p>
<ul>
<li><p>id ：识别切入点的名称</p>
</li>
<li><p>expression ：切入点表达式</p>
</li>
</ul>
<hr>
<h5 id="aspect"><a href="#aspect" class="headerlink" title="aspect"></a>aspect</h5><p>标签：<a href="aop:aspect">aop:aspect</a>，aop:config 的子标签</p>
<p>作用：设置具体的 AOP 通知对应的切入点（切面）</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;beanId&quot;</span>&gt;</span>……<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;beanId&quot;</span>&gt;</span>……<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个aop:config标签中可以配置多个aop:aspect标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>属性：</p>
<ul>
<li>ref ：通知所在的 bean 的 id</li>
</ul>
<hr>
<h4 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h4><h5 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h5><p>切入点描述的是某个方法</p>
<p>切入点表达式是一个快速匹配方法描述的通配格式，类似于正则表达式</p>
<hr>
<h5 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h5><p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">关键字(访问修饰符  返回值  包名.类名.方法名(参数)异常名)</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配UserService中只含有一个参数的findById方法</span></span><br><span class="line">execution(<span class="keyword">public</span> User service.UserService.findById(<span class="type">int</span>))</span><br></pre></td></tr></table></figure>

<p>格式解析：</p>
<ul>
<li>关键字：描述表达式的匹配模式（参看关键字列表）</li>
<li>访问修饰符：方法的访问控制权限修饰符</li>
<li>类名：方法所在的类（此处可以配置接口名称）</li>
<li>异常：方法定义中指定抛出的异常</li>
</ul>
<p>关键字：</p>
<ul>
<li><p>execution ：匹配执行指定方法</p>
</li>
<li><p>args ：匹配带有指定参数类型的方法</p>
</li>
<li><p>within、this、target、@within、@target、@args、@annotation、bean、reference pointcut等</p>
</li>
</ul>
<p>通配符：</p>
<ul>
<li><p>*：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配com.seazean包下的任意包中的UserService类或接口中所有find开头的带有一个任意参数的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> * com.seazean.*.UserService.find*(*)</span><br></pre></td></tr></table></figure>
</li>
<li><p>.. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配com包下的任意包中的UserService类或接口中所有名称为findById参数任意数量和类型的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> User com..UserService.findById(..))</span><br></pre></td></tr></table></figure>
</li>
<li><p>+：专用于匹配子类类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配任意包下的Service结尾的类或者接口的子类或者实现类</span></span><br><span class="line">execution(* *..*Service+.*(..))</span><br></pre></td></tr></table></figure></li>
</ul>
<p>逻辑运算符：</p>
<ul>
<li>&amp;&amp;：连接两个切入点表达式，表示两个切入点表达式同时成立的匹配</li>
<li>||：连接两个切入点表达式，表示两个切入点表达式成立任意一个的匹配</li>
<li>! ：连接单个切入点表达式，表示该切入点表达式不成立的匹配</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(* *(..))		<span class="comment">//前三个都是匹配全部</span></span><br><span class="line">execution(* *..*(..))</span><br><span class="line">execution(* *..*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> * *..*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="type">int</span> *..*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> *..*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com..*.*(..)) </span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com..service.*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.seazean.service.*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.seazean.service.User*.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.seazean.service.*Service.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.seazean.service.UserService.*(..))</span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.find*(..))	<span class="comment">//find开头</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.*Id(..))		<span class="comment">//I</span></span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.findById(..))</span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.findById(<span class="type">int</span>))</span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.findById(<span class="type">int</span>,<span class="type">int</span>))</span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.findById(<span class="type">int</span>,*))</span><br><span class="line">execution(<span class="keyword">public</span> User com.seazean.service.UserService.findById())</span><br><span class="line">execution(List com.seazean.service.*Service+.findAll(..))</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h5><p>XML 配置规则：</p>
<ul>
<li><p>企业开发命名规范严格遵循规范文档进行</p>
</li>
<li><p>先为方法配置局部切入点，再抽取类中公共切入点，最后抽取全局切入点</p>
</li>
<li><p>代码走查过程中检测切入点是否存在越界性包含</p>
</li>
<li><p>代码走查过程中检测切入点是否存在非包含性进驻</p>
</li>
<li><p>设定 AOP 执行检测程序，在单元测试中监控通知被执行次数与预计次数是否匹配（不绝对正确：加进一个不该加的，删去一个不该删的相当于结果不变）</p>
</li>
<li><p>设定完毕的切入点如果发生调整务必进行回归测试</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.配置公共切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--2.配置局部切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt2&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用公共切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用局部切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--3.直接配置切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;logAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>





<hr>
<h4 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h4><h5 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h5><p>AOP 的通知类型共5种：前置通知，后置通知、返回后通知、抛出异常后通知、环绕通知</p>
<h6 id="before"><a href="#before" class="headerlink" title="before"></a>before</h6><p>标签：<a href="aop:before">aop:before</a>，aop:aspect的子标签</p>
<p>作用：设置前置通知</p>
<ul>
<li><strong>前置通知</strong>：原始方法执行前执行，如果通知中抛出异常，阻止原始方法运行</li>
<li>应用：数据校验</li>
</ul>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个aop:aspect标签中可以配置多个aop:before标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基本属性：</p>
<ul>
<li><p>method：在通知类中设置当前通知类别对应的方法</p>
</li>
<li><p>pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</p>
</li>
<li><p>pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突</p>
</li>
</ul>
<h6 id="after"><a href="#after" class="headerlink" title="after"></a>after</h6><p>标签：<a href="aop:after">aop:after</a>，aop:aspect的子标签</p>
<p>作用：设置后置通知</p>
<ul>
<li><p><strong>后置通知</strong>：原始方法执行后执行，无论原始方法中是否出现异常，都将执行通知</p>
</li>
<li><p>应用：现场清理</p>
</li>
</ul>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个aop:aspect标签中可以配置多个aop:after标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基本属性：</p>
<ul>
<li><p>method：在通知类中设置当前通知类别对应的方法</p>
</li>
<li><p>pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</p>
</li>
<li><p>pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突</p>
</li>
</ul>
<h6 id="after-r"><a href="#after-r" class="headerlink" title="after-r"></a>after-r</h6><p>标签：<a href="aop:after-returning">aop:after-returning</a>，aop:aspect的子标签</p>
<p>作用：设置返回后通知</p>
<ul>
<li><p><strong>返回后通知</strong>：原始方法正常执行完毕并返回结果后执行，如果原始方法中抛出异常，无法执行</p>
</li>
<li><p>应用：返回值相关数据处理</p>
</li>
</ul>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个aop:aspect标签中可以配置多个aop:after-returning标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基本属性：</p>
<ul>
<li>method：在通知类中设置当前通知类别对应的方法</li>
<li>pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</li>
<li>pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突</li>
<li>returning：设置接受返回值的参数，与通知类中对应方法的参数一致</li>
</ul>
<h6 id="after-t"><a href="#after-t" class="headerlink" title="after-t"></a>after-t</h6><p>标签：<a href="aop:after-throwing">aop:after-throwing</a>，aop:aspect的子标签</p>
<p>作用：设置抛出异常后通知</p>
<ul>
<li><strong>抛出异常后通知</strong>：原始方法抛出异常后执行，如果原始方法没有抛出异常，无法执行</li>
<li>应用：对原始方法中出现的异常信息进行处理</li>
</ul>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个aop:aspect标签中可以配置多个aop:after-throwing标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基本属性：</p>
<ul>
<li>method：在通知类中设置当前通知类别对应的方法</li>
<li>pointcut：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</li>
<li>pointcut-ref：设置当前通知对应的切入点id，与pointcut属性冲突</li>
<li>throwing：设置接受异常对象的参数，与通知类中对应方法的参数一致</li>
</ul>
<h6 id="around"><a href="#around" class="headerlink" title="around"></a>around</h6><p>标签：<a href="aop:around">aop:around</a>，aop:aspect的子标签</p>
<p>作用：设置环绕通知</p>
<ul>
<li><p><strong>环绕通知</strong>：在原始方法执行前后均有对应执行执行，还可以阻止原始方法的执行</p>
</li>
<li><p>应用：功能强大，可以做任何事情</p>
</li>
</ul>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceId&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;methodName&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--一个aop:aspect标签中可以配置多个aop:around标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基本属性：</p>
<ul>
<li><p>method ：在通知类中设置当前通知类别对应的方法</p>
</li>
<li><p>pointcut ：设置当前通知对应的切入点表达式，与pointcut-ref属性冲突</p>
</li>
<li><p>pointcut-ref ：设置当前通知对应的切入点id，与pointcut属性冲突</p>
</li>
</ul>
<p>环绕通知的开发方式（参考通知顺序章节）：</p>
<ul>
<li><p>环绕通知是<strong>在原始方法的前后添加功能</strong>，在环绕通知中，存在对原始方法的显式调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>环绕通知方法相关说明：</p>
<ul>
<li><p>方法须设定 Object 类型的返回值，否则会<strong>拦截</strong>原始方法的返回。如果原始方法返回值类型为 void，通知方法也可以设定返回值类型为 void，最终返回 null</p>
</li>
<li><p>方法需在第一个参数位置设定 ProceedingJoinPoint 对象，通过该对象调用 proceed() 方法，实现<strong>对原始方法的调用</strong>。如省略该参数，原始方法将无法执行</p>
</li>
<li><p>使用 proceed() 方法调用原始方法时，因无法预知原始方法运行过程中是否会出现异常，强制抛出 Throwable 对象，封装原始方法中可能出现的异常信息</p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="通知顺序"><a href="#通知顺序" class="headerlink" title="通知顺序"></a>通知顺序</h5><p>当同一个切入点配置了多个通知时，通知会存在运行的先后顺序，该顺序以通知配置的顺序为准。</p>
<ul>
<li><p>AOPAdvice</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    public void after()&#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>after...<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    public void afterReturing()&#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>afterReturing...<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    public void afterThrowing()&#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>afterThrowing...<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    public Object around(ProceedingJoinPoint pjp) &#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>around before...<span class="string">&quot;);</span></span><br><span class="line"><span class="string">       	//对原始方法的调用</span></span><br><span class="line"><span class="string">        Object ret = pjp.proceed();</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>around after...<span class="string">&quot;+ret);</span></span><br><span class="line"><span class="string">   	    return ret;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>applicationContext.xml  <strong>顺序执行</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h5><h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><p>第一种方式：</p>
<ul>
<li><p>设定通知方法第一个参数为 JoinPoint，通过该对象调用 getArgs() 方法，获取原始方法运行的参数数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint jp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    Object[] args = jp.getArgs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有的通知均可以获取参数，环绕通知使用ProceedingJoinPoint.getArgs()方法</p>
</li>
</ul>
<p>第二种方式：</p>
<ul>
<li><p>设定切入点表达式为通知方法传递参数（锁定通知变量名）</p>
</li>
<li><p>流程图：<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E9%80%9A%E7%9F%A5%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E6%96%B9%E5%BC%8F%E4%BA%8C.png"></p>
</li>
<li><p>解释：</p>
<ul>
<li><code>&amp;amp</code> 代表并且 &amp;</li>
<li>输出结果：a &#x3D; param1   b &#x3D; param2</li>
</ul>
</li>
</ul>
<p>第三种方式：</p>
<ul>
<li><p>设定切入点表达式为通知方法传递参数（改变通知变量名的定义顺序）</p>
</li>
<li><p>流程图：<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E9%80%9A%E7%9F%A5%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E6%96%B9%E5%BC%8F%E4%B8%89.png"></p>
</li>
<li><p>解释：输出结果 a &#x3D; param2   b &#x3D; param1</p>
</li>
</ul>
<hr>
<h6 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h6><p>环绕通知和返回后通知可以获取返回值，后置通知不一定，其他类型获取不到</p>
<p>第一种方式：适用于返回后通知（after-returning）</p>
<ul>
<li><p>设定返回值变量名</p>
</li>
<li><p>原始方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AOP 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;ret&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通知类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object ret)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;return:&quot;</span> + ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>第二种：适用于环绕通知（around）</p>
<ul>
<li><p>在通知类的方法中调用原始方法获取返回值</p>
</li>
<li><p>原始方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AOP 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))  &quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通知类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice</span> &#123;    </span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> userService.save();</span><br><span class="line">       	System.out.println(<span class="string">&quot;app.....&quot;</span> + ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h6><p>环绕通知和抛出异常后通知可以获取异常，后置通知不一定，其他类型获取不到</p>
<p>第一种：适用于返回后通知（after-throwing）</p>
<ul>
<li><p>设定异常对象变量名</p>
</li>
<li><p>原始方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AOP 配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))  &quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;t&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通知类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span>&#123;</span><br><span class="line">    System.out.println(t.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>第二种：适用于环绕通知（around）</p>
<ul>
<li>在通知类的方法中调用原始方法捕获异常</li>
</ul>
<ul>
<li><p>原始方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AOP 配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *(..))  &quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通知类：try……catch……捕获异常后，ret为null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();	<span class="comment">//对此处调用进行try……catch……捕获异常，或抛出异常</span></span><br><span class="line">    <span class="comment">/* try &#123;</span></span><br><span class="line"><span class="comment">            ret = pjp.proceed();</span></span><br><span class="line"><span class="comment">        &#125; catch (Throwable throwable) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;around exception...&quot; + throwable.getMessage());</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userService.delete();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="获取全部"><a href="#获取全部" class="headerlink" title="获取全部"></a>获取全部</h6><ul>
<li><p>UserService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> m)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service running...&quot;</span> + i + <span class="string">&quot;,&quot;</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service update running...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user service delete running...&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AOPAdvice</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint jp)</span>&#123;</span><br><span class="line">        <span class="comment">//通过JoinPoint参数获取调用原始方法所携带的参数</span></span><br><span class="line">        Object[] args = jp.getArgs();</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>+args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint jp)</span>&#123;</span><br><span class="line">        Object[] args = jp.getArgs();</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>+args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturing</span><span class="params">(Object ret)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturing...&quot;</span>+ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing...&quot;</span>+t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//对原始方法的调用</span></span><br><span class="line">            ret = pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;around...exception....&quot;</span>+throwable.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;around after...&quot;</span>+ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;aop.AOPAdvice&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;ret&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;t&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) ctx.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line"><span class="comment">//        userService.save(666, 888);</span></span><br><span class="line"><span class="comment">//        int ret = userService.update();</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;app.....&quot; + ret);</span></span><br><span class="line">        userService.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="注解开发-2"><a href="#注解开发-2" class="headerlink" title="注解开发"></a>注解开发</h3><h4 id="AOP注解"><a href="#AOP注解" class="headerlink" title="AOP注解"></a>AOP注解</h4><p>AOP 注解简化 XML：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91.png"></p>
<p>注意事项：</p>
<ol>
<li><p>切入点最终体现为一个方法，无参无返回值，无实际方法体内容，但不能是抽象方法</p>
</li>
<li><p>引用切入点时必须使用方法调用名称，方法后面的 () 不能省略</p>
</li>
<li><p>切面类中定义的切入点只能在当前类中使用，如果想引用其他类中定义的切入点使用“类名.方法名()”引用</p>
</li>
<li><p>可以在通知类型注解后添加参数，实现 XML 配置中的属性，例如 after-returning 后的 returning 性</p>
</li>
</ol>
<hr>
<h4 id="启动注解"><a href="#启动注解" class="headerlink" title="启动注解"></a>启动注解</h4><h5 id="XML-1"><a href="#XML-1" class="headerlink" title="XML"></a>XML</h5><p>开启 AOP 注解支持：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;aop,config,service&quot;</span>/&gt;</span><span class="comment">&lt;!--启动Spring扫描--&gt;</span></span><br></pre></td></tr></table></figure>

<p>开发步骤：</p>
<ol>
<li>导入坐标（伴随 spring-context 坐标导入已经依赖导入完成）</li>
<li>开启 AOP 注解支持</li>
<li>配置切面 @Aspect</li>
<li>定义专用的切入点方法，并配置切入点 @Pointcut</li>
<li>为通知方法配置通知类型及对应切入点 @Before</li>
</ol>
<h5 id="纯注解-1"><a href="#纯注解-1" class="headerlink" title="纯注解"></a>纯注解</h5><p>注解：@EnableAspectJAutoProxy</p>
<p>位置：Spring 注解配置类定义上方</p>
<p>作用：设置当前类开启 AOP 注解驱动的支持，加载 AOP 注解</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.seazean&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="基本注解-1"><a href="#基本注解-1" class="headerlink" title="基本注解"></a>基本注解</h4><h5 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h5><p>注解：@Aspect</p>
<p>位置：类定义上方</p>
<p>作用：设置当前类为切面类</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopAdvice</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Pointcut-1"><a href="#Pointcut-1" class="headerlink" title="Pointcut"></a>Pointcut</h5><p>注解：@Pointcut</p>
<p>位置：方法定义上方</p>
<p>作用：使用当前方法名作为切入点引用名称</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* *(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：被修饰的方法忽略其业务功能，格式设定为无参无返回值的方法，方法体内空实现（非抽象）</p>
<h5 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h5><p>注解：@Before</p>
<p>位置：方法定义上方</p>
<p>作用：标注当前方法作为前置通知</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">    <span class="comment">//joinPoint.getArgs();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>多个参数时，JoinPoint参数一定要在第一位</strong></p>
<h5 id="After"><a href="#After" class="headerlink" title="After"></a>After</h5><p>注解：@After</p>
<p>位置：方法定义上方</p>
<p>作用：标注当前方法作为后置通知</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="AfterR"><a href="#AfterR" class="headerlink" title="AfterR"></a>AfterR</h5><p>注解：@AfterReturning</p>
<p>位置：方法定义上方</p>
<p>作用：标注当前方法作为返回后通知</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(value=&quot;pt()&quot;, returning = &quot;result&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特殊参数：</p>
<ul>
<li>returning ：设定使用通知方法参数<strong>接收</strong>返回值的变量名</li>
</ul>
<h5 id="AfterT"><a href="#AfterT" class="headerlink" title="AfterT"></a>AfterT</h5><p>注解：@AfterThrowing</p>
<p>位置：方法定义上方</p>
<p>作用：标注当前方法作为异常后通知</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(value=&quot;pt()&quot;, throwing = &quot;t&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特殊参数：</p>
<ul>
<li>throwing ：设定使用通知方法参数接收原始方法中抛出的异常对象名</li>
</ul>
<h5 id="Around"><a href="#Around" class="headerlink" title="Around"></a>Around</h5><p>注解：@Around</p>
<p>位置：方法定义上方</p>
<p>作用：标注当前方法作为环绕通知</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>AOP 使用 XML 配置情况下，通知的执行顺序由配置顺序决定，在注解情况下由于不存在配置顺序的概念，参照通知所配置的<strong>方法名字符串对应的编码值顺序</strong>，可以简单理解为字母排序</p>
<ul>
<li><p>同一个通知类中，相同通知类型以方法名排序为准</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;aop.AOPPointcut.pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aop001Log</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before(&quot;aop.AOPPointcut.pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aop002Exception</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不同通知类中，以类名排序为准</p>
</li>
<li><p>使用 @Order 注解通过变更 bean 的加载顺序改变通知的加载顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span>  <span class="comment">//先执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(2)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPAdvice1</span> &#123;<span class="comment">//默认执行此通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="AOP-原理"><a href="#AOP-原理" class="headerlink" title="AOP 原理"></a>AOP 原理</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>装饰者模式（Decorator Pattern）：在不惊动原始设计的基础上，为其添加功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceDecorator</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceDecorator</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//原始调用</span></span><br><span class="line">        userService.save();</span><br><span class="line">        <span class="comment">//增强功能（后置）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后置增强功能&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>JDKProxy 动态代理是针对对象做代理，要求原始对象具有接口实现，并对接口方法进行增强，因为<strong>代理类继承Proxy</strong></p>
<p>静态代理和动态代理的区别：</p>
<ul>
<li>静态代理是在编译时就已经将接口、代理类、被代理类的字节码文件确定下来</li>
<li>动态代理是程序在运行后通过反射创建字节码文件交由 JVM 加载</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceJDKProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title function_">createUserServiceJDKProxy</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(</span><br><span class="line">            userService.getClass().getClassLoader(),<span class="comment">//获取被代理对象的类加载器</span></span><br><span class="line">            userService.getClass().getInterfaces(),	<span class="comment">//获取被代理对象实现的接口</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;				<span class="comment">//对原始方法执行进行拦截并增强</span></span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;save&quot;</span>)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;前置增强&quot;</span>);</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> method.invoke(userService, args);</span><br><span class="line">                        System.out.println(<span class="string">&quot;后置增强&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> ret;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line"> 			&#125;);</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h4><p>CGLIB（Code Generation Library）：Code 生成类库 </p>
<p>CGLIB 特点：</p>
<ul>
<li>CGLIB 动态代理<strong>不限定</strong>是否具有接口，可以对任意操作进行增强</li>
<li>CGLIB 动态代理无需要原始被代理对象，动态创建出新的代理对象</li>
<li>CGLIB <strong>继承被代理类</strong>，如果代理类是 final 则不能实现</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-cglib.png"></p>
<ul>
<li><p>CGLIB 类</p>
<ul>
<li>JDKProxy 仅对接口方法做增强，CGLIB 对所有方法做增强，包括 Object 类中的方法（toString、hashCode）</li>
<li>返回值类型采用多态向下转型，所以需要设置父类类型</li>
</ul>
<p>需要对方法进行判断是否是 save，来选择性增强</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImplCglibProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title function_">createUserServiceCglibProxy</span><span class="params">(Class cls)</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建Enhancer对象（可以理解为内存中动态创建了一个类的字节码）</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.设置Enhancer对象的父类是指定类型UserServerImpl</span></span><br><span class="line">        enhancer.setSuperclass(cls);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.设置回调方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method m, Object[] args, MethodProxy mp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                <span class="comment">//o是被代理出的类创建的对象，所以使用MethodProxy调用，并且是调用父类</span></span><br><span class="line">                <span class="comment">//通过调用父类的方法实现对原始方法的调用</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">                <span class="comment">//后置增强内容,需要判断是都是save方法</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;save&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;I love Java&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//使用Enhancer对象创建对应的对象</span></span><br><span class="line">        <span class="keyword">return</span> (UserService)enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Test类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> UserServiceCglibProxy.createUserServiceCglibProxy(UserServiceImpl.class);</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="代理选择"><a href="#代理选择" class="headerlink" title="代理选择"></a>代理选择</h4><p>Spirng 可以通过配置的形式控制使用的代理形式，Spring 会先判断是否实现了接口，如果实现了接口就使用 JDK 动态代理，如果没有实现接口则使用 CGLIB 动态代理，通过配置可以修改为使用 CGLIB </p>
<ul>
<li><p>XML 配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--XML配置AOP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>XML 注解支持</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注解配置AOP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注解驱动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改为使用 cglib 创建代理对象</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>JDK 动态代理和 CGLIB 动态代理的区别：</p>
<ul>
<li>JDK 动态代理只能对实现了接口的类生成代理，没有实现接口的类不能使用。</li>
<li>CGLIB 动态代理即使被代理的类没有实现接口也可以使用，因为 CGLIB 动态代理是使用继承被代理类的方式进行扩展</li>
<li>CGLIB 动态代理是通过继承的方式，覆盖被代理类的方法来进行代理，所以如果方法是被 final 修饰的话，就不能进行代理</li>
</ul>
</li>
</ul>
<hr>
<h4 id="织入时机"><a href="#织入时机" class="headerlink" title="织入时机"></a>织入时机</h4><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/AOP%E7%BB%87%E5%85%A5%E6%97%B6%E6%9C%BA.png" alt="AOP织入时机"></p>
<hr>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h3><h4 id="事务介绍"><a href="#事务介绍" class="headerlink" title="事务介绍"></a>事务介绍</h4><p>事务：数据库中多个操作合并在一起形成的操作序列，事务特征（ACID）</p>
<p>作用：</p>
<ul>
<li>当数据库操作序列中个别操作失败时，提供一种方式使数据库状态恢复到正常状态（<strong>A</strong>），保障数据库即使在异常状态下仍能保持数据一致性（<strong>C</strong>）（要么操作前状态，要么操作后状态）</li>
<li>当出现并发访问数据库时，在多个访问间进行相互隔离，防止并发访问操作结果互相干扰（<strong>I</strong>）</li>
</ul>
<p>Spring 事务一般加到业务层，对应着业务的操作，Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的，Spring 只提供统一事务管理接口</p>
<p>Spring 在事务开始时，根据当前环境中设置的隔离级别，调整数据库隔离级别，由此保持一致。程序是否支持事务首先取决于数据库 ，比如 MySQL ，如果是 <strong>Innodb 引擎</strong>，是支持事务的；如果 MySQL 使用 MyISAM 引擎，那从根上就是不支持事务的</p>
<p><strong>保证原子性</strong>：</p>
<ul>
<li>要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong></li>
<li>在 MySQL 中，恢复机制是通过<strong>回滚日志（undo log）</strong> 实现，所有事务进行的修改都会先先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，直接利用回滚日志中的信息将数据回滚到修改之前的样子即可</li>
<li>回滚日志会先于数据持久化到磁盘上，这样保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务</li>
</ul>
<hr>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>
<ul>
<li>TransactionDefinition.ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ 隔离级别，Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li>
<li>TransactionDefinition.ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li>
<li>TransactionDefinition.ISOLATION_REPEATABLE_READ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li>TransactionDefinition.ISOLATION_SERIALIZABLE：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别</li>
</ul>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong></p>
<p><strong>分布式事务</strong>：允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源，全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高</p>
<p>在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE</p>
<hr>
<h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><p>事务传播行为是为了解决业务层方法之间互相调用的事务问题，也就是方法嵌套：</p>
<ul>
<li><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。</p>
</li>
<li><p>例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外层事务 Service A 的 aMethod 调用内层 Service B 的 bMethod</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>支持当前事务</strong>的情况：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务则<strong>加入该事务</strong>；如果当前没有事务则创建一个新的事务<ul>
<li>内外层是相同的事务，在 aMethod 或者在 bMethod 内的任何地方出现异常，事务都会被回滚</li>
<li>工作流程：<ul>
<li>线程执行到 serviceA.aMethod() 时，其实是执行的代理 serviceA 对象的 aMethod</li>
<li>首先执行事务增强器逻辑（环绕增强），提取事务标签属性，检查当前线程是否绑定 connection 数据库连接资源，没有就调用 datasource.getConnection()，设置事务提交为手动提交 autocommit(false)</li>
<li>执行其他增强器的逻辑，然后调用 target 的目标方法 aMethod() 方法，进入 serviceB 的逻辑</li>
<li>serviceB 也是先执行事务增强器的逻辑，提取事务标签属性，但此时会检查到线程绑定了 connection，检查注解的传播属性，所以调用 DataSourceUtils.getConnection(datasource) 共享该连接资源，执行完相关的增强和 SQL 后，发现事务并不是当前方法开启的，可以直接返回上层</li>
<li>serviceA.aMethod() 继续执行，执行完增强后进行提交事务或回滚事务</li>
</ul>
</li>
</ul>
</li>
<li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则<strong>加入该事务</strong>；如果当前没有事务，则以非事务的方式继续运行</li>
<li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则<strong>加入该事务</strong>；如果当前没有事务，则抛出异常</li>
</ul>
<p><strong>不支持当前事务</strong>的情况：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起<ul>
<li>内外层是不同的事务，如果 bMethod 已经提交，如果 aMethod 失败回滚 ，bMethod 不会回滚</li>
<li>如果 bMethod 失败回滚，ServiceB 抛出的异常被 ServiceA 捕获，如果 B 抛出的异常是 A 会回滚的异常，aMethod 事务需要回滚，否则仍然可以提交</li>
</ul>
</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： <strong>以非事务方式运行</strong>，如果当前存在事务，则把当前事务挂起</li>
<li>TransactionDefinition.PROPAGATION_NEVER： <strong>以非事务方式运行</strong>，如果当前存在事务，则抛出异常</li>
</ul>
<p>其他情况：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务（两个事务没有关系）来运行<ul>
<li>如果 ServiceB 异常回滚，可以通过 try-catch 机制执行 ServiceC</li>
<li>如果 ServiceB 提交， ServiceA 可以根据具体的配置决定是 commit 还是 rollback</li>
<li><strong>应用场景</strong>：在查询数据的时候要向数据库中存储一些日志，系统不希望存日志的行为影响到主逻辑，可以使用该传播</li>
</ul>
</li>
</ul>
<p>requied：必须的、supports：支持的、mandatory：强制的、nested：嵌套的</p>
<hr>
<h4 id="超时属性"><a href="#超时属性" class="headerlink" title="超时属性"></a>超时属性</h4><p>事务超时，指一个事务所允许执行的最长时间，如果超过该时间限制事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒，默认值为 -1</p>
<hr>
<h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务；只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中</p>
<p>读操作为什么需要启用事务支持：</p>
<ul>
<li>MySQL  默认对每一个新建立的连接都启用了 <code>autocommit</code> 模式，在该模式下，每一个发送到 MySQL 服务器的 SQL 语句都会在一个<strong>单独</strong>的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务</li>
<li>执行多条查询语句，如果方法加上了 <code>@Transactional</code> 注解，这个方法执行的所有 SQL 会被放在一个事务中，如果声明了只读事务的话，数据库就会去优化它的执行，并不会带来其他的收益。如果不加 <code>@Transactional</code>，每条 SQL 会开启一个单独的事务，中间被其它事务修改了数据，比如在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则这次整体的统计查询将会出<strong>现读数据不一致的状态</strong></li>
</ul>
<hr>
<h3 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h3><h4 id="事务对象"><a href="#事务对象" class="headerlink" title="事务对象"></a>事务对象</h4><p>J2EE 开发使用分层设计的思想进行，对于简单的业务层转调数据层的单一操作，事务开启在业务层或者数据层并无太大差别，当业务中包含多个数据层的调用时，需要在业务层开启事务，对数据层中多个操作进行组合并归属于同一个事务进行处理</p>
<p>Spring 为业务层提供了整套的事务解决方案：</p>
<ul>
<li><p>PlatformTransactionManager</p>
</li>
<li><p>TransactionDefinition</p>
</li>
<li><p>TransactionStatus</p>
</li>
</ul>
<hr>
<h4 id="PTM"><a href="#PTM" class="headerlink" title="PTM"></a>PTM</h4><p>PlatformTransactionManager，平台事务管理器实现类：</p>
<ul>
<li><p>DataSourceTransactionManager  适用于 Spring JDBC 或 MyBatis</p>
</li>
<li><p>HibernateTransactionManager  适用于 Hibernate3.0 及以上版本</p>
</li>
<li><p>JpaTransactionManager  适用于 JPA</p>
</li>
<li><p>JdoTransactionManager  适用于 JDO</p>
</li>
<li><p>JtaTransactionManager  适用于 JTA</p>
</li>
</ul>
<p>管理器：</p>
<ul>
<li><p>JPA（Java Persistence API）Java EE 标准之一，为 POJO 提供持久化标准规范，并规范了持久化开发的统一 API，符合 JPA 规范的开发可以在不同的 JPA 框架下运行</p>
<p><strong>非持久化一个字段</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String transient1; <span class="comment">// not persistent because of static</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">transient2</span> <span class="operator">=</span> “Satish”; <span class="comment">// not persistent because of final</span></span><br><span class="line"><span class="keyword">transient</span> String transient3; <span class="comment">// not persistent because of transient</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line">String transient4; <span class="comment">// not persistent because of @Transient</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JDO（Java Data Object）是 Java 对象持久化规范，用于存取某种数据库中的对象，并提供标准化 API。JDBC 仅针对关系数据库进行操作，JDO 可以扩展到关系数据库、XML、对象数据库等，可移植性更强</p>
</li>
<li><p>JTA（Java Transaction API）Java EE 标准之一，允许应用程序执行分布式事务处理。与 JDBC 相比，JDBC 事务则被限定在一个单一的数据库连接，而一个 JTA 事务可以有多个参与者，比如 JDBC 连接、JDO 都可以参与到一个 JTA 事务中</p>
</li>
</ul>
<p>此接口定义了事务的基本操作：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TransactionStatus getTransaction(TransactionDefinition definition)</td>
<td>获取事务</td>
</tr>
<tr>
<td>void commit(TransactionStatus status)</td>
<td>提交事务</td>
</tr>
<tr>
<td>void rollback(TransactionStatus status)</td>
<td>回滚事务</td>
</tr>
</tbody></table>
<hr>
<h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>TransactionDefinition 此接口定义了事务的基本信息：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String getName()</td>
<td>获取事务定义名称</td>
</tr>
<tr>
<td>boolean isReadOnly()</td>
<td>获取事务的读写属性</td>
</tr>
<tr>
<td>int getIsolationLevel()</td>
<td>获取事务隔离级别</td>
</tr>
<tr>
<td>int getTimeout()</td>
<td>获取事务超时时间</td>
</tr>
<tr>
<td>int getPropagationBehavior()</td>
<td>获取事务传播行为特征</td>
</tr>
</tbody></table>
<hr>
<h4 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h4><p>TransactionStatus 此接口定义了事务在执行过程中某个时间点上的状态信息及对应的状态操作：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean isNewTransaction()</td>
<td>获取事务是否处于新开始事务状态</td>
</tr>
<tr>
<td>voin flush()</td>
<td>刷新事务状态</td>
</tr>
<tr>
<td>boolean isCompleted()</td>
<td>获取事务是否处于已完成状态</td>
</tr>
<tr>
<td>boolean hasSavepoint()</td>
<td>获取事务是否具有回滚储存点</td>
</tr>
<tr>
<td>boolean isRollbackOnly()</td>
<td>获取事务是否处于回滚状态</td>
</tr>
<tr>
<td>void setRollbackOnly()</td>
<td>设置事务处于回滚状态</td>
</tr>
</tbody></table>
<hr>
<h3 id="编程式"><a href="#编程式" class="headerlink" title="编程式"></a>编程式</h3><h4 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h4><p>编程式、声明式（XML）、声明式（注解）</p>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>银行转账业务</p>
<ul>
<li><p>包装类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DAO层接口：AccountDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="comment">//入账操作	name:入账用户名	money:入账金额</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inMoney</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;money&quot;)</span> Double money)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出账操作	name:出账用户名	money:出账金额</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">outMoney</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;money&quot;)</span> Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>业务层接口提供转账操作：AccountService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">	<span class="comment">//转账操作	outName:出账用户名	inName:入账用户名	money:转账金额</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName,String inName,Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>业务层实现提供转账操作：AccountServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccountDao</span><span class="params">(AccountDao accountDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName,String inName,Double money)</span>&#123;</span><br><span class="line">		accountDao.inMoney(outName,money);</span><br><span class="line">        accountDao.outMoney(inName,money);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>映射配置文件：dao &#x2F; AccountDao.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;dao.AccountDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;inMoney&quot;</span>&gt;</span></span><br><span class="line">        UPDATE account SET money = money + #&#123;money&#125; WHERE name = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;outMoney&quot;</span>&gt;</span></span><br><span class="line">        UPDATE account SET money = money - #&#123;money&#125; WHERE name = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>jdbc.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://192.168.2.185:3306/spring_db</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>核心配置文件：applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;domain&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--扫描映射配置和Dao--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;ap...xml&quot;</span>);</span><br><span class="line"><span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> (AccountService) ctx.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">accountService.transfer(<span class="string">&quot;Jock1&quot;</span>, <span class="string">&quot;Jock2&quot;</span>, <span class="number">100d</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="编程式-1"><a href="#编程式-1" class="headerlink" title="编程式"></a>编程式</h4><p>编程式事务就是代码显式的给出事务的开启和提交</p>
<ul>
<li><p>修改业务层实现提供转账操作：AccountServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName,String inName,Double money)</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建事务管理器，</span></span><br><span class="line">    <span class="type">DataSourceTransactionManager</span> <span class="variable">dstm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    <span class="comment">//2.为事务管理器设置与数据层相同的数据源</span></span><br><span class="line">    dstm.setDataSource(dataSource);</span><br><span class="line">    <span class="comment">//3.创建事务定义对象</span></span><br><span class="line">    <span class="type">TransactionDefinition</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">    <span class="comment">//4.创建事务状态对象，用于控制事务执行，【开启事务】</span></span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">ts</span> <span class="operator">=</span> dstm.getTransaction(td);</span><br><span class="line">    accountDao.inMoney(inName,money);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;    <span class="comment">//模拟业务层事务过程中出现错误</span></span><br><span class="line">    accountDao.outMoney(outName,money);</span><br><span class="line">    <span class="comment">//5.提交事务</span></span><br><span class="line">    dstm.commit(ts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="AOP改造"><a href="#AOP改造" class="headerlink" title="AOP改造"></a>AOP改造</h4><ul>
<li><p>将业务层的事务处理功能抽取出来制作成 AOP 通知，利用环绕通知运行期动态织入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">tx</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//开启事务</span></span><br><span class="line">        <span class="type">PlatformTransactionManager</span> <span class="variable">ptm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">        <span class="comment">//事务定义</span></span><br><span class="line">        <span class="type">TransactionDefinition</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">        <span class="comment">//事务状态</span></span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">ts</span> <span class="operator">=</span>  ptm.getTransaction(td);</span><br><span class="line">        <span class="comment">//pjp.getArgs()标准写法，也可以不加，同样可以传递参数</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed(pjp.getArgs());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        ptm.commit(ts);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 applicationContext.xml，要开启 AOP 空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--修改bean的属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置AOP通知类，并注入dataSource--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;aop.TxAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使用环绕通知将通知类织入到原始业务对象执行过程中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* *..transfer(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;tx&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改业务层实现提供转账操作：AccountServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccountDao</span><span class="params">(AccountDao accountDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName,String inName,Double money)</span>&#123;</span><br><span class="line">		accountDao.inMoney(outName,money);</span><br><span class="line">        <span class="comment">//int i = 1 / 0;</span></span><br><span class="line">        accountDao.outMoney(inName,money);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h3><h4 id="XML-2"><a href="#XML-2" class="headerlink" title="XML"></a>XML</h4><h5 id="tx使用"><a href="#tx使用" class="headerlink" title="tx使用"></a>tx使用</h5><p>删除 TxAdvice 通知类，开启 tx 命名空间，配置 applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置平台事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--定义事务管理的通知类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义控制的事务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使用aop:advisor在AOP配置中引用事务专属通知类，底层invoke调用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* service.*Service.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>aop:advice 与 aop:advisor 区别<ul>
<li><p>aop:advice 配置的通知类可以是普通 Java 对象，不实现接口，也不使用继承关系</p>
</li>
<li><p>aop:advisor 配置的通知类必须实现通知接口，底层 invoke 调用</p>
<ul>
<li><p>MethodBeforeAdvice</p>
</li>
<li><p>AfterReturningAdvice</p>
</li>
<li><p>ThrowsAdvice</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>pom.xml 文件引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>





<hr>
<h5 id="tx配置"><a href="#tx配置" class="headerlink" title="tx配置"></a>tx配置</h5><h6 id="advice"><a href="#advice" class="headerlink" title="advice"></a>advice</h6><p>标签：tx:advice，beans 的子标签</p>
<p>作用：专用于声明事务通知</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基本属性：</p>
<ul>
<li>id：用于配置 aop 时指定通知器的 id</li>
<li>transaction-manager：指定事务管理器 bean</li>
</ul>
<h6 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h6><p>类型：tx:attributes，tx:advice 的子标签</p>
<p>作用：定义通知属性</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h6 id="method"><a href="#method" class="headerlink" title="method"></a>method</h6><p>标签：tx:method，tx:attribute 的子标签</p>
<p>作用：设置具体的事务属性</p>
<p>格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--标准格式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* service.*Service.*(..))&quot;</span>/&gt;</span><span class="comment">&lt;!--标准--&gt;</span></span><br></pre></td></tr></table></figure>

<p>说明：通常事务属性会配置多个，包含 1 个读写的全事务属性，1 个只读的查询类事务属性</p>
<p>属性：</p>
<ul>
<li>name：待添加事务的方法名表达式（支持 * 通配符）</li>
<li>read-only：设置事务的读写属性，true 为只读，false 为读写</li>
<li>timeout：设置事务的超时时长，单位秒，-1 为无限长</li>
<li>isolation：设置事务的隔离界别，该隔离级设定是基于 Spring 的设定，非数据库端</li>
<li>no-rollback-for：设置事务中不回滚的异常，多个异常使用 <code>,</code> 分隔</li>
<li>rollback-for：设置事务中必回滚的异常，多个异常使用 <code>,</code> 分隔</li>
<li>propagation：设置事务的传播行为</li>
</ul>
<hr>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><h5 id="开启注解"><a href="#开启注解" class="headerlink" title="开启注解"></a>开启注解</h5><h6 id="XML-3"><a href="#XML-3" class="headerlink" title="XML"></a>XML</h6><p>标签：tx:annotation-driven</p>
<p>归属：beans 标签</p>
<p>作用：开启事务注解驱动，并指定对应的事务管理器</p>
<p>范例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h6 id="纯注解-2"><a href="#纯注解-2" class="headerlink" title="纯注解"></a>纯注解</h6><p>名称：@EnableTransactionManagement</p>
<p>类型：类注解，Spring 注解配置类上方</p>
<p>作用：开启注解驱动，等同 XML 格式中的注解驱动</p>
<p>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.seazean&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JDBCConfig.class,MyBatisConfig.class,TransactionManagerConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManagerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span>												<span class="comment">//自动装配</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">getTransactionManager</span><span class="params">(<span class="meta">@Autowired</span> DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h5 id="配置注解"><a href="#配置注解" class="headerlink" title="配置注解"></a>配置注解</h5><p>名称：@Transactional</p>
<p>类型：方法注解，类注解，接口注解</p>
<p>作用：设置当前类&#x2F;接口中所有方法或具体方法开启事务，并指定相关事务属性</p>
<p>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">    readOnly = false,</span></span><br><span class="line"><span class="meta">    timeout = -1,</span></span><br><span class="line"><span class="meta">    isolation = Isolation.DEFAULT,</span></span><br><span class="line"><span class="meta">    rollbackFor = &#123;ArithmeticException.class, IOException.class&#125;,</span></span><br><span class="line"><span class="meta">    noRollbackFor = &#123;&#125;,</span></span><br><span class="line"><span class="meta">    propagation = Propagation.REQUIRES_NEW</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> addAccount&#123;&#125; </span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><p><code>@Transactional</code> 注解只有作用到 public 方法上事务才生效</p>
</li>
<li><p>不推荐在接口上使用 <code>@Transactional</code> 注解</p>
<p>原因：在接口上使用注解，<strong>只有在使用基于接口的代理（JDK）时才会生效，因为注解是不能继承的</strong>，这就意味着如果正在使用基于类的代理（CGLIB）时，那么事务的设置将不能被基于类的代理所识别</p>
</li>
<li><p>正确的设置 <code>@Transactional</code> 的 rollbackFor 和 propagation 属性，否则事务可能会回滚失败</p>
</li>
<li><p>默认情况下，事务只有遇到运行期异常 和 Error 会导致事务回滚，但是在遇到检查型（Checked）异常时不会回滚</p>
<ul>
<li>继承自 RuntimeException 或 error 的是非检查型异常，比如空指针和索引越界，而继承自 Exception 的则是检查型异常，比如 IOException、ClassNotFoundException，RuntimeException 本身继承 Exception</li>
<li>非检查型类异常可以不用捕获，而检查型异常则必须用 try 语句块把异常交给上级方法，这样事务才能有效</li>
</ul>
</li>
</ul>
<p><strong>事务不生效的问题</strong></p>
<ul>
<li><p>情况 1：确认创建的 MySQL 数据库表引擎是 InnoDB，MyISAM 不支持事务</p>
</li>
<li><p>情况 2：注解到 protected，private 方法上事务不生效，但不会报错</p>
<p>原因：理论上而言，不用 public 修饰，也可以用 aop 实现事务的功能，但是方法私有化让其他业务无法调用</p>
<p>AopUtils.canApply：<code>methodMatcher.matches(method, targetClass) --true--&gt; return true</code><br><code>TransactionAttributeSourcePointcut.matches()</code> ，AbstractFallbackTransactionAttributeSource 中 getTransactionAttribute 方法调用了其本身的 computeTransactionAttribute 方法，当加了事务注解的方法不是 public 时，该方法直接返回 null，所以造成增强不匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TransactionAttribute <span class="title function_">computeTransactionAttribute</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">    <span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line">    <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>情况 3：注解所在的类没有被加载成 Bean</p>
</li>
<li><p>情况 4：在业务层捕捉异常后未向上抛出，事务不生效</p>
<p>原因：在业务层捕捉并处理了异常（try..catch）等于把异常处理掉了，Spring 就不知道这里有错，也不会主动去回滚数据，推荐做法是在业务层统一抛出异常，然后在控制层统一处理</p>
</li>
<li><p>情况 5：遇到检测异常时，也无法回滚</p>
<p>原因：Spring 的默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。想针对检测异常进行事务回滚，可以在 @Transactional 注解里使用 rollbackFor 属性明确指定异常</p>
</li>
<li><p>情况 6：Spring 的事务传播策略在<strong>内部方法</strong>调用时将不起作用，在一个 Service 内部，事务方法之间的嵌套调用，普通方法和事务方法之间的嵌套调用，都不会开启新的事务，事务注解要加到调用方法上才生效</p>
<p>原因：Spring 的事务都是使用 AOP 代理的模式，动态代理 invoke 后会调用原始对象，而原始对象在去调用方法时是不会触发拦截器，就是<strong>一个方法调用本对象的另一个方法</strong>，所以事务也就无法生效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    update();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注解添加在update方法上无效，需要添加到add()方法上</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>情况 7：注解在接口上，代理对象是 CGLIB</p>
</li>
</ul>
<hr>
<h5 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h5><ul>
<li><p>Dao 层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="meta">@Update(&quot;update account set money = money + #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inMoney</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;money&quot;)</span> Double money)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update account set money = money - #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">outMoney</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;money&quot;)</span> Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>业务层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="comment">//对当前方法添加事务，该配置将替换接口的配置</span></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        readOnly = false,</span></span><br><span class="line"><span class="meta">        timeout = -1,</span></span><br><span class="line"><span class="meta">        isolation = Isolation.DEFAULT,</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;&#125;,//java.lang.ArithmeticException.class, IOException.class</span></span><br><span class="line"><span class="meta">        noRollbackFor = &#123;&#125;,</span></span><br><span class="line"><span class="meta">        propagation = Propagation.REQUIRED</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName, String inName, Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String outName, String inName, Double money)</span> &#123;</span><br><span class="line">        accountDao.inMoney(outName,money);</span><br><span class="line">        <span class="comment">//int i = 1/0;</span></span><br><span class="line">        accountDao.outMoney(inName,money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加文件 Spring.config、Mybatis.config、JDBCConfig (参考ioc_Mybatis)、TransactionManagerConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;&quot;,&quot;&quot;,&quot;&quot;&#125;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JDBCConfig.class,MyBatisConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="模板对象"><a href="#模板对象" class="headerlink" title="模板对象"></a>模板对象</h3><p>Spring 模板对象：TransactionTemplate、JdbcTemplate、RedisTemplate、RabbitTemplate、JmsTemplate、HibernateTemplate、RestTemplate</p>
<ul>
<li><p>JdbcTemplate：提供标准的 sql 语句操作API</p>
</li>
<li><p>NamedParameterJdbcTemplate：提供标准的具名 sql 语句操作API</p>
</li>
<li><p>RedisTemplate：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeMoney</span><span class="params">(Integer id, Double money)</span> &#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;account:id:&quot;</span>+id,money);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Double <span class="title function_">findMondyById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">money</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;account:id:&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Double</span>(money.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-RedisTemplate.png"></p>
<hr>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="XML-4"><a href="#XML-4" class="headerlink" title="XML"></a>XML</h3><p>三大对象：</p>
<ul>
<li><p><strong>BeanDefinition</strong>：是 Spring 中极其重要的一个概念，存储了 bean 对象的所有特征信息，如是否单例、是否懒加载、factoryBeanName 等，和 bean 的关系就是类与对象的关系，一个不同的 bean 对应一个 BeanDefinition</p>
</li>
<li><p><strong>BeanDefinationRegistry</strong>：存放 BeanDefination 的容器，是一种键值对的形式，通过特定的 Bean 定义的 id，映射到相应的 BeanDefination，<strong>BeanFactory 的实现类同样继承 BeanDefinationRegistry 接口</strong>，拥有保存 BD 的能力</p>
</li>
<li><p><strong>BeanDefinitionReader</strong>：读取配置文件，<strong>XML 用 Dom4j 解析</strong>，<strong>注解用 IO 流加载解析</strong></p>
</li>
</ul>
<p>程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>));</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService1</span> <span class="operator">=</span> (UserService)bf.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>源码解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parentBeanFactory);</span><br><span class="line">    <span class="built_in">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource resource)</span> &#123;</span><br><span class="line">    <span class="comment">//将 resource 包装成带编码格式的 EncodedResource</span></span><br><span class="line">    <span class="comment">//EncodedResource 中 getReader()方法，调用java.io包下的 转换流 创建指定编码的输入流对象</span></span><br><span class="line">    <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">EncodedResource</span>(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>XmlBeanDefinitionReader.loadBeanDefinitions()</code>：<strong>把 Resource 解析成 BeanDefinition 对象</strong></p>
<ul>
<li><code>currentResources = this.resourcesCurrentlyBeingLoaded.get()</code>：拿到当前线程已经加载过的所有 EncodedResoure 资源，用 ThreadLocal 保证线程安全</li>
<li><code>if (currentResources == null)</code>：判断 currentResources 是否为空，为空则进行初始化</li>
<li><code>if (!currentResources.add(encodedResource))</code>：如果已经加载过该资源会报错，防止重复加载</li>
<li><code>inputSource = new InputSource(inputStream)</code>：资源对象包装成 InputSource，InputSource 是 <strong>SAX</strong> 中的资源对象，用来进行 XML 文件的解析</li>
<li><code>return doLoadBeanDefinitions()</code>：<strong>加载返回</strong></li>
<li><code>currentResources.remove(encodedResource)</code>：加载完成移除当前 encodedResource</li>
<li><code>resourcesCurrentlyBeingLoaded.remove()</code>：ThreadLocal 为空时移除元素，防止内存泄露</li>
</ul>
</li>
<li><p><code>XmlBeanDefinitionReader.doLoadBeanDefinitions(inputSource, resource)</code>：真正的加载函数</p>
<p><code>Document doc = doLoadDocument(inputSource, resource)</code>：转换成有<strong>层次结构</strong>的 Document 对象</p>
<ul>
<li><p><code>getEntityResolver()</code><strong>：获取用来解析 DTD、XSD 约束的解析器</strong></p>
</li>
<li><p><code>getValidationModeForResource(resource)</code>：获取验证模式</p>
</li>
</ul>
<p><code>int count = registerBeanDefinitions(doc, resource)</code>：<strong>将 Document 解析成 BD 对象，注册（添加）到  BeanDefinationRegistry 中</strong>，返回新注册的数量</p>
<ul>
<li><code>createBeanDefinitionDocumentReader()</code>：创建 DefaultBeanDefinitionDocumentReader 对象</li>
<li><code>getRegistry().getBeanDefinitionCount()</code>：获取解析前 BeanDefinationRegistry 中的 bd 数量</li>
<li><code>registerBeanDefinitions(doc, readerContext)</code>：注册 BD<ul>
<li><code>this.readerContext = readerContext</code>：保存上下文对象</li>
<li><code>doRegisterBeanDefinitions(doc.getDocumentElement())</code>：真正的注册 BD 函数<ul>
<li><code>doc.getDocumentElement()</code>：拿出顶层标签 <beans></beans></li>
</ul>
</li>
</ul>
</li>
<li><code>return getRegistry().getBeanDefinitionCount() - countBefore</code>：返回新加入的数量</li>
</ul>
</li>
<li><p><code>DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions()</code>：注册 BD 到 BR</p>
<ul>
<li><code>createDelegate(getReaderContext(), root, parent)</code>：beans 是标签的解析器对象</li>
<li><code>delegate.isDefaultNamespace(root)</code>：判断 beans 标签是否是默认的属性</li>
<li><code>root.getAttribute(PROFILE_ATTRIBUTE)</code>：解析 profile 属性</li>
<li><code>preProcessXml(root)</code>：解析前置处理，自定义实现</li>
<li><code>parseBeanDefinitions(root, this.delegate)</code>：<strong>解析 beans 标签中的子标签</strong><ul>
<li><code>parseDefaultElement(ele, delegate)</code>：如果是默认的标签，用该方法解析子标签<ul>
<li>判断标签名称，进行相应的解析</li>
<li><code>processBeanDefinition(ele, delegate)</code>：</li>
</ul>
</li>
<li><code>delegate.parseCustomElement(ele)</code>：解析自定义的标签</li>
</ul>
</li>
<li><code>postProcessXml(root)</code>：解析后置处理</li>
</ul>
</li>
<li><p><code>DefaultBeanDefinitionDocumentReader.processBeanDefinition()</code>：<strong>解析 bean 标签并注册到注册中心</strong></p>
<ul>
<li><p><code>delegate.parseBeanDefinitionElement(ele)</code>：解析 bean 标签封装为 BeanDefinitionHolder</p>
<ul>
<li><p><code>if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty())</code>：条件一成立说明 name 没有值，条件二成立说明别名有值</p>
<p><code>beanName = aliases.remove(0)</code>：拿别名列表的第一个元素当作 beanName</p>
</li>
<li><p><code>parseBeanDefinitionElement(ele, beanName, containingBean)</code>：<strong>解析 bean 标签</strong></p>
<ul>
<li><code>parseState.push(new BeanEntry(beanName))</code>：当前解析器的状态设置为 BeanEntry</li>
<li>class 和 parent 属性存在一个，parent 是作为父标签为了被继承</li>
<li><code>createBeanDefinition(className, parent)</code>：设置了class 的 GenericBeanDefinition对象</li>
<li><code>parseBeanDefinitionAttributes()</code>：解析 bean 标签的属性</li>
<li>接下来解析子标签</li>
</ul>
</li>
<li><p><code>beanName = this.readerContext.generateBeanName(beanDefinition)</code>：生成 className + # + 序号的名称赋值给 beanName </p>
</li>
<li><p><code>return new BeanDefinitionHolder(beanDefinition, beanName, aliases)</code>：<strong>包装成 BeanDefinitionHolder</strong></p>
</li>
</ul>
</li>
<li><p><code>registerBeanDefinition(bdHolder, getReaderContext().getRegistry())</code>：<strong>注册到容器</strong></p>
<ul>
<li><code>beanName = definitionHolder.getBeanName()</code>：获取beanName</li>
<li><code>this.beanDefinitionMap.put(beanName, beanDefinition)</code>：添加到注册中心</li>
</ul>
</li>
<li><p><code>getReaderContext().fireComponentRegistered()</code>：发送注册完成事件</p>
</li>
</ul>
</li>
</ul>
<p><strong>说明：源码部分的笔记不一定适合所有人阅读，作者采用流水线式去解析重要的代码，解析的结构类似于树状，如果视觉疲劳可以去网上参考一些博客和流程图学习源码。</strong></p>
<hr>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><h4 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h4><p>Spring IOC 容器是 ApplicationContext 或者 BeanFactory，使用多个 Map 集合保存单实例 Bean，环境信息等资源，不同层级有不同的容器，比如整合 SpringMVC 的父子容器（先看 Bean 部分的源码解析再回看容器）</p>
<p>ClassPathXmlApplicationContext 与 AnnotationConfigApplicationContext 差不多：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    register(annotatedClasses);<span class="comment">// 解析配置类，封装成一个 BeanDefinitionHolder，并注册到容器</span></span><br><span class="line">    refresh();<span class="comment">// 加载刷新容器中的 Bean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注册 Spring 的注解解析器到容器</span></span><br><span class="line">    <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 实例化路径扫描器，用于对指定的包目录进行扫描查找 bean 对象</span></span><br><span class="line">    <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractApplicationContext.refresh()：</p>
<ul>
<li><p>prepareRefresh()：刷新前的<strong>预处理</strong></p>
<ul>
<li><code>this.startupDate = System.currentTimeMillis()</code>：设置容器的启动时间</li>
<li><code>initPropertySources()</code>：初始化一些属性设置，可以自定义个性化的属性设置方法</li>
<li><code>getEnvironment().validateRequiredProperties()</code>：检查环境变量</li>
<li><code>earlyApplicationEvents= new LinkedHashSet&lt;ApplicationEvent&gt;()</code>：保存容器中早期的事件</li>
</ul>
</li>
<li><p>obtainFreshBeanFactory()：获取一个<strong>全新的 BeanFactory 接口实例</strong>，如果容器中存在工厂实例直接销毁</p>
<p><code>refreshBeanFactory()</code>：创建 BeanFactory，设置序列化 ID、读取 BeanDefinition 并加载到工厂</p>
<ul>
<li><code>if (hasBeanFactory())</code>：applicationContext 内部拥有一个 beanFactory 实例，需要将该实例完全释放销毁</li>
<li><code>destroyBeans()</code>：销毁原 beanFactory 实例，将 beanFactory 内部维护的单实例 bean 全部清掉，如果哪个 bean 实现了 Disposablejie接口，还会进行 bean distroy 方法的调用处理<ul>
<li><code>this.singletonsCurrentlyInDestruction = true</code>：设置当前 beanFactory 状态为销毁状态</li>
<li><code>String[] disposableBeanNames</code>：获取销毁集合中的 bean，如果当前 bean 有<strong>析构函数</strong>就会在销毁集合</li>
<li><code>destroySingleton(disposableBeanNames[i])</code>：遍历所有的 disposableBeans，执行销毁方法<ul>
<li><code>removeSingleton(beanName)</code>：清除三级缓存和 registeredSingletons 中的当前 beanName 的数据</li>
<li><code>this.disposableBeans.remove(beanName)</code>：从销毁集合中清除，每个 bean 只能 destroy 一次</li>
<li><code>destroyBean(beanName, disposableBean)</code>：销毁 bean<ul>
<li>dependentBeanMap 记录了依赖当前 bean 的其他 bean 信息，因为依赖的对象要被回收了，所以依赖当前 bean 的其他对象都要执行 destroySingleton，遍历 dependentBeanMap 执行销毁</li>
<li><code>bean.destroy()</code>：解决完成依赖后，执行 DisposableBean 的 destroy 方法</li>
<li><code> this.dependenciesForBeanMap.remove(beanName)</code>：保存当前 bean 依赖了谁，直接清除</li>
</ul>
</li>
</ul>
</li>
<li>进行一些集合和缓存的清理工作</li>
</ul>
</li>
<li><code>closeBeanFactory()</code>：将容器内部的 beanFactory 设置为空，重新创建</li>
<li><code>beanFactory = createBeanFactory()</code>：创建新的 DefaultListableBeanFactory 对象</li>
<li><code>beanFactory.setSerializationId(getId())</code>：进行 ID 的设置，可以根据 ID 获取 BeanFactory 对象</li>
<li><code>customizeBeanFactory(beanFactory)</code>：设置是否允许覆盖和循环引用</li>
<li><code>loadBeanDefinitions(beanFactory)</code>：<strong>加载 BeanDefinition 信息，注册 BD注册到 BeanFactory 中</strong></li>
<li><code>this.beanFactory = beanFactory</code>：把 beanFactory 填充至容器中</li>
</ul>
<p><code>getBeanFactory()</code>：返回创建的 DefaultListableBeanFactory 对象，该对象继承 BeanDefinitionRegistry</p>
</li>
<li><p>prepareBeanFactory(beanFactory)：<strong>BeanFactory 的预准备</strong>工作，向容器中添加一些组件</p>
<ul>
<li><code>setBeanClassLoader(getClassLoader())</code>：给当前 bf 设置一个<strong>类加载器</strong>，加载 bd 的 class 信息</li>
<li><code>setBeanExpressionResolver()</code>：设置 EL 表达式解析器</li>
<li><code>addPropertyEditorRegistrar</code>：添加一个属性编辑器，解决属性注入时的格式转换</li>
<li><code>addBeanPostProcessor()</code>：添加后处理器，主要用于向 bean 内部注入一些框架级别的实例</li>
<li><code>ignoreDependencyInterface()</code>：设置忽略自动装配的接口，bean 内部的这些类型的字段   不参与依赖注入</li>
<li><code>registerResolvableDependency()</code>：注册一些类型依赖关系</li>
<li><code>addBeanPostProcessor()</code>：将配置的监听者注册到容器中，当前 bean 实现 ApplicationListener 接口就是监听器事件</li>
<li><code>beanFactory.registerSingleton()</code>：添加一些系统信息</li>
</ul>
</li>
<li><p>postProcessBeanFactory(beanFactory)：BeanFactory 准备工作完成后进行的后置处理工作，扩展方法</p>
</li>
<li><p>invokeBeanFactoryPostProcessors(beanFactory)：<strong>执行 BeanFactoryPostProcessor 的方法</strong></p>
<ul>
<li><p><code>processedBeans = new HashSet&lt;&gt;()</code>：存储已经执行过的 BeanFactoryPostProcessor 的 beanName</p>
</li>
<li><p><code>if (beanFactory instanceof BeanDefinitionRegistry)</code>：<strong>当前 BeanFactory 是 bd 的注册中心，bd 全部注册到 bf</strong></p>
</li>
<li><p><code>for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors)</code>：遍历所有的 bf 后置处理器</p>
</li>
<li><p><code>if (postProcessor instanceof BeanDefinitionRegistryPostProcessor)</code>：是 Registry 类的后置处理器</p>
<p><code>registryProcessor.postProcessBeanDefinitionRegistry(registry)</code>：向 bf 中注册一些 bd</p>
<p><code>registryProcessors.add(registryProcessor)</code>：添加到 BeanDefinitionRegistryPostProcessor 集合</p>
</li>
<li><p><code>regularPostProcessors.add(postProcessor)</code>：添加到 BeanFactoryPostProcessor 集合</p>
</li>
<li><p>逻辑到这里已经获取到所有 BeanDefinitionRegistryPostProcessor 和 BeanFactoryPostProcessor  接口类型的后置处理器</p>
</li>
<li><p><strong>首先回调 BeanDefinitionRegistryPostProcessor 类的后置处理方法 postProcessBeanDefinitionRegistry()</strong></p>
<ul>
<li><p>获取实现了 PriorityOrdered（主排序接口）接口的 bdrpp，进行 sort 排序，然后全部执行并放入已经处理过的集合</p>
</li>
<li><p>再执行实现了 Ordered（次排序接口）接口的 bdrpp</p>
</li>
<li><p>最后执行没有实现任何优先级或者是顺序接口 bdrpp，<code>boolean reiterate = true</code> 控制 while 是否需要再次循环，循环内是查找并执行 bdrpp 后处理器的 registry 相关的接口方法，接口方法执行以后会向 bf 内注册 bd，注册的 bd 也有可能是 bdrpp 类型，所以需要该变量控制循环</p>
</li>
<li><p><code>processedBeans.add(ppName)</code>：已经执行过的后置处理器存储到该集合中，防止重复执行</p>
</li>
<li><p><code> invokeBeanFactoryPostProcessors()</code>：bdrpp 继承了 BeanFactoryPostProcessor，有 postProcessBeanFactory 方法</p>
</li>
</ul>
</li>
<li><p><strong>执行普通 BeanFactoryPostProcessor 的相关 postProcessBeanFactory 方法，按照主次无次序执行</strong></p>
<ul>
<li><code>if (processedBeans.contains(ppName))</code>：会过滤掉已经执行过的后置处理器</li>
</ul>
</li>
<li><p><code>beanFactory.clearMetadataCache()</code>：清除缓存中合并的 Bean 定义，因为后置处理器可能更改了元数据</p>
</li>
</ul>
</li>
</ul>
<p><strong>以上是 BeanFactory 的创建及预准备工作，接下来进入 Bean 的流程</strong></p>
<ul>
<li><p>registerBeanPostProcessors(beanFactory)：<strong>注册 Bean 的后置处理器</strong>，为了干预 Spring 初始化 bean 的流程，这里仅仅是向容器中<strong>注入而非使用</strong></p>
<ul>
<li><p><code>beanFactory.getBeanNamesForType(BeanPostProcessor.class)</code>：<strong>获取配置中实现了 BeanPostProcessor 接口类型</strong></p>
</li>
<li><p><code>int beanProcessorTargetCount</code>：后置处理器的数量，已经注册的 + 未注册的 + 即将要添加的一个</p>
</li>
<li><p><code>beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker())</code>：添加一个检查器</p>
<p><code>BeanPostProcessorChecker.postProcessAfterInitialization()</code>：初始化后的后处理器方法</p>
<ul>
<li><code>!(bean instanceof BeanPostProcessor) </code>：当前 bean 类型是普通 bean，不是后置处理器</li>
<li><code>!isInfrastructureBean(beanName)</code>：成立说明当前 beanName 是用户级别的 bean  不是 Spring 框架的</li>
<li><code>this.beanFactory.getBeanPostProcessorCount() &lt; this.beanPostProcessorTargetCount</code>：BeanFactory 上面注册后处理器数量 &lt; 后处理器数量，说明后处理框架尚未初始化完成</li>
</ul>
</li>
<li><p><code>for (String ppName : postProcessorNames)</code>：遍历 PostProcessor 集合，<strong>根据实现不同的顺序接口添加到不同集合</strong></p>
</li>
<li><p><code>sortPostProcessors(priorityOrderedPostProcessors, beanFactory)</code>：实现 PriorityOrdered 接口的后处理器排序</p>
<p><code>registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors)</code>：<strong>注册到 beanFactory 中</strong></p>
</li>
<li><p>接着排序注册实现 Ordered 接口的后置处理器，然后注册普通的（ 没有实现任何优先级接口）后置处理器</p>
</li>
<li><p>最后排序 MergedBeanDefinitionPostProcessor 类型的处理器，根据实现的排序接口，排序完注册到 beanFactory 中</p>
</li>
<li><p><code>beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext))</code>：重新注册 ApplicationListenerDetector 后处理器，用于在 Bean 创建完成后检查是否属于 ApplicationListener 类型，如果是就把 Bean 放到<strong>监听器容器</strong>中保存起来</p>
</li>
</ul>
</li>
<li><p>initMessageSource()：初始化 MessageSource 组件，主要用于做国际化功能，消息绑定与消息解析</p>
<ul>
<li><code>if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME))</code>：容器是否含有名称为 messageSource 的 bean</li>
<li><code>beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class)</code>：如果有证明用户自定义了该类型的 bean，获取后直接赋值给 this.messageSource</li>
<li><code>dms = new DelegatingMessageSource()</code>：容器中没有就新建一个赋值</li>
</ul>
</li>
<li><p>initApplicationEventMulticaster()：<strong>初始化事件传播器</strong>，在注册监听器时会用到</p>
<ul>
<li><code>if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME))</code>：<strong>条件成立说明用户自定义了事件传播器</strong>，可以实现 ApplicationEventMulticaster 接口编写自己的事件传播器，通过 bean 的方式提供给 Spring</li>
<li>如果有就直接从容器中获取；如果没有则创建一个 SimpleApplicationEventMulticaster 注册</li>
</ul>
</li>
<li><p>onRefresh()：留给用户去实现，可以硬编码提供一些组件，比如提供一些监听器</p>
</li>
<li><p>registerListeners()：注册通过配置提供的 Listener，这些<strong>监听器</strong>最终注册到 ApplicationEventMulticaster 内</p>
<ul>
<li><p><code>for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) </code>：注册编码实现的监听器</p>
</li>
<li><p><code>getBeanNamesForType(ApplicationListener.class, true, false)</code>：注册通过配置提供的 Listener</p>
</li>
<li><p><code>multicastEvent(earlyEvent)</code>：<strong>发布前面步骤产生的事件 applicationEvents</strong></p>
<p><code>Executor executor = getTaskExecutor()</code>：获取线程池，有线程池就异步执行，没有就同步执行</p>
</li>
</ul>
</li>
<li><p>finishBeanFactoryInitialization()：<strong>实例化非懒加载状态的单实例</strong></p>
<ul>
<li><p><code>beanFactory.freezeConfiguration()</code>：<strong>冻结配置信息</strong>，就是冻结 BD 信息，冻结后无法再向 bf 内注册 bd</p>
</li>
<li><p><code>beanFactory.preInstantiateSingletons()</code>：实例化 non-lazy-init singletons</p>
<ul>
<li><p><code>for (String beanName : beanNames)</code>：遍历容器内所有的 beanDefinitionNames</p>
</li>
<li><p><code>getMergedLocalBeanDefinition(beanName)</code>：获取与父类合并后的对象（Bean → 获取流程部分详解此函数）</p>
</li>
<li><p><code>if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit())</code>：BD 对应的 Class 满足非抽象、单实例，非懒加载，需要预先实例化</p>
<p><code>if (isFactoryBean(beanName))</code>：BD 对应的 Class 是 factoryBean 对象</p>
<ul>
<li><code>getBean(FACTORY_BEAN_PREFIX + beanName)</code>：获取工厂 FactoryBean 实例本身</li>
<li><code>isEagerInit</code>：控制 FactoryBean 内部管理的 Bean 是否也初始化</li>
<li><code>getBean(beanName)</code>：<strong>初始化 Bean，获取 Bean 详解此函数</strong></li>
</ul>
<p><code>getBean(beanName)</code>：不是工厂 bean 直接获取</p>
</li>
<li><p><code>for (String beanName : beanNames)</code>：检查所有的 Bean 是否实现 SmartInitializingSingleton 接口，实现了就执行 afterSingletonsInstantiated()，进行一些创建后的操作</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>finishRefresh()</code>：完成刷新后做的一些事情，主要是启动生命周期</p>
<ul>
<li><code>clearResourceCaches()</code>：清空上下文缓存</li>
<li><code>initLifecycleProcessor()</code>：<strong>初始化和生命周期有关的后置处理器</strong>，容器的生命周期<ul>
<li><code>if (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME))</code>：成立说明自定义了生命周期处理器</li>
<li><code>defaultProcessor = new DefaultLifecycleProcessor()</code>：Spring 默认提供的生命周期处理器</li>
<li><code> beanFactory.registerSingleton()</code>：将生命周期处理器注册到 bf 的一级缓存和注册单例集合中</li>
</ul>
</li>
<li><code>getLifecycleProcessor().onRefresh()</code>：获取该**生命周期后置处理器回调 onRefresh()**，调用 <code>startBeans(true)</code><ul>
<li><code>lifecycleBeans = getLifecycleBeans()</code>：获取到所有实现了 Lifecycle 接口的对象包装到 Map 内，key 是beanName， value 是 Lifecycle 对象</li>
<li><code>int phase = getPhase(bean)</code>：获取当前 Lifecycle 的 phase 值，当前生命周期对象可能依赖其他生命周期对象的执行结果，所以需要 phase 决定执行顺序，数值越低的优先执行</li>
<li><code>LifecycleGroup group = phases.get(phase)</code>：把 phsae 相同的 Lifecycle 存入 LifecycleGroup</li>
<li><code>if (group == null)</code>：group 为空则创建，初始情况下是空的</li>
<li><code>group.add(beanName, bean)</code>：将当前 Lifecycle 添加到当前 phase 值一样的 group 内</li>
<li><code>Collections.sort(keys)</code>：<strong>从小到大排序，按优先级启动</strong></li>
<li><code>phases.get(key).start()</code>：遍历所有的 Lifecycle 对象开始启动</li>
<li><code>doStart(this.lifecycleBeans, member.name, this.autoStartupOnly)</code>：底层调用该方法启动<ul>
<li><code>bean = lifecycleBeans.remove(beanName)</code>： 确保 Lifecycle 只被启动一次，在一个分组内被启动了在其他分组内就看不到 Lifecycle 了</li>
<li><code>dependenciesForBean = getBeanFactory().getDependenciesForBean(beanName)</code>：获取当前即将被启动的 Lifecycle 所依赖的其他 beanName，需要<strong>先启动所依赖的 bean</strong>，才能启动自身</li>
<li><code>if ()</code>：传入的参数 autoStartupOnly 为 true 表示启动 isAutoStartUp 为 true 的 SmartLifecycle 对象，不会启动普通的生命周期的对象；false 代表全部启动</li>
<li>bean.start()：<strong>调用启动方法</strong></li>
</ul>
</li>
</ul>
</li>
<li><code>publishEvent(new ContextRefreshedEvent(this))</code>：<strong>发布容器刷新完成事件</strong></li>
<li><code>liveBeansView.registerApplicationContext(this)</code>：暴露 Mbean</li>
</ul>
</li>
</ul>
<p>补充生命周期 stop() 方法的调用</p>
<ul>
<li><p>DefaultLifecycleProcessor.stop()：调用 DefaultLifecycleProcessor.stopBeans()</p>
<ul>
<li><p>获取到所有实现了 Lifecycle 接口的对象并按 phase 数值分组的</p>
</li>
<li><p><code>keys.sort(Collections.reverseOrder())</code>：按 phase 降序排序 Lifecycle 接口，最先启动的最晚关闭（责任链？）</p>
</li>
<li><p><code>phases.get(key).stop()</code>：遍历所有的 Lifecycle 对象开始停止</p>
<ul>
<li><p><code>latch = new CountDownLatch(this.smartMemberCount)</code>：创建 CountDownLatch，设置 latch 内部的值为当前分组内的  smartMemberCount 的数量</p>
</li>
<li><p><code>countDownBeanNames = Collections.synchronizedSet(new LinkedHashSet&lt;&gt;())</code>：保存当前正在处理关闭的smartLifecycle 的 BeanName</p>
</li>
<li><p><code>for (LifecycleGroupMember member : this.members)</code>：处理本分组内需要关闭的 Lifecycle</p>
<p><code>doStop(this.lifecycleBeans, member.name, latch, countDownBeanNames)</code>：真正的停止方法</p>
<ul>
<li><p><code>getBeanFactory().getDependentBeans(beanName)</code>：<strong>获取依赖当前 Lifecycle 的其他对象的 beanName</strong>，因为当前的 Lifecycle 即将要关闭了，所有的依赖了当前 Lifecycle 的 bean 也要关闭</p>
</li>
<li><p><code>countDownBeanNames.add(beanName)</code>：将当前 SmartLifecycle beanName 添加到 countDownBeanNames 集合内，该集合表示正在关闭的 SmartLifecycle</p>
</li>
<li><p><code>bean.stop()</code>：调用停止的方法</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="获取Bean-1"><a href="#获取Bean-1" class="headerlink" title="获取Bean"></a>获取Bean</h4><p>单实例：在容器启动时创建对象</p>
<p>多实例：在每次获取的时候创建对象</p>
<p>获取流程：<strong>获取 Bean 时先从单例池获取，如果没有则进行第二次获取，并带上工厂类去创建并添加至单例池</strong></p>
<p>Java 启动 Spring 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>AbstractBeanFactory.doGetBean()：获取 Bean，context.getBean() 追踪到此</p>
<ul>
<li><p><code>beanName = transformedBeanName(name)</code>：name 可能是一个别名，重定向出来真实 beanName；也可能是一个 &amp; 开头的 name，说明要获取的 bean 实例对象，是一个 FactoryBean 对象（IOC 原理 → 核心类）</p>
<ul>
<li><code>BeanFactoryUtils.transformedBeanName(name)</code>：判断是哪种 name，返回截取 &amp; 以后的 name 并放入缓存<ul>
<li><code>transformedBeanNameCache.computeIfAbsent</code>：缓存是并发安全集合，key &#x3D;&#x3D; null || value &#x3D;&#x3D; null 时 put 成功 </li>
<li>do while 循环一直去除 &amp; 直到不再含有 &amp;</li>
</ul>
</li>
<li><code>canonicalName(name)</code>：aliasMap 保存别名信息，其中的 do while 逻辑是迭代查找，比如 A 别名叫做 B，但是 B 又有别名叫 C， aliasMap 为 {“C”:”B”, “B”:”A”}，get(C) 最后返回的是  A</li>
</ul>
</li>
<li><p><code>DefaultSingletonBeanRegistry.getSingleton()</code>：<strong>第一次获取从缓存池获取</strong>（循环依赖详解此代码）</p>
<ul>
<li>缓存中有数据进行 getObjectForBeanInstance() 获取可使用的 Bean（本节结束部分详解此函数）</li>
<li>缓存中没有数据进行下面的逻辑进行创建</li>
</ul>
</li>
<li><p><code>if(isPrototypeCurrentlyInCreation(beanName))</code>：检查 bean 是否在原型（Prototype）正在被创建的集合中，如果是就报错，说明产生了循环依赖，<strong>原型模式解决不了循环依赖</strong></p>
<p>原因：先加载 A，把 A 加入集合，A 依赖 B 去加载 B，B 又依赖 A，去加载 A，发现 A 在正在创建集合中，产生循环依赖</p>
</li>
<li><p><code>markBeanAsCreated(beanName)</code>：把 bean 标记为已经创建，<strong>防止其他线程重新创建 Bean</strong></p>
</li>
<li><p><code>mbd = getMergedLocalBeanDefinition(beanName)</code>：<strong>获取合并父 BD 后的 BD 对象</strong>，BD 是直接继承的，合并后的 BD 信息是包含父类的 BD 信息</p>
<ul>
<li><p><code>this.mergedBeanDefinitions.get(beanName)</code>：从缓存中获取</p>
</li>
<li><p><code>if(bd.getParentName()==null)</code>：beanName 对应 BD 没有父 BD 就不用处理继承，封装为 RootBeanDefinition 返回</p>
</li>
<li><p><code>parentBeanName = transformedBeanName(bd.getParentName())</code>：处理父 BD 的 name 信息</p>
</li>
<li><p><code>if(!beanName.equals(parentBeanName))</code>：一般情况父子 BD 的名称不同</p>
<p><code>pbd = getMergedBeanDefinition(parentBeanName)</code>：递归调用，最终返回父 BD 的父 BD 信息</p>
</li>
<li><p><code>mbd = new RootBeanDefinition(pbd)</code>：按照父 BD 信息创建 RootBeanDefinition 对象</p>
</li>
<li><p><code>mbd.overrideFrom(bd)</code>：<strong>子 BD 信息覆盖 mbd</strong>，因为是要以子 BD 为基准，不存在的才去父 BD 寻找（<strong>类似 Java 继承</strong>）</p>
</li>
<li><p><code>this.mergedBeanDefinitions.put(beanName, mbd)</code>：放入缓存</p>
</li>
</ul>
</li>
<li><p><code>checkMergedBeanDefinition()</code>：判断当前 BD 是否为<strong>抽象 BD</strong>，抽象 BD 不能创建实例，只能作为父 BD 被继承</p>
</li>
<li><p><code>mbd.getDependsOn()</code>：获取 bean 标签 depends-on</p>
</li>
<li><p><code>if(dependsOn != null)</code>：<strong>遍历所有的依赖加载，解决不了循环依赖</strong></p>
<p><code>isDependent(beanName, dep)</code>：判断循环依赖，出现循环依赖问题报错</p>
<ul>
<li><p>两个 Map：<code>&lt;bean name=&quot;A&quot; depends-on=&quot;B&quot; ...&gt;</code></p>
<ul>
<li>dependentBeanMap：记录依赖了当前 beanName 的其他 beanName（谁依赖我，我记录谁）</li>
<li>dependenciesForBeanMap：记录当前 beanName 依赖的其它 beanName </li>
<li>以 B 为视角 dependentBeanMap {“B”：{“A”}}，以 A 为视角 dependenciesForBeanMap {“A” :{“B”}}</li>
</ul>
</li>
<li><p><code>canonicalName(beanName)</code>：处理 bean 的 name</p>
</li>
<li><p><code>dependentBeans = this.dependentBeanMap.get(canonicalName)</code>：获取依赖了当前 bean 的 name</p>
</li>
<li><p><code>if (dependentBeans.contains(dependentBeanName))</code>：依赖了当前 bean 的集合中是否有该 name，有就产生循环依赖</p>
</li>
<li><p>进行递归处理所有的引用：假如 <code>&lt;bean name=&quot;A&quot; dp=&quot;B&quot;&gt; &lt;bean name=&quot;B&quot; dp=&quot;C&quot;&gt; &lt;bean name=&quot;C&quot; dp=&quot;A&quot;&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dependentBeanMap=&#123;A:&#123;C&#125;, B:&#123;A&#125;, C:&#123;B&#125;&#125; </span><br><span class="line"><span class="comment">// C 依赖 A     		判断谁依赖了C				递归判断				谁依赖了B</span></span><br><span class="line">isDependent(C, A)  → C#dependentBeans=&#123;B&#125; → isDependent(B, A); → B#dependentBeans=&#123;A&#125; <span class="comment">//返回true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>registerDependentBean(dep, beanName)</code>：把 bean 和依赖注册到两个 Map 中，注意参数的位置，被依赖的在前</p>
<p><code>getBean(dep)</code>：<strong>先加载依赖的 Bean</strong>，又进入 doGetBean() 的逻辑</p>
</li>
<li><p><code>if (mbd.isSingleton())</code>：<strong>判断 bean 是否是单例的 bean</strong></p>
<p><code>getSingleton(String, ObjectFactory&lt;?&gt;)</code>：<strong>第二次获取，传入一个工厂对象</strong>，这个方法更倾向于创建实例并返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> createBean(beanName, mbd, args);<span class="comment">//创建，跳转生命周期</span></span><br><span class="line">    <span class="comment">//lambda表达式，调用了ObjectFactory的getObject()方法，实际回调接口实现的是 createBean()方法进行创建对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>singletonObjects.get(beanName)</code>：从一级缓存检查是否已经被加载，单例模式复用已经创建的 bean</p>
</li>
<li><p><code>this.singletonsCurrentlyInDestruction</code>：容器销毁时会设置这个属性为 true，这时就不能再创建 bean 实例了</p>
</li>
<li><p><code>beforeSingletonCreation(beanName)</code>：检查构造注入的依赖，<strong>构造参数注入产生的循环依赖无法解决</strong></p>
<p><code>!this.singletonsCurrentlyInCreation.add(beanName)</code>：将当前 beanName 放入到正在创建中单实例集合，放入成功说明没有产生循环依赖，失败则产生循环依赖，进入判断条件内的逻辑抛出异常</p>
<p>原因：加载 A，向正在创建集合中添加了 {A}，根据 A 的构造方法实例化 A 对象，发现 A 的构造方法依赖 B，然后加载 B，B 构造方法的参数依赖于 A，又去加载 A 时来到当前方法，因为创建中集合已经存在 A，所以添加失败</p>
</li>
<li><p><code>singletonObject = singletonFactory.getObject()</code>：<strong>创建 bean</strong>（生命周期部分详解）</p>
</li>
<li><p><strong>创建完成以后，Bean 已经初始化好，是一个完整的可使用的 Bean</strong></p>
</li>
<li><p><code>afterSingletonCreation(beanName)</code>：从正在创建中的集合中移出</p>
</li>
<li><p><code>addSingleton(beanName, singletonObject)</code>：<strong>添加一级缓存单例池中，从二级三级缓存移除</strong></p>
</li>
</ul>
<p><code>bean = getObjectForBeanInstance</code>：<strong>单实例可能是普通单实例或者 FactoryBean</strong>，如果是 FactoryBean 实例，需要判断 name 是带 &amp; 还是不带 &amp;，带 &amp; 说明 getBean 获取 FactoryBean 对象，否则是获取 FactoryBean 内部管理的实例</p>
<ul>
<li><p>参数 name 是未处理 &amp; 的 name，beanName 是处理过 &amp; 和别名后的 name</p>
</li>
<li><p><code>if(BeanFactoryUtils.isFactoryDereference(name))</code>：判断 doGetBean 中参数 name 前是否带 &amp;，不是处理后的</p>
</li>
<li><p><code>if(!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name))</code>：Bean 是普通单实例或者是 FactoryBean 就可以直接返回，否则进入下面的获取 <strong>FactoryBean 内部管理的实例</strong>的逻辑</p>
</li>
<li><p><code>getCachedObjectForFactoryBean(beanName)</code>：尝试到缓存获取，获取到直接返回，获取不到进行下面逻辑</p>
</li>
<li><p><code>if (mbd == null &amp;&amp; containsBeanDefinition(beanName))</code>：Spring 中有当前 beanName 的 BeanDefinition 信息</p>
<p><code>mbd = getMergedLocalBeanDefinition(beanName)</code>：获取合并后的 BeanDefinition</p>
</li>
<li><p><code>mbd.isSynthetic()</code>：默认值是 false 表示这是一个用户对象，如果是 true 表示是系统对象</p>
</li>
<li><p><code>object = getObjectFromFactoryBean(factory, beanName, !synthetic)</code>：从工厂内获取实例</p>
<ul>
<li><code>factory.isSingleton() &amp;&amp; containsSingleton(beanName)</code>：工厂内部维护的对象是单实例并且一级缓存存在该 bean</li>
<li>首先去缓存中获取，获取不到就<strong>使用工厂获取</strong>然后放入缓存，进行循环依赖判断</li>
</ul>
</li>
</ul>
</li>
<li><p><code>else if (mbd.isPrototype())</code>：<strong>bean 是原型的 bean</strong></p>
<p><code>beforePrototypeCreation(beanName)</code>：当前线程正在创建的原型对象 beanName 存入 prototypesCurrentlyInCreation</p>
<ul>
<li><code>curVal = this.prototypesCurrentlyInCreation.get()</code>：获取当前线程的正在创建的原型类集合</li>
<li><code>this.prototypesCurrentlyInCreation.set(beanName)</code>：集合为空就把当前 beanName 加入</li>
<li><code>if (curVal instanceof String)</code>：已经有线程相关原型类创建了，把当前的创建的加进去</li>
</ul>
<p><code>createBean(beanName, mbd, args)</code>：创建原型类对象，不需要三级缓存</p>
<p><code>afterPrototypeCreation(beanName)</code>：从正在创建中的集合中移除该 beanName， <strong>与 beforePrototypeCreation逻辑相反</strong></p>
</li>
<li><p><code>convertIfNecessary()</code>：<strong>依赖检查</strong>，检查所需的类型是否与实际 bean 实例的类型匹配</p>
</li>
<li><p><code>return (T) bean</code>：返回创建完成的 bean</p>
</li>
</ul>
<hr>
<h4 id="生命周期-2"><a href="#生命周期-2" class="headerlink" title="生命周期"></a>生命周期</h4><h5 id="四个阶段"><a href="#四个阶段" class="headerlink" title="四个阶段"></a>四个阶段</h5><p>Bean 的生命周期：实例化 instantiation，填充属性 populate，初始化 initialization，销毁 destruction</p>
<p>AbstractAutowireCapableBeanFactory.createBean()：进入 Bean 生命周期的流程</p>
<ul>
<li><p><code>resolvedClass = resolveBeanClass(mbd, beanName)</code>：判断 mdb 中的 class 是否已经<strong>加载到 JVM</strong>，如果未加载则使用类加载器将 beanName 加载到 JVM中并返回 class 对象</p>
</li>
<li><p><code>if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null)</code>：条件成立封装 mbd 并把 resolveBeanClass 设置到 bd 中</p>
<ul>
<li>条件二：mbd 在 resolveBeanClass 之前是否有 class</li>
<li>条件三：mbd 有 className</li>
</ul>
</li>
<li><p><code>bean = resolveBeforeInstantiation(beanName, mbdToUse)</code>：实例化前的后置处理器返回一个代理实例对象（不是 AOP）</p>
<ul>
<li>自定义类继承 InstantiationAwareBeanPostProcessor，重写 postProcessBeforeInstantiation 方法，<strong>方法逻辑为创建对象</strong> </li>
<li>并配置文件 <code>&lt;bean class=&quot;intefacePackage.MyInstantiationAwareBeanPostProcessor&quot;&gt;</code> 导入为 bean</li>
<li>条件成立，<strong>短路操作</strong>，直接 return bean</li>
</ul>
</li>
<li><p><code>Object beanInstance = doCreateBean(beanName, mbdToUse, args)</code>：Do it</p>
</li>
</ul>
<p>AbstractAutowireCapableBeanFactory.<strong>doCreateBean</strong>(beanName, RootBeanDefinition, Object[] args)：创建 Bean</p>
<ul>
<li><p><code>BeanWrapper instanceWrapper = null</code>：<strong>Spring 给所有创建的 Bean 实例包装成 BeanWrapper</strong>，内部最核心的方法是获取实例，提供了一些额外的接口方法，比如属性访问器</p>
</li>
<li><p><code>instanceWrapper = this.factoryBeanInstanceCache.remove(beanName)</code>：单例对象尝试从缓存中获取，会移除缓存</p>
</li>
<li><p><code>createBeanInstance()</code>：<strong>缓存中没有实例就进行创建实例</strong>（逻辑复杂，下一小节详解）</p>
</li>
<li><p><code>if (!mbd.postProcessed)</code>：每个 bean 只进行一次该逻辑</p>
<p><code>applyMergedBeanDefinitionPostProcessors()</code>：<strong>后置处理器，合并 bd 信息</strong>，接下来要属性填充了</p>
<p><code>AutowiredAnnotationBeanPostProcessor.postProcessMergedBeanDefinition()</code>：<strong>后置处理逻辑（@Autowired）</strong></p>
<ul>
<li><p><code>metadata = findAutowiringMetadata(beanName, beanType, null)</code>：提取当前 bean 整个继承体系内的 <strong>@Autowired、@Value、@Inject</strong> 信息，存入一个 InjectionMetadata 对象，保存着当前 bean 信息和要自动注入的字段信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; targetClass;							<span class="comment">//当前 bean </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;InjectedElement&gt; injectedElements;	<span class="comment">//要注入的信息集合</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>metadata = buildAutowiringMetadata(clazz)</code>：查询当前 clazz 感兴趣的注解信息</p>
<ul>
<li><p><code>ReflectionUtils.doWithLocalFields()</code>：提取<strong>字段</strong>的注解的信息</p>
<p><code>findAutowiredAnnotation(field)</code>：代表感兴趣的注解就是那三种注解，获取这三种注解的元数据</p>
</li>
<li><p><code>ReflectionUtils.doWithLocalMethods()</code>：提取<strong>方法</strong>的注解的信息</p>
</li>
<li><p><code>do&#123;&#125; while (targetClass != null &amp;&amp; targetClass != Object.class)</code>：循环从父类中解析，直到 Object 类</p>
</li>
</ul>
</li>
<li><p><code>this.injectionMetadataCache.put(cacheKey, metadata)</code>：存入缓存</p>
</li>
</ul>
</li>
</ul>
<p><code>mbd.postProcessed = true</code>：设置为 true，下次访问该逻辑不会再进入</p>
</li>
<li><p><code>earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)</code>：单例、解决循环引用、是否在单例正在创建集合中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="comment">// 【放入三级缓存一个工厂对象，用来获取提前引用】</span></span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    <span class="comment">// lamda 表达式，用来获取提前引用，循环依赖部分详解该逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
<li><p><code> populateBean(beanName, mbd, instanceWrapper)</code>：**属性填充，依赖注入，整体逻辑是先处理标签再处理注解，填充至 pvs 中，最后通过 apply 方法最后完成属性依赖注入到 BeanWrapper **</p>
<ul>
<li><p><code>if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName))</code>：实例化后的后置处理器，默认返回 true，可以自定义类继承 InstantiationAwareBeanPostProcessor 修改后置处理方法的返回值为 false，使 continueWithPropertyPopulation 为 false，<strong>会导致直接返回，不进行属性的注入</strong></p>
</li>
<li><p><code>if (!continueWithPropertyPopulation)</code>：自定义方法返回值会造成该条件成立，逻辑为直接返回，<strong>不进行依赖注入</strong></p>
</li>
<li><p><code>PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null)</code>：处理依赖注入逻辑开始</p>
</li>
<li><p><code>mbd.getResolvedAutowireMode() == ?</code>：<strong>根据 bean 标签配置的 autowire</strong> 判断是 BY_NAME 或者 BY_TYPE</p>
<p><code>autowireByName(beanName, mbd, bw, newPvs)</code>：根据字段名称去获取依赖的 bean，还没注入，只是添加到 pvs</p>
<ul>
<li><p><code>propertyNames = unsatisfiedNonSimpleProperties(mbd, bw)</code>：bean 实例中有该字段和该字段的 setter 方法，但是在 bd 中没有 property 属性</p>
<ul>
<li><p>拿到配置的 property 信息和 bean 的所有字段信息</p>
</li>
<li><p><code>pd.getWriteMethod() != null</code>：<strong>当前字段是否有 set 方法，配置类注入的方式需要 set 方法</strong></p>
<p><code>!isExcludedFromDependencyCheck(pd)</code>：当前字段类型是否在忽略自动注入的列表中</p>
<p><code>!pvs.contains(pd.getName()</code>：当前字段不在 xml 或者其他方式的配置中，也就是 bd 中不存在对应的 property</p>
<p><code>!BeanUtils.isSimpleProperty(pd.getPropertyType()</code>：是否是基本数据类型和内置的几种数据类型，基本数据类型不允许自动注入</p>
</li>
</ul>
</li>
<li><p><code>if (containsBean(propertyName))</code>：BeanFactory 中存在当前 property 的 bean 实例，说明找到对应的依赖数据</p>
</li>
<li><p><code>getBean(propertyName)</code>：<strong>拿到 propertyName 对应的 bean 实例</strong></p>
</li>
<li><p><code>pvs.add(propertyName, bean)</code>：填充到 pvs 中</p>
</li>
<li><p><code>registerDependentBean(propertyName, beanName))</code>：添加到两个依赖 Map（dependsOn）中</p>
</li>
</ul>
<p><code>autowireByType(beanName, mbd, bw, newPvs)</code>：根据字段类型去查找依赖的 bean</p>
<ul>
<li><code>desc = new AutowireByTypeDependencyDescriptor(methodParam, eager)</code>：依赖描述信息</li>
<li><code>resolveDependency(desc, beanName, autowiredBeanNames, converter)</code>：根据描述信息，查找依赖对象，容器中没有对应的实例但是有对应的 BD，会调用 getBean(Type) 获取对象</li>
</ul>
<p><code>pvs = newPvs</code>：newPvs 是处理了依赖数据后的 pvs，所以赋值给 pvs</p>
</li>
<li><p><code>hasInstAwareBpps</code>：表示当前是否有 InstantiationAwareBeanPostProcessors 的后置处理器（Autowired）</p>
</li>
<li><p><code>pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName)</code>：**@Autowired 注解的注入**，这个传入的 pvs 对象，最后原封不动的返回，不会添加东西</p>
<ul>
<li><p><code>findAutowiringMetadata()</code>：包装着当前 bd 需要注入的注解信息集合，<strong>三种注解的元数据</strong>，直接缓存获取</p>
</li>
<li><p><code>InjectionMetadata.InjectedElement.inject()</code>：遍历注解信息解析后注入到 Bean，方法和字段的注入实现不同</p>
<p>以字段注入为例：</p>
<ul>
<li><p><code>value = resolveFieldValue(field, bean, beanName)</code>：处理字段属性值</p>
<p><code>value = beanFactory.resolveDependency()</code>：解决依赖</p>
<p><code>result = doResolveDependency()</code>：<strong>真正处理自动注入依赖的逻辑</strong></p>
<ul>
<li><p><code>Object shortcut = descriptor.resolveShortcut(this)</code>：默认返回 null</p>
</li>
<li><p><code>Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor)</code>：<strong>获取 @Value 的值</strong></p>
</li>
<li><p><code>converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor())</code>：如果 value 不是 null，就直接进行类型转换返回数据</p>
</li>
<li><p><code>matchingBeans = findAutowireCandidates(beanName, type, descriptor)</code>：如果 value 是空说明字段是引用类型，<strong>获取 @Autowired 的 Bean</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// addCandidateEntry() → Object beanInstance = descriptor.resolveCandidate()</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveCandidate</span><span class="params">(String beanName, Class&lt;?&gt; requiredType, BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	<span class="comment">// 获取 bean</span></span><br><span class="line">    <span class="keyword">return</span> beanFactory.getBean(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>ReflectionUtils.makeAccessible(field)</code>：修改访问权限</p>
</li>
<li><p><code>field.set(bean, value)</code>：获取属性访问器为此 field 对象赋值</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>applyPropertyValues()</code>：<strong>将所有解析的 PropertyValues 的注入至 BeanWrapper 实例中</strong>（深拷贝）</p>
<ul>
<li><code>if (pvs.isEmpty())</code>：注解 @Autowired 和 @Value 标注的信息在后置处理的逻辑注入完成，此处为空直接返回</li>
<li>下面的逻辑进行 XML 配置的属性的注入，首先获取转换器进行数据转换，然后<strong>获取 WriteMethod (set) 方法进行反射调用</strong>，完成属性的注入</li>
</ul>
</li>
</ul>
</li>
<li><p><code>initializeBean(String,Object,RootBeanDefinition)</code>：<strong>初始化，分为配置文件和实现接口两种方式</strong></p>
<ul>
<li><p><code>invokeAwareMethods(beanName, bean)</code>：根据 bean 是否实现 Aware 接口执行初始化的方法</p>
</li>
<li><p><code>wrappedBean = applyBeanPostProcessorsBeforeInitialization</code>：初始化前的后置处理器，可以继承接口重写方法</p>
<ul>
<li><code>processor.postProcessBeforeInitialization()</code>：执行后置处理的方法，默认返回 bean 本身</li>
<li><code>if (current == null) return result</code>：重写方法返回 null，会造成后置处理的短路，直接返回</li>
</ul>
</li>
<li><p><code>invokeInitMethods(beanName, wrappedBean, mbd)</code>：<strong>反射执行初始化方法</strong></p>
<ul>
<li><p><code>isInitializingBean = (bean instanceof InitializingBean)</code>：初始化方法的定义有两种方式，一种是自定义类实现 InitializingBean 接口，另一种是配置文件配置 &lt;bean id&#x3D;”…” class&#x3D;”…” init-method&#x3D;”init”&#x2F; &gt;</p>
</li>
<li><p><code>isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))</code>：</p>
<ul>
<li><p>条件一：当前 bean 是不是实现了 InitializingBean </p>
</li>
<li><p>条件二：InitializingBean 接口中的方法 afterPropertiesSet，判断该方法是否是容器外管理的方法</p>
</li>
</ul>
</li>
<li><p><code>if (mbd != null &amp;&amp; bean.getClass() != NullBean.class)</code>：成立说明是配置文件的方式</p>
<p><code>if(!(接口条件))</code>表示<strong>如果通过接口实现了初始化方法的话，就不会在调用配置类中 init-method 定义的方法</strong></p>
<p><code>((InitializingBean) bean).afterPropertiesSet()</code>：调用方法</p>
<p><code>invokeCustomInitMethod</code>：执行自定义的方法</p>
<ul>
<li><code>initMethodName = mbd.getInitMethodName()</code>：获取方法名</li>
<li><code>Method initMethod = ()</code>：根据方法名获取到 init-method 方法</li>
<li><code> methodToInvoke = ClassUtils.getInterfaceMethodIfPossible(initMethod)</code>：将方法转成从接口层面获取</li>
<li><code>ReflectionUtils.makeAccessible(methodToInvoke)</code>：访问权限设置成可访问</li>
<li><code> methodToInvoke.invoke(bean)</code>：<strong>反射调用初始化方法</strong>，以当前 bean 为角度去调用</li>
</ul>
</li>
</ul>
</li>
<li><p><code>wrappedBean = applyBeanPostProcessorsAfterInitialization</code>：初始化后的后置处理器</p>
<ul>
<li><p><code>AbstractAutoProxyCreator.postProcessAfterInitialization()</code>：如果 Bean 被子类标识为要代理的 bean，则使用配置的拦截器<strong>创建代理对象</strong>，AOP 部分详解</p>
</li>
<li><p>如果不存在循环依赖，创建动态代理 bean 在此处完成；否则真正的创建阶段是在属性填充时获取提前引用的阶段，<strong>循环依赖</strong>详解，源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该集合用来避免重复将某个 bean 生成代理对象，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; earlyProxyReferences = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean,String bN)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// cacheKey 是 beanName 或者加上 &amp;</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);y</span><br><span class="line">            <span class="title function_">if</span> <span class="params">(<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey)</span> != bean) &#123;</span><br><span class="line">                <span class="comment">// 去提前代理引用池中寻找该key，不存在则创建代理</span></span><br><span class="line">                <span class="comment">// 如果存在则证明被代理过，则判断是否是当前的 bean，不是则创建代理</span></span><br><span class="line">                <span class="keyword">return</span> wrapIfNecessary(bean, bN, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><code>if (earlySingletonExposure)</code>：是否允许提前引用</p>
<p><code>earlySingletonReference = getSingleton(beanName, false)</code>：<strong>从二级缓存获取实例</strong>，放入一级缓存是在 doGetBean 中的sharedInstance &#x3D; getSingleton() 逻辑中，此时在 createBean 的逻辑还没有返回，所以一级缓存没有</p>
<p><code>if (earlySingletonReference != null)</code>：当前 bean 实例从二级缓存中获取到了，说明<strong>产生了循环依赖</strong>，在属性填充阶段会提前调用三级缓存中的工厂生成 Bean 的代理对象（或原始实例），放入二级缓存中，然后使用原始 bean 继续执行初始化</p>
<ul>
<li><p><code> if (exposedObject == bean)</code>：<strong>初始化后的 bean &#x3D;&#x3D; 创建的原始实例</strong>，条件成立的两种情况：当前的真实实例不需要被代理；当前实例存在循环依赖已经被提前代理过了，初始化时的后置处理器直接返回 bean 原实例</p>
<p><code>exposedObject = earlySingletonReference</code>：<strong>把代理后的 Bean 传给 exposedObject 用来返回，因为只有代理对象才封装了拦截器链，main 方法中用代理对象调用方法时会进行增强，代理是对原始对象的包装，所以这里返回的代理对象中含有完整的原实例（属性填充和初始化后的），是一个完整的代理对象，返回后外层方法会将当前 Bean 放入一级缓存</strong></p>
</li>
<li><p><code>else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName))</code>：是否有其他 bean 依赖当前 bean，执行到这里说明是不存在循环依赖、存在增强代理的逻辑，也就是正常的逻辑</p>
<ul>
<li><p><code>dependentBeans = getDependentBeans(beanName)</code>：取到依赖当前 bean 的其他 beanName</p>
</li>
<li><p><code>if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean))</code>：判断 dependentBean 是否创建完成</p>
<ul>
<li><code>if (!this.alreadyCreated.contains(beanName))</code>：成立当前 bean 尚未创建完成，当前 bean 是依赖exposedObject 的 bean，返回 true</li>
</ul>
</li>
<li><p><code>return false</code>：创建完成返回 false</p>
<p><code>actualDependentBeans.add(dependentBean)</code>：创建完成的 dependentBean 加入该集合</p>
</li>
<li><p><code>if (!actualDependentBeans.isEmpty())</code>：条件成立说明有依赖于当前 bean 的 bean 实例创建完成，但是当前的 bean 还没创建完成返回，依赖当前 bean 的外部 bean 持有的是不完整的 bean，所以需要报错</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>registerDisposableBeanIfNecessary</code>：判断当前 bean 是否需要<strong>注册析构函数回调</strong>，当容器销毁时进行回调</p>
<ul>
<li><p><code>if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd))</code></p>
<ul>
<li><p>如果是原型 prototype 不会注册析构回调，不会回调该函数，对象的回收由 JVM 的 GC 机制完成</p>
</li>
<li><p>requiresDestruction()：</p>
<ul>
<li><p><code>DisposableBeanAdapter.hasDestroyMethod(bean, mbd)</code>：bd 中定义了 DestroyMethod 返回 true</p>
</li>
<li><p><code>hasDestructionAwareBeanPostProcessors()</code>：后处理器框架决定是否进行析构回调</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>registerDisposableBean()</code>：条件成立进入该方法，给当前单实例注册回调适配器，适配器内根据当前 bean 实例是继承接口（DisposableBean）还是自定义标签来判定具体调用哪个方法实现</p>
</li>
</ul>
</li>
<li><p><code>this.disposableBeans.put(beanName, bean)</code>：向销毁集合添加实例</p>
</li>
</ul>
<hr>
<h5 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h5><p>AbstractAutowireCapableBeanFactory.createBeanInstance(beanName, RootBeanDefinition, Object[] args)</p>
<ul>
<li><p><code>resolveBeanClass(mbd, beanName)</code>：确保 Bean 的 Class 真正的被加载</p>
</li>
<li><p>判断类的访问权限是不是 public，不是进入下一个判断，是否允许访问类的 non-public 的构造方法，不允许则报错</p>
</li>
<li><p><code>Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier()</code>：获取创建实例的函数，可以自定义，没有进入下面的逻辑</p>
</li>
<li><p><code>if (mbd.getFactoryMethodName() != null)</code>：<strong>判断 bean 是否设置了 factory-method 属性，优先使用</strong></p>
<p><bean class factory-method>，设置了该属性进入 factory-method 方法创建实例</bean></p>
</li>
<li><p><code>resolved = false</code>：代表 bd 对应的构造信息是否已经解析成可以反射调用的构造方法</p>
</li>
<li><p><code>autowireNecessary = false</code>：是否自动匹配构造方法</p>
</li>
<li><p><code>if(mbd.resolvedConstructorOrFactoryMethod != null)</code>：获取 bd 的构造信息转化成反射调用的 method 信息</p>
<ul>
<li>method 为 null 则 resolved 和 autowireNecessary 都为默认值 false</li>
<li><code>autowireNecessary = mbd.constructorArgumentsResolved</code>：构造方法有参数，设置为 true</li>
</ul>
</li>
<li><p><strong>bd 对应的构造信息解析完成，可以直接反射调用构造方法了</strong>：</p>
<ul>
<li><p><code>return autowireConstructor(beanName, mbd, null, null)</code>：<strong>有参构造</strong>，根据参数匹配最优的构造器创建实例</p>
</li>
<li><p><code>return instantiateBean(beanName, mbd)</code>：<strong>无参构造方法通过反射创建实例</strong></p>
<ul>
<li><p><code>SimpleInstantiationStrategy.instantiate()</code>：<strong>真正用来实例化的函数</strong>（无论如何都会走到这一步）</p>
<ul>
<li><p><code>if (!bd.hasMethodOverrides())</code>：没有方法重写覆盖</p>
<p><code>BeanUtils.instantiateClass(constructorToUse)</code>：调用 <code>Constructor.newInstance()</code> 实例化</p>
</li>
<li><p><code>instantiateWithMethodInjection(bd, beanName, owner)</code>：<strong>有方法重写采用 CGLIB  实例化</strong></p>
</li>
</ul>
</li>
<li><p><code>BeanWrapper bw = new BeanWrapperImpl(beanInstance)</code>：包装成 BeanWrapper 类型的对象</p>
</li>
<li><p><code>return bw</code>：返回实例</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName)</code>：**@Autowired 注解**，对应的后置处理器 AutowiredAnnotationBeanPostProcessor 逻辑</p>
<ul>
<li><p>配置了 lookup 的相关逻辑</p>
</li>
<li><p><code>this.candidateConstructorsCache.get(beanClass)</code>：从缓存中获取构造方法，第一次获取为 null，进入下面逻辑</p>
</li>
<li><p><code>rawCandidates = beanClass.getDeclaredConstructors()</code>：获取所有的构造器</p>
</li>
<li><p><code>Constructor&lt;?&gt; requiredConstructor = null</code>：唯一的选项构造器，**@Autowired(required &#x3D; “true”)** 时有值</p>
</li>
<li><p><code>for (Constructor&lt;?&gt; candidate : rawCandidates)</code>：遍历所有的构造器：</p>
<p><code>ann = findAutowiredAnnotation(candidate)</code>：有三种注解中的一个会返回注解的属性</p>
<ul>
<li><p>遍历 this.autowiredAnnotationTypes 中的三种注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.autowiredAnnotationTypes.add(Autowired.class);<span class="comment">//！！！！！！！！！！！！！！</span></span><br><span class="line"><span class="built_in">this</span>.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line"><span class="built_in">this</span>.autowiredAnnotationTypes.add(...ClassUtils.forName(<span class="string">&quot;javax.inject.Inject&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p><code> AnnotatedElementUtils.getMergedAnnotationAttributes(ao, type)</code>：获取注解的属性</p>
</li>
<li><p><code>if (attributes != null) return attributes</code>：任意一个注解属性不为空就注解返回</p>
</li>
</ul>
<p><code>if (ann == null)</code>：注解属性为空</p>
<ul>
<li><code>userClass = ClassUtils.getUserClass(beanClass)</code>：如果当前 beanClass 是代理对象，方法上就已经没有注解了，所以<strong>获取原始的用户类型重新获取该构造器上的注解属性</strong>（<strong>事务注解失效</strong>也是这个原理）</li>
</ul>
<p><code>if (ann != null)</code>：注解属性不为空了</p>
<ul>
<li><p><code>required = determineRequiredStatus(ann)</code>：获取 required 属性的值</p>
<ul>
<li><code>!ann.containsKey(this.requiredParameterName) || </code>：判断属性是否包含 required，不包含进入后面逻辑</li>
<li><code>this.requiredParameterValue == ann.getBoolean(this.requiredParameterName)</code>：获取属性值返回</li>
</ul>
</li>
<li><p><code>if (required)</code>：代表注解 @Autowired(required &#x3D; true)</p>
<p><code>if (!candidates.isEmpty())</code>：true 代表只能有一个构造方法，构造集合不是空代表可选的构造器不唯一，报错</p>
<p><code>requiredConstructor = candidate</code>：把构造器赋值给 requiredConstructor</p>
</li>
<li><p><code>candidates.add(candidate)</code>：把当前构造方法添加至 candidates 集合</p>
</li>
</ul>
<p><code> if(candidate.getParameterCount() == 0)</code>：当前遍历的构造器的参数为 0 代表没有参数，是<strong>默认构造器</strong>，赋值给 defaultConstructor </p>
</li>
<li><p><code>candidateConstructors = candidates.toArray(new Constructor&lt;?&gt;[0])</code>：<strong>将构造器转成数组返回</strong></p>
</li>
</ul>
</li>
<li><p><code>if(ctors != null)</code>：条件成立代表指定了<strong>构造方法数组</strong></p>
<p><code>mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR</code>：<bean autowire> 标签内 autowiremode 的属性值，默认是 no，AUTOWIRE_CONSTRUCTOR 代表选择最优的构造方法</bean></p>
<p><code>mbd.hasConstructorArgumentValues()</code>：bean 信息中是否配置了构造参数的值</p>
<p><code>!ObjectUtils.isEmpty(args)</code>：getBean 时，指定了参数 arg</p>
</li>
<li><p><code>return autowireConstructor(beanName, mbd, ctors, args)</code>：<strong>选择最优的构造器进行创建实例</strong>（复杂，不建议研究）</p>
<ul>
<li><p><code>beanFactory.initBeanWrapper(bw)</code>：向 BeanWrapper 中注册转换器，向工厂中注册属性编辑器</p>
</li>
<li><p><code>Constructor&lt;?&gt; constructorToUse = null</code>：实例化反射构造器</p>
<p><code>ArgumentsHolder argsHolderToUse</code>：实例化时真正去用的参数，并持有对象</p>
<ul>
<li>rawArguments 是转换前的参数，arguments 是类型转换完成的参数</li>
</ul>
<p><code>Object[] argsToUse</code>：参数实例化时使用的参数</p>
</li>
<li><p><code>Object[] argsToResolve</code>：表示构造器参数做转换后的参数引用</p>
</li>
<li><p><code>if (constructorToUse != null &amp;&amp; mbd.constructorArgumentsResolved)</code>：</p>
<ul>
<li>条件一成立说明当前 bd 生成的实例不是第一次，缓存中有解析好的构造器方法可以直接拿来反射调用</li>
<li>条件二成立说明构造器参数已经解析过了</li>
</ul>
</li>
<li><p><code>argsToUse = resolvePreparedArguments()</code>：argsToResolve 不是完全解析好的，还需要继续解析</p>
</li>
<li><p><code>if (constructorToUse == null || argsToUse == null)</code>：条件成立说明缓存机制失败，进入构造器匹配逻辑</p>
</li>
<li><p><code>Constructor&lt;?&gt;[] candidates = chosenCtors</code>：chosenCtors  只有在构造方法上有 autowaire 三种注解时才有数据</p>
</li>
<li><p><code>if (candidates == null)</code>：candidates 为空就根据 beanClass 是否允许访问非公开的方法来获取构造方法</p>
</li>
<li><p><code>if (candidates.length == 1 &amp;&amp; explicitArgs == null &amp;&amp; !mbd.hasConstructorArgumentValues())</code>：默认无参</p>
<p><code>bw.setBeanInstance(instantiate())</code>：<strong>使用无参构造器反射调用，创建出实例对象，设置到 BeanWrapper 中去</strong></p>
</li>
<li><p><code>boolean autowiring</code>：<strong>需要选择最优的构造器</strong></p>
</li>
<li><p><code>cargs = mbd.getConstructorArgumentValues()</code>：获取参数值</p>
<p><code>resolvedValues = new ConstructorArgumentValues()</code>：获取已经解析后的构造器参数值</p>
<ul>
<li><code>final Map&lt;Integer, ValueHolder&gt; indexedArgumentValues</code>：key 是 index， value 是值</li>
<li><code>final List&lt;ValueHolder&gt; genericArgumentValues</code>：没有 index 的值</li>
</ul>
<p><code>minNrOfArgs = resolveConstructorArguments(..,resolvedValues)</code>：从 bd 中解析并获取构造器参数的个数</p>
<ul>
<li><code>valueResolver.resolveValueIfNecessary()</code>：将引用转换成真实的对象</li>
<li><code>resolvedValueHolder.setSource(valueHolder)</code>：将对象填充至 ValueHolder 中</li>
<li><code> resolvedValues.addIndexedArgumentValue()</code>：将参数值封装至 resolvedValues 中</li>
</ul>
</li>
<li><p><code>AutowireUtils.sortConstructors(candidates)</code>：排序规则 public &gt; 非公开的 &gt; 参数多的 &gt; 参数少的</p>
</li>
<li><p><code> int minTypeDiffWeight = Integer.MAX_VALUE</code>：值越低说明构造器<strong>参数列表类型</strong>和构造参数的匹配度越高</p>
</li>
<li><p><code>Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors</code>：模棱两可的构造器，两个构造器匹配度相等时放入</p>
</li>
<li><p><code>for (Constructor&lt;?&gt; candidate : candidates)</code>：遍历筛选出 minTypeDiffWeight 最低的构造器</p>
</li>
<li><p><code>Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes()</code>：获取当前处理的构造器的参数类型</p>
</li>
<li><p><code>if()</code>：candidates 是排过序的，当前筛选出来的构造器的优先级一定是优先于后面的 constructor</p>
</li>
<li><p><code>if (paramTypes.length &lt; minNrOfArgs)</code>：需求的小于给的，不匹配</p>
</li>
<li><p><code>int typeDiffWeight</code>：获取匹配度</p>
<ul>
<li><code>mbd.isLenientConstructorResolution()</code>：true 表示 ambiguousConstructors 允许有数据，false 代表不允许有数据，有数据就报错（LenientConstructorResolution：宽松的构造函数解析）</li>
<li><code>argsHolder.getTypeDifferenceWeight(paramTypes)</code>：选择参数转换前和转换后匹配度最低的，循环向父类中寻找该方法，直到寻找到 Obejct 类</li>
</ul>
</li>
<li><p><code> if (typeDiffWeight &lt; minTypeDiffWeight)</code>：条件成立说明当前循环处理的构造器更优</p>
</li>
<li><p><code>else if (constructorToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight)</code>：当前处理的构造器的计算出来的 DiffWeight 与上一次筛选出来的最优构造器的值一致，说明有模棱两可的情况</p>
</li>
<li><p><code>if (constructorToUse == null)</code>：未找到可以使用的构造器，报错</p>
</li>
<li><p><code> else if (ambiguousConstructors != null &amp;&amp; !mbd.isLenientConstructorResolution())</code>：模棱两可有数据，LenientConstructorResolution &#x3D;&#x3D; false，所以报错</p>
</li>
<li><p><code>argsHolderToUse.storeCache(mbd, constructorToUse)</code>：匹配成功，进行缓存，方便后来者使用该 bd 实例化</p>
</li>
<li><p><code> bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse))</code>：匹配成功调用 instantiate 创建出实例对象，设置到 BeanWrapper 中去</p>
</li>
</ul>
</li>
<li><p><code>return instantiateBean(beanName, mbd)</code>：默认走到这里</p>
</li>
</ul>
<hr>
<h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><h5 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h5><p>循环依赖：是一个或多个对象实例之间存在直接或间接的依赖关系，这种依赖关系构成一个环形调用</p>
<p>Spring 循环依赖有四种：</p>
<ul>
<li>DependsOn 依赖加载【无法解决】（两种 Map）</li>
<li>原型模式 Prototype 循环依赖【无法解决】（正在创建集合）</li>
<li>单例 Bean 循环依赖：构造参数产生依赖【无法解决】（正在创建集合，getSingleton() 逻辑中）</li>
<li>单例 Bean 循环依赖：setter 产生依赖【可以解决】</li>
</ul>
<p>解决循环依赖：提前引用，提前暴露创建中的 Bean</p>
<ul>
<li>Spring 先实例化 A，拿到 A 的构造方法反射创建出来 A 的早期实例对象，这个对象被包装成 ObjectFactory 对象，放入三级缓存</li>
<li>处理 A 的依赖数据，检查发现 A 依赖 B 对象，所以 Spring 就会去根据 B 类型到容器中去 getBean(B)，这里产生递归</li>
<li>拿到 B 的构造方法，进行反射创建出来 B 的早期实例对象，也会把 B 包装成 ObjectFactory 对象，放到三级缓存，处理 B 的依赖数据，检查发现 B 依赖了 A 对象，然后 Spring 就会去根据 A 类型到容器中去 getBean(A.class)</li>
<li>这时从三级缓存中获取到 A 的早期对象进入属性填充</li>
</ul>
<p>循环依赖的三级缓存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一级缓存：存放所有初始化完成单实例 bean，单例池，key是beanName，value是对应的单实例对象引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//二级缓存：存放实例化未进行初始化的 Bean，提前引用池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. 3*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为什么需要三级缓存？</p>
<ul>
<li>循环依赖解决需要提前引用动态代理对象，AOP 动态代理是在 Bean 初始化后的后置处理中进行，这时的 bean 已经是成品对象。因为需要提前进行动态代理，三级缓存的 ObjectFactory 提前产生需要代理的对象，把提前引用放入二级缓存</li>
<li>如果只有二级缓存，提前引用就直接放入了一级缓存，然后 Bean 初始化完成后又会放入一级缓存，产生数据覆盖，<strong>导致提前引用的对象和一级缓存中的并不是同一个对象</strong></li>
<li>一级缓存只能存放完整的单实例，<strong>为了保证 Bean 的生命周期不被破坏</strong>，不能将未初始化的 Bean 暴露到一级缓存</li>
<li>若存在循环依赖，<strong>后置处理不创建代理对象，真正创建代理对象的过程是在 getBean(B) 的阶段中</strong></li>
</ul>
</li>
<li><p>三级缓存一定会创建提前引用吗？</p>
<ul>
<li>出现循环依赖就会去三级缓存获取提前引用，不出现就不会，走正常的逻辑，创建完成直接放入一级缓存</li>
<li>存在循环依赖，就创建代理对象放入二级缓存，如果没有增强方法就返回 createBeanInstance 创建的实例，因为 addSingletonFactory 参数中传入了实例化的 Bean，在 singletonFactory.getObject() 中返回给 singletonObject，所以<strong>存在循环依赖就一定会使用工厂</strong>，但是不一定创建的是代理对象，不需要增强就是原始对象</li>
</ul>
</li>
<li><p>wrapIfNecessary 一定创建代理对象吗？（AOP 动态代理部分有源码解析）</p>
<ul>
<li>存在增强器会创建动态代理，不需要增强就不需要创建动态代理对象</li>
<li>存在循环依赖会提前增强，初始化后不需要增强</li>
</ul>
</li>
<li><p>什么时候将 Bean 的引用提前暴露给第三级缓存的 ObjectFactory 持有？</p>
<ul>
<li><p>实例化之后，依赖注入之前</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">createBeanInstance -&gt; addSingletonFactory -&gt; populateBean</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h5><p>假如 A 依赖 B，B 依赖 A</p>
<ul>
<li><p>当 A 创建实例后填充属性前，执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加给定的单例工厂以构建指定的单例</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">// 单例池包含该Bean说明已经创建完成，不需要循环依赖</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="comment">//加入三级缓存</span></span><br><span class="line">            <span class="built_in">this</span>.singletonFactories.put(beanName,singletonFactory);</span><br><span class="line">            <span class="built_in">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="comment">// 从二级缓存移除，因为三个Map中都是一个对象，不能同时存在！</span></span><br><span class="line">            <span class="built_in">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>填充属性时 A 依赖 B，这时需要 getBean(B)，也会把 B 的工厂放入三级缓存，接着 B 填充属性时发现依赖 A，去进行**第一次 ** getSingleton(A)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);<span class="comment">//为true代表允许拿到早期引用。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">    <span class="comment">// 在一级缓存中获取 beanName 对应的单实例对象。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">// 单实例确实尚未创建；单实例正在创建，发生了循环依赖</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 从二级缓存获取</span></span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">// 二级缓存不存在，并且允许获取早期实例对象，去三级缓存查看</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 从三级缓存获取工厂对象，并得到 bean 的提前引用</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="comment">// 【缓存升级】，放入二级缓存，提前引用池</span></span><br><span class="line">                    <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="comment">// 从三级缓存移除该对象</span></span><br><span class="line">                    <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从三级缓存获取 A 的 Bean：<code>singletonFactory.getObject()</code>，调用了 lambda 表达式的 getEarlyBeanReference 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">    <span class="comment">// 【向提前引用代理池 earlyProxyReferences 中添加该 Bean，防止对象被重新代理】</span></span><br><span class="line">    <span class="built_in">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">    <span class="comment">// 创建代理对象，createProxy</span></span><br><span class="line">    <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>B 填充了 A 的提前引用后会继续初始化直到完成，<strong>返回原始 A 的逻辑继续执行</strong></p>
</li>
</ul>
<hr>
<h3 id="AOP-2"><a href="#AOP-2" class="headerlink" title="AOP"></a>AOP</h3><h4 id="注解原理"><a href="#注解原理" class="headerlink" title="注解原理"></a>注解原理</h4><p>@EnableAspectJAutoProxy：AOP 注解驱动，给容器中导入 AspectJAutoProxyRegistrar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">    <span class="comment">// 是否强制使用 CGLIB 创建代理对象 </span></span><br><span class="line">    <span class="comment">// 配置文件方式：&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将当前代理对象暴露到上下文内，方便代理对象内部的真实对象拿到代理对象</span></span><br><span class="line">    <span class="comment">// 配置文件方式：&lt;aop:aspectj-autoproxy expose-proxy=&quot;true&quot;/&gt;</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AspectJAutoProxyRegistrar 在用来向容器中注册 <strong>AnnotationAwareAspectJAutoProxyCreator</strong>，以 BeanDefiantion 形式存在，在容器初始化时加载。AnnotationAwareAspectJAutoProxyCreator 间接实现了 InstantiationAwareBeanPostProcessor，Order 接口，该类会在 Bean 的实例化和初始化的前后起作用</p>
<p>工作流程：创建 IOC 容器，调用 refresh() 刷新容器，<code>registerBeanPostProcessors(beanFactory)</code> 阶段，通过 getBean() 创建 AnnotationAwareAspectJAutoProxyCreator 对象，在生命周期的初始化方法中执行回调 initBeanFactory() 方法初始化注册三个工具类：BeanFactoryAdvisorRetrievalHelperAdapter、ReflectiveAspectJAdvisorFactory、BeanFactoryAspectJAdvisorsBuilderAdapter</p>
<hr>
<h4 id="后置处理"><a href="#后置处理" class="headerlink" title="后置处理"></a>后置处理</h4><p>Bean 初始化完成的执行后置处理器的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean,String bN)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// cacheKey 是 【beanName 或者加上 &amp; 的 beanName】</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">                <span class="comment">// 去提前代理引用池中寻找该 key，不存在则创建代理</span></span><br><span class="line">                <span class="comment">// 如果存在则证明被代理过，则判断是否是当前的 bean，不是则创建代理</span></span><br><span class="line">                <span class="keyword">return</span> wrapIfNecessary(bean, bN, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractAutoProxyCreator.wrapIfNecessary()：根据通知创建动态代理，没有通知直接返回原实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> &#123;</span><br><span class="line">    <span class="comment">// 条件一般不成立，很少使用 TargetSourceCreator 去创建对象 BeforeInstantiation 阶段，doCreateBean 之前的阶段</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// advisedBeans 集合保存的是 bean 是否被增强过了</span></span><br><span class="line">    <span class="comment">// 条件成立说明当前 beanName 对应的实例不需要被增强处理，判断是在 BeforeInstantiation 阶段做的</span></span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="built_in">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件一：判断当前 bean 类型是否是基础框架类型，这个类的实例不能被增强</span></span><br><span class="line">    <span class="comment">// 条件二：shouldSkip 判断当前 beanName 是否是 .ORIGINAL 结尾，如果是就跳过增强逻辑，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【查找适合当前 bean 实例的增强方法】（下一节详解）</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 条件成立说明上面方法查询到适合当前class的通知</span></span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// 根据查询到的增强创建代理对象（下一节详解）</span></span><br><span class="line">        <span class="comment">// 参数一：目标对象</span></span><br><span class="line">        <span class="comment">// 参数二：beanName</span></span><br><span class="line">        <span class="comment">// 参数三：匹配当前目标对象 clazz 的 Advisor 数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(</span><br><span class="line">            bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(bean));</span><br><span class="line">        <span class="comment">// 保存代理对象类型</span></span><br><span class="line">        <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="comment">// 返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 执行到这里说明没有查到通知，当前 bean 不需要增强</span></span><br><span class="line">    <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="comment">// 【返回原始的 bean 实例】</span></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="获取通知"><a href="#获取通知" class="headerlink" title="获取通知"></a>获取通知</h4><p>AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean()：查找适合当前类实例的增强，并进行排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line">	<span class="comment">// 查询适合当前类型的增强通知</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 增强为空直接返回 null，不需要创建代理</span></span><br><span class="line">        <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不是空，转成数组返回</span></span><br><span class="line">    <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractAdvisorAutoProxyCreator.findEligibleAdvisors()：</p>
<ul>
<li><p><code>candidateAdvisors = findCandidateAdvisors()</code>：<strong>获取当前容器内可以使用（所有）的 advisor</strong>，调用的是 AnnotationAwareAspectJAutoProxyCreator 类的方法，每个方法对应一个 Advisor </p>
<ul>
<li><p><code>advisors = super.findCandidateAdvisors()</code>：<strong>查询出 XML 配置的所有 Advisor 类型</strong></p>
<ul>
<li><code>advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors()</code>：通过 BF 查询出来 BD 配置的 class 中 是 Advisor 子类的 BeanName</li>
<li><code>advisors.add()</code>：使用 Spring 容器获取当前这个 Advisor 类型的实例</li>
</ul>
</li>
<li><p><code>advisors.addAll(....buildAspectJAdvisors())</code>：<strong>获取所有添加 @Aspect 注解类中的 Advisor</strong></p>
<p><code>buildAspectJAdvisors()</code>：构建的方法，<strong>把 Advice 封装成 Advisor</strong></p>
<ul>
<li><p><code> beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Object.class, true, false)</code>：获取出容器内 Object 所有的 beanName，就是全部的</p>
</li>
<li><p><code> for (String beanName : beanNames)</code>：遍历所有的 beanName，判断每个 beanName 对应的 Class 是否是 Aspect 类型，就是加了 @Aspect 注解的类</p>
<ul>
<li><p><code>factory = new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName)</code>：使用工厂模式管理 Aspect 的元数据，关联的真实 @Aspect 注解的实例对象</p>
</li>
<li><p><code>classAdvisors = this.advisorFactory.getAdvisors(factory)</code>：添加了 @Aspect 注解的类的通知信息</p>
<ul>
<li><p>aspectClass：@Aspect 标签的类的 class</p>
</li>
<li><p><code>for (Method method : getAdvisorMethods(aspectClass))</code>：遍历<strong>不包括 @Pointcut 注解的方法</strong></p>
<p><code>Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName)</code>：<strong>将当前 method 包装成 Advisor 数据</strong></p>
<ul>
<li><p><code>AspectJExpressionPointcut expressionPointcut = getPointcut()</code>：获取切点表达式</p>
</li>
<li><p><code>return new InstantiationModelAwarePointcutAdvisorImpl()</code>：把 method 中 Advice 包装成 Advisor，Spring 中每个 Advisor 内部一定是持有一个 Advice 的，Advice 内部最重要的数据是当前 method 和aspectInstanceFactory，工厂用来获取实例</p>
<p><code>this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut)</code>：实例化 Advice 对象，逻辑是获取注解信息，根据注解的不同生成对应的 Advice 对象</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>advisors.addAll(classAdvisors)</code>：保存通过 @Aspect 注解定义的 Advisor 数据</p>
</li>
</ul>
</li>
<li><p><code>this.aspectBeanNames = aspectNames</code>：将所有 @Aspect 注解 beanName 缓存起来，表示提取 Advisor 工作完成</p>
</li>
<li><p><code>return advisors</code>：返回 Advisor 列表</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, ...)</code>：<strong>选出匹配当前类的增强</strong></p>
<ul>
<li><p><code>if (candidateAdvisors.isEmpty())</code>：条件成立说明当前 Spring 没有可以操作的 Advisor</p>
</li>
<li><p><code>List&lt;Advisor&gt; eligibleAdvisors = new ArrayList&lt;&gt;()</code>：存放匹配当前 beanClass 的 Advisors 信息</p>
</li>
<li><p><code>for (Advisor candidate : candidateAdvisors)</code>：<strong>遍历所有的 Advisor</strong></p>
<p><code> if (canApply(candidate, clazz, hasIntroductions))</code>：判断遍历的 advisor 是否匹配当前的 class，匹配就加入集合</p>
<ul>
<li><p><code>if (advisor instanceof PointcutAdvisor)</code>：创建的 advisor 是 InstantiationModelAwarePointcutAdvisorImpl 类型</p>
<p><code>PointcutAdvisor pca = (PointcutAdvisor) advisor</code>：封装当前 Advisor</p>
<p><code>return canApply(pca.getPointcut(), targetClass, hasIntroductions)</code>：重载该方法</p>
<ul>
<li><code>if (!pc.getClassFilter().matches(targetClass))</code>：<strong>类不匹配 Pointcut 表达式，直接返回 false</strong></li>
<li><code>methodMatcher = pc.getMethodMatcher()</code>：<strong>获取 Pointcut 方法匹配器</strong>，类匹配进行类中方法的匹配</li>
<li><code>Set&lt;Class&lt;?&gt;&gt; classes</code>：保存目标对象 class 和目标对象父类超类的接口和自身实现的接口</li>
<li><code>if (!Proxy.isProxyClass(targetClass))</code>：判断当前实例是不是代理类，确保 class 内存储的数据包括目标对象的class  而不是代理类的 class</li>
<li><code>for (Class&lt;?&gt; clazz : classes)</code>：<strong>检查目标 class 和上级接口的所有方法，查看是否会被方法匹配器匹配</strong>，如果有一个方法匹配成功，就说明目标对象 AOP 代理需要增强<ul>
<li><code>specificMethod = AopUtils.getMostSpecificMethod(method, targetClass)</code>：方法可能是接口的，判断当前类有没有该方法</li>
<li><code>return (specificMethod != method &amp;&amp; matchesMethod(specificMethod))</code>：<strong>类和方法的匹配</strong>，不包括参数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>extendAdvisors(eligibleAdvisors)</code>：在 eligibleAdvisors 列表的索引 0 的位置添加 DefaultPointcutAdvisor，<strong>封装了 ExposeInvocationInterceptor 拦截器</strong></p>
</li>
<li><p><code> eligibleAdvisors = sortAdvisors(eligibleAdvisors)</code>：<strong>对拦截器进行排序</strong>，数值越小优先级越高，高的排在前面</p>
<ul>
<li>实现 Ordered 或 PriorityOrdered 接口，PriorityOrdered 的级别要优先于 Ordered，使用 OrderComparator 比较器</li>
<li>使用 @Order（Spring 规范）或 @Priority（JDK 规范）注解，使用 AnnotationAwareOrderComparator 比较器</li>
<li>ExposeInvocationInterceptor 实现了 PriorityOrdered ，所以总是排在第一位，MethodBeforeAdviceInterceptor 没实现任何接口，所以优先级最低，排在最后</li>
</ul>
</li>
<li><p><code>return eligibleAdvisors</code>：返回拦截器链</p>
</li>
</ul>
<hr>
<h4 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h4><p>AbstractAutoProxyCreator.createProxy()：根据增强方法创建代理对象</p>
<ul>
<li><p><code>ProxyFactory proxyFactory = new ProxyFactory()</code>：<strong>无参构造 ProxyFactory</strong>，此处讲解一下两种有参构造方法：</p>
<ul>
<li><p>public ProxyFactory(Object target)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">	<span class="comment">// 将目标对象封装成 SingletonTargetSource 保存到父类的字段中</span></span><br><span class="line">   	setTarget(target);</span><br><span class="line">    <span class="comment">// 获取目标对象 class 所有接口保存到 AdvisedSupport 中的 interfaces 集合中</span></span><br><span class="line">   	setInterfaces(ClassUtils.getAllInterfaces(target));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ClassUtils.getAllInterfaces(target) 底层调用 getAllInterfacesForClassAsSet(java.lang.Class&lt;?&gt;, java.lang.ClassLoader)：</p>
<ul>
<li><code>if (clazz.isInterface() &amp;&amp; isVisible(clazz, classLoader))</code>：<ul>
<li>条件一：判断当前目标对象是接口</li>
<li>条件二：检查给定的类在给定的 ClassLoader 中是否可见</li>
</ul>
</li>
<li><code>Class&lt;?&gt;[] ifcs = current.getInterfaces()</code>：拿到自己实现的接口，拿不到接口实现的接口</li>
<li><code>current = current.getSuperclass()</code>：递归寻找父类的接口，去获取父类实现的接口</li>
</ul>
</li>
<li><p>public ProxyFactory(Class&lt;?&gt; proxyInterface, Interceptor interceptor)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Class&lt;?&gt; proxyInterface, Interceptor interceptor)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加一个代理的接口</span></span><br><span class="line">    addInterface(proxyInterface);</span><br><span class="line">    <span class="comment">// 添加通知，底层调用 addAdvisor</span></span><br><span class="line">    addAdvice(interceptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>addAdvisor(pos, new DefaultPointcutAdvisor(advice))</code>：Spring 中 Advice 对应的接口就是 Advisor，Spring 使用 Advisor 包装 Advice 实例</li>
</ul>
</li>
</ul>
</li>
<li><p><code>proxyFactory.copyFrom(this)</code>：填充一些信息到 proxyFactory</p>
</li>
<li><p><code>if (!proxyFactory.isProxyTargetClass())</code>：条件成立说明 proxyTargetClass 为 false（默认），两种配置方法：</p>
<ul>
<li><code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; </code>：强制使用 CGLIB</li>
<li><code>@EnableAspectJAutoProxy(proxyTargetClass = true)</code></li>
</ul>
<p><code>if (shouldProxyTargetClass(beanClass, beanName))</code>：如果 bd 内有 preserveTargetClass &#x3D; true ，那么这个 bd 对应的 class <strong>创建代理时必须使用 CGLIB</strong>，条件成立设置 proxyTargetClass 为 true</p>
<p><code>evaluateProxyInterfaces(beanClass, proxyFactory)</code>：<strong>根据目标类判定是否可以使用 JDK 动态代理</strong></p>
<ul>
<li><code>targetInterfaces = ClassUtils.getAllInterfacesForClass()</code>：获取当前目标对象 class 和父类的全部实现接口</li>
<li><code>boolean hasReasonableProxyInterface = false</code>：实现的接口中是否有一个合理的接口</li>
<li><code>if (!isConfigurationCallbackInterface(ifc) &amp;&amp; !isInternalLanguageInterface(ifc) &amp;&amp; ifc.getMethods().length &gt; 0)</code>：遍历所有的接口，如果有任意一个接口满足条件，设置 hRPI 变量为 true<ul>
<li>条件一：判断当前接口是否是 Spring 生命周期内会回调的接口</li>
<li>条件二：接口不能是 GroovyObject、Factory、MockAccess 类型的</li>
<li>条件三：找到一个可以使用的被代理的接口</li>
</ul>
</li>
<li><code>if (hasReasonableProxyInterface)</code>：<strong>有合理的接口，将这些接口设置到 proxyFactory 内</strong></li>
<li><code>proxyFactory.setProxyTargetClass(true)</code>：<strong>没有合理的代理接口，强制使用 CGLIB 创建对象</strong></li>
</ul>
</li>
<li><p><code>advisors = buildAdvisors(beanName, specificInterceptors)</code>：匹配目标对象 clazz 的 Advisors，填充至 ProxyFactory</p>
</li>
<li><p><code>proxyFactory.setPreFiltered(true)</code>：设置为 true 表示传递给 proxyFactory 的 Advisors 信息做过基础类和方法的匹配</p>
</li>
<li><p><code>return proxyFactory.getProxy(getProxyClassLoader())</code>：创建代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultAopProxyFactory.createAopProxy(AdvisedSupport config)：参数是一个配置对象，保存着创建代理需要的生产资料，会加锁创建，保证线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">    <span class="comment">// 条件二为 true 代表强制使用 CGLIB 动态代理</span></span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || </span><br><span class="line">        <span class="comment">// 条件三：被代理对象没有实现任何接口或者只实现了 SpringProxy 接口，只能使用 CGLIB 动态代理</span></span><br><span class="line">        hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 条件成立说明 target 【是接口或者是已经被代理过的类型】，只能使用 JDK 动态代理</span></span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);	<span class="comment">// 使用 JDK 动态代理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);	<span class="comment">// 使用 CGLIB 动态代理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);		<span class="comment">// 【有接口的情况下只能使用 JDK 动态代理】</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JdkDynamicAopProxy.getProxy(java.lang.ClassLoader)：获取 JDK 的代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">JdkDynamicAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">    <span class="comment">// 配置类封装到 JdkDynamicAopProxy.advised 属性中</span></span><br><span class="line">    <span class="built_in">this</span>.advised = config;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取需要代理的接口数组</span></span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="built_in">this</span>.advised, <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找当前所有的需要代理的接口，看是否有 equals 方法和 hashcode 方法，如果有就做一个标记</span></span><br><span class="line">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该方法最终返回一个代理类对象</span></span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// classLoader：类加载器  proxiedInterfaces：生成的代理类，需要实现的接口集合</span></span><br><span class="line">    <span class="comment">// this JdkDynamicAopProxy 实现了 InvocationHandler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AopProxyUtils.completeProxiedInterfaces(this.advised, true)：获取代理的接口数组，并添加 SpringProxy 接口</p>
<ul>
<li><p><code>specifiedInterfaces = advised.getProxiedInterfaces()</code>：从 ProxyFactory 中拿到所有的 target 提取出来的接口</p>
<ul>
<li><code>if (specifiedInterfaces.length == 0)</code>：如果没有实现接口，检查当前 target 是不是接口或者已经是代理类，封装到 ProxyFactory 的 interfaces 集合中</li>
</ul>
</li>
<li><p><code> addSpringProxy = !advised.isInterfaceProxied(SpringProxy.class)</code>：判断目标对象所有接口中是否有 SpringProxy 接口，没有的话需要添加，这个接口<strong>标识这个代理类型是 Spring 管理的</strong></p>
<ul>
<li><code>addAdvised = !advised.isOpaque() &amp;&amp; !advised.isInterfaceProxied(Advised.class)</code>：判断目标对象的所有接口，是否已经有 Advised 接口</li>
<li><code> addDecoratingProxy = (decoratingProxy &amp;&amp; !advised.isInterfaceProxied(DecoratingProxy.class))</code>：判断目标对象的所有接口，是否已经有 DecoratingProxy 接口</li>
<li><code>int nonUserIfcCount = 0</code>：非用户自定义的接口数量，接下来要添加上面的三个接口了</li>
<li><code>proxiedInterfaces = new Class&lt;?&gt;[specifiedInterfaces.length + nonUserIfcCount]</code>：创建一个新的 class 数组，长度是原目标对象提取出来的接口数量和 Spring 追加的数量，然后进行 <strong>System.arraycopy 拷贝到新数组中</strong></li>
<li><code>int index = specifiedInterfaces.length</code>：获取原目标对象提取出来的接口数量，当作 index</li>
<li><code>if(addSpringProxy)</code>：根据上面三个布尔值把接口添加到新数组中</li>
<li><code>return proxiedInterfaces</code>：返回追加后的接口集合</li>
</ul>
</li>
</ul>
<p>JdkDynamicAopProxy.findDefinedEqualsAndHashCodeMethods()：查找在任何定义在接口中的 equals 和 hashCode 方法</p>
<ul>
<li><code>for (Class&lt;?&gt; proxiedInterface : proxiedInterfaces)</code>：遍历所有的接口<ul>
<li><p><code> Method[] methods = proxiedInterface.getDeclaredMethods()</code>：获取接口中的所有方法</p>
</li>
<li><p><code>for (Method method : methods)</code>：遍历所有的方法</p>
<ul>
<li><code>if (AopUtils.isEqualsMethod(method))</code>：当前方法是 equals 方法，把 equalsDefined 置为 true</li>
<li><code>if (AopUtils.isHashCodeMethod(method))</code>：当前方法是 hashCode 方法，把 hashCodeDefined 置为 true</li>
</ul>
</li>
<li><p><code>if (this.equalsDefined &amp;&amp; this.hashCodeDefined)</code>：如果有一个接口中有这两种方法，直接返回</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="方法增强"><a href="#方法增强" class="headerlink" title="方法增强"></a>方法增强</h4><p>main() 函数中调用用户方法，会进入代理对象的 invoke 方法</p>
<p>JdkDynamicAopProxy 类中的 invoke 方法是真正执行代理方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// proxy：代理对象，method：目标对象的方法，args：目标对象方法对应的参数</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">oldProxy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">setProxyContext</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// advised 就是初始化 JdkDynamicAopProxy 对象时传入的变量</span></span><br><span class="line">    <span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> <span class="built_in">this</span>.advised.targetSource;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 条件成立说明代理类实现的接口没有定义 equals 方法，并且当前 method 调用 equals 方法，</span></span><br><span class="line">        <span class="comment">// 就调用 JdkDynamicAopProxy 提供的 equals 方法</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">        Object retVal;</span><br><span class="line">		<span class="comment">// 需不需要暴露当前代理对象到 AOP 上下文内</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">            <span class="comment">// 【把代理对象设置到上下文环境】</span></span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">            setProxyContext = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 targetSource 获取真正的代理对象</span></span><br><span class="line">        target = targetSource.getTarget();</span><br><span class="line">        Class&lt;?&gt; targetClass = (target != <span class="literal">null</span> ? target.getClass() : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找【适合该方法的增强】，首先从缓存中查找，查找不到进入主方法【下文详解】</span></span><br><span class="line">        List&lt;Object&gt; chain = <span class="built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 拦截器链是空，说明当前 method 不需要被增强</span></span><br><span class="line">        <span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 有匹配当前 method 的方法拦截器，要做增强处理，把方法信息封装到方法调用器里</span></span><br><span class="line">            <span class="type">MethodInvocation</span> <span class="variable">invocation</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(proxy, target, method, args, targetClass, chain);</span><br><span class="line">            <span class="comment">// 【拦截器链驱动方法，核心】</span></span><br><span class="line">            retVal = invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">        <span class="keyword">if</span> (retVal != <span class="literal">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">            returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">            !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">          	<span class="comment">// 如果目标方法返回目标对象，这里做个普通替换返回代理对象</span></span><br><span class="line">            retVal = proxy;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回执行的结果</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">            targetSource.releaseTarget(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果允许了提前暴露，这里需要设置为初始状态</span></span><br><span class="line">        <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">            <span class="comment">// 当前代理对象已经完成工作，【把原始对象设置回上下文】</span></span><br><span class="line">            AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)：查找适合该方法的增强，首先从缓存中查找，获取通知时是从全部增强中获取适合当前类的，这里是<strong>从当前类的中获取适合当前方法的增强</strong></p>
<ul>
<li><p><code>AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance()</code>：向容器注册适配器，<strong>可以将非 Advisor 类型的增强，包装成为 Advisor，将 Advisor 类型的增强提取出来对应的 MethodInterceptor</strong></p>
<ul>
<li><p><code>instance = new DefaultAdvisorAdapterRegistry()</code>：该对象向容器中注册了 MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter、ThrowsAdviceAdapter 三个适配器</p>
</li>
<li><p>Advisor 中持有 Advice 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Advisor</span> &#123;</span><br><span class="line">	Advice <span class="title function_">getAdvice</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>advisors = config.getAdvisors()</code>：获取 ProxyFactory 内部持有的增强信息</p>
</li>
<li><p><code>interceptorList = new ArrayList&lt;&gt;(advisors.length)</code>：拦截器列表有 5 个，1 个 ExposeInvocation和 4 个增强器</p>
</li>
<li><p><code>actualClass = (targetClass != null ? targetClass : method.getDeclaringClass())</code>：真实的目标对象类型</p>
</li>
<li><p><code>Boolean hasIntroductions = null</code>：引介增强，不关心</p>
</li>
<li><p><code>for (Advisor advisor : advisors)</code>：<strong>遍历所有的 advisor 增强</strong></p>
</li>
<li><p><code>if (advisor instanceof PointcutAdvisor)</code>：条件成立说明当前 Advisor 是包含切点信息的，进入匹配逻辑</p>
<p><code>pointcutAdvisor = (PointcutAdvisor) advisor</code>：转成可以获取到切点信息的接口</p>
<p><code>if(config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass))</code>：当前代理被预处理，或者当前被代理的 class 对象匹配当前 Advisor 成功，只是 class 匹配成功</p>
<ul>
<li><p><code>mm = pointcutAdvisor.getPointcut().getMethodMatcher()</code>：获取切点的方法匹配器，不考虑引介增强</p>
</li>
<li><p><code>match = mm.matches(method, actualClass)</code>：<strong>静态匹配成功返回 true，只关注于处理类及其方法，不考虑参数</strong></p>
</li>
<li><p><code>if (match)</code>：如果静态切点检查是匹配的，在运行的时候才进行<strong>动态切点检查，会考虑参数匹配</strong>（代表传入了参数）。如果静态匹配失败，直接不需要进行参数匹配，提高了工作效率</p>
<p><code>interceptors = registry.getInterceptors(advisor)</code>：提取出当前 advisor 内持有的 advice 信息 </p>
<ul>
<li><p><code>Advice advice = advisor.getAdvice()</code>：获取增强方法</p>
</li>
<li><p><code>if (advice instanceof MethodInterceptor)</code>：当前 advice 是 MethodInterceptor 直接加入集合</p>
</li>
<li><p><code>for (AdvisorAdapter adapter : this.adapters)</code>：<strong>遍历三个适配器进行匹配</strong>（初始化时创建的），匹配成功创建对应的拦截器返回，以 MethodBeforeAdviceAdapter 为例</p>
<p><code>if (adapter.supportsAdvice(advice))</code>：判断当前 advice 是否是对应的 MethodBeforeAdvice</p>
<p><code>interceptors.add(adapter.getInterceptor(advisor))</code>：条件成立就往拦截器链中添加 advisor</p>
<ul>
<li><code>advice = (MethodBeforeAdvice) advisor.getAdvice()</code>：<strong>获取增强方法</strong></li>
<li><code>return new MethodBeforeAdviceInterceptor(advice)</code>：<strong>封装成 MethodBeforeAdviceInterceptor 返回</strong></li>
</ul>
</li>
</ul>
<p><code>interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm))</code>：向拦截器链添加动态匹配器</p>
<p><code>interceptorList.addAll(Arrays.asList(interceptors))</code>：将当前 advisor 内部的方法拦截器追加到 interceptorList</p>
</li>
</ul>
</li>
<li><p><code>interceptors = registry.getInterceptors(advisor)</code>：进入 else 的逻辑，说明当前 Advisor 匹配全部 class 的全部 method，全部加入到 interceptorList</p>
</li>
<li><p><code>return interceptorList</code>：返回 method 方法的拦截器链</p>
</li>
</ul>
<p>retVal &#x3D; invocation.proceed()：<strong>拦截器链驱动方法</strong></p>
<ul>
<li><p><code>if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1)</code>：条件成立说明方法拦截器全部都已经调用过了（index 从 - 1 开始累加），接下来需要执行目标对象的目标方法</p>
<p><code>return invokeJoinpoint()</code>：<strong>调用连接点（目标）方法</strong></p>
</li>
<li><p><code>this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex)</code>：<strong>获取下一个方法拦截器</strong></p>
</li>
<li><p><code>if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher)</code>：需要运行时匹配</p>
<p><code>if (dm.methodMatcher.matches(this.method, targetClass, this.arguments))</code>：判断是否匹配成功</p>
<ul>
<li><code>return dm.interceptor.invoke(this)</code>：匹配成功，执行方法</li>
<li><code>return proceed()</code>：匹配失败跳过当前拦截器</li>
</ul>
</li>
<li><p><code>return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this)</code>：<strong>一般方法拦截器都会执行到该方法，此方法内继续执行 proceed() 完成责任链的驱动，直到最后一个  MethodBeforeAdviceInterceptor 调用前置通知，然后调用 mi.proceed()，发现是最后一个拦截器就直接执行连接点（目标方法），return 到上一个拦截器的 mi.proceed() 处，依次返回到责任链的上一个拦截器执行通知方法</strong></p>
</li>
</ul>
<p>图示先从上往下建立链，然后从下往上依次执行，责任链模式</p>
<ul>
<li><p>正常执行：（环绕通知）→ 前置通知 → 目标方法 → 后置通知 → 返回通知</p>
</li>
<li><p>出现异常：（环绕通知）→ 前置通知 → 目标方法 → 后置通知 → 异常通知</p>
</li>
<li><p>MethodBeforeAdviceInterceptor 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 先执行通知方法，再驱动责任链</span></span><br><span class="line">    <span class="built_in">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">    <span class="comment">// 开始驱动目标方法执行，执行完后返回到这，然后继续向上层返回</span></span><br><span class="line">    <span class="keyword">return</span> mi.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AfterReturningAdviceInterceptor 源码：没有任何异常处理机制，直接抛给上层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 先驱动责任链，再执行通知方法</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> mi.proceed();</span><br><span class="line">    <span class="built_in">this</span>.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AspectJAfterThrowingAdvice 执行异常处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 默认直接驱动责任链</span></span><br><span class="line">        <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 出现错误才执行该方法</span></span><br><span class="line">        <span class="keyword">if</span> (shouldInvokeOnThrowing(ex)) &#123;</span><br><span class="line">            invokeAdviceMethod(getJoinPointMatch(), <span class="literal">null</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Spring-AOP%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95.png"></p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1gW411W7wy">https://www.bilibili.com/video/BV1gW411W7wy</a></p>
<hr>
<h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><h4 id="解析方法"><a href="#解析方法" class="headerlink" title="解析方法"></a>解析方法</h4><h5 id="标签解析"><a href="#标签解析" class="headerlink" title="标签解析"></a>标签解析</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>容器启动时会根据注解注册对应的解析器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxNamespaceHandler</span> <span class="keyword">extends</span> <span class="title class_">NamespaceHandlerSupport</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;advice&quot;</span>, <span class="keyword">new</span> <span class="title class_">TxAdviceBeanDefinitionParser</span>());</span><br><span class="line">        <span class="comment">// 注册解析器</span></span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;annotation-driven&quot;</span>, <span class="keyword">new</span> <span class="title class_">AnnotationDrivenBeanDefinitionParser</span>());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">&quot;jta-transaction-manager&quot;</span>, <span class="keyword">new</span> <span class="title class_">JtaTransactionManagerBeanDefinitionParser</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitionParser</span><span class="params">(String elementName, BeanDefinitionParser parser)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.parsers.put(elementName, parser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取对应的解析器 NamespaceHandlerSupport#findParserForElement：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> BeanDefinitionParser <span class="title function_">findParserForElement</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">localName</span> <span class="operator">=</span> parserContext.getDelegate().getLocalName(element);</span><br><span class="line">    <span class="comment">// 获取对应的解析器</span></span><br><span class="line">    <span class="type">BeanDefinitionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="built_in">this</span>.parsers.get(localName);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用解析器的方法对 XML 文件进行解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">	<span class="comment">// 向Spring容器注册了一个 BD -&gt; TransactionalEventListenerFactory.class</span></span><br><span class="line">    registerTransactionalEventListenerFactory(parserContext);</span><br><span class="line">    <span class="type">String</span> <span class="variable">mode</span> <span class="operator">=</span> element.getAttribute(<span class="string">&quot;mode&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;aspectj&quot;</span>.equals(mode)) &#123;</span><br><span class="line">        <span class="comment">// mode=&quot;aspectj&quot;</span></span><br><span class="line">        registerTransactionAspect(element, parserContext);</span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isPresent(<span class="string">&quot;javax.transaction.Transactional&quot;</span>, getClass().getClassLoader())) &#123;</span><br><span class="line">            registerJtaTransactionAspect(element, parserContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// mode=&quot;proxy&quot;，默认逻辑，不配置 mode 时</span></span><br><span class="line">        <span class="comment">// 用来向容器中注入一些 BeanDefinition，包括事务增强器、事务拦截器、注解解析器</span></span><br><span class="line">        AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h5 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h5><p>@EnableTransactionManagement 导入 TransactionManagementConfigurationSelector，该类给 Spring 容器中两个组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">        <span class="comment">// 导入 AutoProxyRegistrar 和 ProxyTransactionManagementConfiguration（默认）</span></span><br><span class="line">        <span class="keyword">case</span> PROXY:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;AutoProxyRegistrar.class.getName(),</span><br><span class="line">                                 ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line">        <span class="comment">// 导入 AspectJTransactionManagementConfiguration（与声明式事务无关）</span></span><br><span class="line">        <span class="keyword">case</span> ASPECTJ:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AutoProxyRegistrar：给容器中注册 InfrastructureAdvisorAutoProxyCreator，<strong>利用后置处理器机制拦截 bean 以后包装并返回一个代理对象</strong>，代理对象中保存所有的拦截器，利用拦截器的链式机制依次进入每一个拦截器中进行拦截执行（就是 AOP 原理）</p>
<p>ProxyTransactionManagementConfiguration：是一个 Spring 的事务配置类，注册了三个 Bean：</p>
<ul>
<li>BeanFactoryTransactionAttributeSourceAdvisor：事务驱动，利用注解 @Bean 把该类注入到容器中，该增强器有两个字段：</li>
<li>TransactionAttributeSource：解析事务注解的相关信息，真实类型是 AnnotationTransactionAttributeSource，构造方法中注册了三个<strong>注解解析器</strong>，解析 Spring、JTA、Ejb3 三种类型的事务注解</li>
<li>TransactionInterceptor：<strong>事务拦截器</strong>，代理对象执行拦截器方法时，调用 TransactionInterceptor 的 invoke 方法，底层调用TransactionAspectSupport.invokeWithinTransaction()，通过 PlatformTransactionManager 控制着事务的提交和回滚，所以事务的底层原理就是通过 AOP 动态织入，进行事务开启和提交</li>
</ul>
<p>注解解析器 SpringTransactionAnnotationParser <strong>解析 @Transactional 注解</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">parseTransactionAnnotation</span><span class="params">(AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">    <span class="type">RuleBasedTransactionAttribute</span> <span class="variable">rbta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuleBasedTransactionAttribute</span>();</span><br><span class="line">	<span class="comment">// 从注解信息中获取传播行为</span></span><br><span class="line">    <span class="type">Propagation</span> <span class="variable">propagation</span> <span class="operator">=</span> attributes.getEnum(<span class="string">&quot;propagation&quot;</span>);</span><br><span class="line">    rbta.setPropagationBehavior(propagation.value());</span><br><span class="line">    <span class="comment">// 获取隔离界别</span></span><br><span class="line">    <span class="type">Isolation</span> <span class="variable">isolation</span> <span class="operator">=</span> attributes.getEnum(<span class="string">&quot;isolation&quot;</span>);</span><br><span class="line">    rbta.setIsolationLevel(isolation.value());</span><br><span class="line">    rbta.setTimeout(attributes.getNumber(<span class="string">&quot;timeout&quot;</span>).intValue());</span><br><span class="line">    <span class="comment">// 从注解信息中获取 readOnly 参数</span></span><br><span class="line">    rbta.setReadOnly(attributes.getBoolean(<span class="string">&quot;readOnly&quot;</span>));</span><br><span class="line">    <span class="comment">// 从注解信息中获取 value 信息并且设置 qualifier，表示当前事务指定使用的【事务管理器】</span></span><br><span class="line">    rbta.setQualifier(attributes.getString(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">	<span class="comment">// 【存放的是 rollback 条件】，回滚规则放在这个集合</span></span><br><span class="line">    List&lt;RollbackRuleAttribute&gt; rollbackRules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 表示事务碰到哪些指定的异常才进行回滚，不指定的话默认是 RuntimeException/Error 非检查型异常菜回滚</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">&quot;rollbackFor&quot;</span>)) &#123;</span><br><span class="line">        rollbackRules.add(<span class="keyword">new</span> <span class="title class_">RollbackRuleAttribute</span>(rbRule));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与 rollbackFor 功能相同</span></span><br><span class="line">    <span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">&quot;rollbackForClassName&quot;</span>)) &#123;</span><br><span class="line">        rollbackRules.add(<span class="keyword">new</span> <span class="title class_">RollbackRuleAttribute</span>(rbRule));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表示事务碰到指定的 exception 实现对象不进行回滚，否则碰到其他的class就进行回滚</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">&quot;noRollbackFor&quot;</span>)) &#123;</span><br><span class="line">        rollbackRules.add(<span class="keyword">new</span> <span class="title class_">NoRollbackRuleAttribute</span>(rbRule));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">&quot;noRollbackForClassName&quot;</span>)) &#123;</span><br><span class="line">        rollbackRules.add(<span class="keyword">new</span> <span class="title class_">NoRollbackRuleAttribute</span>(rbRule));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置回滚规则</span></span><br><span class="line">    rbta.setRollbackRules(rollbackRules);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rbta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="驱动方法"><a href="#驱动方法" class="headerlink" title="驱动方法"></a>驱动方法</h4><p>TransactionInterceptor 事务拦截器的核心驱动方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// targetClass 是需要被事务增强器增强的目标类，invocation.getThis() → 目标对象 → 目标类</span></span><br><span class="line">    Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="literal">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="literal">null</span>);</span><br><span class="line">	<span class="comment">// 参数一是目标方法，参数二是目标类，参数三是方法引用，用来触发驱动方法</span></span><br><span class="line">    <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span><br><span class="line"><span class="params">                                         <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务属性源信息</span></span><br><span class="line">    <span class="type">TransactionAttributeSource</span> <span class="variable">tas</span> <span class="operator">=</span> getTransactionAttributeSource();</span><br><span class="line">    <span class="comment">//  提取 @Transactional 注解信息，txAttr 是注解信息的承载对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> (tas != <span class="literal">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 获取 Spring 配置的事务管理器</span></span><br><span class="line">    <span class="comment">// 首先会检查是否通过XML或注解配置 qualifier，没有就尝试去容器获取，一般情况下为 DatasourceTransactionManager</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">PlatformTransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> determineTransactionManager(txAttr);</span><br><span class="line">    <span class="comment">// 权限定类名.方法名，该值用来当做事务名称使用</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">joinpointIdentification</span> <span class="operator">=</span> methodIdentification(method, targetClass, txAttr);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 条件成立说明是【声明式事务】</span></span><br><span class="line">    <span class="keyword">if</span> (txAttr == <span class="literal">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">    	<span class="comment">// 用来【开启事务】</span></span><br><span class="line">        <span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// This is an 【around advice】: Invoke the next interceptor in the chain.</span></span><br><span class="line">            <span class="comment">// 环绕通知，执行目标方法（方法引用方式，invocation::proceed，还是调用 proceed）</span></span><br><span class="line">            retVal = invocation.proceedWithInvocation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">//  执行业务代码时抛出异常，执行回滚逻辑</span></span><br><span class="line">            completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清理事务的信息</span></span><br><span class="line">            cleanupTransactionInfo(txInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 提交事务的入口</span></span><br><span class="line">        commitTransactionAfterReturning(txInfo);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 编程式事务，省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h4><h5 id="事务绑定"><a href="#事务绑定" class="headerlink" title="事务绑定"></a>事务绑定</h5><p>创建事务的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionInfo <span class="title function_">createTransactionIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> PlatformTransactionManager tm,</span></span><br><span class="line"><span class="params">                                                       <span class="meta">@Nullable</span> TransactionAttribute txAttr, </span></span><br><span class="line"><span class="params">                                                       <span class="keyword">final</span> String joinpointIdentification)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If no name specified, apply method identification as transaction name.</span></span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="literal">null</span> &amp;&amp; txAttr.getName() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 事务的名称： 类的权限定名.方法名</span></span><br><span class="line">        txAttr = <span class="keyword">new</span> <span class="title class_">DelegatingTransactionAttribute</span>(txAttr) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tm != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过事务管理器根据事务属性创建事务状态对象，事务状态对象一般情况下包装着 事务对象，当然也有可能是null</span></span><br><span class="line">            <span class="comment">// 方法上的注解为 @Transactional(propagation = NOT_SUPPORTED || propagation = NEVER) 时</span></span><br><span class="line">            <span class="comment">// 【下一小节详解】</span></span><br><span class="line">            status = tm.getTransaction(txAttr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Skipping transactional joinpoint [&quot;</span> + joinpointIdentification +</span><br><span class="line">                             <span class="string">&quot;] because no transaction manager has been configured&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 包装成一个上层的事务上下文对象</span></span><br><span class="line">    <span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TransactionAspectSupport#prepareTransactionInfo：为事务的属性和状态准备一个事务信息对象</p>
<ul>
<li><code>TransactionInfo txInfo = new TransactionInfo(tm, txAttr, joinpointIdentification)</code>：创建事务信息对象</li>
<li><code>txInfo.newTransactionStatus(status)</code>：填充事务的状态信息</li>
<li><code>txInfo.bindToThread()</code>：利用 ThreadLocal <strong>把当前事务信息绑定到当前线程</strong>，不同的事务信息会形成一个栈的结构<ul>
<li><code>this.oldTransactionInfo = transactionInfoHolder.get()</code>：获取其他事务的信息存入 oldTransactionInfo </li>
<li><code>transactionInfoHolder.set(this)</code>：将当前的事务信息设置到 ThreadLocalMap 中</li>
</ul>
</li>
</ul>
<hr>
<h5 id="事务创建"><a href="#事务创建" class="headerlink" title="事务创建"></a>事务创建</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="comment">// 获取事务的对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">transaction</span> <span class="operator">=</span> doGetTransaction();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">debugEnabled</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (definition == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line">        definition = <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 条件成立说明当前是事务重入的情况，事务中有 ConnectionHolder 对象</span></span><br><span class="line">    <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">        <span class="comment">// a方法开启事务，a方法内调用b方法，b方法仍然加了 @Transactional 注解，需要检查传播行为</span></span><br><span class="line">        <span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 逻辑到这说明当前线程没有连接资源，一个连接对应一个事务，没有连接就相当于没有开启事务</span></span><br><span class="line">    <span class="comment">// 检查事务的延迟属性</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidTimeoutException</span>(<span class="string">&quot;Invalid transaction timeout&quot;</span>, definition.getTimeout());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传播行为是 MANDATORY，没有事务就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要开启事务的传播行为</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">             definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">             definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">        <span class="comment">// 什么也没挂起，因为线程并没有绑定事务</span></span><br><span class="line">        <span class="type">SuspendedResourcesHolder</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 是否支持同步线程事务，一般是 true</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">            <span class="comment">// 新建一个事务状态信息</span></span><br><span class="line">            <span class="type">DefaultTransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> newTransactionStatus(</span><br><span class="line">                definition, transaction, <span class="literal">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">            <span class="comment">// 【启动事务】</span></span><br><span class="line">            doBegin(transaction, definition);</span><br><span class="line">            <span class="comment">// 设置线程上下文变量，方便程序运行期间获取当前事务的一些核心的属性，initSynchronization() 启动同步</span></span><br><span class="line">            prepareSynchronization(status, definition);</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">            <span class="comment">// 恢复现场</span></span><br><span class="line">            resume(<span class="literal">null</span>, suspendedResources);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不支持事务的传播行为</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">        <span class="comment">// 创建事务状态对象</span></span><br><span class="line">        <span class="comment">// 参数2 transaction 是 null 说明当前事务状态是未手动开启事，线程上未绑定任何的连接资源，业务程序执行时需要先去 datasource 获取的 conn，是自动提交事务的，不需要 Spring 再提交事务</span></span><br><span class="line">        <span class="comment">// 参数6 suspendedResources 是 null 说明当前事务状态未挂起任何事务，当前事务执行到后置处理时不需要恢复现场</span></span><br><span class="line">        <span class="keyword">return</span> prepareTransactionStatus(definition, <span class="literal">null</span>, <span class="literal">true</span>, newSynchronization, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DataSourceTransactionManager#doGetTransaction：真正获取事务的方法</p>
<ul>
<li><p><code>DataSourceTransactionObject txObject = new DataSourceTransactionObject()</code>：<strong>创建事务对象</strong></p>
</li>
<li><p><code>txObject.setSavepointAllowed(isNestedAllowed())</code>：设置事务对象是否支持保存点，由事务管理器控制（默认不支持）</p>
</li>
<li><p><code>ConnectionHolder conHolder = TransactionSynchronizationManager.getResource(obtainDataSource())</code>：</p>
<ul>
<li><p>从 ThreadLocal 中获取 conHolder 资源，可能拿到 null 或者不是 null</p>
</li>
<li><p>是 null：举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transaction</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;...b.b()....&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不是 null：执行 b 方法事务增强的前置逻辑时，可以拿到 a 放进去的 conHolder 资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transaction</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;....&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>txObject.setConnectionHolder(conHolder, false)</code>：将 ConnectionHolder 保存到事务对象内，参数二是 false 代表连接资源是上层事务共享的，不是新建的连接资源</p>
</li>
<li><p><code>return txObject</code>：返回事务的对象</p>
</li>
</ul>
<p>DataSourceTransactionManager#doBegin：事务开启的逻辑</p>
<ul>
<li><p><code>txObject = (DataSourceTransactionObject) transaction</code>：强转为事务对象</p>
</li>
<li><p>事务中没有数据库连接资源就要分配：</p>
<p><code>Connection newCon = obtainDataSource().getConnection()</code>：<strong>获取 JDBC 原生的数据库连接对象</strong></p>
<p><code>txObject.setConnectionHolder(new ConnectionHolder(newCon), true)</code>：代表是新开启的事务，新建的连接对象</p>
</li>
<li><p><code>previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)</code>：修改连接属性</p>
<ul>
<li><p><code>if (definition != null &amp;&amp; definition.isReadOnly())</code>：注解（或 XML）配置了只读属性，需要设置</p>
</li>
<li><p><code>if (..definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT)</code>：注解配置了隔离级别</p>
<p><code>int currentIsolation = con.getTransactionIsolation()</code>：获取连接的隔离界别</p>
<p><code>previousIsolationLevel = currentIsolation</code>：保存之前的隔离界别，返回该值</p>
<p><code> con.setTransactionIsolation(definition.getIsolationLevel())</code>：<strong>将当前连接设置为配置的隔离界别</strong></p>
</li>
</ul>
</li>
<li><p><code>txObject.setPreviousIsolationLevel(previousIsolationLevel)</code>：将 Conn 原来的隔离级别保存到事务对象，为了释放 Conn 时重置回原状态</p>
</li>
<li><p><code>if (con.getAutoCommit())</code>：默认会成立，说明还没开启事务</p>
<p><code>txObject.setMustRestoreAutoCommit(true)</code>：保存 Conn 原来的事务状态</p>
<p><code>con.setAutoCommit(false)</code>：<strong>开启事务，JDBC 原生的方式</strong></p>
</li>
<li><p><code>txObject.getConnectionHolder().setTransactionActive(true)</code>：表示 Holder 持有的 Conn 已经手动开启事务了</p>
</li>
<li><p><code>TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder())</code>：将 ConnectionHolder 对象绑定到 ThreadLocal 内，数据源为 key，为了方便获取手动开启事务的连接对象去执行 SQL</p>
</li>
</ul>
<hr>
<h5 id="事务重入"><a href="#事务重入" class="headerlink" title="事务重入"></a>事务重入</h5><p>事务重入的核心处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TransactionStatus <span class="title function_">handleExistingTransaction</span><span class="params">( TransactionDefinition definition, </span></span><br><span class="line"><span class="params">                                                    Object transaction, <span class="type">boolean</span> debugEnabled)</span>&#123;</span><br><span class="line">	<span class="comment">// 传播行为是 PROPAGATION_NEVER，需要以非事务方式执行操作，如果当前事务存在则【抛出异常】</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 传播行为是 PROPAGATION_NOT_SUPPORTED，以非事务方式运行，如果当前存在事务，则【把当前事务挂起】</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</span><br><span class="line">        <span class="comment">// 挂起事务</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(transaction);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">        <span class="comment">// 创建一个非事务的事务状态对象返回</span></span><br><span class="line">        <span class="keyword">return</span> prepareTransactionStatus(definition, <span class="literal">null</span>, <span class="literal">false</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 开启新事物的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</span><br><span class="line">        <span class="comment">// 【挂起当前事务】</span></span><br><span class="line">        <span class="type">SuspendedResourcesHolder</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(transaction);</span><br><span class="line">       	<span class="comment">// 【开启新事物】</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 传播行为是 PROPAGATION_NESTED，嵌套事务</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">        <span class="comment">// Spring 默认不支持内嵌事务</span></span><br><span class="line">        <span class="comment">// 【开启方式】：&lt;property name=&quot;nestedTransactionAllowed&quot; value=&quot;true&quot;&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (!isNestedTransactionAllowed()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedTransactionNotSupportedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (useSavepointForNestedTransaction()) &#123;</span><br><span class="line">            <span class="comment">//  为当前方法创建一个 TransactionStatus 对象，</span></span><br><span class="line">            <span class="type">DefaultTransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span></span><br><span class="line">                prepareTransactionStatus(definition, transaction, <span class="literal">false</span>, <span class="literal">false</span>, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 创建一个 JDBC 的保存点</span></span><br><span class="line">            status.createAndHoldSavepoint();</span><br><span class="line">            <span class="comment">// 不需要使用同步，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Usually only for JTA transaction，开启一个新事务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED，【使用当前的事务】</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">    <span class="keyword">return</span> prepareTransactionStatus(definition, transaction, <span class="literal">false</span>, newSynchronization, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="挂起恢复"><a href="#挂起恢复" class="headerlink" title="挂起恢复"></a>挂起恢复</h5><p>AbstractPlatformTransactionManager#suspend：<strong>挂起事务</strong>，并获得一个上下文信息对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SuspendedResourcesHolder <span class="title function_">suspend</span><span class="params">(<span class="meta">@Nullable</span> Object transaction)</span> &#123;</span><br><span class="line">    <span class="comment">// 事务是同步状态的</span></span><br><span class="line">    <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">        List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (transaction != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// do it</span></span><br><span class="line">                suspendedResources = doSuspend(transaction);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将上层事务绑定在线程上下文的变量全部取出来</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">// 通过被挂起的资源和上层事务的上下文变量，创建一个【SuspendedResourcesHolder】返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SuspendedResourcesHolder</span>(suspendedResources, suspendedSynchronizations, </span><br><span class="line">                                                name, readOnly, isolationLevel, wasActive);</span><br><span class="line">        &#125; <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doSuspend</span><span class="params">(Object transaction)</span> &#123;</span><br><span class="line">    <span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> (DataSourceTransactionObject) transaction;</span><br><span class="line">    <span class="comment">// 将当前方法的事务对象 connectionHolder 属性置为 null，不和上层共享资源</span></span><br><span class="line">    <span class="comment">// 当前方法有可能是不开启事务或者要开启一个独立的事务</span></span><br><span class="line">    txObject.setConnectionHolder(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 【解绑在线程上的事务】</span></span><br><span class="line">    <span class="keyword">return</span> TransactionSynchronizationManager.unbindResource(obtainDataSource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractPlatformTransactionManager#resume：<strong>恢复现场</strong>，根据挂起资源去恢复线程上下文信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resume</span><span class="params">(Object transaction, SuspendedResourcesHolder resourcesHolder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (resourcesHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取被挂起的事务资源</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> resourcesHolder.suspendedResources;</span><br><span class="line">        <span class="keyword">if</span> (suspendedResources != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//绑定上一个事务的 ConnectionHolder 到线程上下文</span></span><br><span class="line">            doResume(transaction, suspendedResources);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;TransactionSynchronization&gt; suspendedSynchronizations = resourcesHolder.suspendedSynchronizations;</span><br><span class="line">        <span class="keyword">if</span> (suspendedSynchronizations != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">            <span class="comment">// 将线程上下文变量恢复为上一个事务的挂起现场</span></span><br><span class="line">            doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doResume</span><span class="params">(<span class="meta">@Nullable</span> Object transaction, Object suspendedResources)</span> &#123;</span><br><span class="line">    <span class="comment">// doSuspend 的逆动作，【绑定资源】</span></span><br><span class="line">    TransactionSynchronizationManager.bindResource(obtainDataSource(), suspendedResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="提交回滚"><a href="#提交回滚" class="headerlink" title="提交回滚"></a>提交回滚</h4><h5 id="回滚方式"><a href="#回滚方式" class="headerlink" title="回滚方式"></a>回滚方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">completeTransactionAfterThrowing</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo, Throwable ex)</span> &#123;</span><br><span class="line">    <span class="comment">// 事务状态信息不为空进入逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 条件二成立 说明目标方法抛出的异常需要回滚事务</span></span><br><span class="line">        <span class="keyword">if</span> (txInfo.transactionAttribute != <span class="literal">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 事务管理器的回滚方法</span></span><br><span class="line">                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行到这里，说明当前事务虽然抛出了异常，但是该异常并不会导致整个事务回滚</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 提交事务</span></span><br><span class="line">                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">rollbackOn</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">    <span class="comment">// 继承自 RuntimeException 或 error 的是【非检查型异常】，才会归滚事务</span></span><br><span class="line">    <span class="comment">// 如果配置了其他回滚错误，会获取到回滚规则 rollbackRules 进行判断</span></span><br><span class="line">    <span class="keyword">return</span> (ex <span class="keyword">instanceof</span> RuntimeException || ex <span class="keyword">instanceof</span> Error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="comment">// 事务已经完成不需要回滚</span></span><br><span class="line">    <span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">DefaultTransactionStatus</span> <span class="variable">defStatus</span> <span class="operator">=</span> (DefaultTransactionStatus) status;</span><br><span class="line">    <span class="comment">// 开始回滚事务</span></span><br><span class="line">    processRollback(defStatus, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractPlatformTransactionManager#processRollback：事务回滚</p>
<ul>
<li><p><code>triggerBeforeCompletion(status)</code>：用来做扩展逻辑，回滚前的前置处理</p>
</li>
<li><p><code>if (status.hasSavepoint())</code>：条件成立说明当前事务是一个<strong>内嵌事务</strong>，当前方法只是复用了上层事务的一个内嵌事务</p>
<p><code>status.rollbackToHeldSavepoint()</code>：内嵌事务加入事务时会创建一个保存点，此时恢复至保存点</p>
</li>
<li><p><code>if (status.isNewTransaction())</code>：说明事务是当前连接开启的，需要去回滚事务</p>
<p><code>doRollback(status)</code>：真正的的回滚函数</p>
<ul>
<li><code>DataSourceTransactionObject txObject = status.getTransaction()</code>：获取事务对象</li>
<li><code>Connection con = txObject.getConnectionHolder().getConnection()</code>：获取连接对象</li>
<li><code>con.rollback()</code>：<strong>JDBC 的方式回滚事务</strong></li>
</ul>
</li>
<li><p><code>else</code>：当前方法是共享的上层的事务，和上层使用同一个 Conn 资源，<strong>共享的事务不能直接回滚，应该交给上层处理</strong></p>
<p><code>doSetRollbackOnly(status)</code>：设置 con.rollbackOnly &#x3D; true，线程回到上层事务 commit 时会检查该字段，然后执行回滚操作</p>
</li>
<li><p><code>triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK)</code>：回滚的后置处理</p>
</li>
<li><p><code>cleanupAfterCompletion(status)</code>：清理和恢复现场</p>
</li>
</ul>
<hr>
<h5 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">commitTransactionAfterReturning</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 事务管理器的提交方法</span></span><br><span class="line">        txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="comment">// 已经完成的事务不需要提交了</span></span><br><span class="line">    <span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">DefaultTransactionStatus</span> <span class="variable">defStatus</span> <span class="operator">=</span> (DefaultTransactionStatus) status;</span><br><span class="line">    <span class="comment">// 条件成立说明是当前的业务强制回滚</span></span><br><span class="line">    <span class="keyword">if</span> (defStatus.isLocalRollbackOnly()) &#123;</span><br><span class="line">        <span class="comment">// 回滚逻辑，</span></span><br><span class="line">        processRollback(defStatus, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 成立说明共享当前事务的【下层事务逻辑出错，需要回滚】</span></span><br><span class="line">    <span class="keyword">if</span> (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</span><br><span class="line">        <span class="comment">// 如果当前事务还是事务重入，会继续抛给上层，最上层事务会进行真实的事务回滚操作</span></span><br><span class="line">        processRollback(defStatus, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 执行提交</span></span><br><span class="line">    processCommit(defStatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractPlatformTransactionManager#processCommit：事务提交</p>
<ul>
<li><p><code>prepareForCommit(status)</code>：前置处理</p>
</li>
<li><p><code>if (status.hasSavepoint())</code>：条件成立说明当前事务是一个<strong>内嵌事务</strong>，只是复用了上层事务</p>
<p><code>status.releaseHeldSavepoint()</code>：清理保存点，因为没有发生任何异常，所以保存点没有存在的意义了</p>
</li>
<li><p><code>if (status.isNewTransaction())</code>：说明事务是归属于当前连接的，需要去提交事务</p>
<p><code>doCommit(status)</code>：真正的提交函数</p>
<ul>
<li><code>Connection con = txObject.getConnectionHolder().getConnection()</code>：获取连接对象</li>
<li><code>con.commit()</code>：<strong>JDBC 的方式提交事务</strong></li>
</ul>
</li>
<li><p><code>doRollbackOnCommitException(status, ex)</code>：<strong>提交事务出错后进行回滚</strong></p>
</li>
<li><p><code> cleanupAfterCompletion(status)</code>：清理和恢复现场</p>
</li>
</ul>
<hr>
<h5 id="清理现场"><a href="#清理现场" class="headerlink" title="清理现场"></a>清理现场</h5><p>恢复上层事务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">cleanupTransactionInfo</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从当前线程的 ThreadLocal 获取上层的事务信息，将当前事务出栈，继续执行上层事务</span></span><br><span class="line">        txInfo.restoreThreadLocalStatus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">restoreThreadLocalStatus</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Use stack to restore old transaction TransactionInfo.</span></span><br><span class="line">    transactionInfoHolder.set(<span class="built_in">this</span>.oldTransactionInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前层级事务结束时的清理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cleanupAfterCompletion</span><span class="params">(DefaultTransactionStatus status)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置当前方法的事务状态为完成状态</span></span><br><span class="line">    status.setCompleted();</span><br><span class="line">    <span class="keyword">if</span> (status.isNewSynchronization()) &#123;</span><br><span class="line">        <span class="comment">// 清理线程上下文变量以及扩展点注册的 sync</span></span><br><span class="line">        TransactionSynchronizationManager.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 事务是当前线程开启的</span></span><br><span class="line">    <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">        <span class="comment">// 解绑资源</span></span><br><span class="line">        doCleanupAfterCompletion(status.getTransaction());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件成立说明当前事务执行的时候，【挂起了一个上层的事务】</span></span><br><span class="line">    <span class="keyword">if</span> (status.getSuspendedResources() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">transaction</span> <span class="operator">=</span> (status.hasTransaction() ? status.getTransaction() : <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 恢复上层事务现场</span></span><br><span class="line">        resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DataSourceTransactionManager#doCleanupAfterCompletion：清理工作</p>
<ul>
<li><p><code>TransactionSynchronizationManager.unbindResource(obtainDataSource())</code>：解绑数据库资源</p>
</li>
<li><p><code>if (txObject.isMustRestoreAutoCommit())</code>：是否恢复连接，Conn 归还到 DataSource<strong>，归还前需要恢复到申请时的状态</strong></p>
<p><code>con.setAutoCommit(true)</code>：恢复连接为自动提交</p>
</li>
<li><p><code>DataSourceUtils.resetConnectionAfterTransaction(con, txObject.getPreviousIsolationLevel())</code>：恢复隔离级别</p>
</li>
<li><p><code>DataSourceUtils.releaseConnection(con, this.dataSource)</code>：<strong>将连接归还给数据库连接池</strong></p>
</li>
<li><p><code>txObject.getConnectionHolder().clear()</code>：清理 ConnectionHolder 资源</p>
</li>
</ul>
<hr>
<h3 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h3><h4 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h4><p>@Component 解析流程：</p>
<ul>
<li><p>注解类启动容器的时，注册 ClassPathBeanDefinitionScanner 到容器，用来扫描 Bean 的相关信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历指定的所有的包，【这就相当于扫描了】</span></span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">        <span class="comment">// 读取当前包下的资源装换为 BeanDefinition，字节流的方式</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">            <span class="comment">// 遍历，封装，类似于 XML 的解析方式，注册到容器中</span></span><br><span class="line">            registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ClassPathScanningCandidateComponentProvider.findCandidateComponents()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title function_">findCandidateComponents</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.componentsIndex != <span class="literal">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;</span><br><span class="line">        <span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="built_in">this</span>.componentsIndex, basePackage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title function_">scanCandidateComponents</span><span class="params">(String basePackage)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX resolveBasePackage(basePackage) + &#39;/&#39; + this.resourcePattern</code> ：将 package 转化为 ClassLoader 类资源搜索路径 packageSearchPath，例如：<code>com.sea.spring.boot</code> 转化为 <code>classpath*:com/sea/spring/boot/**/*.class</code></p>
</li>
<li><p><code>resources = getResourcePatternResolver().getResources(packageSearchPath)</code>：加载路径下的资源</p>
</li>
<li><p><code>for (Resource resource : resources) </code>：遍历所有的资源</p>
<p><code>metadataReader = getMetadataReaderFactory().getMetadataReader(resource)</code>：获取元数据阅读器</p>
<p><code>if (isCandidateComponent(metadataReader))</code>：<strong>当前类不匹配任何排除过滤器，并且匹配一个包含过滤器</strong>，返回 true</p>
<ul>
<li><p>includeFilters 由 <code>registerDefaultFilters()</code> 设置初始值，方法有 @Component，没有 @Service，因为 @Component 是 @Service 的元注解，Spring 在读取 @Service 时也读取了元注解，并将 @Service 作为 @Component 处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.includeFilters.add(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(Component.class))</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span>	<span class="comment">// 拥有了 Component 功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>candidates.add(sbd)</code>：添加到返回结果的 list</p>
</li>
</ul>
</li>
</ul>
<p>参考文章：<a href="https://my.oschina.net/floor/blog/4325651">https://my.oschina.net/floor/blog/4325651</a></p>
<hr>
<h4 id="Autowired"><a href="#Autowired" class="headerlink" title="Autowired"></a>Autowired</h4><p>打开 @Autowired 源码，注释上写 Please consult the javadoc for the AutowiredAnnotationBeanPostProcessor</p>
<p>AutowiredAnnotationBeanPostProcessor 间接实现 InstantiationAwareBeanPostProcessor，就具备了实例化前后（而不是初始化前后）管理对象的能力，实现了 BeanPostProcessor，具有初始化前后管理对象的能力，实现 BeanFactoryAware，具备随时拿到 BeanFactory 的能力，所以这个类<strong>具备一切后置处理器的能力</strong></p>
<p><strong>在容器启动，为对象赋值的时候，遇到 @Autowired 注解，会用后置处理器机制，来创建属性的实例，然后再利用反射机制，将实例化好的属性，赋值给对象上，这就是 Autowired 的原理</strong></p>
<p>作用时机：</p>
<ul>
<li>Spring 在每个 Bean 实例化之后，调用 AutowiredAnnotationBeanPostProcessor 的 <code>postProcessMergedBeanDefinition()</code> 方法，查找该 Bean 是否有 @Autowired 注解，进行相关元数据的获取</li>
<li>Spring 在每个 Bean 调用 <code>populateBean()</code> 进行属性注入的时候，即调用 <code>postProcessProperties()</code> 方法，查找该 Bean 属性是否有 @Autowired 注解，进行相关数据的填充</li>
</ul>
<hr>
<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><h2 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>SpringMVC：是一种基于 Java 实现 MVC 模型的轻量级 Web 框架</p>
<p>SpringMVC 优点：</p>
<ul>
<li>使用简单</li>
<li>性能突出（对比现有的框架技术）</li>
<li>灵活性强</li>
</ul>
<p>软件开发三层架构：</p>
<ul>
<li><p>表现层：负责数据展示</p>
</li>
<li><p>业务层：负责业务处理</p>
</li>
<li><p>数据层：负责数据操作</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-MVC%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png"></p>
</li>
</ul>
<p>MVC（Model View Controller），一种用于设计创建Web应用程序表现层的模式</p>
<ul>
<li><p>Model（模型）：数据模型，用于封装数据</p>
</li>
<li><p>View（视图）：页面视图，用于展示数据</p>
<ul>
<li>jsp  </li>
<li>html</li>
</ul>
</li>
</ul>
<ul>
<li><p>Controller（控制器）：处理用户交互的调度器，用于根据用户需求处理程序逻辑</p>
<ul>
<li>Servlet</li>
<li>SpringMVC</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-MVC%E5%8A%9F%E8%83%BD%E5%9B%BE%E7%A4%BA.png"></p>
</li>
</ul>
<p>参考视频：<a href="https://space.bilibili.com/37974444/">https://space.bilibili.com/37974444/</a></p>
<hr>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="入门项目-2"><a href="#入门项目-2" class="headerlink" title="入门项目"></a>入门项目</h3><p>流程分析：</p>
<ul>
<li>服务器启动<ol>
<li>加载 web.xml 中 DispatcherServlet</li>
<li>读取 spring-mvc.xml 中的配置，加载所有 controller 包中所有标记为 bean 的类</li>
<li>读取 bean 中方法上方标注 @RequestMapping 的内容</li>
</ol>
</li>
<li>处理请求<ol>
<li>DispatcherServlet 配置拦截所有请求 &#x2F;</li>
<li>使用请求路径与所有加载的 @RequestMapping 的内容进行比对</li>
<li>执行对应的方法</li>
<li>根据方法的返回值在 webapp 目录中查找对应的页面并展示</li>
</ol>
</li>
</ul>
<p>代码实现：</p>
<ul>
<li><p>pom.xml 导入坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring_base_config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- servlet3.0规范的坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jsp坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring的坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--springmvc的坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--构建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--具体的插件配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设定具体 Controller，控制层 java &#x2F; controller &#x2F; UserController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span>  <span class="comment">//@Component衍生注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">//设定当前方法的访问映射地址，等同于Servlet在web.xml中的配置</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="comment">//设置当前方法返回值类型为String，用于指定请求完成后跳转的页面</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user mvc controller is running ...&quot;</span>);</span><br><span class="line">        <span class="comment">//设定具体跳转的页面</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>webapp &#x2F; WEB-INF &#x2F; web.xml，配置SpringMVC核心控制器，请求转发到对应的具体业务处理器Controller中（等同于Servlet配置）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置Servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--加载Spring控制文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>resouces &#x2F; spring-mvc.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描加载所有的控制类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="加载控制-1"><a href="#加载控制-1" class="headerlink" title="加载控制"></a>加载控制</h3><p>Controller 加载控制：SpringMVC 的处理器对应的 bean 必须按照规范格式开发，未避免加入无效的 bean 可通过 bean 加载过滤器进行包含设定或排除设定，表现层 bean 标注通常设定为 @Controller  </p>
<ul>
<li><p>resources &#x2F; spring-mvc.xml 配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.seazean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> </span></span><br><span class="line"><span class="tag">						<span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> </span></span><br><span class="line"><span class="tag">						<span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>静态资源加载（webapp 目录下的相关资源），spring-mvc.xml 配置，开启 mvc 命名空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--放行指定类型静态资源配置方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/img/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/img/&quot;</span>/&gt;</span> <span class="comment">&lt;!--webapp/img/资源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/css/&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--SpringMVC 提供的通用资源放行方式，建议选择--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>中文乱码处理 SpringMVC 提供专用的中文字符过滤器，用于处理乱码问题。配置在 web.xml 里面</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--乱码处理过滤器，与Servlet中使用的完全相同，差异之处在于处理器的类由Spring提供--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="注解驱动-1"><a href="#注解驱动-1" class="headerlink" title="注解驱动"></a>注解驱动</h3><p>WebApplicationContext，生成 Spring 核心容器（主容器&#x2F;父容器&#x2F;根容器）</p>
<ul>
<li>父容器：Spring 环境加载后形成的容器，包含 Spring 环境下的所有的 bean</li>
<li>子容器：当前 mvc 环境加载后形成的容器，不包含 Spring 环境下的 bean</li>
<li>子容器可以访问父容器中的资源，父容器不可以访问子容器的资源</li>
</ul>
<p>EnableWebMvc 注解作用：</p>
<ul>
<li>支持 ConversionService 的配置，可以方便配置自定义类型转换器</li>
<li>支持 @NumberFormat 注解格式化数字类型</li>
<li>支持 @DateTimeFormat 注解格式化日期数据，日期包括 Date、Calendar</li>
<li>支持 @Valid 的参数校验（需要导入 JSR-303 规范）</li>
<li>配合第三方 jar 包和 SpringMVC 提供的注解读写 XML 和 JSON 格式数据</li>
</ul>
<p>纯注解开发：</p>
<ul>
<li><p>使用注解形式转化 SpringMVC 核心配置文件为配置类 java &#x2F; config &#x2F;  SpringMVCConfiguration.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.seazean&quot;, includeFilters = @ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">    								type=FilterType.ANNOTATION,</span></span><br><span class="line"><span class="meta">    								classes = &#123;Controller.class&#125; )</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="comment">//等同于&lt;mvc:annotation-driven/&gt;，还不完全相同</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMVCConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>&#123;</span><br><span class="line">    <span class="comment">//注解配置通用放行资源的格式 建议使用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于 servlet3.0 规范，自定义 Servlet 容器初始化配置类，加载 SpringMVC 核心配置类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">//创建Servlet容器时，使用注解方式加载SPRINGMVC配置类中的信息，</span></span><br><span class="line">    <span class="comment">//并加载成WEB专用的ApplicationContext对象该对象放入了ServletContext范围，</span></span><br><span class="line">    <span class="comment">//在整个WEB容器中可以随时获取调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        A.C.W.<span class="type">A</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        ctx.register(SpringMVCConfiguration.class);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注解配置映射地址方式，服务于SpringMVC的核心控制器DispatcherServlet</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//乱码处理作为过滤器，在servlet容器启动时进行配置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStartup(servletContext);</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">cef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        cef.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        FilterRegistration.<span class="type">Dynamic</span> <span class="variable">registration</span> <span class="operator">=</span> servletContext.addFilter(<span class="string">&quot;characterEncodingFilter&quot;</span>, cef);</span><br><span class="line">        registration.addMappingForUrlPatterns(EnumSet.of(</span><br><span class="line">           			DispatcherType.REQUEST,</span><br><span class="line">            		DispatcherType.FORWARD,</span><br><span class="line">            		DispatcherType.INCLUDE), <span class="literal">false</span>,<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="请求映射"><a href="#请求映射" class="headerlink" title="请求映射"></a>请求映射</h3><p>名称：@RequestMapping</p>
<p>类型：方法注解、类注解</p>
<p>位置：处理器类中的方法定义上方、处理器类定义上方</p>
<ul>
<li><p>方法注解</p>
<p>作用：绑定请求地址与对应处理方法间的关系</p>
<p>无类映射地址访问格式： <a href="http://localhost/requestURL2">http://localhost/requestURL2</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/requestURL2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">requestURL2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类注解</p>
<p>作用：为当前处理器中所有方法设定公共的访问路径前缀</p>
<p>带有类映射地址访问格式，将类映射地址作为前缀添加在实际映射地址前面：**&#x2F;user&#x2F;requestURL1**</p>
<p>最终返回的页面如果未设定绝对访问路径，将从类映射地址所在目录中查找 <strong>webapp&#x2F;user&#x2F;page.jsp</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/requestURL2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">requestURL2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>常用属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">    value=&quot;/requestURL3&quot;, //设定请求路径，与path属性、 value属性相同</span></span><br><span class="line"><span class="meta">    method = RequestMethod.GET, //设定请求方式</span></span><br><span class="line"><span class="meta">    params = &quot;name&quot;, //设定请求参数条件</span></span><br><span class="line"><span class="meta">    headers = &quot;content-type=text/*&quot;, //设定请求消息头条件</span></span><br><span class="line"><span class="meta">    consumes = &quot;text/*&quot;, //用于指定可以接收的请求正文类型（MIME类型）</span></span><br><span class="line"><span class="meta">    produces = &quot;text/*&quot; //用于指定可以生成的响应正文类型（MIME类型）</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestURL3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h3><h4 id="普通类型"><a href="#普通类型" class="headerlink" title="普通类型"></a>普通类型</h4><p>SpringMVC 将传递的参数封装到处理器方法的形参中，达到快速访问参数的目的</p>
<ul>
<li><p>访问 URL：<a href="http://localhost/requestParam1?name=seazean&amp;age=14">http://localhost/requestParam1?name=seazean&amp;age=14</a>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/requestParam1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">requestParam1</span><span class="params">(String name ,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name=&quot;</span> + name + <span class="string">&quot;,age=&quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html;UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;h1&gt;请求参数测试页面&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>@RequestParam 的使用：</p>
<ul>
<li><p>类型：形参注解</p>
</li>
<li><p>位置：处理器类中的方法形参前方</p>
</li>
<li><p>作用：绑定请求参数与对应处理方法形参间的关系</p>
</li>
<li><p>访问 URL：<a href="http://localhost/requestParam2?userName=Jock">http://localhost/requestParam2?userName=Jock</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam2</span><span class="params">(<span class="meta">@RequestParam(</span></span></span><br><span class="line"><span class="meta"><span class="params">                            name = &quot;userName&quot;,</span></span></span><br><span class="line"><span class="meta"><span class="params">                            required = true,	//为true代表必须有参数</span></span></span><br><span class="line"><span class="meta"><span class="params">                            defaultValue = &quot;s&quot;)</span> String name)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name=&quot;</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="POJO类型"><a href="#POJO类型" class="headerlink" title="POJO类型"></a>POJO类型</h4><h5 id="简单类型"><a href="#简单类型" class="headerlink" title="简单类型"></a>简单类型</h5><p>当 POJO 中使用简单类型属性时， 参数名称与 POJO 类属性名保持一致  </p>
<ul>
<li><p>访问 URL： <a href="http://localhost/requestParam3?name=seazean&amp;age=14">http://localhost/requestParam3?name=seazean&amp;age=14</a>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam3</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name=&quot;</span> + user.getName());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="参数冲突"><a href="#参数冲突" class="headerlink" title="参数冲突"></a>参数冲突</h5><p>当 POJO 类型属性与其他形参出现同名问题时，将被<strong>同时赋值</strong>，建议使用 @RequestParam 注解进行区分</p>
<ul>
<li><p>访问 URL： <a href="http://localhost/requestParam4?name=seazean&amp;age=14">http://localhost/requestParam4?name=seazean&amp;age=14</a>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam4</span><span class="params">(User user, String age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user.age=&quot;</span> + user.getAge() + <span class="string">&quot;,age=&quot;</span> + age);<span class="comment">//14 14 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h5><p>当 POJO 中出现对象属性时，参数名称与对象层次结构名称保持一致  </p>
<ul>
<li><p>访问 URL： <a href="http://localhost/requestParam5?address.province=beijing">http://localhost/requestParam5?address.province=beijing</a>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam5</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user.address=&quot;</span> + user.getAddress().getProvince());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Address address; <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="容器类型"><a href="#容器类型" class="headerlink" title="容器类型"></a>容器类型</h5><p>POJO 中出现集合类型的处理方式</p>
<ul>
<li><p>通过 URL 地址中同名参数，可以为 POJO 中的集合属性进行赋值，集合属性要求保存简单数据</p>
<p>访问 URL：<a href="http://localhost/requestParam6?nick=Jock1&amp;nick=Jockme&amp;nick=zahc">http://localhost/requestParam6?nick=Jock1&amp;nick=Jockme&amp;nick=zahc</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam6</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user=&quot;</span> + user);</span><br><span class="line">    <span class="comment">//user = User&#123;name=&#x27;null&#x27;,age=null,nick=&#123;Jock1,Jockme,zahc&#125;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; nick;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>POJO 中出现 List 保存对象数据，参数名称与对象层次结构名称保持一致，使用数组格式描述集合中对象的位置访问 URL：<a href="http://localhost/requestParam7?addresses%5B0%5D.province=bj&amp;addresses%5B1%5D.province=tj">http://localhost/requestParam7?addresses[0].province=bj&amp;addresses[1].province=tj</a>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam7&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam7</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user.addresses=&quot;</span> + user.getAddress());</span><br><span class="line">    <span class="comment">//&#123;Address&#123;provice=bj,city=&#x27;null&#x27;,address=&#x27;null&#x27;&#125;&#125;,&#123;Address&#123;....&#125;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Address&gt; addresses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>POJO 中出现 Map 保存对象数据，参数名称与对象层次结构名称保持一致，使用映射格式描述集合中对象位置</p>
<p>URL: <a href="http://localhost/requestParam8?addressMap%5B%E2%80%99home%E2%80%99%5D.province=bj&amp;addressMap%5B%E2%80%99job%E2%80%99%5D.province=tj">http://localhost/requestParam8?addressMap[’home’].province=bj&amp;addressMap[’job’].province=tj</a>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam8&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam8</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user.addressMap=&quot;</span> + user.getAddressMap());</span><br><span class="line">    <span class="comment">//user.addressMap=&#123;home=Address&#123;p=,c=,a=&#125;,job=Address&#123;....&#125;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Address&gt; addressMap;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="数组集合"><a href="#数组集合" class="headerlink" title="数组集合"></a>数组集合</h4><h5 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h5><p>请求参数名与处理器方法形参名保持一致，且请求参数数量＞ 1个  </p>
<ul>
<li><p>访问 URL： <a href="http://localhost/requestParam9?nick=Jockme&amp;nick=zahc">http://localhost/requestParam9?nick=Jockme&amp;nick=zahc</a>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam9&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam9</span><span class="params">(String[] nick)</span>&#123;</span><br><span class="line">    System.out.println(nick[<span class="number">0</span>] + <span class="string">&quot;,&quot;</span> + nick[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h5><p>保存简单类型数据，请求参数名与处理器方法形参名保持一致，且请求参数数量＞ 1个</p>
<ul>
<li><p>访问 URL： <a href="http://localhost/requestParam10?nick=Jockme&amp;nick=zahc">http://localhost/requestParam10?nick=Jockme&amp;nick=zahc</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam10&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam10</span><span class="params">(<span class="meta">@RequestParam(&quot;nick&quot;)</span> List&lt;String&gt; nick)</span>&#123;</span><br><span class="line">    System.out.println(nick);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意： SpringMVC 默认将 List 作为对象处理，赋值前先创建对象，然后将 nick <strong>作为对象的属性</strong>进行处理。List 是接口无法创建对象，报无法找到构造方法异常；修复类型为可创建对象的 ArrayList 类型后，对象可以创建但没有 nick 属性，因此数据为空<br>解决方法：需要告知 SpringMVC 的处理器 nick 是一组数据，而不是一个单一属性。通过 @RequestParam 注解，将数量大于 1 个 names 参数打包成参数数组后， SpringMVC 才能识别该数据格式，并判定形参类型是否为数组或集合，并按数组或集合对象的形式操作数据</p>
</li>
</ul>
<hr>
<h4 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h4><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>开启转换配置：<code>&lt;mvc:annotation-driven /&gt;  </code><br>作用：提供 Controller 请求转发，Json 自动转换等功能</p>
<p>如果访问 URL：<a href="http://localhost/requestParam1?name=seazean&amp;age=seazean%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%8A%A5%E9%94%99%EF%BC%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%BC%82%E5%B8%B8">http://localhost/requestParam1?name=seazean&amp;age=seazean，会出现报错，类型转化异常</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam1</span><span class="params">(String name ,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name=&quot;</span> + name + <span class="string">&quot;,age=&quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringMVC 对接收的数据进行自动类型转换，该工作通过 Converter 接口实现：</p>
<ul>
<li><p>标量转换器</p>
</li>
<li><p>集合、数组相关转换器</p>
</li>
<li><p>默认转换器</p>
</li>
</ul>
<hr>
<h5 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h5><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-date%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png"></p>
<p>如果访问 URL：<a href="http://localhost/requestParam11?date=1999-09-09">http://localhost/requestParam11?date=1999-09-09</a> 会报错，所以需要日期类型转换</p>
<ul>
<li><p>声明自定义的转换格式并覆盖系统转换格式，配置 resources &#x2F; spring-mvc.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--5.启用自定义Converter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1.设定格式类型Converter，注册为Bean，受SpringMVC管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2.自定义Converter格式类型设定，该设定使用的是同类型覆盖的思想--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;formatters&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--3.使用set保障相同类型的转换器仅保留一个，避免冲突--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--4.设置具体的格式类型--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.format.datetime.DateFormatter&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--5.类型规则--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yyyy-MM-dd&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>@DateTimeFormat<br>类型：形参注解、成员变量注解<br>位置：形参前面 或 成员变量上方<br>作用：为当前参数或变量指定类型转换规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam12</span><span class="params">(<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date date)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;date=&quot;</span> + date);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date date;</span><br></pre></td></tr></table></figure>

<p>依赖注解驱动支持，xml 开启配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span>  </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="自定义-1"><a href="#自定义-1" class="headerlink" title="自定义"></a>自定义</h5><p>自定义类型转换器，实现 Converter 接口或者直接容器中注入：</p>
<ul>
<li><p>方式一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">webMvcConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">                  registry.addConverter(<span class="keyword">new</span> <span class="title class_">Converter</span>&lt;String, Date&gt;() &#123;</span><br><span class="line">                      <span class="meta">@Override</span></span><br><span class="line">                      <span class="keyword">public</span> Pet <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line">                      	<span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">                          <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                          <span class="comment">//类型转换器无法预计使用过程中出现的异常，因此必须在类型转换器内部捕获，</span></span><br><span class="line">                          <span class="comment">//不允许抛出，框架无法预计此类异常如何处理</span></span><br><span class="line">                          <span class="keyword">try</span> &#123;</span><br><span class="line">                              date = df.parse(source);</span><br><span class="line">                          &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                              e.printStackTrace();</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">return</span> date;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">* 方式二：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="comment">//本例中的泛型填写的是String，Date，最终出现字符串转日期时，该类型转换器生效</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDateConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String, Date&gt; &#123;</span><br><span class="line">      <span class="comment">//重写接口的抽象方法，参数由泛型决定</span></span><br><span class="line">      <span class="keyword">public</span> Date <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line">          <span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">          <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">          <span class="comment">//类型转换器无法预计使用过程中出现的异常，因此必须在类型转换器内部捕获，</span></span><br><span class="line">          <span class="comment">//不允许抛出，框架无法预计此类异常如何处理</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              date = df.parse(source);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> date;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>配置 resources &#x2F; spring-mvc.xml，注册自定义转换器，将功能加入到 SpringMVC 转换服务 ConverterService 中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.将自定义Converter注册为Bean，受SpringMVC管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDateConverter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;converter.MyDateConverter&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2.设定自定义Converter服务bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3.注入所有的自定义Converter，该设定使用的是同类型覆盖的思想--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--4.set保障同类型转换器仅保留一个，去重规则以Converter&lt;S,T&gt;的泛型为准--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--5.具体的类型转换器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;myDateConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--开启注解驱动，加载自定义格式化转换器对应的类型转换服务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用转换器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/requestParam12&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">requestParam12</span><span class="params">(Date date)</span>&#123;</span><br><span class="line">    System.out.println(date);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h3><h4 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h4><p>请求转发和重定向：</p>
<ul>
<li><p>请求转发：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/showPage1&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">showPage1</span><span class="params">()</span> &#123;</span><br><span class="line">   	 	System.out.println(<span class="string">&quot;user mvc controller is running ...&quot;</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;forward:/WEB-INF/page/page.jsp;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>请求重定向：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showPage2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">showPage2</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user mvc controller is running ...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/WEB-INF/page/page.jsp&quot;</span>;<span class="comment">//不能访问WEB-INF下的资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>页面访问快捷设定（InternalResourceViewResolver）：</p>
<ul>
<li><p>展示页面的保存位置通常固定且结构相似，可以设定通用的访问路径简化页面配置，配置 spring-mvc.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>简化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showPage3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">showPage3</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user mvc controller is running...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/showPage4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">showPage4</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user mvc controller is running...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:page&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/showPage5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">showPage5</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user mvc controller is running...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:page&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果未设定了返回值，使用 void 类型，则默认使用访问路径作页面地址的前缀后缀</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最简页面配置方式，使用访问路径作为页面名称，省略返回值</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/showPage6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showPage6</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user mvc controller is running ...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="数据跳转"><a href="#数据跳转" class="headerlink" title="数据跳转"></a>数据跳转</h4><p>ModelAndView 是 SpringMVC 提供的一个对象，该对象可以用作控制器方法的返回值（Model 同），实现携带数据跳转</p>
<p>作用：</p>
<ul>
<li>设置数据，向请求域对象中存储数据</li>
<li>设置视图，逻辑视图</li>
</ul>
<p>代码实现：</p>
<ul>
<li><p>使用 HttpServletRequest 类型形参进行数据传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/showPageAndData1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">showPageAndData1</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;seazean&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Model 类型形参进行数据传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showPageAndData2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">showPageAndData2</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;seazean&quot;</span>);</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">    book.setName(<span class="string">&quot;SpringMVC入门实战&quot;</span>);</span><br><span class="line">    book.setPrice(<span class="number">66.6d</span>);</span><br><span class="line">    <span class="comment">//添加数据的方式，key对value</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;book&quot;</span>,book);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 ModelAndView 类型形参进行数据传递，将该对象作为返回值传递给调用者  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showPageAndData3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">showPageAndData3</span><span class="params">(ModelAndView modelAndView)</span> &#123;</span><br><span class="line">    <span class="comment">//ModelAndView mav = new ModelAndView(); 替换形参中的参数</span></span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">    book.setName(<span class="string">&quot;SpringMVC入门案例&quot;</span>);</span><br><span class="line">    book.setPrice(<span class="number">66.66d</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据的方式，key对value</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;book&quot;</span>,book);</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Jockme&quot;</span>);</span><br><span class="line">    <span class="comment">//设置页面的方式，该方法最后一次执行的结果生效</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;page&quot;</span>);</span><br><span class="line">    <span class="comment">//返回值设定成ModelAndView对象</span></span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ModelAndView 扩展</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ModelAndView对象支持转发的手工设定，该设定不会启用前缀后缀的页面拼接格式</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/showPageAndData4&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">showPageAndData4</span><span class="params">(ModelAndView modelAndView)</span> &#123;</span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;forward:/WEB-INF/page/page.jsp&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ModelAndView对象支持重定向的手工设定，该设定不会启用前缀后缀的页面拼接格式</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/showPageAndData5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">showPageAndData6</span><span class="params">(ModelAndView modelAndView)</span> &#123;</span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;redirect:page.jsp&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>注解：@ResponseBody</p>
<p>作用：将 Controller 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到 Response 的 body 区。如果返回值是字符串，那么直接将字符串返回客户端；如果是一个对象，会<strong>将对象转化为 JSON</strong>，返回客户端</p>
<p>注意：当方法上面没有写 ResponseBody，底层会将方法的返回值封装为 ModelAndView 对象</p>
<ul>
<li><p>使用 HttpServletResponse 对象响应数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/showData1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showData1</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <strong>@ResponseBody 将返回的结果作为响应内容</strong>（页面显示），而非响应的页面名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showData2&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">showData2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;name&#x27;:&#x27;Jock&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 jackson 进行 json 数据格式转化</p>
<p>导入坐标：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--json相关坐标3个--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showData3&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">showData3</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">    book.setName(<span class="string">&quot;SpringMVC入门案例&quot;</span>);</span><br><span class="line">    book.setPrice(<span class="number">66.66d</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="keyword">return</span> om.writeValueAsString(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 SpringMVC 提供的消息类型转换器将对象与集合数据自动转换为 JSON 数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用SpringMVC注解驱动，对标注@ResponseBody注解的控制器方法进行结果转换，由于返回值为引用类型，自动调用jackson提供的类型转换器进行格式转换</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/showData4&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">showData4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">    book.setName(<span class="string">&quot;SpringMVC入门案例&quot;</span>);</span><br><span class="line">    book.setPrice(<span class="number">66.66d</span>);</span><br><span class="line">    <span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>手工添加信息类型转换器  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.</span></span></span><br><span class="line"><span class="string"><span class="tag">             annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.</span></span></span><br><span class="line"><span class="string"><span class="tag">                      json.MappingJackson2HttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">&lt;/bean</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 SpringMVC 注解驱动：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启springmvc注解驱动，对@ResponseBody的注解进行格式增强，追加其类型转换的功能，具体实现由MappingJackson2HttpMessageConverter进行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>转换集合类型数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/showData5&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> List <span class="title function_">showData5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book1</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">    book1.setName(<span class="string">&quot;SpringMVC入门案例&quot;</span>);</span><br><span class="line">    book1.setPrice(<span class="number">66.66d</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Book</span> <span class="variable">book2</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">    book2.setName(<span class="string">&quot;SpringMVC入门案例&quot;</span>);</span><br><span class="line">    book2.setPrice(<span class="number">66.66d</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">al</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    al.add(book1);</span><br><span class="line">    al.add(book2);</span><br><span class="line">    <span class="keyword">return</span> al;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="Restful"><a href="#Restful" class="headerlink" title="Restful"></a>Restful</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Rest（REpresentational State Transfer）：表现层状态转化，定义了<strong>资源在网络传输中以某种表现形式进行状态转移</strong>，即网络资源的访问方式</p>
<ul>
<li>资源：把真实的对象数据称为资源，一个资源既可以是一个集合，也可以是单个个体；每一种资源都有特定的 URI（统一资源标识符）与之对应，如果获取这个资源，访问这个 URI 就可以，比如获取特定的班级 <code>/class/12</code>；资源也可以包含子资源，比如 <code>/classes/classId/teachers</code> 某个指定班级的所有老师</li>
<li>表现形式：资源是一种信息实体，它可以有多种外在表现形式，把资源具体呈现出来的形式比如 json、xml、image、txt 等等叫做它的”表现层&#x2F;表现形式”</li>
<li>状态转移：描述的服务器端资源的状态，比如增删改查（通过 HTTP 动词实现）引起资源状态的改变，互联网通信协议 HTTP 协议，是一个<strong>无状态协议</strong>，所有的资源状态都保存在服务器端</li>
</ul>
<hr>
<h4 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h4><p>Restful 是按照 Rest 风格访问网络资源</p>
<ul>
<li>传统风格访问路径：<a href="http://localhost/user/get?id=1">http://localhost/user/get?id=1</a></li>
<li>Rest 风格访问路径：<a href="http://localhost/user/1">http://localhost/user/1</a></li>
</ul>
<p>优点：隐藏资源的访问行为，通过地址无法得知做的是何种操作，书写简化</p>
<p>Restful 请求路径简化配置方式：<code>@RestController = @Controller + @ResponseBody</code></p>
<p>相关注解：@GetMapping 注解是 @RequestMapping 注解的衍生，所以效果是一样的，建议使用 @GetMapping </p>
<ul>
<li><p><code>@GetMapping(&quot;/poll&quot;)</code> &#x3D; <code>@RequestMapping(value = &quot;/poll&quot;,method = RequestMethod.GET)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(method = RequestMethod.GET)</span>			<span class="comment">// @GetMapping 就拥有了 @RequestMapping 的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GetMapping &#123;</span><br><span class="line">    <span class="meta">@AliasFor(annotation = RequestMapping.class)</span>	<span class="comment">// 与 RequestMapping 相通</span></span><br><span class="line">	String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@PostMapping(&quot;/push&quot;)</code> &#x3D; <code>@RequestMapping(value = &quot;/push&quot;,method = RequestMethod.POST)</code></p>
</li>
</ul>
<p>过滤器：HiddenHttpMethodFilter 是 SpringMVC 对 Restful 风格的访问支持的过滤器</p>
<p>代码实现：</p>
<ul>
<li><p>restful.jsp：</p>
<ul>
<li><p>页面表单<strong>使用隐藏域提交请求类型</strong>，参数名称固定为 _method，必须配合提交类型 method&#x3D;post 使用</p>
</li>
<li><p>GET 请求通过地址栏可以发送，也可以通过设置 form 的请求方式提交</p>
</li>
<li><p>POST 请求必须通过 form 的请求方式提交</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>restful风格请求表单<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--切换请求路径为restful风格--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--一隐藏域，切换为PUT请求或DELETE请求，但是form表单的提交方式method属性必须填写post--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PUT&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;REST-PUT 提交&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>java &#x2F; controller &#x2F; UserController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span>				<span class="comment">//设置rest风格的控制器</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/&quot;)</span>	<span class="comment">//设置公共访问路径，配合下方访问路径使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GET-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">saveUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;POST-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">putUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PUT-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DELETE-张三&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置拦截器 web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器，解析请求中的参数_method，否则无法发起PUT请求与DELETE请求，配合页面表单使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="参数注解"><a href="#参数注解" class="headerlink" title="参数注解"></a>参数注解</h4><p>Restful 开发中的参数注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 @PathVariable 注解获取路径上配置的具名变量，一般在有多个参数的时候添加</p>
<p>其他注解：</p>
<ul>
<li>@RequestHeader：获取请求头</li>
<li>@RequestParam：获取请求参数（指问号后的参数，url?a&#x3D;1&amp;b&#x3D;2）</li>
<li>@CookieValue：获取 Cookie 值</li>
<li>@RequestAttribute：获取 request 域属性</li>
<li>@RequestBody：获取请求体 [POST]</li>
<li>@MatrixVariable：矩阵变量</li>
<li>@ModelAttribute：自定义类型变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span>	</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">//rest风格访问路径简化书写方式，配合类注解@RequestMapping使用</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">restLocation2</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;restful is running ....get:&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@RequestMapping(value = &quot;&#123;id&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;restful is running ....get:&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">post</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;restful is running ....post:&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">put</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;restful is running ....put:&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;restful is running ....delete:&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="识别原理"><a href="#识别原理" class="headerlink" title="识别原理"></a>识别原理</h4><p>表单提交要使用 REST 时，会带上 <code>_method=PUT</code>，请求过来被 <code>HiddenHttpMethodFilter</code> 拦截，进行过滤操作</p>
<p>org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HiddenHttpMethodFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="comment">// 兼容的请求 PUT、DELETE、PATCH</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; ALLOWED_METHODS =</span><br><span class="line">			Collections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(),</span><br><span class="line">					HttpMethod.DELETE.name(), HttpMethod.PATCH.name()));</span><br><span class="line">    <span class="comment">// 隐藏域的名字</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_METHOD_PARAM</span> <span class="operator">=</span> <span class="string">&quot;_method&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">methodParam</span> <span class="operator">=</span> DEFAULT_METHOD_PARAM;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                    FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">requestToUse</span> <span class="operator">=</span> request;</span><br><span class="line">        <span class="comment">// 请求必须是 POST，</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取标签中 name=&quot;_method&quot; 的 value 值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">paramValue</span> <span class="operator">=</span> request.getParameter(<span class="built_in">this</span>.methodParam);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(paramValue)) &#123;</span><br><span class="line">                <span class="comment">// 转成大写</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> paramValue.toUpperCase(Locale.ENGLISH);</span><br><span class="line">                <span class="comment">// 兼容的请求方式</span></span><br><span class="line">                <span class="keyword">if</span> (ALLOWED_METHODS.contains(method)) &#123;</span><br><span class="line">                    <span class="comment">// 包装请求</span></span><br><span class="line">                    requestToUse = <span class="keyword">new</span> <span class="title class_">HttpMethodRequestWrapper</span>(request, method);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requesWrapper的</span></span><br><span class="line">        filterChain.doFilter(requestToUse, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rest 使用客户端工具，如 Postman 可直接发送 put、delete 等方式请求不被过滤</p>
<p>改变默认的 <code>_method</code> 的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span>&#123;</span><br><span class="line">    <span class="comment">//自定义filter</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HiddenHttpMethodFilter <span class="title function_">hiddenHttpMethodFilter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">HiddenHttpMethodFilter</span> <span class="variable">methodFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HiddenHttpMethodFilter</span>();</span><br><span class="line">        <span class="comment">//通过set 方法自定义</span></span><br><span class="line">        methodFilter.setMethodParam(<span class="string">&quot;_m&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> methodFilter;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>SpringMVC 提供访问原始 Servlet 接口的功能</p>
<ul>
<li><p>SpringMVC 提供访问原始 Servlet 接口 API 的功能，通过形参声明即可 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/servletApi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">servletApi</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                         HttpServletResponse response, HttpSession session)</span>&#123;</span><br><span class="line">    System.out.println(request);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    System.out.println(session);</span><br><span class="line">    request.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;seazean&quot;</span>);</span><br><span class="line">    System.out.println(request.getAttribute(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Head 数据获取快捷操作方式<br>名称：@RequestHeader<br>类型：形参注解<br>位置：处理器类中的方法形参前方<br>作用：绑定请求头数据与对应处理方法形参间的关系<br>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">快捷操作方式<span class="meta">@RequestMapping(&quot;/headApi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">headApi</span><span class="params">(<span class="meta">@RequestHeader(&quot;Accept-Language&quot;)</span> String headMsg)</span>&#123;</span><br><span class="line">    System.out.println(headMsg);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page&quot;</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>Cookie 数据获取快捷操作方式<br>名称：@CookieValue<br>类型：形参注解<br>位置：处理器类中的方法形参前方<br>作用：绑定请求 Cookie 数据与对应处理方法形参间的关系<br>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/cookieApi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">cookieApi</span><span class="params">(<span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String jsessionid)</span>&#123;</span><br><span class="line">    System.out.println(jsessionid);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page&quot;</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>Session 数据获取<br>名称：@SessionAttribute<br>类型：形参注解<br>位置：处理器类中的方法形参前方<br>作用：绑定请求Session数据与对应处理方法形参间的关系<br>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/sessionApi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sessionApi</span><span class="params">(<span class="meta">@SessionAttribute(&quot;name&quot;)</span> String name)</span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于在session中放入数据</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/setSessionData&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">setSessionData</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;seazean&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Session 数据设置<br>名称：@SessionAttributes<br>类型：类注解<br>位置：处理器类上方<br>作用：声明放入session范围的变量名称，适用于Model类型数据传参<br>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">//设定当前类中名称为age和gender的变量放入session范围，不常用</span></span><br><span class="line"><span class="meta">@SessionAttributes(names = &#123;&quot;age&quot;,&quot;gender&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletController</span> &#123;</span><br><span class="line">	<span class="comment">//将数据放入session存储范围，Model对象实现数据set，@SessionAttributes注解实现范围设定</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/setSessionData2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">setSessionDate2</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;age&quot;</span>,<span class="number">39</span>);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;gender&quot;</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/sessionApi&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sessionApi</span><span class="params">(<span class="meta">@SessionAttribute(&quot;age&quot;)</span> <span class="type">int</span> age,</span></span><br><span class="line"><span class="params">                             <span class="meta">@SessionAttribute(&quot;gender&quot;)</span> String gender)</span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>spring-mvc.xml 配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.seazean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/page/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="运行原理-1"><a href="#运行原理-1" class="headerlink" title="运行原理"></a>运行原理</h2><h3 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h3><h4 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h4><p>核心组件：</p>
<ul>
<li><p>DispatcherServlet：核心控制器， 是 SpringMVC 的核心，整体流程控制的中心，所有的请求第一步都先到达这里，由其调用其它组件处理用户的请求，它就是在 web.xml 配置的核心 Servlet，有效的降低了组件间的耦合性</p>
</li>
<li><p>HandlerMapping：处理器映射器， 负责根据请求找到对应具体的 Handler 处理器，SpringMVC 中针对配置文件方式、注解方式等提供了不同的映射器来处理</p>
</li>
<li><p>Handler：处理器，其实就是 Controller，业务处理的核心类，通常由开发者编写，并且必须遵守 Controller 开发的规则，这样适配器才能正确的执行。例如实现 Controller 接口，将 Controller 注册到 IOC 容器中等</p>
</li>
<li><p>HandlAdapter：处理器适配器，根据映射器中找到的 Handler，通过 HandlerAdapter 去执行 Handler，这是适配器模式的应用</p>
</li>
<li><p>View Resolver：视图解析器， 将 Handler 中返回的逻辑视图（ModelAndView）解析为一个具体的视图（View）对象</p>
</li>
<li><p>View：视图， View 最后对页面进行渲染将结果返回给用户，SpringMVC 框架提供了很多的 View 视图类型，包括：jstlView、freemarkerView、pdfView 等</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84.png"></p>
</li>
</ul>
<p>优点：</p>
<ul>
<li>与 Spring 集成，更好的管理资源</li>
<li>有很多参数解析器和视图解析器，支持的数据类型丰富</li>
<li>将映射器、处理器、视图解析器进行解耦，分工明确</li>
</ul>
<hr>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>在 Spring 容器初始化时会建立所有的 URL 和 Controller 的对应关系，保存到 Map&lt;URL, Controller&gt; 中，这样 request 就能快速根据 URL 定位到 Controller：</p>
<ul>
<li>在 Spring IOC 容器初始化完所有单例 bean 后</li>
<li>SpringMVC 会遍历所有的 bean，获取 Controller 中对应的 URL（这里获取 URL 的实现类有多个，用于处理不同形式配置的 Controller）</li>
<li>将每一个 URL 对应一个 Controller 存入 Map&lt;URL, Controller&gt; 中</li>
</ul>
<p>注意：将 @Controller 注解换成 @Component，启动时不会报错，但是在浏览器中输入路径时会出现 404，说明 Spring 没有对所有的 bean 进行 URL 映射</p>
<p><strong>一个 Request 来了：</strong></p>
<ul>
<li>监听端口，获得请求：Tomcat 监听 8080 端口的请求处理，根据路径调用了 web.xml 中配置的核心控制器 DispatcherServlet，<code>DispatcherServlet#doDispatch</code> 是<strong>核心调度方法</strong></li>
<li><strong>首先根据 URI 获取 HandlerMapping 处理器映射器</strong>，RequestMappingHandlerMapping 用来处理 @RequestMapping 注解的映射规则，其中保存了所有 handler 的映射规则，最后包装成一个拦截器链返回，拦截器链对象持有 HandlerMapping。如果没有合适的处理请求的 HandlerMapping，说明请求处理失败，设置响应码 404 返回</li>
<li>根据映射器获取当前 handler，<strong>处理器适配器执行处理方法</strong>，适配器根据请求的 URL 去 handler 中寻找对应的处理方法：<ul>
<li>创建 ModelAndViewContainer (mav) 对象，用来填充数据，然后通过不同的<strong>参数解析器</strong>去解析 URL 中的参数，完成数据解析绑定，然后执行真正的 Controller 方法，完成 handle 处理</li>
<li>方法执行完对<strong>返回值</strong>进行处理，没添加 @ResponseBody 注解的返回值使用视图处理器处理，把视图名称设置进入 mav 中</li>
<li>对添加了 @ResponseBody 注解的 Controller 的按照普通的返回值进行处理，首先进行内容协商，找到一种浏览器可以接受（请求头 Accept）的并且服务器可以生成的数据类型，选择合适数据转换器，设置响应头中的数据类型，然后写出数据</li>
<li>最后把 ModelAndViewContainer 和 ModelMap 中的数据<strong>封装到 ModelAndView 对象</strong>返回</li>
</ul>
</li>
<li><strong>视图解析</strong>，根据返回值创建视图，请求转发 View 实例为 InternalResourceView，重定向 View 实例为 RedirectView。最后调用 view.render 进行页面渲染，结果派发<ul>
<li>请求转发时请求域中的数据不丢失，会把 ModelAndView 的数据设置到请求域中，获取 Servlet 原生的 RequestDispatcher，调用 <code>RequestDispatcher#forward</code> 实现转发</li>
<li>重定向会造成请求域中的数据丢失，使用 Servlet 原生方式实现重定向 <code>HttpServletResponse#sendRedirect</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="调度函数"><a href="#调度函数" class="headerlink" title="调度函数"></a>调度函数</h3><p>请求进入原生的 HttpServlet 的 doGet() 方法处理，调用子类 FrameworkServlet 的 doGet() 方法，最终调用 DispatcherServlet 的 doService() 方法，为请求设置相关属性后调用 doDispatch()，请求和响应的以参数的形式传入</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E8%AF%B7%E6%B1%82%E7%9B%B8%E5%BA%94%E7%9A%84%E5%8E%9F%E7%90%86.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// request 和 response 为 Java 原生的类</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 文件上传请求</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 异步管理器</span></span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 文件上传相关请求</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到当前请求使用哪个 HandlerMapping （Controller 的方法）处理，返回执行链</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="comment">// 没有合适的处理请求的方式 HandlerMapping，请求失败，直接返回 404</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据映射器获取当前 handler 处理器适配器，用来【处理当前的请求】</span></span><br><span class="line">            <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">            <span class="comment">// 获取发出此次请求的方式</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">            <span class="comment">// 判断请求是不是 GET 方法</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> HttpMethod.GET.matches(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || HttpMethod.HEAD.matches(method)) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 拦截器链的前置处理</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行处理方法，返回的是 ModelAndView 对象，封装了所有的返回值数据</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 设置视图名字</span></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            <span class="comment">// 执行拦截器链中的后置处理方法</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理程序调用的结果，进行结果派发</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>笔记参考视频：<a href="https://www.bilibili.com/video/BV19K4y1L7MT">https://www.bilibili.com/video/BV19K4y1L7MT</a></p>
<hr>
<h3 id="请求映射-1"><a href="#请求映射-1" class="headerlink" title="请求映射"></a>请求映射</h3><h4 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h4><p>doDispatch() 中调用 getHandler 方法获取所有的映射器</p>
<p>总体流程：</p>
<ul>
<li><p>所有的请求映射都在 HandlerMapping 中，<strong>RequestMappingHandlerMapping 处理 @RequestMapping 注解的映射规则</strong></p>
</li>
<li><p>遍历所有的 HandlerMapping 看是否可以匹配当前请求，匹配成功后返回，匹配失败设置 HTTP 404 响应码</p>
</li>
<li><p>用户可以自定义的映射处理，也可以给容器中放入自定义 HandlerMapping</p>
</li>
</ul>
<p>访问 URL：<a href="http://localhost:8080/user">http://localhost:8080/user</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;GET&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">postUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;POST&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//。。。。。</span></span><br></pre></td></tr></table></figure>

<p>HandlerMapping 处理器映射器，<strong>保存了所有 <code>@RequestMapping</code>  和 <code>handler</code> 的映射规则</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的 HandlerMapping</span></span><br><span class="line">        <span class="keyword">for</span> (HandlerMapping mapping : <span class="built_in">this</span>.handlerMappings) &#123;</span><br><span class="line">            <span class="comment">// 尝试去每个 HandlerMapping 中匹配当前请求的处理</span></span><br><span class="line">            <span class="type">HandlerExecutionChain</span> <span class="variable">handler</span> <span class="operator">=</span> mapping.getHandler(request);</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E8%8E%B7%E5%8F%96Controller%E5%A4%84%E7%90%86%E5%99%A8.png"></p>
<ul>
<li><p><code>mapping.getHandler(request)</code>：调用 AbstractHandlerMapping#getHandler</p>
<ul>
<li><p><code>Object handler = getHandlerInternal(request)</code>：<strong>获取映射器</strong>，底层调用 RequestMappingInfoHandlerMapping 类的方法，又调用 AbstractHandlerMethodMapping#getHandlerInternal</p>
<ul>
<li><p><code>String lookupPath = initLookupPath(request)</code>：地址栏的 URI，这里的 lookupPath 为 &#x2F;user</p>
</li>
<li><p><code>this.mappingRegistry.acquireReadLock()</code>：加读锁防止其他线程并发修改</p>
</li>
<li><p><code>handlerMethod = lookupHandlerMethod(lookupPath, request)</code>：获取当前 HandlerMapping 中的映射规则</p>
<ul>
<li><p><code>directPathMatches = this.mappingRegistry.getMappingsByDirectPath(lookupPath)</code>：获取当前的映射器与当前<strong>请求的 URI 有关的所有映射规则</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-HandlerMapping%E7%9A%84%E6%98%A0%E5%B0%84%E8%A7%84%E5%88%99.png"></p>
</li>
<li><p><code>addMatchingMappings(directPathMatches, matches, request)</code>：<strong>匹配某个映射规则</strong></p>
<ul>
<li><code>for (T mapping : mappings)</code>：遍历所有的映射规则</li>
<li><code>match = getMatchingMapping(mapping, request)</code>：去匹配每一个映射规则，匹配失败返回 null</li>
<li><code>matches.add(new Match())</code>：匹配成功后封装成匹配器添加到匹配集合中</li>
</ul>
</li>
<li><p><code>matches.sort(comparator)</code>：匹配集合排序</p>
</li>
<li><p><code>Match bestMatch = matches.get(0)</code>：匹配完成只剩一个，直接获取返回对应的处理方法</p>
</li>
<li><p><code>if (matches.size() &gt; 1)</code>：当有多个映射规则符合请求时，报错</p>
</li>
<li><p><code>return bestMatch.getHandlerMethod()</code>：返回匹配器中的处理方法</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>executionChain = getHandlerExecutionChain(handler, request)</code>：<strong>为当前请求和映射器的构建一个拦截器链</strong></p>
<ul>
<li><code>for (HandlerInterceptor interceptor : this.adaptedInterceptors)</code>：遍历所有的拦截器</li>
<li><code>chain.addInterceptor(interceptor)</code>：把所有的拦截器添加到 HandlerExecutionChain 中，形成拦截器链</li>
</ul>
</li>
<li><p><code>return executionChain</code>：<strong>返回拦截器链，HandlerMapping 是链的 handler 成员属性</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h4><p>doDispatch() 中调用 <code>HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler())</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerAdapter <span class="title function_">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerAdapters != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的 HandlerAdapter</span></span><br><span class="line">        <span class="keyword">for</span> (HandlerAdapter adapter : <span class="built_in">this</span>.handlerAdapters) &#123;</span><br><span class="line">            <span class="comment">// 判断当前适配器是否支持当前 handle</span></span><br><span class="line">            <span class="keyword">if</span> (adapter.supports(handler)) &#123;</span><br><span class="line">                <span class="comment">// 返回的是 【RequestMappingHandlerAdapter】</span></span><br><span class="line">                <span class="comment">// AbstractHandlerMethodAdapter#supports -&gt; RequestMappingHandlerAdapter</span></span><br><span class="line">                <span class="keyword">return</span> adapter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="方法执行"><a href="#方法执行" class="headerlink" title="方法执行"></a>方法执行</h4><p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/params&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">param</span><span class="params">(Map&lt;String, Object&gt; map, Model model, HttpServletRequest request)</span> &#123;</span><br><span class="line">    map.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);			<span class="comment">// 都可以向请求域中添加数据</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);	<span class="comment">// 它们两个都在数据封装在 【BindingAwareModelMap】，继承自 LinkedHashMap</span></span><br><span class="line">    request.setAttribute(<span class="string">&quot;m&quot;</span>, <span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-Model%E5%92%8CMap%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90.png"></p>
<p>doDispatch() 中调用 <code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler())</code> <strong>使用适配器执行方法</strong></p>
<p><code>AbstractHandlerMethodAdapter#handle</code> → <code>RequestMappingHandlerAdapter#handleInternal</code> → <code>invokeHandlerMethod</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                           HttpServletResponse response, </span></span><br><span class="line"><span class="params">                                           HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">// 封装成 SpringMVC 的接口，用于通用 Web 请求拦截器，使能够访问通用请求元数据，而不是用于实际处理请求</span></span><br><span class="line">    <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// WebDataBinder 用于【从 Web 请求参数到 JavaBean 对象的数据绑定】，获取创建该实例的工厂</span></span><br><span class="line">        <span class="type">WebDataBinderFactory</span> <span class="variable">binderFactory</span> <span class="operator">=</span> getDataBinderFactory(handlerMethod);</span><br><span class="line">        <span class="comment">// 创建 Model 实例，用于向模型添加属性</span></span><br><span class="line">        <span class="type">ModelFactory</span> <span class="variable">modelFactory</span> <span class="operator">=</span> getModelFactory(handlerMethod, binderFactory);</span><br><span class="line">		<span class="comment">// 方法执行器</span></span><br><span class="line">        <span class="type">ServletInvocableHandlerMethod</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 参数解析器，有很多</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">            invocableMethod.setHandlerMethodArgumentResolvers(<span class="built_in">this</span>.argumentResolvers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回值处理器，也有很多</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>) &#123;</span><br><span class="line">            invocableMethod.setHandlerMethodReturnValueHandlers(<span class="built_in">this</span>.returnValueHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置数据绑定器</span></span><br><span class="line">        invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">        <span class="comment">// 设置参数检查器</span></span><br><span class="line">		invocableMethod.setParameterNameDiscoverer(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 新建一个 ModelAndViewContainer 并进行初始化和一些属性的填充</span></span><br><span class="line">        <span class="type">ModelAndViewContainer</span> <span class="variable">mavContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>();</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 设置一些属性</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【执行目标方法】</span></span><br><span class="line">        invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">        <span class="comment">// 异步请求</span></span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 【获取 ModelAndView 对象，封装了 ModelAndViewContainer】</span></span><br><span class="line">        <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        webRequest.requestCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServletInvocableHandlerMethod#invokeAndHandle：执行目标方法</p>
<ul>
<li><p><code>returnValue = invokeForRequest(webRequest, mavContainer, providedArgs)</code>：<strong>执行自己写的 controller 方法，返回的就是自定义方法中 return 的值</strong></p>
<p><code>Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs)</code>：<strong>参数处理的逻辑</strong>，遍历所有的参数解析器解析参数或者将 URI 中的参数进行绑定，绑定完成后开始执行目标方法</p>
<ul>
<li><p><code>parameters = getMethodParameters()</code>：获取此处理程序方法的方法参数的详细信息</p>
</li>
<li><p><code>Object[] args = new Object[parameters.length]</code>：存放所有的参数</p>
</li>
<li><p><code>for (int i = 0; i &lt; parameters.length; i++)</code>：遍历所有的参数</p>
</li>
<li><p><code>args[i] = findProvidedArgument(parameter, providedArgs)</code>：获取调用方法时提供的参数，一般是空</p>
</li>
<li><p><code>if (!this.resolvers.supportsParameter(parameter))</code>：<strong>获取可以解析当前参数的参数解析器</strong></p>
<p><code>return getArgumentResolver(parameter) != null</code>：获取参数的解析是否为空</p>
<ul>
<li><p><code>for (HandlerMethodArgumentResolver resolver : this.argumentResolvers)</code>：遍历容器内所有的解析器</p>
<p><code>if (resolver.supportsParameter(parameter))</code>：是否支持当前参数</p>
<ul>
<li><code>PathVariableMethodArgumentResolver#supportsParameter</code>：<strong>解析标注 @PathVariable 注解的参数</strong></li>
<li><code>ModelMethodProcessor#supportsParameter</code>：解析 Map 和 Model 类型的参数，Model 和 Map 的作用一样</li>
<li><code>ExpressionValueMethodArgumentResolver#supportsParameter</code>：解析标注 @Value 注解的参数</li>
<li><code>RequestParamMapMethodArgumentResolver#supportsParameter</code>：<strong>解析标注 @RequestParam 注解</strong></li>
<li><code>RequestPartMethodArgumentResolver#supportsParameter</code>：解析文件上传的信息</li>
<li><code>ModelAttributeMethodProcessor#supportsParameter</code>：解析标注 @ModelAttribute 注解或者不是简单类型<ul>
<li>子类 ServletModelAttributeMethodProcessor 是解析自定义类型 JavaBean 的解析器</li>
<li>简单类型有 Void、Enum、Number、CharSequence、Date、URI、URL、Locale、Class</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>args[i] = this.resolvers.resolveArgument()</code>：<strong>开始解析参数，每个参数使用的解析器不同</strong></p>
<p><code>resolver = getArgumentResolver(parameter)</code>：获取参数解析器</p>
<p><code>return resolver.resolveArgument()</code>：开始解析</p>
<ul>
<li><code>PathVariableMapMethodArgumentResolver#resolveArgument</code>：@PathVariable，包装 URI 中的参数为 Map</li>
<li><code>MapMethodProcessor#resolveArgument</code>：调用 <code>mavContainer.getModel()</code> 返回默认 BindingAwareModelMap 对象</li>
<li><code>ModelAttributeMethodProcessor#resolveArgument</code>：<strong>自定义的 JavaBean 的绑定封装</strong>，下一小节详解</li>
</ul>
</li>
</ul>
<p><code>return doInvoke(args)</code>：<strong>真正的执行 Controller 方法</strong></p>
<ul>
<li><code>Method method = getBridgedMethod()</code>：从 HandlerMethod 获取要反射执行的方法</li>
<li><code>ReflectionUtils.makeAccessible(method)</code>：破解权限</li>
<li><code>method.invoke(getBean(), args)</code>：执行方法，getBean 获取的是标记 @Controller 的 Bean 类，其中包含执行方法</li>
</ul>
</li>
<li><p><strong>进行返回值的处理，响应部分详解</strong>，处理完成进入下面的逻辑</p>
</li>
</ul>
<p>RequestMappingHandlerAdapter#getModelAndView：获取 ModelAndView 对象</p>
<ul>
<li><p><code>modelFactory.updateModel(webRequest, mavContainer)</code>：Model 数据升级到会话域（<strong>请求域中的数据在重定向时丢失</strong>）</p>
<ul>
<li><code>updateBindingResult(request, defaultModel)</code>：把绑定的数据添加到 BindingAwareModelMap 中</li>
</ul>
</li>
<li><p><code>if (mavContainer.isRequestHandled())</code>：判断请求是否已经处理完成了</p>
</li>
<li><p><code>ModelMap model = mavContainer.getModel()</code>：获取<strong>包含 Controller 方法参数</strong>的 BindingAwareModelMap（本节开头）</p>
</li>
<li><p><code>mav = new ModelAndView()</code>：<strong>把 ModelAndViewContainer 和 ModelMap 中的数据封装到 ModelAndView</strong> </p>
</li>
<li><p><code>if (!mavContainer.isViewReference())</code>：是否是通过名称指定视图引用</p>
</li>
<li><p><code>if (model instanceof RedirectAttributes)</code>：判断 model 是否是重定向数据，如果是进行重定向逻辑</p>
</li>
<li><p><code>return mav</code>：<strong>任何方法执行都会返回 ModelAndView 对象</strong></p>
</li>
</ul>
<hr>
<h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><p>解析自定义的 JavaBean 为例，调用 ModelAttributeMethodProcessor#resolveArgument 处理参数的方法，通过合适的类型转换器把 URL 中的参数转换以后，利用反射获取 set 方法，注入到 JavaBean</p>
<ul>
<li><p>Person.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span>	<span class="comment">//加入到容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span>	<span class="comment">//返回的数据不是页面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParameterController</span> &#123;</span><br><span class="line">    <span class="comment">// 数据绑定：页面提交的请求数据（GET、POST）都可以和对象属性进行绑定</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/saveuser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">saveuser</span><span class="params">(Person person)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问 URL：<a href="http://localhost:8080/saveuser?userName=zhangsan&amp;age=20">http://localhost:8080/saveuser?userName=zhangsan&amp;age=20</a></p>
</li>
</ul>
<p>进入源码：ModelAttributeMethodProcessor#resolveArgument</p>
<ul>
<li><p><code>name = ModelFactory.getNameForParameter(parameter)</code>：获取名字，此例就是 person</p>
</li>
<li><p><code>ann = parameter.getParameterAnnotation(ModelAttribute.class)</code>：是否有 ModelAttribute 注解</p>
</li>
<li><p><code>if (mavContainer.containsAttribute(name))</code>：ModelAndViewContainer 中是否包含 person 对象</p>
</li>
<li><p><code>attribute = createAttribute()</code>：<strong>创建一个实例，空的 Person 对象</strong></p>
</li>
<li><p><code>binder = binderFactory.createBinder(webRequest, attribute, name)</code>：Web 数据绑定器，可以利用 Converters 将请求数据转成指定的数据类型，绑定到 JavaBean 中</p>
</li>
<li><p><code>bindRequestParameters(binder, webRequest)</code>：<strong>利用反射向目标对象填充数据</strong></p>
<p><code>servletBinder = (ServletRequestDataBinder) binder</code>：类型强转</p>
<p><code>servletBinder.bind(servletRequest)</code>：绑定数据</p>
<ul>
<li><p><code>mpvs = new MutablePropertyValues(request.getParameterMap())</code>：获取请求 URI 参数中的 k-v 键值对</p>
</li>
<li><p><code>addBindValues(mpvs, request)</code>：子类可以用来为请求添加额外绑定值</p>
</li>
<li><p><code>doBind(mpvs)</code>：真正的绑定的方法，调用 <code>applyPropertyValues</code> 应用参数值，然后调用 <code>setPropertyValues</code> 方法</p>
<p><code>AbstractPropertyAccessor#setPropertyValues()</code>：</p>
<ul>
<li><p><code>List&lt;PropertyValue&gt; propertyValues</code>：获取到所有的参数的值，就是 URI 上的所有的参数值</p>
</li>
<li><p><code>for (PropertyValue pv : propertyValues)</code>：遍历所有的参数值</p>
</li>
<li><p><code>setPropertyValue(pv)</code>：<strong>填充到空的 Person 实例中</strong></p>
<ul>
<li><p><code>nestedPa = getPropertyAccessorForPropertyPath(propertyName)</code>：获取属性访问器</p>
</li>
<li><p><code>tokens = getPropertyNameTokens()</code>：获取元数据的信息</p>
</li>
<li><p><code>nestedPa.setPropertyValue(tokens, pv)</code>：填充数据</p>
</li>
<li><p><code>processLocalProperty(tokens, pv)</code>：处理属性</p>
<ul>
<li><p><code>if (!Boolean.FALSE.equals(pv.conversionNecessary))</code>：数据是否需要转换了</p>
</li>
<li><p><code>if (pv.isConverted())</code>：数据已经转换过了，转换了直接赋值，没转换进行转换</p>
</li>
<li><p><code>oldValue = ph.getValue()</code>：获取未转换的数据</p>
</li>
<li><p><code>valueToApply = convertForProperty()</code>：进行数据转换</p>
<p><code>TypeConverterDelegate#convertIfNecessary</code>：进入该方法的逻辑</p>
<ul>
<li><p><code>if (conversionService.canConvert(sourceTypeDesc, typeDescriptor))</code>：判断能不能转换</p>
<p><code>GenericConverter converter = getConverter(sourceType, targetType)</code>：<strong>获取类型转换器</strong></p>
<ul>
<li><p><code>converter = this.converters.find(sourceType, targetType)</code>：寻找合适的转换器</p>
<ul>
<li><p><code>sourceCandidates = getClassHierarchy(sourceType.getType())</code>：原数据类型</p>
</li>
<li><p><code>targetCandidates = getClassHierarchy(targetType.getType())</code>：目标数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; sourceCandidate : sourceCandidates) &#123;</span><br><span class="line">    <span class="comment">//双重循环遍历，寻找合适的转换器</span></span><br><span class="line"> 	<span class="keyword">for</span> (Class&lt;?&gt; targetCandidate : targetCandidates) &#123;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>GenericConverter converter = getRegisteredConverter(..)</code>：匹配类型转换器</p>
</li>
<li><p><code>return converter</code>：返回转换器</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)</code>：开始转换</p>
<ul>
<li><code>converter = getConverter(sourceType, targetType)</code>：<strong>获取可用的转换器</strong></li>
<li><code>result = ConversionUtils.invokeConverter()</code>：执行转换方法<ul>
<li><code>converter.convert()</code>：<strong>调用转换器的转换方法</strong>（GenericConverter#convert）</li>
</ul>
</li>
<li><code>return handleResult(sourceType, targetType, result)</code>：返回结果</li>
</ul>
</li>
</ul>
</li>
<li><p><code>ph.setValue(valueToApply)</code>：<strong>设置 JavaBean 属性</strong>（BeanWrapperImpl.BeanPropertyHandler）</p>
<ul>
<li><code>Method writeMethod</code>：获取写数据方法<ul>
<li><code>Class&lt;?&gt; cls = getClass0()</code>：获取 Class 对象</li>
<li><code>writeMethodName = Introspector.SET_PREFIX + getBaseName()</code>：<strong>set 前缀 + 属性名</strong></li>
<li><code>writeMethod = Introspector.findMethod(cls, writeMethodName, 1, args)</code>：获取只包含一个参数的 set 方法</li>
<li><code>setWriteMethod(writeMethod)</code>：加入缓存</li>
</ul>
</li>
<li><code>ReflectionUtils.makeAccessible(writeMethod)</code>：设置访问权限</li>
<li><code>writeMethod.invoke(getWrappedInstance(), value)</code>：执行方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>bindingResult = binder.getBindingResult()</code>：获取绑定的结果</p>
</li>
<li><p><code>mavContainer.addAllAttributes(bindingResultModel)</code>：<strong>把所有填充的参数放入 ModelAndViewContainer</strong></p>
</li>
<li><p><code>return attribute</code>：返回填充后的 Person 对象</p>
</li>
</ul>
<hr>
<h3 id="响应处理-1"><a href="#响应处理-1" class="headerlink" title="响应处理"></a>响应处理</h3><h4 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h4><p>以 Person 为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span>  		<span class="comment">// 利用返回值处理器里面的消息转换器进行处理，而不是视图</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">getPerson</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    person.setAge(<span class="number">28</span>);</span><br><span class="line">    person.setBirth(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    person.setUserName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接进入方法执行完后的逻辑 ServletInvocableHandlerMethod#invokeAndHandle：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">                            Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">// 【执行目标方法】，return person 对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">    <span class="comment">// 设置状态码</span></span><br><span class="line">    setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断方法是否有返回值</span></span><br><span class="line">    <span class="keyword">if</span> (returnValue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="literal">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">            disableContentCachingIfNecessary(webRequest);</span><br><span class="line">            mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	<span class="comment">// 返回值是字符串</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">        <span class="comment">// 设置请求处理完成</span></span><br><span class="line">        mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 设置请求没有处理完成，还需要进行返回值的逻辑</span></span><br><span class="line">    mavContainer.setRequestHandled(<span class="literal">false</span>);</span><br><span class="line">    Assert.state(<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>, <span class="string">&quot;No return value handlers&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 【返回值的处理】</span></span><br><span class="line">        <span class="built_in">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>没有加 @ResponseBody 注解的返回数据按照视图处理的逻辑</strong>，ViewNameMethodReturnValueHandler（视图详解）</li>
<li>此例是加了注解的，返回的数据不是视图，HandlerMethodReturnValueHandlerComposite#handleReturnValue：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">                              ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span>  &#123;</span><br><span class="line">	<span class="comment">// 获取合适的返回值处理器</span></span><br><span class="line">    <span class="type">HandlerMethodReturnValueHandler</span> <span class="variable">handler</span> <span class="operator">=</span> selectHandler(returnValue, returnType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用处理器处理返回值（详解源码中的这两个函数）</span></span><br><span class="line">    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HandlerMethodReturnValueHandlerComposite#selectHandler：获取合适的返回值处理器</p>
<ul>
<li><p><code>boolean isAsyncValue = isAsyncReturnValue(value, returnType)</code>：是否是异步请求</p>
</li>
<li><p><code>for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers)</code>：遍历所有的返回值处理器</p>
<ul>
<li><code>RequestResponseBodyMethodProcessor#supportsReturnType</code>：<strong>处理标注 @ResponseBody 注解的返回值</strong></li>
<li><code>ModelAndViewMethodReturnValueHandler#supportsReturnType</code>：处理返回值类型是 ModelAndView 的处理器</li>
<li><code>ModelAndViewResolverMethodReturnValueHandler#supportsReturnType</code>：直接返回 true，处理所有数据</li>
</ul>
</li>
</ul>
<p>RequestResponseBodyMethodProcessor#handleReturnValue：处理返回值，要进行<strong>内容协商</strong></p>
<ul>
<li><p><code>mavContainer.setRequestHandled(true)</code>：设置请求处理完成</p>
</li>
<li><p><code>inputMessage = createInputMessage(webRequest)</code>：获取输入的数据</p>
</li>
<li><p><code>outputMessage = createOutputMessage(webRequest)</code>：获取输出的数据</p>
</li>
<li><p><code>writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage)</code>：使用消息转换器进行写出</p>
<ul>
<li><p><code>if (value instanceof CharSequence)</code>：判断返回的数据是不是字符类型</p>
</li>
<li><p><code>body = value</code>：把 value 赋值给 body，此时 body 中就是自定义方法执行完后的 Person 对象</p>
</li>
<li><p><code>if (isResourceType(value, returnType))</code>：当前数据是不是流数据</p>
</li>
<li><p><code>MediaType selectedMediaType</code>：<strong>内容协商后选择使用的类型，浏览器和服务器都支持的媒体（数据）类型</strong></p>
</li>
<li><p><code>MediaType contentType = outputMessage.getHeaders().getContentType()</code>：获取响应头的数据</p>
</li>
<li><p><code>if (contentType != null &amp;&amp; contentType.isConcrete())</code>：判断当前响应头中是否已经有确定的媒体类型</p>
<p><code>selectedMediaType = contentType</code>：前置处理已经使用了媒体类型，直接继续使用该类型</p>
</li>
<li><p><code>acceptableTypes = getAcceptableMediaTypes(request)</code>：<strong>获取浏览器支持的媒体类型，请求头字段</strong></p>
<ul>
<li><code>this.contentNegotiationManager.resolveMediaTypes()</code>：调用该方法</li>
<li><code>for(ContentNegotiationStrategy strategy:this.strategies)</code>：<strong>默认策略是提取请求头的字段的内容</strong>，策略类为HeaderContentNegotiationStrategy，可以配置添加其他类型的策略<ul>
<li><code>List&lt;MediaType&gt; mediaTypes = strategy.resolveMediaTypes(request)</code>：解析 Accept 字段存储为 List<ul>
<li><code>headerValueArray = request.getHeaderValues(HttpHeaders.ACCEPT)</code>：获取请求头中 Accept 字段</li>
<li><code>List&lt;MediaType&gt; mediaTypes = MediaType.parseMediaTypes(headerValues)</code>：解析成 List 集合</li>
<li><code>MediaType.sortBySpecificityAndQuality(mediaTypes)</code>：按照相对品质因数 q 降序排序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%AF%E6%8C%81%E6%8E%A5%E6%94%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p>
</li>
<li><p><code>producibleTypes = getProducibleMediaTypes(request, valueType, targetType)</code>：<strong>服务器能生成的媒体类型</strong></p>
<ul>
<li><code>request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE)</code>：从请求域获取默认的媒体类型<ul>
<li><code> for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters)</code>：遍历所有的消息转换器</li>
<li><code>converter.canWrite(valueClass, null)</code>：是否支持当前的类型</li>
<li><code> result.addAll(converter.getSupportedMediaTypes())</code>：把当前 MessageConverter 支持的所有类型放入 result</li>
</ul>
</li>
</ul>
</li>
<li><p><code>List&lt;MediaType&gt; mediaTypesToUse = new ArrayList&lt;&gt;()</code>：存储最佳匹配的集合</p>
</li>
<li><p><strong>内容协商：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (MediaType requestedType : acceptableTypes) &#123;				<span class="comment">// 遍历所有浏览器能接受的媒体类型</span></span><br><span class="line">    <span class="keyword">for</span> (MediaType producibleType : producibleTypes) &#123;		<span class="comment">// 遍历所有服务器能产出的</span></span><br><span class="line">        <span class="keyword">if</span> (requestedType.isCompatibleWith(producibleType)) &#123;	<span class="comment">// 判断类型是否匹配，最佳匹配</span></span><br><span class="line">            <span class="comment">// 数据协商匹配成功，一般有多种</span></span><br><span class="line">            mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>MediaType.sortBySpecificityAndQuality(mediaTypesToUse)</code>：按照相对品质因数 q 排序，降序排序，越大的越好</p>
</li>
<li><p><code>for (MediaType mediaType : mediaTypesToUse)</code>：<strong>遍历所有的最佳匹配</strong>，选择一种赋值给选择的类型</p>
</li>
<li><p><code>selectedMediaType = selectedMediaType.removeQualityValue()</code>：媒体类型去除相对品质因数</p>
</li>
<li><p><code>for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters)</code>：<strong>遍历所有的 HTTP 数据转换器</strong></p>
</li>
<li><p><code>GenericHttpMessageConverter genericConverter</code>：<strong>MappingJackson2HttpMessageConverter 可以将对象写为 JSON</strong></p>
</li>
<li><p><code>((GenericHttpMessageConverter) converter).canWrite()</code>：判断转换器是否可以写出给定的类型</p>
<p><code>AbstractJackson2HttpMessageConverter#canWrit</code></p>
<ul>
<li><p><code>if (!canWrite(mediaType))</code>：是否可以写出指定类型</p>
<ul>
<li><code>MediaType.ALL.equalsTypeAndSubtype(mediaType)</code>：是不是 <code>*/*</code> 类型</li>
<li><code>getSupportedMediaTypes()</code>：支持 <code>application/json</code> 和 <code>application/*+json</code> 两种类型<ul>
<li><code>return true</code>：返回 true</li>
</ul>
</li>
<li><code>objectMapper = selectObjectMapper(clazz, mediaType)</code>：选择可以使用的 objectMapper </li>
<li><code>causeRef = new AtomicReference&lt;&gt;()</code>：获取并发安全的引用</li>
<li><code>if (objectMapper.canSerialize(clazz, causeRef))</code>：objectMapper 可以序列化当前类</li>
<li><code>return true</code>：返回 true</li>
</ul>
</li>
<li><p><code> body = getAdvice().beforeBodyWrite()</code>：<strong>获取要响应的所有数据，就是 Person 对象</strong></p>
</li>
</ul>
</li>
<li><p><code>addContentDispositionHeader(inputMessage, outputMessage)</code>：检查路径</p>
</li>
<li><p><code>genericConverter.write(body, targetType, selectedMediaType, outputMessage)</code>：调用消息转换器的 write 方法</p>
<p><code>AbstractGenericHttpMessageConverter#write</code>：该类的方法</p>
<ul>
<li><p><code>addDefaultHeaders(headers, t, contentType)</code>：<strong>设置响应头中的数据类型</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p>
</li>
<li><p><code>writeInternal(t, type, outputMessage)</code>：<strong>数据写出为 JSON 格式</strong></p>
<ul>
<li><code>Object value = object</code>：value 引用 Person 对象</li>
<li><code>ObjectWriter objectWriter = objectMapper.writer()</code>：获取 ObjectWriter 对象</li>
<li><code>objectWriter.writeValue(generator, value)</code>：使用 ObjectWriter 写出数据为 JSON</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="协商策略"><a href="#协商策略" class="headerlink" title="协商策略"></a>协商策略</h4><p>开启基于请求参数的内容协商模式：（SpringBoot 方式）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.mvc.contentnegotiation:favor-parameter:</span> <span class="literal">true</span>  <span class="comment"># 开启请求参数内容协商模式</span></span><br></pre></td></tr></table></figure>

<p>发请求： <a href="http://localhost:8080/person?format=json%EF%BC%8C%E8%A7%A3%E6%9E%90">http://localhost:8080/person?format=json，解析</a> format</p>
<p>策略类为 ParameterContentNegotiationStrategy，运行流程如下：</p>
<ul>
<li><p><code>acceptableTypes = getAcceptableMediaTypes(request)</code>：获取浏览器支持的媒体类型</p>
<p><code>mediaTypes = strategy.resolveMediaTypes(request)</code>：解析请求 URL 参数中的数据</p>
<ul>
<li><p><code>return resolveMediaTypeKey(webRequest, getMediaTypeKey(webRequest))</code>：</p>
<p><code>getMediaTypeKey(webRequest)</code>：</p>
<ul>
<li><code>request.getParameter(getParameterName())</code>：获取 URL 中指定的需求的数据类型<ul>
<li><code>getParameterName()</code>：获取参数的属性名 format</li>
<li><code>getParameter()</code>：<strong>获取 URL 中 format 对应的数据</strong></li>
</ul>
</li>
</ul>
<p><code>resolveMediaTypeKey()</code>：解析媒体类型，封装成集合</p>
</li>
</ul>
</li>
</ul>
<p>自定义内容协商策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">webMvcConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span>	<span class="comment">//自定义内容协商策略</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureContentNegotiation</span><span class="params">(ContentNegotiationConfigurer configurer)</span> &#123;</span><br><span class="line">                Map&lt;String, MediaType&gt; mediaTypes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                mediaTypes.put(<span class="string">&quot;json&quot;</span>, MediaType.APPLICATION_JSON);</span><br><span class="line">                mediaTypes.put(<span class="string">&quot;xml&quot;</span>,MediaType.APPLICATION_XML);</span><br><span class="line">                mediaTypes.put(<span class="string">&quot;person&quot;</span>,MediaType.parseMediaType(<span class="string">&quot;application/x-person&quot;</span>));</span><br><span class="line">                <span class="comment">// 指定支持解析哪些参数对应的哪些媒体类型</span></span><br><span class="line">                <span class="type">ParameterContentNegotiationStrategy</span> <span class="variable">parameterStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParameterContentNegotiationStrategy</span>(mediaTypes);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 请求头解析</span></span><br><span class="line">                <span class="type">HeaderContentNegotiationStrategy</span> <span class="variable">headStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeaderContentNegotiationStrategy</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 添加到容器中，即可以解析请求头 又可以解析请求参数</span></span><br><span class="line">                configurer.strategies(Arrays.asList(parameterStrategy,headStrategy));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span> 	<span class="comment">// 自定义消息转换器</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">                converters.add(<span class="keyword">new</span> <span class="title class_">GuiguMessageConverter</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以自定义 HttpMessageConverter，实现 HttpMessageConverter<T> 接口重写方法即可</T></p>
<hr>
<h3 id="视图解析"><a href="#视图解析" class="headerlink" title="视图解析"></a>视图解析</h3><h4 id="返回解析"><a href="#返回解析" class="headerlink" title="返回解析"></a>返回解析</h4><p>请求处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/params&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">param</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;forward:/success&quot;</span>;</span><br><span class="line">    <span class="comment">//return &quot;redirect:/success&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入执行方法逻辑 ServletInvocableHandlerMethod#invokeAndHandle，进入 <code>this.returnValueHandlers.handleReturnValue</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">                              ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span>  &#123;</span><br><span class="line">	<span class="comment">// 获取合适的返回值处理器：调用 if (handler.supportsReturnType(returnType))判断是否支持</span></span><br><span class="line">    <span class="type">HandlerMethodReturnValueHandler</span> <span class="variable">handler</span> <span class="operator">=</span> selectHandler(returnValue, returnType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用处理器处理返回值</span></span><br><span class="line">    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ViewNameMethodReturnValueHandler#supportsReturnType：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; paramType = returnType.getParameterType();</span><br><span class="line">    <span class="comment">// 返回值是否是 void 或者是 CharSequence 字符序列，这里是字符序列</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>.class == paramType || CharSequence.class.isAssignableFrom(paramType));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ViewNameMethodReturnValueHandler#handleReturnValue：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">                              ModelAndViewContainer mavContainer, </span></span><br><span class="line"><span class="params">                              NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">// 返回值是字符串，是 return &quot;forward:/success&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (returnValue <span class="keyword">instanceof</span> CharSequence) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">viewName</span> <span class="operator">=</span> returnValue.toString();</span><br><span class="line">        <span class="comment">// 【把视图名称设置进入 ModelAndViewContainer 中】</span></span><br><span class="line">        mavContainer.setViewName(viewName);</span><br><span class="line">        <span class="comment">// 判断是否是重定向数据 `viewName.startsWith(&quot;redirect:&quot;)`</span></span><br><span class="line">        <span class="keyword">if</span> (isRedirectViewName(viewName)) &#123;</span><br><span class="line">            <span class="comment">// 如果是重定向，设置是重定向指令</span></span><br><span class="line">            mavContainer.setRedirectModelScenario(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (returnValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// should not happen</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="结果派发"><a href="#结果派发" class="headerlink" title="结果派发"></a>结果派发</h4><p>doDispatch() 中的 processDispatchResult：处理派发结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, </span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> ModelAndView mv,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">errorView</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mv 是 ModelAndValue</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        <span class="comment">// 渲染视图</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispatcherServlet#render：</p>
<ul>
<li><p><code>Locale locale = this.localeResolver.resolveLocale(request)</code>：国际化相关</p>
</li>
<li><p><code>String viewName = mv.getViewName()</code>：视图名字，是请求转发 forward:&#x2F;success（响应数据解析并存入 ModelAndView）</p>
</li>
<li><p><code>view = resolveViewName(viewName, mv.getModelInternal(), locale, request)</code>：解析视图</p>
<ul>
<li><p><code>for (ViewResolver viewResolver : this.viewResolvers)</code>：<strong>遍历所有的视图解析器</strong></p>
<p><code>view = viewResolver.resolveViewName(viewName, locale)</code>：根据视图名字解析视图，调用内容协商视图处理器 ContentNegotiatingViewResolver 的方法</p>
<ul>
<li><p><code>attrs = RequestContextHolder.getRequestAttributes()</code>：获取请求的相关属性信息</p>
</li>
<li><p><code>requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest())</code>：获取最佳匹配的媒体类型，函数内进行了匹配的逻辑</p>
</li>
<li><p><code>candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes)</code>：获取候选的视图对象</p>
<ul>
<li><p><code>for (ViewResolver viewResolver : this.viewResolvers)</code>：遍历所有的视图解析器</p>
</li>
<li><p><code>View view = viewResolver.resolveViewName(viewName, locale)</code>：<strong>解析视图</strong></p>
<p><code>AbstractCachingViewResolver#resolveViewName</code>：</p>
<ul>
<li><p><code>returnview = createView(viewName, locale)</code>：UrlBasedViewResolver#createView</p>
<p><strong>请求转发</strong>：实例为 InternalResourceView</p>
<ul>
<li><p><code>if (viewName.startsWith(FORWARD_URL_PREFIX))</code>：视图名字是否是 <strong><code>forward:</code></strong> 的前缀</p>
</li>
<li><p><code>forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length())</code>：名字截取前缀</p>
</li>
<li><p><code>view = new InternalResourceView(forwardUrl)</code>：新建 InternalResourceView  对象并返回</p>
</li>
<li><p><code>return applyLifecycleMethods(FORWARD_URL_PREFIX, view)</code>：Spring 中的初始化操作</p>
</li>
</ul>
<p><strong>重定向</strong>：实例为 RedirectView </p>
<ul>
<li><code>if (viewName.startsWith(REDIRECT_URL_PREFIX))</code>：视图名字是否是 <strong><code>redirect:</code></strong> 的前缀</li>
<li><code>redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length())</code>：名字截取前缀</li>
<li><code>RedirectView view = new RedirectView()</code>：新建 RedirectView 对象并返回</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>bestView = getBestView(candidateViews, requestedMediaTypes, attrs)</code>：选出最佳匹配的视图对象</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>view.render(mv.getModelInternal(), request, response)</code>：<strong>页面渲染</strong></p>
<ul>
<li><p><code>mergedModel = createMergedOutputModel(model, request, response)</code>：把请求域中的数据封装到 model</p>
</li>
<li><p><code>prepareResponse(request, response)</code>：响应前的准备工作，设置一些响应头</p>
</li>
<li><p><code>renderMergedOutputModel(mergedModel, getRequestToExpose(request), response)</code>：渲染输出的数据</p>
<p><code>getRequestToExpose(request)</code>：获取 Servlet 原生的方式</p>
<p><strong>请求转发 InternalResourceView 的逻辑：请求域中的数据不丢失</strong></p>
<ul>
<li><code>exposeModelAsRequestAttributes(model, request)</code>：暴露 model 作为请求域的属性<ul>
<li><code>model.forEach()</code>：遍历 Model 中的数据</li>
<li><code>request.setAttribute(name, value)</code>：<strong>设置到请求域中</strong></li>
</ul>
</li>
<li><code>exposeHelpers(request)</code>：自定义接口</li>
<li><code>dispatcherPath = prepareForRendering(request, response)</code>：确定调度分派的路径，此例是 &#x2F;success</li>
<li><code>rd = getRequestDispatcher(request, dispatcherPath)</code>：<strong>获取 Servlet 原生的 RequestDispatcher 实现转发</strong></li>
<li><code>rd.forward(request, response)</code>：实现请求转发</li>
</ul>
<p><strong>重定向 RedirectView 的逻辑：请求域中的数据会丢失</strong></p>
<ul>
<li><code>targetUrl = createTargetUrl(model, request)</code>：获取目标 URL<ul>
<li><code>enc = request.getCharacterEncoding()</code>：设置编码 UTF-8</li>
<li><code>appendQueryProperties(targetUrl, model, enc)</code>：添加一些属性，比如 <code>url + ?name=123&amp;&amp;age=324</code></li>
</ul>
</li>
<li><code>sendRedirect(request, response, targetUrl, this.http10Compatible)</code>：重定向<ul>
<li><code>response.sendRedirect(encodedURL)</code>：<strong>使用 Servlet 原生方法实现重定向</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><p>名称：@RequestBody</p>
<p>类型：形参注解</p>
<p>位置：处理器类中的方法形参前方</p>
<p>作用：将异步提交数据<strong>转换</strong>成标准请求参数格式，并赋值给形参<br>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span> <span class="comment">//控制层</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AjaxController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/ajaxController&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">ajaxController</span><span class="params">(<span class="meta">@RequestBody</span> String message)</span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注解添加到 POJO  参数前方时，封装的异步提交数据按照 POJO  的属性格式进行关系映射<ul>
<li>POJO 中的属性如果请求数据中没有，属性值为 null</li>
<li>POJO 中没有的属性如果请求数据中有，不进行映射</li>
</ul>
</li>
<li>注解添加到集合参数前方时，封装的异步提交数据按照集合的存储结构进行关系映射</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ajaxPojoToController&quot;)</span></span><br><span class="line"><span class="comment">//如果处理参数是POJO，且页面发送的请求数据格式与POJO中的属性对应，@RequestBody注解可以自动映射对应请求数据到POJO中</span></span><br><span class="line"><span class="keyword">public</span> String  <span class="title function_">ajaxPojoToController</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;controller pojo :&quot;</span>+user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ajaxListToController&quot;)</span></span><br><span class="line"><span class="comment">//如果处理参数是List集合且封装了POJO，且页面发送的数据是JSON格式，数据将自动映射到集合参数</span></span><br><span class="line"><span class="keyword">public</span> String  <span class="title function_">ajaxListToController</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; userList)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;controller list :&quot;</span>+userList);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ajax.jsp</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@page pageEncoding=&quot;UTF-8&quot; language=&quot;java&quot; contentType=&quot;text/html;UTF-8&quot; %&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0);&quot;</span> <span class="attr">id</span>=<span class="string">&quot;testAjax&quot;</span>&gt;</span>访问springmvc后台controller<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0);&quot;</span> <span class="attr">id</span>=<span class="string">&quot;testAjaxPojo&quot;</span>&gt;</span>传递Json格式POJO<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0);&quot;</span> <span class="attr">id</span>=<span class="string">&quot;testAjaxList&quot;</span>&gt;</span>传递Json格式List<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//为id=&quot;testAjax&quot;的组件绑定点击事件</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#testAjax&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//发送异步调用</span></span></span><br><span class="line"><span class="language-javascript">            $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="comment">//请求方式：POST请求</span></span></span><br><span class="line"><span class="language-javascript">               <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="comment">//请求的地址</span></span></span><br><span class="line"><span class="language-javascript">               <span class="attr">url</span>:<span class="string">&quot;ajaxController&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="comment">//请求参数（也就是请求内容）</span></span></span><br><span class="line"><span class="language-javascript">               <span class="attr">data</span>:<span class="string">&#x27;ajax message&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="comment">//响应正文类型</span></span></span><br><span class="line"><span class="language-javascript">               <span class="attr">dataType</span>:<span class="string">&quot;text&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="comment">//请求正文的MIME类型</span></span></span><br><span class="line"><span class="language-javascript">               <span class="attr">contentType</span>:<span class="string">&quot;application/text&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">         <span class="comment">//为id=&quot;testAjaxPojo&quot;的组件绑定点击事件</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#testAjaxPojo&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">url</span>:<span class="string">&quot;ajaxPojoToController&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">data</span>:<span class="string">&#x27;&#123;&quot;name&quot;:&quot;Jock&quot;,&quot;age&quot;:39&#125;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">dataType</span>:<span class="string">&quot;text&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">contentType</span>:<span class="string">&quot;application/json&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//为id=&quot;testAjaxList&quot;的组件绑定点击事件</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#testAjaxList&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            $.<span class="title function_">ajax</span>(&#123;<span class="comment">//.....</span></span></span><br><span class="line"><span class="language-javascript">               <span class="attr">data</span>:<span class="string">&#x27;[&#123;&quot;name&quot;:&quot;Jock&quot;,&quot;age&quot;:39&#125;,&#123;&quot;name&quot;:&quot;Jockme&quot;,&quot;age&quot;:40&#125;]&#x27;</span>&#125;)&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>web.xml配置：请求响应章节请求中的web.xml配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">CharacterEncodingFilter + DispatcherServlet</span><br></pre></td></tr></table></figure>

<p>spring-mvc.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;controller,domain&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="响应数据-1"><a href="#响应数据-1" class="headerlink" title="响应数据"></a>响应数据</h3><p>注解：@ResponseBody</p>
<p>作用：将 Java 对象转为 json 格式的数据</p>
<p>方法返回值为 POJO 时，自动封装数据成 Json 对象数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ajaxReturnJson&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">ajaxReturnJson</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;controller return json pojo...&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jockme&quot;</span>,<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>方法返回值为 List 时，自动封装数据成 json 对象数组数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ajaxReturnJsonList&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">//基于jackon技术，使用@ResponseBody注解可以将返回的保存POJO对象的集合转成json数组格式数据</span></span><br><span class="line"><span class="keyword">public</span> List <span class="title function_">ajaxReturnJsonList</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;controller return json list...&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">al</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    al.add(user1);</span><br><span class="line">    al.add(user2);</span><br><span class="line">    <span class="keyword">return</span> al;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AJAX 文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为id=&quot;testAjaxReturnString&quot;的组件绑定点击事件</span></span><br><span class="line">$(<span class="string">&quot;#testAjaxReturnString&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//发送异步调用</span></span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;ajaxReturnString&quot;</span>,</span><br><span class="line">        <span class="comment">//回调函数</span></span><br><span class="line">        <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">            <span class="comment">//打印返回结果</span></span><br><span class="line">            <span class="title function_">alert</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为id=&quot;testAjaxReturnJson&quot;的组件绑定点击事件</span></span><br><span class="line">$(<span class="string">&quot;#testAjaxReturnJson&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;ajaxReturnJson&quot;</span>,</span><br><span class="line">        <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">            <span class="title function_">alert</span>(data[<span class="string">&#x27;name&#x27;</span>]+<span class="string">&quot; ,  &quot;</span>+data[<span class="string">&#x27;age&#x27;</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为id=&quot;testAjaxReturnJsonList&quot;的组件绑定点击事件</span></span><br><span class="line">$(<span class="string">&quot;#testAjaxReturnJsonList&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;ajaxReturnJsonList&quot;</span>,</span><br><span class="line">        <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">            <span class="title function_">alert</span>(data);</span><br><span class="line">            <span class="title function_">alert</span>(data[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">            <span class="title function_">alert</span>(data[<span class="number">1</span>][<span class="string">&quot;age&quot;</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="跨域访问"><a href="#跨域访问" class="headerlink" title="跨域访问"></a>跨域访问</h3><p>跨域访问：当通过域名 A 下的操作访问域名 B 下的资源时，称为跨域访问，跨域访问时，会出现无法访问的现象</p>
<p>环境搭建：</p>
<ul>
<li>为当前主机添加备用域名<ul>
<li>修改 windows 安装目录中的 host 文件</li>
<li>格式： ip 域名</li>
</ul>
</li>
<li>动态刷新 DNS<ul>
<li>命令： ipconfig &#x2F;displaydns</li>
<li>命令： ipconfig &#x2F;flushdns</li>
</ul>
</li>
</ul>
<p>跨域访问支持：</p>
<ul>
<li>名称：@CrossOrigin</li>
<li>类型：方法注解 、 类注解</li>
<li>位置：处理器类中的方法上方或类上方</li>
<li>作用：设置当前处理器方法 &#x2F; 处理器类中所有方法支持跨域访问</li>
<li>范例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/cross&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">//使用@CrossOrigin开启跨域访问</span></span><br><span class="line"><span class="comment">//标注在处理器方法上方表示该方法支持跨域访问</span></span><br><span class="line"><span class="comment">//标注在处理器类上方表示该处理器类中的所有处理器方法均支持跨域访问</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">cross</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;controller cross...&quot;</span> + request.getRequestURL());</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jockme&quot;</span>,<span class="number">36</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>jsp 文件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0);&quot;</span> <span class="attr">id</span>=<span class="string">&quot;testCross&quot;</span>&gt;</span>跨域访问<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//为id=&quot;testCross&quot;的组件绑定点击事件</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#testCross&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//发送异步调用</span></span></span><br><span class="line"><span class="language-javascript">            $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">url</span>:<span class="string">&quot;http://127.0.0.1/cross&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="comment">//回调函数</span></span></span><br><span class="line"><span class="language-javascript">               <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                   <span class="title function_">alert</span>(<span class="string">&quot;跨域调用信息反馈:&quot;</span> + data[<span class="string">&#x27;name&#x27;</span>] + <span class="string">&quot;,&quot;</span> + data[<span class="string">&#x27;age&#x27;</span>]);</span></span><br><span class="line"><span class="language-javascript">               &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>拦截器（Interceptor）是一种动态拦截方法调用的机制</p>
<p>作用：</p>
<ol>
<li>在指定的方法调用前后执行预先设定后的的代码</li>
<li>阻止原始方法的执行</li>
</ol>
<p>核心原理：AOP 思想</p>
<p>拦截器链：多个拦截器按照一定的顺序，对原始被调用功能进行增强  </p>
<p>拦截器和过滤器对比：</p>
<ol>
<li><p>归属不同： Filter 属于 Servlet 技术， Interceptor 属于 SpringMVC 技术</p>
</li>
<li><p>拦截内容不同： Filter 对所有访问进行增强， Interceptor 仅针对 SpringMVC 的访问进行增强  </p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-过滤器和拦截器的运行机制.png" style="zoom:67%;"></li>
</ol>
<hr>
<h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><h4 id="前置处理"><a href="#前置处理" class="headerlink" title="前置处理"></a>前置处理</h4><p>原始方法之前运行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                         HttpServletResponse response,</span></span><br><span class="line"><span class="params">                         Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;preHandle&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数：<ul>
<li>request：请求对象</li>
<li>response：响应对象</li>
<li>handler：被调用的处理器对象，本质上是一个方法对象，对反射中的Method对象进行了再包装<ul>
<li>handler：public String controller.InterceptorController.handleRun</li>
<li>handler.getClass()：org.springframework.web.method.HandlerMethod</li>
</ul>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>返回值为 false，被拦截的处理器将不执行</li>
</ul>
</li>
</ul>
<hr>
<h4 id="后置处理-1"><a href="#后置处理-1" class="headerlink" title="后置处理"></a>后置处理</h4><p>原始方法运行后运行，如果原始方法被拦截，则不执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                       HttpServletResponse response,</span></span><br><span class="line"><span class="params">                       Object handler,</span></span><br><span class="line"><span class="params">                       ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;postHandle&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>modelAndView：如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整</li>
</ul>
<hr>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>拦截器最后执行的方法，无论原始方法是否执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                            HttpServletResponse response,</span></span><br><span class="line"><span class="params">                            Object handler,</span></span><br><span class="line"><span class="params">                            Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;afterCompletion&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>ex：如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理</li>
</ul>
<hr>
<h3 id="拦截配置"><a href="#拦截配置" class="headerlink" title="拦截配置"></a>拦截配置</h3><p>拦截路径：</p>
<ul>
<li><code>/**</code>：表示拦截所有映射</li>
<li><code>/* </code>：表示拦截所有&#x2F;开头的映射</li>
<li><code>/user/*</code>：表示拦截所有 &#x2F;user&#x2F; 开头的映射</li>
<li><code>/user/add*</code>：表示拦截所有 &#x2F;user&#x2F; 开头，且具体映射名称以 add 开头的映射</li>
<li><code>/user/*All</code>：表示拦截所有 &#x2F;user&#x2F; 开头，且具体映射名称以 All 结尾的映射</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启具体的拦截器的使用，可以配置多个--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置拦截器的拦截路径，支持*通配--&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/handleRun*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置拦截排除的路径，配置/**或/*，达到快速配置的目的--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/b*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定具体的拦截器类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h3><p><strong>责任链模式</strong>：责任链模式是一种行为模式</p>
<p>特点：沿着一条预先设定的任务链顺序执行，每个节点具有独立的工作任务<br>优势：</p>
<ul>
<li>独立性：只关注当前节点的任务，对其他任务直接放行到下一节点</li>
<li>隔离性：具备链式传递特征，无需知晓整体链路结构，只需等待请求到达后进行处理即可</li>
<li>灵活性：可以任意修改链路结构动态新增或删减整体链路责任</li>
<li>解耦：将动态任务与原始任务解耦</li>
</ul>
<p>缺点：</p>
<ul>
<li>链路过长时，处理效率低下</li>
<li>可能存在节点上的循环引用现象，造成死循环，导致系统崩溃</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-多拦截器配置.png" style="zoom:67%;">



<hr>
<h3 id="源码解析-2"><a href="#源码解析-2" class="headerlink" title="源码解析"></a>源码解析</h3><p>DispatcherServlet#doDispatch 方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取映射器以及映射器的所有拦截器（运行原理部分详解了源码）</span></span><br><span class="line">        mappedHandler = getHandler(processedRequest);</span><br><span class="line">        <span class="comment">// 前置处理，返回 false 代表条件成立</span></span><br><span class="line">        <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">            <span class="comment">//请求从这里直接结束</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//所有拦截器都返回 true，执行目标方法</span></span><br><span class="line">        mv = ha.handle(processedRequest, response, mappedHandler.getHandler())</span><br><span class="line">        <span class="comment">// 倒序执行所有拦截器的后置处理方法</span></span><br><span class="line">        mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="comment">//异常处理机制</span></span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HandlerExecutionChain#applyPreHandle：前置处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//遍历所有的拦截器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.interceptorList.size(); i++) &#123;</span><br><span class="line">        <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line">        <span class="comment">//执行前置处理，如果拦截器返回 false，则条件成立，不在执行其他的拦截器，直接返回 false，请求直接结束</span></span><br><span class="line">        <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="built_in">this</span>.handler)) &#123;</span><br><span class="line">            triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.interceptorIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HandlerExecutionChain#applyPostHandle：后置处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> ModelAndView mv)</span></span><br><span class="line">    <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">//倒序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line">        interceptor.postHandle(request, response, <span class="built_in">this</span>.handler, mv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispatcherServlet#triggerAfterCompletion 底层调用 HandlerExecutionChain#triggerAfterCompletion：</p>
<ul>
<li><p>前面的步骤有任何异常都会直接倒序触发 afterCompletion</p>
</li>
<li><p>页面成功渲染有异常，也会倒序触发 afterCompletion</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> Exception ex)</span> &#123;</span><br><span class="line">    <span class="comment">//倒序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行异常处理的方法</span></span><br><span class="line">            interceptor.afterCompletion(request, response, <span class="built_in">this</span>.handler, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;HandlerInterceptor.afterCompletion threw exception&quot;</span>, ex2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>拦截器的执行流程：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-拦截器工作流程.png" style="zoom: 50%;">



<p>参考文章：<a href="https://www.yuque.com/atguigu/springboot/vgzmgh#wtPLU">https://www.yuque.com/atguigu/springboot/vgzmgh#wtPLU</a></p>
<hr>
<h3 id="自定义-2"><a href="#自定义-2" class="headerlink" title="自定义"></a>自定义</h3><ul>
<li><p>Contoller层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterceptorController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/handleRun&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleRun</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;业务处理器运行------------main&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义拦截器需要实现 HandleInterceptor 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义拦截器需要实现HandleInterceptor接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//处理器运行之前执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                             HttpServletResponse response,</span></span><br><span class="line"><span class="params">                             Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置运行----a1&quot;</span>);</span><br><span class="line">        <span class="comment">//返回值为false将拦截原始处理器的运行</span></span><br><span class="line">        <span class="comment">//如果配置多拦截器，返回值为false将终止当前拦截器后面配置的拦截器的运行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理器运行之后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                           HttpServletResponse response,</span></span><br><span class="line"><span class="params">                           Object handler,</span></span><br><span class="line"><span class="params">                           ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置运行----b1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有拦截器的后置执行全部结束后，执行该操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                Object handler,</span></span><br><span class="line"><span class="params">                                Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;完成运行----c1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：三个方法的运行顺序为    preHandle → postHandle → afterCompletion，如果 preHandle 返回值为 false，三个方法仅运行preHandle</p>
</li>
<li><p>web.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">CharacterEncodingFilter + DispatcherServlet</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置拦截器：spring-mvc.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;interceptor,controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/handleRun&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;interceptor.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：配置顺序为<strong>先配置执行位置，后配置执行类</strong></p>
</li>
</ul>
<hr>
<h2 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="处理器-1"><a href="#处理器-1" class="headerlink" title="处理器"></a>处理器</h3><p>异常处理器： <strong>HandlerExceptionResolver</strong> 接口</p>
<p>类继承该接口的以后，当开发出现异常后会执行指定的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                         HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                         Object handler,</span></span><br><span class="line"><span class="params">                                         Exception ex)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常处理器正在执行中&quot;</span>);</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        <span class="comment">//定义异常现象出现后，反馈给用户查看的信息</span></span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;出错啦！ &quot;</span>);</span><br><span class="line">        <span class="comment">//定义异常现象出现后，反馈给用户查看的页面</span></span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;error.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据异常的种类不同，进行分门别类的管理，返回不同的信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                         HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                         Object handler,</span></span><br><span class="line"><span class="params">                                         Exception ex)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;my exception is running ....&quot;</span> + ex);</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        <span class="keyword">if</span>( ex <span class="keyword">instanceof</span> NullPointerException)&#123;</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;空指针异常&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( ex <span class="keyword">instanceof</span>  ArithmeticException)&#123;</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;算数运算异常&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;未知的异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;error.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> String name)</span> &#123;</span><br><span class="line">        <span class="comment">//模拟业务层发起调用产生了异常</span></span><br><span class="line"><span class="comment">//        int i = 1/0;</span></span><br><span class="line"><span class="comment">//        String str = null;</span></span><br><span class="line"><span class="comment">//        str.length();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="注解开发-3"><a href="#注解开发-3" class="headerlink" title="注解开发"></a>注解开发</h3><p>使用注解实现异常分类管理，开发异常处理器</p>
<p>@ControllerAdvice 注解：</p>
<ul>
<li><p>类型：类注解</p>
</li>
<li><p>位置：异常处理器类上方</p>
</li>
<li><p>作用：设置当前类为异常处理器类</p>
</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//声明该类是一个Controller的通知类，声明后该类就会被加载成异常处理器</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionAdvice</span> &#123;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ul>
<p>@ExceptionHandler 注解：</p>
<ul>
<li><p>类型：方法注解</p>
</li>
<li><p>位置：异常处理器类中针对指定异常进行处理的方法上方</p>
</li>
<li><p>作用：设置指定异常的处理方式</p>
</li>
<li><p>说明：处理器方法可以设定多个</p>
</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//类中定义的方法携带@ExceptionHandler注解的会被作为异常处理器，后面添加实际处理的异常类型</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(NullPointerException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doNullException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;空指针异常&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;all Exception&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>@ResponseStatus 注解：</p>
<ul>
<li><p>类型：类注解、方法注解</p>
</li>
<li><p>位置：异常处理器类、方法上方</p>
</li>
<li><p>参数：</p>
<p>value：出现错误指定返回状态码</p>
<p>reason：出现错误返回的错误信息</p>
</li>
</ul>
<hr>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li><p>web.xml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DispatcherServlet + CharacterEncodingFilter</span><br></pre></td></tr></table></figure>
</li>
<li><p>ajax.jsp</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html;UTF-8&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=<span class="string">&quot;javascript:void(0);&quot;</span> id=<span class="string">&quot;testException&quot;</span>&gt;点击&lt;/a&gt;&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    $(function () &#123;</span><br><span class="line">        $(<span class="string">&quot;#testException&quot;</span>).click(function()&#123;</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                contentType:<span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">                type:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">                url:<span class="string">&quot;save&quot;</span>,</span><br><span class="line">                <span class="comment">/*通过修改参数，激活自定义异常的出现*/</span></span><br><span class="line">                <span class="comment">// name长度低于8位出现业务异常</span></span><br><span class="line">                <span class="comment">// age小于0出现业务异常</span></span><br><span class="line">                <span class="comment">// age大于100出现系统异常</span></span><br><span class="line">                <span class="comment">// age类型如果无法匹配将转入其他类别异常</span></span><br><span class="line">                data:<span class="string">&#x27;&#123;&quot;name&quot;:&quot;JockSuperMan&quot;,&quot;age&quot;:&quot;-1&quot;&#125;&#x27;</span>,</span><br><span class="line">                dataType:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">                <span class="comment">//回调函数</span></span><br><span class="line">                success:function(data)&#123;</span><br><span class="line">                    alert(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>spring-mvc.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.seazean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>java &#x2F; controller &#x2F; UserController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user controller save is running ...&quot;</span>);</span><br><span class="line">        <span class="comment">//对用户的非法操作进行判定，并包装成异常对象进行处理，便于统一管理</span></span><br><span class="line">        <span class="keyword">if</span>(user.getName().trim().length() &lt; <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;对不起，用户名长度不满足要求，请重新输入！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(user.getAge() &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;对不起，年龄必须是0到100之间的数字！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(user.getAge() &gt; <span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SystemException</span>(<span class="string">&quot;服务器连接失败，请尽快检查处理！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">5</span>);</span><br><span class="line">        ArrayList&lt;User&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">        al.add(u1);al.add(u2);</span><br><span class="line">        <span class="keyword">return</span> al;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义异常继承RuntimeException，覆盖父类所有的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;覆盖父类所有的构造方法&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过自定义异常将所有的异常现象进行分类管理，以统一的格式对外呈现异常消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doBusinessException</span><span class="params">(Exception ex, Model m)</span>&#123;</span><br><span class="line">        <span class="comment">//使用参数Model将要保存的数据传递到页面上，功能等同于ModelAndView</span></span><br><span class="line">        <span class="comment">//业务异常出现的消息要发送给用户查看</span></span><br><span class="line">        m.addAttribute(<span class="string">&quot;msg&quot;</span>,ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(SystemException.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doSystemException</span><span class="params">(Exception ex, Model m)</span>&#123;</span><br><span class="line">        <span class="comment">//系统异常出现的消息不要发送给用户查看，发送统一的信息给用户看</span></span><br><span class="line">        m.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;服务器出现问题，请联系管理员！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doException</span><span class="params">(Exception ex, Model m)</span>&#123;</span><br><span class="line">        m.addAttribute(<span class="string">&quot;msg&quot;</span>,ex.getMessage());</span><br><span class="line">        <span class="comment">//将ex对象保存起来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h2><h3 id="上传下载"><a href="#上传下载" class="headerlink" title="上传下载"></a>上传下载</h3><p>上传文件过程：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.png"></p>
<p>MultipartResolver接口：</p>
<ul>
<li>MultipartResolver 接口定义了文件上传过程中的相关操作，并对通用性操作进行了封装</li>
<li>MultipartResolver 接口底层实现类 CommonsMultipartResovler</li>
<li>CommonsMultipartResovler 并未自主实现文件上传下载对应的功能，而是调用了 apache 文件上传下载组件</li>
</ul>
<p>文件上传下载实现：</p>
<ul>
<li><p>导入坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>页面表单 fileupload.jsp</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">DispatcherServlet + CharacterEncodingFilter</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestParam(&quot;email&quot;)</span> String email,</span></span><br><span class="line"><span class="params">                     <span class="meta">@RequestParam(&quot;username&quot;)</span> String username,</span></span><br><span class="line"><span class="params">                     <span class="meta">@RequestPart(&quot;headerImg&quot;)</span> MultipartFile headerImg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!headerImg.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//保存到文件服务器，OSS服务器</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> headerImg.getOriginalFilename();</span><br><span class="line">        headerImg.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;H:\\cache\\&quot;</span> + originalFilename));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="名称问题"><a href="#名称问题" class="headerlink" title="名称问题"></a>名称问题</h3><p>MultipartFile 参数中封装了上传的文件的相关信息。</p>
<ol>
<li><p>文件命名问题， 获取上传文件名，并解析文件名与扩展名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">file.getOriginalFilename();</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件名过长问题</p>
</li>
<li><p>文件保存路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line"><span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> context.getRealPath(<span class="string">&quot;/uploads&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(realPath + <span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!file.exists()) file.mkdirs();</span><br></pre></td></tr></table></figure>
</li>
<li><p>重名问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID.toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).toUpperCase();</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/fileupload&quot;)</span></span><br><span class="line">	<span class="comment">//参数中定义MultipartFile参数，用于接收页面提交的type=file类型的表单，表单名称与参数名相同</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fileupload</span><span class="params">(MultipartFile file,MultipartFile file1,MultipartFile file2, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;file upload is running ...&quot;</span>+file);</span><br><span class="line"><span class="comment">//        MultipartFile参数中封装了上传的文件的相关信息</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getSize());</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getBytes().length);</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getContentType());</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getName());</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getOriginalFilename());</span></span><br><span class="line"><span class="comment">//        System.out.println(file.isEmpty());</span></span><br><span class="line">        <span class="comment">//首先判断是否是空文件，也就是存储空间占用为0的文件</span></span><br><span class="line">        <span class="keyword">if</span>(!file.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//如果大小在范围要求内正常处理，否则抛出自定义异常告知用户（未实现）</span></span><br><span class="line">            <span class="comment">//获取原始上传的文件名，可以作为当前文件的真实名称保存到数据库中备用</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">            <span class="comment">//设置保存的路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;/images&quot;</span>);</span><br><span class="line">            <span class="comment">//保存文件的方法，通常文件名使用随机生成策略产生，避免文件名冲突问题</span></span><br><span class="line">            file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(realPath,file.getOriginalFilename()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//测试一次性上传多个文件</span></span><br><span class="line">        <span class="keyword">if</span>(!file1.isEmpty())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file1.getOriginalFilename();</span><br><span class="line">            <span class="comment">//可以根据需要，对不同种类的文件做不同的存储路径的区分，修改对应的保存位置即可</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;/images&quot;</span>);</span><br><span class="line">            file1.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(realPath,file1.getOriginalFilename()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!file2.isEmpty())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file2.getOriginalFilename();</span><br><span class="line">            <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;/images&quot;</span>);</span><br><span class="line">            file2.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(realPath,file2.getOriginalFilename()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="源码解析-3"><a href="#源码解析-3" class="headerlink" title="源码解析"></a>源码解析</h3><p>StandardServletMultipartResolver 是文件上传解析器</p>
<p>DispatcherServlet#doDispatch：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 判断当前请求是不是文件上传请求</span></span><br><span class="line">    processedRequest = checkMultipart(request);</span><br><span class="line">    <span class="comment">// 文件上传请求会对 request 进行包装，导致两者不相等，此处赋值为 true，代表已经被解析</span></span><br><span class="line">    multipartRequestParsed = (processedRequest != request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispatcherServlet#checkMultipart：</p>
<ul>
<li><code>if (this.multipartResolver != null &amp;&amp; this.multipartResolver.isMultipart(request))</code>：判断是否是文件请求<ul>
<li><code>StandardServletMultipartResolver#isMultipart</code>：根据开头是否符合 multipart&#x2F;form-data 或者 multipart&#x2F;</li>
</ul>
</li>
<li><code>return this.multipartResolver.resolveMultipart(request)</code>：把请求封装成 StandardMultipartHttpServletRequest 对象</li>
</ul>
<p>开始执行 ha.handle() 目标方法进行数据的解析</p>
<ul>
<li><p>RequestPartMethodArgumentResolver#supportsParameter：支持解析文件上传数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数上有 @RequestPart 注解</span></span><br><span class="line">    <span class="keyword">if</span> (parameter.hasParameterAnnotation(RequestPart.class)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RequestPartMethodArgumentResolver#resolveArgument：解析参数数据，封装成 MultipartFile 对象</p>
<ul>
<li><code>RequestPart requestPart = parameter.getParameterAnnotation(RequestPart.class)</code>：获取注解的相关信息</li>
<li><code>String name = getPartName(parameter, requestPart)</code>：获取上传文件的名字</li>
<li><code>Object mpArg = MultipartResolutionDelegate.resolveMultipartArgument()</code>：解析参数<ul>
<li><code>List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name)</code>：获取文件的所有数据</li>
</ul>
</li>
</ul>
</li>
<li><p><code>return doInvoke(args)</code>：解析完成执行自定义的方法，完成上传功能</p>
</li>
</ul>
<hr>
<h2 id="实用技术"><a href="#实用技术" class="headerlink" title="实用技术"></a>实用技术</h2><h3 id="校验框架"><a href="#校验框架" class="headerlink" title="校验框架"></a>校验框架</h3><h4 id="校验概述"><a href="#校验概述" class="headerlink" title="校验概述"></a>校验概述</h4><p>表单校验保障了数据有效性、安全性  </p>
<p>校验分类：客户端校验和服务端校验</p>
<ul>
<li>格式校验<ul>
<li>客户端：使用 js 技术，利用正则表达式校验</li>
<li>服务端：使用校验框架</li>
</ul>
</li>
<li>逻辑校验<ul>
<li>客户端：使用ajax发送要校验的数据，在服务端完成逻辑校验，返回校验结果</li>
<li>服务端：接收到完整的请求后，在执行业务操作前，完成逻辑校验</li>
</ul>
</li>
</ul>
<p>表单校验框架：</p>
<ul>
<li><p>JSR（Java Specification Requests）：Java 规范提案 </p>
</li>
<li><p>303：提供bean属性相关校验规则</p>
</li>
<li><p>JCP（Java Community Process）：Java社区</p>
</li>
<li><p>Hibernate框架中包含一套独立的校验框架hibernate-validator </p>
</li>
<li><p>导入坐标：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入校验的jsr303规范--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--导入校验框架实现技术--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>tomcat7：搭配 hibernate-validator 版本 5.<em>.</em>.Final</li>
<li>tomcat8.5：搭配 hibernate-validator 版本 6.<em>.</em>.Final</li>
</ul>
<hr>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="开启校验"><a href="#开启校验" class="headerlink" title="开启校验"></a>开启校验</h5><p>名称：@Valid、@Validated</p>
<p>类型：形参注解</p>
<p>位置：处理器类中的实体类类型的方法形参前方</p>
<p>作用：设定对当前实体类类型参数进行校验</p>
<p>范例：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/addemployee&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addEmployee</span><span class="params">(<span class="meta">@Valid</span> Employee employee)</span> &#123;</span><br><span class="line">    System.out.println(employee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="校验规则"><a href="#校验规则" class="headerlink" title="校验规则"></a>校验规则</h5><p>名称：@NotNull</p>
<p>类型：属性注解等</p>
<p>位置：实体类属性上方</p>
<p>作用：设定当前属性校验规则</p>
<p>范例：每个校验规则所携带的参数不同，根据校验规则进行相应的调整，具体的校验规则查看对应的校验框架进行获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;姓名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//员工姓名</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<h5 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/addemployee&quot;)</span></span><br><span class="line"><span class="comment">//Errors对象用于封装校验结果，如果不满足校验规则，对应的校验结果封装到该对象中，包含校验的属性名和校验不通过返回的消息</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addEmployee</span><span class="params">(<span class="meta">@Valid</span> Employee employee, Errors errors, Model model)</span>&#123;</span><br><span class="line">    System.out.println(employee);</span><br><span class="line">    <span class="comment">//判定Errors对象中是否存在未通过校验的字段</span></span><br><span class="line">    <span class="keyword">if</span>(errors.hasErrors())&#123;</span><br><span class="line">        <span class="keyword">for</span>(FieldError error : errors.getFieldErrors())&#123;</span><br><span class="line">        	<span class="comment">//将校验结果添加到Model对象中，用于页面显示，返回json数据即可</span></span><br><span class="line">            model.addAttribute(error.getField(),error.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当出现未通过校验的字段时，跳转页面到原始页面，进行数据回显</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;addemployee.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>通过形参Errors获取校验结果数据，通过Model接口将数据封装后传递到页面显示，页面获取后台封装的校验结果信息  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/addemployee&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    员工姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>$&#123;name&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    员工年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>$&#123;age&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="多规则校验"><a href="#多规则校验" class="headerlink" title="多规则校验"></a>多规则校验</h4><ul>
<li><p>同一个属性可以添加多个校验器  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;姓名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//员工姓名</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;请输入年龄&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 60,message = &quot;年龄最大值60&quot;)</span></span><br><span class="line">    <span class="meta">@Min(value = 18,message = &quot;年龄最小值18&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;<span class="comment">//员工年龄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>三种判定空校验器的区别<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringMVC-%E4%B8%89%E7%A7%8D%E5%88%A4%E5%AE%9A%E7%A9%BA%E6%A3%80%E9%AA%8C%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB.png"></p>
</li>
</ul>
<hr>
<h4 id="嵌套校验"><a href="#嵌套校验" class="headerlink" title="嵌套校验"></a>嵌套校验</h4><p>名称：@Valid</p>
<p>类型：属性注解</p>
<p>位置：实体类中的引用类型属性上方</p>
<p>作用：设定当前应用类型属性中的属性开启校验</p>
<p>范例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="comment">//实体类中的引用类型通过标注@Valid注解，设定开启当前引用类型字段中的属性参与校验</span></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：开启嵌套校验后，被校验对象内部需要添加对应的校验规则  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//嵌套校验的实体中，对每个属性正常添加校验规则即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;请输入省份名称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String provinceName;<span class="comment">//省份名称</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;请输入邮政编码&quot;)</span></span><br><span class="line">    <span class="meta">@Size(max = 6,min = 6,message = &quot;邮政编码由6位组成&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String zipCode;<span class="comment">//邮政编码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h4><p>分组校验的介绍</p>
<ul>
<li>同一个模块，根据执行的业务不同，需要校验的属性会有不同<ul>
<li>新增用户</li>
<li>修改用户</li>
</ul>
</li>
<li>对不同种类的属性进行分组，在校验时可以指定参与校验的字段所属的组类别<ul>
<li>定义组（通用）</li>
<li>为属性设置所属组，可以设置多个</li>
<li>开启组校验</li>
</ul>
</li>
</ul>
<p>domain：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于设定分组校验中的组名，当前接口仅提供字节码，用于识别</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GroupOne</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;姓名不能为空&quot;,groups = &#123;GroupA.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//员工姓名</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;请输入年龄&quot;,groups = &#123;GroupA.class&#125;)</span></span><br><span class="line">    <span class="meta">@Max(value = 60,message = &quot;年龄最大值60&quot;)</span><span class="comment">//不加Group的校验不生效</span></span><br><span class="line">    <span class="meta">@Min(value = 18,message = &quot;年龄最小值18&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;<span class="comment">//员工年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/addemployee&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addEmployee</span><span class="params">(<span class="meta">@Validated(&#123;GroupA.class&#125;)</span> Employee employee, Errors errors, Model m)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(errors.hasErrors())&#123;</span><br><span class="line">            List&lt;FieldError&gt; fieldErrors = errors.getFieldErrors();</span><br><span class="line">            System.out.println(fieldErrors.size());</span><br><span class="line">            <span class="keyword">for</span>(FieldError error : fieldErrors)&#123;</span><br><span class="line">                m.addAttribute(error.getField(),error.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;addemployee.jsp&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jsp：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/addemployee&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span>&lt;%--页面使用$&#123;&#125;获取后台传递的校验信息--%&gt;</span><br><span class="line">    员工姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>$&#123;name&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    员工年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>$&#123;age&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    &lt;%--注意，引用类型的校验未通过信息不是通过对象进行封装的，直接使用对象名.属性名的格式作为整体属性字符串进行保存的，和使用者的属性传递方式有关，不具有通用性，仅适用于本案例--%&gt;</span><br><span class="line">    省：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;address.provinceName&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>$&#123;requestScope[&#x27;address.provinceName&#x27;]&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">/form&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p>Lombok 用标签方式代替构造器、getter&#x2F;setter、toString() 等方法</p>
<p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下载插件：IDEA 中 File → Settings → Plugins，搜索安装 Lombok 插件</p>
<p>常用注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span>		<span class="comment">// 无参构造</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span>		<span class="comment">// 全参构造</span></span><br><span class="line"><span class="meta">@Data</span>					<span class="comment">// set + get</span></span><br><span class="line"><span class="meta">@ToString</span>				<span class="comment">// toString</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span>		<span class="comment">// hashConde + equals</span></span><br></pre></td></tr></table></figure>

<p>简化日志：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handle01</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;请求进来了....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Spring!&quot;</span> + <span class="string">&quot;你好：&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="Boot"><a href="#Boot" class="headerlink" title="Boot"></a>Boot</h1><h2 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="Boot介绍"><a href="#Boot介绍" class="headerlink" title="Boot介绍"></a>Boot介绍</h3><p>SpringBoot 提供了一种快速使用 Spring 的方式，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率</p>
<p>SpringBoot 功能：</p>
<ul>
<li><p>自动配置，自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素选择使用哪个配置，该过程是SpringBoot 自动完成的</p>
</li>
<li><p>起步依赖，起步依赖本质上是一个 Maven 项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能</p>
</li>
<li><p>辅助功能，提供了一些大型项目中常见的非功能性特性，如内嵌 web 服务器、安全、指标，健康检测、外部配置等</p>
</li>
</ul>
<p>参考视频：<a href="https://www.bilibili.com/video/BV19K4y1L7MT">https://www.bilibili.com/video/BV19K4y1L7MT</a></p>
<hr>
<h3 id="构建工程"><a href="#构建工程" class="headerlink" title="构建工程"></a>构建工程</h3><p>普通构建：</p>
<ol>
<li><p>创建 Maven 项目</p>
</li>
<li><p>导入 SpringBoot 起步依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--springboot 工程需要继承的父工程--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--web 开发的起步依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义 Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; hello Spring Boot !&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写引导类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引导类，SpringBoot项目的入口</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(HelloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>快速构建：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringBoot-IDEA%E6%9E%84%E5%BB%BA%E5%B7%A5%E7%A8%8B.png"></p>
<hr>
<h2 id="自动装配-1"><a href="#自动装配-1" class="headerlink" title="自动装配"></a>自动装配</h2><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>在 spring-boot-starter-parent 中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。在各种 starter 中，定义了完成该功能需要的坐标合集，其中大部分版本信息来自于父工程。工程继承 parent，引入 starter 后，通过依赖传递，就可以简单方便获得需要的 jar 包，并且不会存在版本冲突，自动版本仲裁机制</p>
<hr>
<h3 id="底层注解"><a href="#底层注解" class="headerlink" title="底层注解"></a>底层注解</h3><h4 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h4><p>@SpringBootApplication：启动注解，实现 SpringBoot 的自动部署</p>
<ul>
<li>参数 scanBasePackages：可以指定扫描范围</li>
<li>默认扫描当前引导类所在包及其子包</li>
</ul>
<p>假如所在包为 com.example.springbootenable，扫描配置包 com.example.config 的信息，三种解决办法：</p>
<ol>
<li><p>使用 @ComponentScan 扫描 com.example.config 包</p>
</li>
<li><p>使用 @Import 注解，加载类，这些类都会被 Spring 创建并放入 ioc 容器，默认组件的名字就是<strong>全类名</strong></p>
</li>
<li><p>对 @Import 注解进行封装</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.@ComponentScan(&quot;com.example.config&quot;)</span></span><br><span class="line"><span class="comment">//2.@Import(UserConfig.class)</span></span><br><span class="line"><span class="meta">@EnableUser</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootEnableApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(SpringbootEnableApplication.class, args);</span><br><span class="line">    	<span class="comment">//获取Bean</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserConfig：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EnableUser 注解类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(UserConfig.class)</span><span class="comment">//@Import注解实现Bean的动态加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableUser &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><p>@Configuration：设置当前类为 SpringBoot 的配置类</p>
<ul>
<li>proxyBeanMethods &#x3D; true：Full 全模式，每个 @Bean 方法被调用多少次返回的组件都是单实例的，默认值，类组件之间<strong>有依赖关系</strong>，方法会被调用得到之前单实例组件</li>
<li>proxyBeanMethods &#x3D; false：Lite 轻量级模式，每个 @Bean 方法被调用多少次返回的组件都是新创建的，类组件之间<strong>无依赖关系</strong>用 Lite 模式加速容器启动过程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//给容器中添加组件。以方法名作为组件的 id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><h5 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h5><p>Condition 是 Spring4.0 后引入的条件化配置接口，通过实现 Condition 接口可以完成有条件的加载相应的 Bean</p>
<p>注解：@Conditional</p>
<p>作用：条件装配，满足 Conditional 指定的条件则进行组件注入，加上方法或者类上，作用范围不同</p>
<p>使用：@Conditional 配合 Condition 的实现类（ClassCondition）进行使用</p>
<p>ConditionContext 类API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ConfigurableListableBeanFactory  getBeanFactory（）</td>
<td>获取到 IOC 使用的 beanfactory</td>
</tr>
<tr>
<td>ClassLoader getClassLoader()</td>
<td>获取类加载器</td>
</tr>
<tr>
<td>Environment getEnvironment()</td>
<td>获取当前环境信息</td>
</tr>
<tr>
<td>BeanDefinitionRegistry getRegistry()</td>
<td>获取到 bean 定义的注册类</td>
</tr>
</tbody></table>
<ul>
<li><p>ClassCondition</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * context 上下文对象。用于获取环境，IOC容器，ClassLoader对象</span></span><br><span class="line"><span class="comment">     * metadata 注解元对象。 可以用于获取注解定义的属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//1.需求： 导入Jedis坐标后创建Bean</span></span><br><span class="line">        <span class="comment">//思路：判断redis.clients.jedis.Jedis.class文件是否存在</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;redis.clients.jedis.Jedis&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>UserConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional(ClassCondition.class)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootConditionApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//启动SpringBoot应用，返回Spring的IOC容器</span></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(SpringbootConditionApplication.class, args);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h5><p>将类的判断定义为动态的，判断哪个字节码文件存在可以动态指定</p>
<ul>
<li><p>自定义条件注解类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional(ClassCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionOnClass &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ClassCondition</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext conditionContext, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求：通过注解属性值value指定坐标后创建bean</span></span><br><span class="line">        Map&lt;String, Object&gt; map = metadata.getAnnotationAttributes</span><br><span class="line">            					(ConditionOnClass.class.getName());</span><br><span class="line">        <span class="comment">//map = &#123;value=&#123;属性值&#125;&#125;</span></span><br><span class="line">        <span class="comment">//获取所有的</span></span><br><span class="line">        String[] value = (String[]) map.get(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String className : value) &#123;</span><br><span class="line">                Class&lt;?&gt; cls = Class.forName(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>UserConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionOnClass(&quot;com.alibaba.fastjson.JSON&quot;)</span><span class="comment">//JSON加载了才注册 User 到容器</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试 User 对象的创建</p>
</li>
</ul>
<hr>
<h5 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h5><p>SpringBoot 提供的常用条件注解：</p>
<p>@ConditionalOnProperty：判断<strong>配置文件</strong>中是否有对应属性和值才初始化 Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(name = &quot;it&quot;, havingValue = &quot;seazean&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">it</span>=<span class="string">seazean</span></span><br></pre></td></tr></table></figure>

<p>@ConditionalOnClass：判断环境中是否有对应类文件才初始化 Bean</p>
<p>@ConditionalOnMissingClass：判断环境中是否有对应类文件才初始化 Bean</p>
<p>@ConditionalOnMissingBean：判断环境中没有对应Bean才初始化 Bean</p>
<hr>
<h4 id="ImportRes"><a href="#ImportRes" class="headerlink" title="ImportRes"></a>ImportRes</h4><p>使用 bean.xml 文件生成配置 bean，如果需要继续复用 bean.xml，@ImportResource 导入配置文件即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:beans.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;haha&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lun.boot.bean.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hehe&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lun.boot.bean.Pet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tomcat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><p>@ConfigurationProperties：读取到 properties 文件中的内容，并且封装到 JavaBean 中</p>
<p>配置文件：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mycar.brand</span>=<span class="string">BYD</span></span><br><span class="line"><span class="attr">mycar.price</span>=<span class="string">100000</span></span><br></pre></td></tr></table></figure>

<p>JavaBean 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>	<span class="comment">//导入到容器内</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span><span class="comment">//代表配置文件的前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="源码解析-4"><a href="#源码解析-4" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><p>应用启动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 启动代码</span></span><br><span class="line">        SpringApplication.run(BootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringApplication 构造方法：</p>
<ul>
<li><p><code>this.resourceLoader = resourceLoader</code>：资源加载器，初始为 null</p>
</li>
<li><p><code>this.webApplicationType = WebApplicationType.deduceFromClasspath()</code>：判断当前应用的类型，是响应式还是 Web 类</p>
</li>
<li><p><code>this.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories()</code>：<strong>获取引导器</strong></p>
<ul>
<li>去 <strong><code>META-INF/spring.factories</code></strong> 文件中找 org.springframework.boot.Bootstrapper</li>
<li>寻找的顺序：classpath → spring-beans → boot-devtools → springboot → boot-autoconfigure</li>
</ul>
</li>
<li><p><code>setInitializers(getSpringFactoriesInstances(ApplicationContextInitializer.class))</code>：<strong>获取初始化器</strong></p>
<ul>
<li>去 <code>META-INF/spring.factories</code> 文件中找 org.springframework.context.ApplicationContextInitializer</li>
</ul>
</li>
<li><p><code>setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class))</code>：<strong>获取监听器</strong></p>
<ul>
<li>去 <code>META-INF/spring.factories</code> 文件中找 org.springframework.context.ApplicationListener</li>
</ul>
</li>
<li><p><code>this.mainApplicationClass = deduceMainApplicationClass()</code>：获取出 main 程序类</p>
</li>
</ul>
<p>SpringApplication#run(String… args)：创建 IOC 容器并实现了自动装配</p>
<ul>
<li><p><code>StopWatch stopWatch = new StopWatch()</code>：停止监听器，<strong>监控整个应用的启停</strong></p>
</li>
<li><p><code>stopWatch.start()</code>：记录应用的启动时间</p>
</li>
<li><p><code>bootstrapContext = createBootstrapContext()</code>：<strong>创建引导上下文环境</strong></p>
<ul>
<li><code>bootstrapContext = new DefaultBootstrapContext()</code>：创建默认的引导类环境</li>
<li><code>this.bootstrapRegistryInitializers.forEach()</code>：遍历所有的引导器调用 initialize 方法完成初始化设置</li>
</ul>
</li>
<li><p><code>configureHeadlessProperty()</code>：让当前应用进入 headless 模式</p>
</li>
<li><p><code>listeners = getRunListeners(args)</code>：<strong>获取所有 RunListener（运行监听器）</strong></p>
<ul>
<li>去 <code>META-INF/spring.factories</code> 文件中找 org.springframework.boot.SpringApplicationRunListener</li>
</ul>
</li>
<li><p><code>listeners.starting(bootstrapContext, this.mainApplicationClass)</code>：遍历所有的运行监听器调用 starting 方法</p>
</li>
<li><p><code>applicationArguments = new DefaultApplicationArguments(args)</code>：获取所有的命令行参数</p>
</li>
<li><p><code>environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments)</code>：<strong>准备环境</strong></p>
<ul>
<li><p><code>environment = getOrCreateEnvironment()</code>：返回或创建基础环境信息对象</p>
<ul>
<li><code>switch (this.webApplicationType)</code>：<strong>根据当前应用的类型创建环境</strong><ul>
<li><code>case SERVLET</code>：Web 应用环境对应 ApplicationServletEnvironment</li>
<li><code>case REACTIVE</code>：响应式编程对应 ApplicationReactiveWebEnvironment</li>
<li><code>default</code>：默认为 Spring 环境 ApplicationEnvironment</li>
</ul>
</li>
</ul>
</li>
<li><p><code>configureEnvironment(environment, applicationArguments.getSourceArgs())</code>：读取所有配置源的属性值配置环境</p>
</li>
<li><p><code>ConfigurationPropertySources.attach(environment)</code>：属性值绑定环境信息</p>
<ul>
<li><code>sources.addFirst(ATTACHED_PROPERTY_SOURCE_NAME,..)</code>：把 configurationProperties 放入环境的属性信息头部</li>
</ul>
</li>
<li><p><code>listeners.environmentPrepared(bootstrapContext, environment)</code>：运行监听器调用 environmentPrepared()，EventPublishingRunListener 发布事件通知所有的监听器当前环境准备完成</p>
</li>
<li><p><code>DefaultPropertiesPropertySource.moveToEnd(environment)</code>：移动 defaultProperties 属性源到环境中的最后一个源</p>
</li>
<li><p><code>bindToSpringApplication(environment)</code>：与容器绑定当前环境</p>
</li>
<li><p><code>ConfigurationPropertySources.attach(environment)</code>：重新将属性值绑定环境信息</p>
</li>
<li><p><code>sources.remove(ATTACHED_PROPERTY_SOURCE_NAME)</code>：从环境信息中移除 configurationProperties </p>
</li>
<li><p><code>sources.addFirst(ATTACHED_PROPERTY_SOURCE_NAME,..)</code>：把 configurationProperties 重新放入环境信息</p>
</li>
</ul>
</li>
<li><p><code>configureIgnoreBeanInfo(environment)</code>：<strong>配置忽略的 bean</strong></p>
</li>
<li><p><code>printedBanner = printBanner(environment)</code>：打印 SpringBoot 标志</p>
</li>
<li><p><code>context = createApplicationContext()</code>：<strong>创建 IOC 容器</strong></p>
<p><code>switch (this.webApplicationType)</code>：根据当前应用的类型创建 IOC 容器</p>
<ul>
<li><code>case SERVLET</code>：Web 应用环境对应 AnnotationConfigServletWebServerApplicationContext</li>
<li><code>case REACTIVE</code>：响应式编程对应 AnnotationConfigReactiveWebServerApplicationContext</li>
<li><code>default</code>：默认为 Spring 环境 AnnotationConfigApplicationContext</li>
</ul>
</li>
<li><p><code>context.setApplicationStartup(this.applicationStartup)</code>：设置一个启动器</p>
</li>
<li><p><code>prepareContext()</code>：配置 IOC 容器的基本信息</p>
<ul>
<li><p><code>postProcessApplicationContext(context)</code>：后置处理流程</p>
</li>
<li><p><code>applyInitializers(context)</code>：获取所有的<strong>初始化器调用 initialize() 方法</strong>进行初始化</p>
</li>
<li><p><code>listeners.contextPrepared(context)</code>：所有的运行监听器调用 environmentPrepared() 方法，EventPublishingRunListener 发布事件通知 IOC 容器准备完成</p>
</li>
<li><p><code>listeners.contextLoaded(context)</code>：所有的运行监听器调用 contextLoaded() 方法，通知 IOC 加载完成</p>
</li>
</ul>
</li>
<li><p><code>refreshContext(context)</code>：<strong>刷新 IOC 容器</strong></p>
<ul>
<li>Spring 的容器启动流程</li>
<li><code>invokeBeanFactoryPostProcessors(beanFactory)</code>：<strong>实现了自动装配</strong></li>
<li><code>onRefresh()</code>：<strong>创建 WebServer</strong> 使用该接口</li>
</ul>
</li>
<li><p><code>afterRefresh(context, applicationArguments)</code>：留给用户自定义容器刷新完成后的处理逻辑</p>
</li>
<li><p><code>stopWatch.stop()</code>：记录应用启动完成的时间</p>
</li>
<li><p><code>callRunners(context, applicationArguments)</code>：调用所有 runners</p>
</li>
<li><p><code>listeners.started(context)</code>：所有的运行监听器调用 started() 方法</p>
</li>
<li><p><code>listeners.running(context)</code>：所有的运行监听器调用 running() 方法</p>
<ul>
<li><p>获取容器中的 ApplicationRunner、CommandLineRunner</p>
</li>
<li><p><code>AnnotationAwareOrderComparator.sort(runners)</code>：合并所有 runner 并且按照 @Order 进行排序</p>
</li>
<li><p><code>callRunner()</code>：遍历所有的 runner，调用 run 方法</p>
</li>
</ul>
</li>
<li><p><code>handleRunFailure(context, ex, listeners)</code>：<strong>处理异常</strong>，出现异常进入该逻辑</p>
<ul>
<li><code>handleExitCode(context, exception)</code>：处理错误代码</li>
<li><code>listeners.failed(context, exception)</code>：运行监听器调用 failed() 方法</li>
<li><code>reportFailure(getExceptionReporters(context), exception)</code>：通知异常</li>
</ul>
</li>
</ul>
<hr>
<h4 id="注解分析"><a href="#注解分析" class="headerlink" title="注解分析"></a>注解分析</h4><p>SpringBoot 定义了一套接口规范，这套规范规定 SpringBoot 在启动时会扫描外部引用 jar 包中的 <code>META-INF/spring.factories</code> 文件，将文件中配置的类型信息加载到 Spring 容器，并执行类中定义的各种操作，对于外部的 jar 包，直接引入一个 starter 即可</p>
<p>@SpringBootApplication 注解是 <code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合</p>
<ul>
<li><p>@SpringBootApplication 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span>	<span class="comment">//代表 @SpringBootApplication 拥有了该注解的功能</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span>	<span class="comment">//同理</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="comment">// 扫描被 @Component (@Service,@Controller)注解的 bean，容器中将排除TypeExcludeFilter 和 AutoConfigurationExcludeFilter</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@SpringBootConfiguration 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>	<span class="comment">// 代表是配置类</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">	<span class="meta">@AliasFor(annotation = Configuration.class)</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@AliasFor 注解：表示别名，可以注解到自定义注解的两个属性上表示这两个互为别名，两个属性其实是同一个含义相互替代</p>
</li>
<li><p>@ComponentScan 注解：默认扫描当前类所在包及其子级包下的所有文件</p>
</li>
<li><p><strong>@EnableAutoConfiguration 注解：启用 SpringBoot 的自动配置机制</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span>	</span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123; </span><br><span class="line">	<span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;; </span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>@AutoConfigurationPackage：<strong>将添加该注解的类所在的 package 作为自动配置 package 进行管理</strong>，把启动类所在的包设置一次，为了给各种自动配置的第三方库扫描用，比如带 @Mapper 注解的类，Spring 自身是不能识别的，但自动配置的 Mybatis 需要扫描用到，而 ComponentScan 只是用来扫描注解类，并没有提供接口给三方使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span>	<span class="comment">// 利用 Registrar 给容器中导入组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123; </span><br><span class="line">	String[] basePackages() <span class="keyword">default</span> &#123;&#125;;	<span class="comment">//自动配置包，指定了配置类的包</span></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]))</code>：注册 BD</p>
<ul>
<li><code>new PackageImports(metadata).getPackageNames()</code>：获取添加当前注解的类的所在包</li>
<li><code>registry.registerBeanDefinition(BEAN, new BasePackagesBeanDefinition(packageNames))</code>：存放到容器中<ul>
<li><code>new BasePackagesBeanDefinition(packageNames)</code>：把当前主类所在的包名封装到该对象中</li>
</ul>
</li>
</ul>
</li>
<li><p>@Import(AutoConfigurationImportSelector.class)：<strong>自动装配的核心类</strong></p>
<p>容器刷新时执行：<strong>invokeBeanFactoryPostProcessors()</strong> → invokeBeanDefinitionRegistryPostProcessors() → postProcessBeanDefinitionRegistry() → processConfigBeanDefinitions() → parse() → process() → processGroupImports() → getImports() → process() → <strong>AutoConfigurationImportSelector#getAutoConfigurationEntry()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取注解属性，@SpringBootApplication 注解的 exclude 属性和 excludeName 属性</span></span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> getAttributes(annotationMetadata);</span><br><span class="line">    <span class="comment">// 获取所有需要自动装配的候选项</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    <span class="comment">// 去除重复的选项</span></span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    <span class="comment">// 获取注解配置的排除的自动装配类</span></span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    <span class="comment">// 移除所有的配置的不需要自动装配的类</span></span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    <span class="comment">// 过滤，条件装配</span></span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    <span class="comment">// 获取 AutoConfigurationImportListener 类的监听器调用 onAutoConfigurationImportEvent 方法</span></span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="comment">// 包装成 AutoConfigurationEntry 返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AutoConfigurationImportSelector#getCandidateConfigurations：<strong>获取自动配置的候选项</strong></p>
<ul>
<li><p><code>List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames()</code>：加载自动配置类</p>
<p>参数一：<code>getSpringFactoriesLoaderFactoryClass()</code>：获取 @EnableAutoConfiguration 注解类</p>
<p>参数二：<code>getBeanClassLoader()</code>：获取类加载器</p>
<ul>
<li><code>factoryTypeName = factoryType.getName()</code>：@EnableAutoConfiguration 注解的全类名</li>
<li><code>return loadSpringFactories(classLoaderToUse).getOrDefault()</code>：加载资源<ul>
<li><code>urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION)</code>：获取资源类</li>
<li><code>FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;</code>：<strong>加载的资源的位置</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><code>return configurations</code>：返回所有自动装配类的候选项</p>
</li>
</ul>
</li>
<li><p>从 spring-boot-autoconfigure-2.5.3.jar&#x2F;META-INF&#x2F;spring.factories 文件中寻找 EnableAutoConfiguration 字段，获取自动装配类，<strong>进行条件装配，按需装配</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringBoot-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="装配流程"><a href="#装配流程" class="headerlink" title="装配流程"></a>装配流程</h4><p>Spring Boot 通过 <code>@EnableAutoConfiguration</code> 开启自动装配，通过 SpringFactoriesLoader 加载 <code>META-INF/spring.factories</code> 中的自动配置类实现自动装配，自动配置类其实就是通过 <code>@Conditional</code> 注解按需加载的配置类，想要其生效必须引入 <code>spring-boot-starter-xxx</code> 包实现起步依赖</p>
<ul>
<li>SpringBoot 先加载所有的自动配置类 xxxxxAutoConfiguration</li>
<li>每个自动配置类进行<strong>条件装配</strong>，默认都会绑定配置文件指定的值（xxxProperties 和配置文件进行了绑定）</li>
<li>SpringBoot 默认会在底层配好所有的组件，如果用户自己配置了<strong>以用户的优先</strong></li>
<li><strong>定制化配置：</strong><ul>
<li>用户可以使用 @Bean 新建自己的组件来替换底层的组件</li>
<li>用户可以去看这个组件是获取的配置文件前缀值，在配置文件中修改</li>
</ul>
</li>
</ul>
<p>以 DispatcherServletAutoConfiguration 为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="comment">// 类中的 Bean 默认不是单例</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="comment">// 条件装配，环境中有 DispatcherServlet 类才进行自动装配</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServletAutoConfiguration</span> &#123;</span><br><span class="line">	<span class="comment">// 注册的 DispatcherServlet 的 BeanName</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DISPATCHER_SERVLET_BEAN_NAME</span> <span class="operator">=</span> <span class="string">&quot;dispatcherServlet&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">	<span class="meta">@Conditional(DefaultDispatcherServletCondition.class)</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass(ServletRegistration.class)</span></span><br><span class="line">    <span class="comment">// 绑定配置文件的属性，从配置文件中获取配置项</span></span><br><span class="line">	<span class="meta">@EnableConfigurationProperties(WebMvcProperties.class)</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DispatcherServletConfiguration</span> &#123;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 给容器注册一个 DispatcherServlet，起名字为 dispatcherServlet</span></span><br><span class="line">		<span class="meta">@Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span></span><br><span class="line">		<span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">(WebMvcProperties webMvcProperties)</span> &#123;</span><br><span class="line">            <span class="comment">// 新建一个 DispatcherServlet 设置相关属性</span></span><br><span class="line">			<span class="type">DispatcherServlet</span> <span class="variable">dispatcherServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">            <span class="comment">// spring.mvc 中的配置项获取注入，没有就填充默认值</span></span><br><span class="line">			dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest());</span><br><span class="line">			<span class="comment">// ......</span></span><br><span class="line">            <span class="comment">// 返回该对象注册到容器内</span></span><br><span class="line">			<span class="keyword">return</span> dispatcherServlet;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">        <span class="comment">// 容器中有这个类型组件才进行装配</span></span><br><span class="line">		<span class="meta">@ConditionalOnBean(MultipartResolver.class)</span></span><br><span class="line">        <span class="comment">// 容器中没有这个名字 multipartResolver 的组件</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</span></span><br><span class="line">        <span class="comment">// 方法名就是 BeanName</span></span><br><span class="line">		<span class="keyword">public</span> MultipartResolver <span class="title function_">multipartResolver</span><span class="params">(MultipartResolver resolver)</span> &#123;</span><br><span class="line">			<span class="comment">// 给 @Bean 标注的方法传入了对象参数，这个参数就会从容器中找，因为用户自定义了该类型，以用户配置的优先</span></span><br><span class="line">            <span class="comment">// 但是名字不符合规范，所以获取到该 Bean 并返回到容器一个规范的名称：multipartResolver</span></span><br><span class="line">			<span class="keyword">return</span> resolver;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将配置文件中的 spring.mvc 前缀的属性与该类绑定</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.mvc&quot;)</span>	</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcProperties</span> &#123; &#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>SpringBoot 在项目启动时，会对几个监听器进行回调，可以实现监听器接口，在项目启动时完成一些操作</p>
<p>ApplicationContextInitializer、SpringApplicationRunListener、CommandLineRunner、ApplicationRunner</p>
<ul>
<li><p>MyApplicationRunner</p>
<p><strong>自定义监听器的启动时机</strong>：MyApplicationRunner 和 MyCommandLineRunner 都是当项目启动后执行，使用 @Component 放入容器即可使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当项目启动后执行run方法</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationRunner</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ApplicationRunner...run&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.asList(args.getSourceArgs()));<span class="comment">//properties配置信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>MyCommandLineRunner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCommandLineRunner</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CommandLineRunner...run&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.asList(args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MyApplicationContextInitializer 的启用要<strong>在 resource 文件夹下添加 META-INF&#x2F;spring.factories</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.context.ApplicationContextInitializer</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.example.springbootlistener.listener.MyApplicationContextInitializer</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ApplicationContextInitializer....initialize&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MySpringApplicationRunListener 的使用要添加<strong>构造器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySpringApplicationRunListener</span> <span class="keyword">implements</span> <span class="title class_">SpringApplicationRunListener</span> &#123;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySpringApplicationRunListener</span><span class="params">(SpringApplication sa, String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">starting</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;starting...项目启动中&quot;</span>);<span class="comment">//输出SPRING之前</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;environmentPrepared...环境对象开始准备&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;contextPrepared...上下文对象开始准备&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;contextLoaded...上下文对象开始加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">started</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;started...上下文对象加载完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">running</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;running...项目启动完成，开始运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;failed...项目启动失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h3><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p>SpringBoot 是基于约定的，很多配置都有默认值，如果想使用自己的配置替换默认配置，可以使用 application.properties 或者application.yml（application.yaml）进行配置</p>
<ul>
<li>默认配置文件名称：application</li>
<li>在同一级目录下优先级为：properties &gt; yml &gt; yaml</li>
</ul>
<p>例如配置内置 Tomcat 的端口</p>
<ul>
<li><p>properties：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>yml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server: port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>yaml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server: port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h4><p>所有位置的配置文件都会被加载，互补配置，<strong>高优先级配置内容会覆盖低优先级配置内容</strong></p>
<p>扫描配置文件的位置按优先级<strong>从高到底</strong>：</p>
<ul>
<li><p><code>file:./config/</code>：<strong>当前项目</strong>下的 &#x2F;config 目录下</p>
</li>
<li><p><code>file:./</code>：当前项目的根目录，Project工程目录</p>
</li>
<li><p><code>classpath:/config/</code>：classpath 的 &#x2F;config 目录</p>
</li>
<li><p><code>classpath:/</code>：classpath 的根目录，就是 resoureces 目录</p>
</li>
</ul>
<p>项目外部配置文件加载顺序：外部配置文件的使用是为了对内部文件的配合</p>
<ul>
<li><p>命令行：在 package 打包后的 target 目录下，使用该命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -jar myproject.jar --server.port=9000</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定配置文件位置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -jar myproject.jar --spring.config.location=e://application.properties</span><br></pre></td></tr></table></figure>
</li>
<li><p>按优先级从高到底选择配置文件的加载命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -jar myproject.jar</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="yaml语法"><a href="#yaml语法" class="headerlink" title="yaml语法"></a>yaml语法</h3><p>基本语法：</p>
<ul>
<li><p>大小写敏感</p>
</li>
<li><p><strong>数据值前边必须有空格，作为分隔符</strong></p>
</li>
<li><p>使用缩进表示层级关系</p>
</li>
<li><p>缩进时不允许使用Tab键，只允许使用空格（各个系统 Tab对应空格数目可能不同，导致层次混乱）</p>
</li>
<li><p>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</p>
</li>
<li><p>‘’#” 表示注释，从这个字符一直到行尾，都会被解析器忽略</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span> </span><br><span class="line">	<span class="attr">port:</span> <span class="number">8080</span>  </span><br><span class="line">    <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>数据格式：</p>
<ul>
<li><p>纯量：单个的、不可再分的值</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">msg1:</span> <span class="string">&#x27;hello \n world&#x27;</span>  <span class="comment"># 单引忽略转义字符</span></span><br><span class="line"><span class="attr">msg2:</span> <span class="string">&quot;hello \n world&quot;</span>  <span class="comment"># 双引识别转义字符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象：键值对集合，Map、Hash</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span>  </span><br><span class="line">   <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">   <span class="attr">age:</span> <span class="number">20</span></span><br><span class="line"><span class="comment"># 行内写法</span></span><br><span class="line"><span class="attr">person:</span> &#123;<span class="attr">name:</span> <span class="string">zhangsan</span>&#125;</span><br></pre></td></tr></table></figure>

<p>注意：不建议使用 JSON，应该使用 yaml 语法</p>
</li>
<li><p>数组：一组按次序排列的值，List、Array</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">address:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">beijing</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">shanghai</span></span><br><span class="line"><span class="comment"># 行内写法</span></span><br><span class="line"><span class="attr">address:</span> [<span class="string">beijing</span>,<span class="string">shanghai</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">allPerson</span>	<span class="comment">#List&lt;Person&gt;</span></span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="string">name:lisi</span>, <span class="string">age:18</span>&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="string">name:wangwu</span>, <span class="string">age:20</span>&#125;</span><br><span class="line"><span class="comment"># 行内写法</span></span><br><span class="line"><span class="attr">allPerson:</span> [&#123;<span class="string">name:lisi</span>, <span class="string">age:18</span>&#125;, &#123;<span class="string">name:wangwu</span>, <span class="string">age:20</span>&#125;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数引用：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">lisi</span> </span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">$&#123;name&#125;</span> <span class="comment"># 引用上边定义的name值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="获取配置"><a href="#获取配置" class="headerlink" title="获取配置"></a>获取配置</h3><p>三种获取配置文件的方式：</p>
<ul>
<li><p>注解 @Value</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;person.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;address[0]&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;msg1&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String msg1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;msg2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String msg2;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有的数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; hello Spring Boot !&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Evironment 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;person.name&quot;</span>));</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;address[0]&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; hello Spring Boot !&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注解 @ConfigurationProperties 配合 @Component 使用</p>
<p><strong>注意</strong>：参数 prefix 一定要指定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>	<span class="comment">//不扫描该组件到容器内，无法完成自动装配</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String[] address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(person);</span><br><span class="line">    <span class="comment">//Person&#123;name=&#x27;zhangsan&#x27;, age=20, address=[beijing, shanghai]&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; hello Spring Boot !&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="配置提示"><a href="#配置提示" class="headerlink" title="配置提示"></a>配置提示</h3><p>自定义的类和配置文件绑定一般没有提示，添加如下依赖可以使用提示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下面插件作用是工程打包时，不将spring-boot-configuration-processor打进包内，让其只在编码的时候有用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>





<hr>
<h3 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h3><p>@Profile：指定组件在哪个环境的情况下才能被注册到容器中，不指定，任何环境下都能注册这个组件</p>
<ul>
<li>加了环境标识的 bean，只有这个环境被激活的时候才能注册到容器中，默认是 default 环境</li>
<li>写在配置类上，只有是指定的环境的时候，整个配置类里面的所有配置才能开始生效</li>
<li>没有标注环境标识的 bean 在，任何环境下都是加载的</li>
</ul>
<p>Profile 的配置：</p>
<ul>
<li><p><strong>profile 是用来完成不同环境下，配置动态切换功能</strong></p>
</li>
<li><p><strong>profile 配置方式</strong>：多 profile 文件方式，提供多个配置文件，每个代表一种环境</p>
<ul>
<li>application-dev.properties&#x2F;yml 开发环境</li>
<li>application-test.properties&#x2F;yml 测试环境</li>
<li>sapplication-pro.properties&#x2F;yml 生产环境</li>
</ul>
</li>
<li><p>yml 多文档方式：在 yml 中使用  — 分隔不同配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">spring:</span><br><span class="line">  profiles:dev</span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line">spring:</span><br><span class="line">  profiles:test</span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8083</span><br><span class="line">spring:</span><br><span class="line">  profiles:pro</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>profile 激活方式</strong></p>
<ul>
<li><p>配置文件：在配置文件中配置：spring.profiles.active&#x3D;dev</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>虚拟机参数：在VM options 指定：<code>-Dspring.profiles.active=dev</code></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/SpringBoot-profile%E6%BF%80%E6%B4%BB%E6%96%B9%E5%BC%8F%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%82%E6%95%B0.png"></p>
</li>
<li><p>命令行参数：<code>java –jar xxx.jar  --spring.profiles.active=dev</code></p>
<p>在 Program arguments 里输入，也可以先 package</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h2><h3 id="功能支持"><a href="#功能支持" class="headerlink" title="功能支持"></a>功能支持</h3><p>SpringBoot 自动配置了很多约定，大多场景都无需自定义配置</p>
<ul>
<li>内容协商视图解析器 ContentNegotiatingViewResolver 和 BeanName 视图解析器 BeanNameViewResolver</li>
<li>支持静态资源（包括 webjars）和静态 index.html 页支持</li>
<li>自动注册相关类：Converter、GenericConverter、Formatter</li>
<li>内容协商处理器：HttpMessageConverters</li>
<li>国际化：MessageCodesResolver</li>
</ul>
<p>开发规范：</p>
<ul>
<li>使用 <code>@Configuration</code> + <code>WebMvcConfigurer</code> 自定义规则，不使用 <code>@EnableWebMvc</code> 注解</li>
<li>声明 <code>WebMvcRegistrations</code> 的实现类改变默认底层组件</li>
<li>使用 <code>@EnableWebMvc</code> + <code>@Configuration</code> + <code>DelegatingWebMvcConfiguration</code> 全面接管 SpringMVC</li>
</ul>
<hr>
<h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><h4 id="访问规则"><a href="#访问规则" class="headerlink" title="访问规则"></a>访问规则</h4><p>默认的静态资源路径是 classpath 下的，优先级由高到低为：&#x2F;META-INF&#x2F;resources、&#x2F;resources、 &#x2F;static、&#x2F;public  的包内，<code>/</code> 表示当前项目的根路径</p>
<p>静态映射 <code>/**</code> ，表示请求 <code>/ + 静态资源名</code> 就直接去默认的资源路径寻找请求的资源</p>
<p>处理原理：静请求去寻找 Controller 处理，不能处理的请求就会交给静态资源处理器，静态资源也找不到就响应 404 页面</p>
<ul>
<li><p>修改默认资源路径：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">static-locations::</span> [<span class="string">classpath:/haha/</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改静态资源访问前缀，默认是 <code>/**</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/resources/**</span></span><br></pre></td></tr></table></figure>

<p>访问 URL：<a href="http://localhost:8080/resources/">http://localhost:8080/resources/</a> + 静态资源名，将所有资源<strong>重定位</strong>到 <code>/resources/</code></p>
</li>
<li><p>webjar 访问资源：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>访问地址：<a href="http://localhost:8080/webjars/jquery/3.5.1/jquery.js%EF%BC%8C%E5%90%8E%E9%9D%A2%E5%9C%B0%E5%9D%80%E8%A6%81%E6%8C%89%E7%85%A7%E4%BE%9D%E8%B5%96%E9%87%8C%E9%9D%A2%E7%9A%84%E5%8C%85%E8%B7%AF%E5%BE%84">http://localhost:8080/webjars/jquery/3.5.1/jquery.js，后面地址要按照依赖里面的包路径</a></p>
</li>
</ul>
<hr>
<h4 id="欢迎页面"><a href="#欢迎页面" class="headerlink" title="欢迎页面"></a>欢迎页面</h4><p>静态资源路径下 index.html 默认作为欢迎页面，访问 <a href="http://localhost:8080/">http://localhost:8080</a> 出现该页面，使用 welcome page 功能不能修改前缀</p>
<p>网页标签上的小图标可以自定义规则，把资源重命名为 favicon.ico 放在静态资源目录下即可</p>
<hr>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>SpringMVC 功能的自动配置类 WebMvcAutoConfiguration：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">//当前项目的根路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVLET_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>内部类 WebMvcAutoConfigurationAdapter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line"><span class="comment">// 绑定 spring.mvc、spring.web、spring.resources 相关的配置属性</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123; WebMvcProperties.class,ResourceProperties.class, WebProperties.class &#125;)</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>, ServletContextAware &#123;</span><br><span class="line">	<span class="comment">//有参构造器所有参数的值都会从容器中确定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WebMvcAutoConfigurationAdapter</span><span class="params">(<span class="comment">/*参数*/</span>)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.resourceProperties = resourceProperties.hasBeenCustomized() ? resourceProperties</span><br><span class="line">					: webProperties.getResources();</span><br><span class="line">			<span class="built_in">this</span>.mvcProperties = mvcProperties;</span><br><span class="line">			<span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">			<span class="built_in">this</span>.messageConvertersProvider = messageConvertersProvider;</span><br><span class="line">			<span class="built_in">this</span>.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable();</span><br><span class="line">			<span class="built_in">this</span>.dispatcherServletPath = dispatcherServletPath;</span><br><span class="line">			<span class="built_in">this</span>.servletRegistrations = servletRegistrations;</span><br><span class="line">			<span class="built_in">this</span>.mvcProperties.checkConfiguration();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ResourceProperties resourceProperties：获取和 spring.resources 绑定的所有的值的对象</li>
<li>WebMvcProperties mvcProperties：获取和 spring.mvc 绑定的所有的值的对象</li>
<li>ListableBeanFactory beanFactory：Spring 的 beanFactory</li>
<li>HttpMessageConverters：找到所有的 HttpMessageConverters</li>
<li>ResourceHandlerRegistrationCustomizer：找到 资源处理器的自定义器。</li>
<li>DispatcherServletPath：项目路径</li>
<li>ServletRegistrationBean：给应用注册 Servlet、Filter</li>
</ul>
</li>
<li><p>WebMvcAutoConfiguration.WebMvcAutoConfigurationAdapter.addResourceHandler()：两种静态资源映射规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">//配置文件设置 spring.resources.add-mappings: false，禁用所有静态资源</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);<span class="comment">//被禁用</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册webjars静态资源的映射规则	映射			路径</span></span><br><span class="line">    addResourceHandler(registry, <span class="string">&quot;/webjars/**&quot;</span>, <span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">    <span class="comment">//注册静态资源路径的映射规则		 默认映射 staticPathPattern = &quot;/**&quot; </span></span><br><span class="line">    addResourceHandler(registry, <span class="built_in">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;</span><br><span class="line">        <span class="comment">//staticLocations = CLASSPATH_RESOURCE_LOCATIONS</span></span><br><span class="line">        registration.addResourceLocations(<span class="built_in">this</span>.resourceProperties.getStaticLocations());</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.servletContext != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ServletContextResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextResource</span>(<span class="built_in">this</span>.servletContext, SERVLET_LOCATION);</span><br><span class="line">            registration.addResourceLocations(resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.web&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebProperties</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Resources</span> &#123;</span><br><span class="line">    	<span class="comment">//默认资源路径，优先级从高到低</span></span><br><span class="line">    	<span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="string">&quot;classpath:/META-INF/resources/&quot;</span>,</span><br><span class="line">                                                 <span class="string">&quot;classpath:/resources/&quot;</span>, </span><br><span class="line">                                                 <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span> &#125;</span><br><span class="line">        <span class="keyword">private</span> String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br><span class="line">        <span class="comment">//可以进行规则重写</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStaticLocations</span><span class="params">(String[] staticLocations)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.staticLocations = appendSlashIfNecessary(staticLocations);</span><br><span class="line">			<span class="built_in">this</span>.customized = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>WebMvcAutoConfiguration.EnableWebMvcConfiguration.welcomePageHandlerMapping()：欢迎页</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//spring.web 属性</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(WebProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EnableWebMvcConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WelcomePageHandlerMapping <span class="title function_">welcomePageHandlerMapping</span><span class="params">(<span class="comment">/*参数*/</span>)</span> &#123;</span><br><span class="line">        <span class="type">WelcomePageHandlerMapping</span> <span class="variable">welcomePageHandlerMapping</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WelcomePageHandlerMapping</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">TemplateAvailabilityProviders</span>(applicationContext), </span><br><span class="line">            applicationContext, getWelcomePage(),</span><br><span class="line">            <span class="comment">//staticPathPattern = &quot;/**&quot;</span></span><br><span class="line">            <span class="built_in">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">        <span class="keyword">return</span> welcomePageHandlerMapping;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">WelcomePageHandlerMapping(<span class="comment">/*参数*/</span>) &#123;</span><br><span class="line">    <span class="comment">//所以限制 staticPathPattern 必须为 /** 才能启用该功能</span></span><br><span class="line">    <span class="keyword">if</span> (welcomePage != <span class="literal">null</span> &amp;&amp; <span class="string">&quot;/**&quot;</span>.equals(staticPathPattern)) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Adding welcome page: &quot;</span> + welcomePage);</span><br><span class="line">        <span class="comment">//重定向</span></span><br><span class="line">        setRootViewName(<span class="string">&quot;forward:index.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Adding welcome page template: index&quot;</span>);</span><br><span class="line">        setRootViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WelcomePageHandlerMapping，访问 &#x2F; 能访问到 index.html</p>
</li>
</ul>
<hr>
<h3 id="Rest映射"><a href="#Rest映射" class="headerlink" title="Rest映射"></a>Rest映射</h3><p>开启 Rest 功能</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">hiddenmethod:</span></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment">#开启页面表单的Rest功能</span></span><br></pre></td></tr></table></figure>

<p>源码分析，注入了 HiddenHttpMethodFilte 解析 Rest 风格的访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)</span></span><br><span class="line">	<span class="meta">@ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> OrderedHiddenHttpMethodFilter <span class="title function_">hiddenHttpMethodFilter</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderedHiddenHttpMethodFilter</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细源码解析：SpringMVC → 基本操作 → Restful → 识别原理</p>
<p>Web 部分源码详解：SpringMVC → 运行原理</p>
<hr>
<h3 id="内嵌容器"><a href="#内嵌容器" class="headerlink" title="内嵌容器"></a>内嵌容器</h3><p>SpringBoot 嵌入式 Servlet 容器，默认支持的 WebServe：Tomcat、Jetty、Undertow</p>
<p>配置方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span> <span class="comment">&lt;!--必须要把内嵌的 Tomcat 容器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Web 应用启动，SpringBoot 导入 Web 场景包 tomcat，创建一个 Web 版的 IOC 容器：</p>
<ul>
<li><p><code>SpringApplication.run(BootApplication.class, args)</code>：应用启动</p>
</li>
<li><p><code>ConfigurableApplicationContext.run()</code>：</p>
<ul>
<li><p><code>context = createApplicationContext()</code>：<strong>创建容器</strong></p>
<ul>
<li><p><code>applicationContextFactory = ApplicationContextFactory.DEFAULT</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContextFactory</span> <span class="variable">DEFAULT</span> <span class="operator">=</span> (webApplicationType) -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (webApplicationType) &#123;</span><br><span class="line">            <span class="keyword">case</span> SERVLET:</span><br><span class="line">                <span class="comment">// Servlet 容器，继承自 ServletWebServerApplicationContext</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>();</span><br><span class="line">            <span class="keyword">case</span> REACTIVE:</span><br><span class="line">                <span class="comment">// 响应式编程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigReactiveWebServerApplicationContext</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 普通 Spring 容器</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>applicationContextFactory.create(this.webApplicationType)</code>：根据应用类型创建容器</p>
</li>
</ul>
</li>
<li><p><code>refreshContext(context)</code>：容器启动刷新</p>
</li>
</ul>
</li>
</ul>
<p>内嵌容器工作流程：</p>
<ul>
<li><p>Spring 容器启动逻辑中，在实例化非懒加载的单例 Bean 之前有一个方法 **onRefresh()**，留给子类去扩展，Web 容器就是重写这个方法创建 WebServer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//省略....</span></span><br><span class="line">	createWebServer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createWebServer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ServletWebServerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> getWebServerFactory();</span><br><span class="line">    <span class="built_in">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line">    createWebServer.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取 WebServer 工厂 ServletWebServerFactory，并且获取的数量不等于 1 会报错，Spring 底层有三种：</p>
<p><code>TomcatServletWebServerFactory</code>、<code>JettyServletWebServerFactory</code>、<code>UndertowServletWebServerFactory</code></p>
</li>
<li><p><strong>自动配置类 ServletWebServerFactoryAutoConfiguration</strong> 导入了 ServletWebServerFactoryConfiguration（配置类），根据条件装配判断系统中到底导入了哪个 Web 服务器的包，创建出服务器并启动</p>
</li>
<li><p>默认是 web-starter 导入 tomcat 包，容器中就有 TomcatServletWebServerFactory，创建出 Tomcat 服务器并启动，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TomcatWebServer</span><span class="params">(Tomcat tomcat, <span class="type">boolean</span> autoStart, Shutdown shutdown)</span> &#123;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">   	initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化方法 initialize 中有启动方法：<code>this.tomcat.start()</code></p>
</li>
</ul>
<hr>
<h3 id="自定义-3"><a href="#自定义-3" class="headerlink" title="自定义"></a>自定义</h3><h4 id="定制规则"><a href="#定制规则" class="headerlink" title="定制规则"></a>定制规则</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">webMvcConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">            <span class="comment">//进行一些方法重写，来实现自定义的规则</span></span><br><span class="line">            <span class="comment">//比如添加一些解析器和拦截器，就是对原始容器功能的增加</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//也可以不加 @Bean，直接从这里重写方法进行功能增加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="定制容器"><a href="#定制容器" class="headerlink" title="定制容器"></a>定制容器</h4><p>@EnableWebMvc：全面接管 SpringMVC，所有规则全部自己重新配置</p>
<ul>
<li><p>@EnableWebMvc + WebMvcConfigurer + @Bean  全面接管SpringMVC</p>
</li>
<li><p>@Import(DelegatingWebMvcConfiguration.<strong>class</strong>)，该类继承 WebMvcConfigurationSupport，自动配置了一些非常底层的组件，只能保证 SpringMVC 最基本的使用</p>
</li>
</ul>
<p>原理：自动配置类 <strong>WebMvcAutoConfiguration</strong> 里面的配置要能生效，WebMvcConfigurationSupport 类不能被加载，所以 @EnableWebMvc 导致配置类失效，从而接管了 SpringMVC</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>注意：一般不适用此注解</p>
<hr>
<h2 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h2><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>导入 starter：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入 JDBC 场景--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--导入 MySQL 驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--版本对应你的 MySQL 版本&lt;version&gt;5.1.49&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>单独导入 MySQL 驱动是因为不确定用户使用的什么数据库</p>
<p>配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.0.107:3306/db1?useSSL=false</span>	<span class="comment"># 不加 useSSL 会警告</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>测试文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boot05WebAdminApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">res</span> <span class="operator">=</span> jdbcTemplate.queryForObject(<span class="string">&quot;select count(*) from account_tbl&quot;</span>, Long.class);</span><br><span class="line">        log.info(<span class="string">&quot;记录总数：&#123;&#125;&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h4><p>DataSourceAutoConfiguration：数据源的自动配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; DataSource.class, EmbeddedDatabaseType.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DataSourceProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceAutoConfiguration</span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Conditional(PooledDataSourceCondition.class)</span> </span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)</span></span><br><span class="line">	<span class="meta">@Import(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,</span></span><br><span class="line"><span class="meta">			DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class&#125;)</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PooledDataSourceConfiguration</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 配置项</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProperties</span> <span class="keyword">implements</span> <span class="title class_">BeanClassLoaderAware</span>, InitializingBean &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>底层默认配置好的连接池是：<strong>HikariDataSource</strong></li>
<li>数据库连接池的配置，是容器中没有 DataSource 才自动配置的</li>
<li>修改数据源相关的配置：spring.datasource</li>
</ul>
<p>相关配置：</p>
<ul>
<li>DataSourceTransactionManagerAutoConfiguration： 事务管理器的自动配置</li>
<li>JdbcTemplateAutoConfiguration： JdbcTemplate 的自动配置<ul>
<li>可以修改这个配置项 @ConfigurationProperties(prefix &#x3D; <strong>“spring.jdbc”</strong>) 来修改JdbcTemplate</li>
<li><code>@AutoConfigureAfter(DataSourceAutoConfiguration.class)</code>：在 DataSource 装配后装配</li>
</ul>
</li>
<li>JndiDataSourceAutoConfiguration： jndi 的自动配置</li>
<li>XADataSourceAutoConfiguration： 分布式事务相关</li>
</ul>
<hr>
<h3 id="Druid-2"><a href="#Druid-2" class="headerlink" title="Druid"></a>Druid</h3><p>导入坐标：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DruidDataSource.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;DruidStatProperties.class, DataSourceProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;DruidSpringAopConfiguration.class,</span></span><br><span class="line"><span class="meta">    DruidStatViewServletConfiguration.class,</span></span><br><span class="line"><span class="meta">    DruidWebStatFilterConfiguration.class,</span></span><br><span class="line"><span class="meta">    DruidFilterConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidDataSourceAutoConfigure</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>自动配置：</p>
<ul>
<li><p>扩展配置项 <strong>spring.datasource.druid</strong></p>
</li>
<li><p>DruidSpringAopConfiguration： 监控 SpringBean，配置项为 <code>spring.datasource.druid.aop-patterns</code></p>
</li>
<li><p>DruidStatViewServletConfiguration：监控页的配置项为 <code>spring.datasource.druid.stat-view-servlet</code>，默认开启</p>
</li>
<li><p>DruidWebStatFilterConfiguration：Web 监控配置项为 <code>spring.datasource.druid.web-stat-filter</code>，默认开启</p>
</li>
<li><p>DruidFilterConfiguration：所有 Druid 自己 filter 的配置</p>
</li>
</ul>
<p>配置示例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db_account</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">aop-patterns:</span> <span class="string">com.atguigu.admin.*</span>  <span class="comment">#监控SpringBean</span></span><br><span class="line">      <span class="attr">filters:</span> <span class="string">stat,wall</span>     <span class="comment"># 底层开启功能，stat（sql监控），wall（防火墙）</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">stat-view-servlet:</span>   <span class="comment"># 配置监控页功能</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">login-username:</span> <span class="string">admin</span>	<span class="comment">#项目启动访问：http://localhost:8080/druid ，账号和密码是 admin</span></span><br><span class="line">        <span class="attr">login-password:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">resetEnable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">web-stat-filter:</span>  <span class="comment"># 监控web</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">urlPattern:</span> <span class="string">/*</span></span><br><span class="line">        <span class="attr">exclusions:</span> <span class="string">&#x27;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">stat:</span>    <span class="comment"># 对上面filters里面的stat的详细配置</span></span><br><span class="line">          <span class="attr">slow-sql-millis:</span> <span class="number">1000</span></span><br><span class="line">          <span class="attr">logSlowSql:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">wall:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">config:</span></span><br><span class="line">            <span class="attr">drop-table-allow:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<p>配置示例：<a href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter">https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter</a></p>
<p>配置项列表：<a href="https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8">https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8</a></p>
<hr>
<h3 id="MyBatis-1"><a href="#MyBatis-1" class="headerlink" title="MyBatis"></a>MyBatis</h3><h4 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h4><p>导入坐标：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>编写 MyBatis 相关配置：application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置mybatis规则</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="comment">#  config-location: classpath:mybatis/mybatis-config.xml  建议不写</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/*.xml</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment">#可以不写全局配置文件，所有全局配置文件的配置都放在 configuration 配置项中即可</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义表和实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写 dao 和 mapper 文件&#x2F;纯注解开发</p>
<p>dao：**@Mapper 注解必须加，使用自动装配的 package，否则在启动类指定 @MapperScan() 扫描路径（不建议）**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span>  <span class="comment">//必须加Mapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserXmlMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.seazean.springbootmybatis.mapper.UserXmlMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>纯注解开发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="自动配置-1"><a href="#自动配置-1" class="headerlink" title="自动配置"></a>自动配置</h4><p>MybatisAutoConfiguration：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(MybatisProperties.class)</span>	<span class="comment">//MyBatis配置项绑定类。</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">  	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  	<span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    	<span class="type">SqlSessionFactoryBean</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="keyword">return</span> factory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@org</span>.springframework.context.annotation.Configuration</span><br><span class="line">   	<span class="meta">@Import(AutoConfiguredMapperScannerRegistrar.class)</span></span><br><span class="line">   	<span class="meta">@ConditionalOnMissingBean(&#123; MapperFactoryBean.class, MapperScannerConfigurer.class &#125;)</span></span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MapperScannerRegistrarNotFoundConfiguration</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mybatis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisProperties</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置文件：<code>mybatis</code></li>
<li>自动配置了 SqlSessionFactory</li>
<li>导入 <code>AutoConfiguredMapperScannerRegistra</code> 实现 @Mapper 的扫描</li>
</ul>
<hr>
<h4 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>自动配置类：MybatisPlusAutoConfiguration </p>
<p>只需要 Mapper 继承 <strong>BaseMapper</strong> 就可以拥有 CRUD 功能</p>
<hr>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="基本使用-3"><a href="#基本使用-3" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>配置redis相关属性</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment"># redis的主机ip</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注入 RedisTemplate 模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootRedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//存入数据</span></span><br><span class="line">        redisTemplate.boundValueOps(<span class="string">&quot;name&quot;</span>).set(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.boundValueOps(<span class="string">&quot;name&quot;</span>).get();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="自动配置-2"><a href="#自动配置-2" class="headerlink" title="自动配置"></a>自动配置</h4><p>RedisAutoConfiguration 自动配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RedisOperations.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RedisProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="type">StringRedisTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>配置项：<code>spring.redis</code></p>
</li>
<li><p>自动导入了连接工厂配置类：LettuceConnectionConfiguration、JedisConnectionConfiguration</p>
</li>
<li><p>自动注入了模板类：RedisTemplate&lt;Object, Object&gt; 、StringRedisTemplate，k v 都是 String 类型</p>
</li>
<li><p>使用 @Autowired 注入模板类就可以操作 redis</p>
</li>
</ul>
<hr>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="Junit5"><a href="#Junit5" class="headerlink" title="Junit5"></a>Junit5</h3><p>Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库，由三个不同的子模块组成：</p>
<ul>
<li><p>JUnit Platform：在 JVM 上启动测试框架的基础，不仅支持 Junit 自制的测试引擎，其他测试引擎也可以接入</p>
</li>
<li><p>JUnit Jupiter：提供了 JUnit5 的新的编程模型，是 JUnit5 新特性的核心，内部包含了一个测试引擎，用于在 Junit Platform 上运行</p>
</li>
<li><p>JUnit Vintage：JUnit Vintage 提供了兼容 JUnit4.x、Junit3.x 的测试引擎</p>
<p>注意：SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖，如果需要兼容 Junit4 需要自行引入</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boot05WebAdminApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="常用注解-1"><a href="#常用注解-1" class="headerlink" title="常用注解"></a>常用注解</h3><p>JUnit5 的注解如下：</p>
<ul>
<li><p>@Test：表示方法是测试方法，但是与 JUnit4 的 @Test 不同，它的职责非常单一不能声明任何属性，拓展的测试将会由 Jupiter 提供额外测试，包是 <code>org.junit.jupiter.api.Test</code></p>
</li>
<li><p>@ParameterizedTest：表示方法是参数化测试</p>
</li>
<li><p>@RepeatedTest：表示方法可重复执行</p>
</li>
<li><p>@DisplayName：为测试类或者测试方法设置展示名称</p>
</li>
<li><p>@BeforeEach：表示在每个单元测试之前执行</p>
</li>
<li><p>@AfterEach：表示在每个单元测试之后执行</p>
</li>
<li><p>@BeforeAll：表示在所有单元测试之前执行</p>
</li>
<li><p>@AfterAll：表示在所有单元测试之后执行</p>
</li>
<li><p>@Tag：表示单元测试类别，类似于 JUnit4 中的 @Categories</p>
</li>
<li><p>@Disabled：表示测试类或测试方法不执行，类似于 JUnit4 中的 @Ignore</p>
</li>
<li><p>@Timeout：表示测试方法运行如果超过了指定时间将会返回错误</p>
</li>
<li><p>@ExtendWith：为测试类或测试方法提供扩展类引用</p>
</li>
</ul>
<hr>
<h3 id="断言机制"><a href="#断言机制" class="headerlink" title="断言机制"></a>断言机制</h3><h4 id="简单断言"><a href="#简单断言" class="headerlink" title="简单断言"></a>简单断言</h4><p>断言（assertions）是测试方法中的核心，用来对测试需要满足的条件进行验证，断言方法都是 org.junit.jupiter.api.Assertions 的静态方法</p>
<p>用来对单个值进行简单的验证：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>assertEquals</td>
<td>判断两个对象或两个原始类型是否相等</td>
</tr>
<tr>
<td>assertNotEquals</td>
<td>判断两个对象或两个原始类型是否不相等</td>
</tr>
<tr>
<td>assertSame</td>
<td>判断两个对象引用是否指向同一个对象</td>
</tr>
<tr>
<td>assertNotSame</td>
<td>判断两个对象引用是否指向不同的对象</td>
</tr>
<tr>
<td>assertTrue</td>
<td>判断给定的布尔值是否为 true</td>
</tr>
<tr>
<td>assertFalse</td>
<td>判断给定的布尔值是否为 false</td>
</tr>
<tr>
<td>assertNull</td>
<td>判断给定的对象引用是否为 null</td>
</tr>
<tr>
<td>assertNotNull</td>
<td>判断给定的对象引用是否不为 null</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;simple assertion&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simple</span><span class="params">()</span> &#123;</span><br><span class="line">     assertEquals(<span class="number">3</span>, <span class="number">1</span> + <span class="number">2</span>, <span class="string">&quot;simple math&quot;</span>);</span><br><span class="line">     assertNull(<span class="literal">null</span>);</span><br><span class="line">     assertNotNull(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="数组断言"><a href="#数组断言" class="headerlink" title="数组断言"></a>数组断言</h4><p>通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;array assertion&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">array</span><span class="params">()</span> &#123;</span><br><span class="line"> 	assertArrayEquals(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="组合断言"><a href="#组合断言" class="headerlink" title="组合断言"></a>组合断言</h4><p>assertAll 方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为验证的断言，可以通过 lambda 表达式提供这些断言</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;assert all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">all</span><span class="params">()</span> &#123;</span><br><span class="line">	assertAll(<span class="string">&quot;Math&quot;</span>,</span><br><span class="line">              () -&gt; assertEquals(<span class="number">2</span>, <span class="number">1</span> + <span class="number">1</span>),</span><br><span class="line">              () -&gt; assertTrue(<span class="number">1</span> &gt; <span class="number">0</span>)</span><br><span class="line">   	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="异常断言"><a href="#异常断言" class="headerlink" title="异常断言"></a>异常断言</h4><p>Assertions.assertThrows()，配合函数式编程就可以进行使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;异常测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ArithmeticException</span> <span class="variable">exception</span> <span class="operator">=</span> Assertions.assertThrows(</span><br><span class="line">        <span class="comment">//扔出断言异常</span></span><br><span class="line">		ArithmeticException.class, () -&gt; System.out.println(<span class="number">1</span> / <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="超时断言"><a href="#超时断言" class="headerlink" title="超时断言"></a>超时断言</h4><p>Assertions.assertTimeout() 为测试方法设置了超时时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;超时测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">timeoutTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//如果测试方法时间超过1s将会异常</span></span><br><span class="line">    Assertions.assertTimeout(Duration.ofMillis(<span class="number">1000</span>), () -&gt; Thread.sleep(<span class="number">500</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h4><p>通过 fail 方法直接使得测试失败</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;fail&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shouldFail</span><span class="params">()</span> &#123;</span><br><span class="line">	fail(<span class="string">&quot;This should fail&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><p>JUnit 5 中的前置条件（assumptions）类似于断言，不同之处在于<strong>不满足的断言会使得测试方法失败</strong>，而不满足的<strong>前置条件只会使得测试方法的执行终止</strong>，前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;测试前置条件&quot;)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testassumptions</span><span class="params">()</span>&#123;</span><br><span class="line">    Assumptions.assumeTrue(<span class="literal">false</span>,<span class="string">&quot;结果不是true&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="嵌套测试"><a href="#嵌套测试" class="headerlink" title="嵌套测试"></a>嵌套测试</h3><p>JUnit 5 可以通过 Java 中的内部类和 @Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起，在内部类中可以使用 @BeforeEach 和 @AfterEach 注解，而且嵌套的层次没有限制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;A stack&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestingAStackDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Object&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;is instantiated with new Stack()&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">isInstantiatedWithNew</span><span class="params">()</span> &#123;</span><br><span class="line">        assertNull(stack)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;when new&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WhenNew</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@BeforeEach</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">createNewStack</span><span class="params">()</span> &#123;</span><br><span class="line">            stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;is empty&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">            assertTrue(stack.isEmpty());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;throws EmptyStackException when popped&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">throwsExceptionWhenPopped</span><span class="params">()</span> &#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::pop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="参数测试"><a href="#参数测试" class="headerlink" title="参数测试"></a>参数测试</h3><p>参数化测试是 JUnit5 很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能</p>
<p>利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。</p>
<ul>
<li><p>@ValueSource：为参数化测试指定入参来源，支持八大基础类以及 String 类型、Class 类型</p>
</li>
<li><p>@NullSource：表示为参数化测试提供一个 null 的入参</p>
</li>
<li><p>@EnumSource：表示为参数化测试提供一个枚举入参</p>
</li>
<li><p>@CsvFileSource：表示读取指定 CSV 文件内容作为参数化测试入参</p>
</li>
<li><p>@MethodSource：表示读取指定方法的返回值作为参数化测试入参（注意方法返回需要是一个流）</p>
</li>
</ul>
<hr>
<h2 id="指标监控"><a href="#指标监控" class="headerlink" title="指标监控"></a>指标监控</h2><h3 id="Actuator"><a href="#Actuator" class="headerlink" title="Actuator"></a>Actuator</h3><p>每一个微服务在云上部署以后，都需要对其进行监控、追踪、审计、控制等，SpringBoot 抽取了 Actuator 场景，使得每个微服务快速引用即可获得生产级别的应用监控、审计等功能</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>暴露所有监控信息为 HTTP：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">enabled-by-default:</span> <span class="literal">true</span> <span class="comment">#暴露所有端点信息</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span>  <span class="comment">#以web方式暴露</span></span><br></pre></td></tr></table></figure>

<p>访问 <a href="http://localhost:8080/actuator/[beans/health/metrics/]">http://localhost:8080/actuator/[beans/health/metrics/]</a></p>
<p>可视化界面：<a href="https://github.com/codecentric/spring-boot-admin">https://github.com/codecentric/spring-boot-admin</a></p>
<hr>
<h3 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h3><p>默认所有的 Endpoint 除过 shutdown 都是开启的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">enabled-by-default:</span> <span class="literal">false</span>	<span class="comment">#禁用所有的</span></span><br><span class="line">  <span class="attr">endpoint:</span>						<span class="comment">#手动开启一部分</span></span><br><span class="line">    <span class="attr">beans:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>端点：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>auditevents</code></td>
<td>暴露当前应用程序的审核事件信息。需要一个 <code>AuditEventRepository</code> 组件</td>
</tr>
<tr>
<td><code>beans</code></td>
<td>显示应用程序中所有 Spring Bean 的完整列表</td>
</tr>
<tr>
<td><code>caches</code></td>
<td>暴露可用的缓存</td>
</tr>
<tr>
<td><code>conditions</code></td>
<td>显示自动配置的所有条件信息，包括匹配或不匹配的原因</td>
</tr>
<tr>
<td><code>configprops</code></td>
<td>显示所有 <code>@ConfigurationProperties</code></td>
</tr>
<tr>
<td><code>env</code></td>
<td>暴露 Spring 的属性 <code>ConfigurableEnvironment</code></td>
</tr>
<tr>
<td><code>flyway</code></td>
<td>显示已应用的所有 Flyway 数据库迁移。 需要一个或多个 Flyway 组件。</td>
</tr>
<tr>
<td><code>health</code></td>
<td>显示应用程序运行状况信息</td>
</tr>
<tr>
<td><code>httptrace</code></td>
<td>显示 HTTP 跟踪信息，默认情况下 100 个 HTTP 请求-响应需要一个 <code>HttpTraceRepository</code> 组件</td>
</tr>
<tr>
<td><code>info</code></td>
<td>显示应用程序信息</td>
</tr>
<tr>
<td><code>integrationgraph</code></td>
<td>显示 Spring integrationgraph，需要依赖 <code>spring-integration-core</code></td>
</tr>
<tr>
<td><code>loggers</code></td>
<td>显示和修改应用程序中日志的配置</td>
</tr>
<tr>
<td><code>liquibase</code></td>
<td>显示已应用的所有 Liquibase 数据库迁移，需要一个或多个 Liquibase 组件</td>
</tr>
<tr>
<td><code>metrics</code></td>
<td>显示当前应用程序的指标信息。</td>
</tr>
<tr>
<td><code>mappings</code></td>
<td>显示所有 <code>@RequestMapping</code> 路径列表</td>
</tr>
<tr>
<td><code>scheduledtasks</code></td>
<td>显示应用程序中的计划任务</td>
</tr>
<tr>
<td><code>sessions</code></td>
<td>允许从 Spring Session 支持的会话存储中检索和删除用户会话，需要使用 Spring Session 的基于 Servlet 的 Web 应用程序</td>
</tr>
<tr>
<td><code>shutdown</code></td>
<td>使应用程序正常关闭，默认禁用</td>
</tr>
<tr>
<td><code>startup</code></td>
<td>显示由 <code>ApplicationStartup</code> 收集的启动步骤数据。需要使用 <code>SpringApplication</code> 进行配置 <code>BufferingApplicationStartup</code></td>
</tr>
<tr>
<td><code>threaddump</code></td>
<td>执行线程转储</td>
</tr>
</tbody></table>
<p>应用程序是 Web 应用程序（Spring MVC，Spring WebFlux 或 Jersey），则可以使用以下附加端点：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>heapdump</code></td>
<td>返回 <code>hprof</code> 堆转储文件。</td>
</tr>
<tr>
<td><code>jolokia</code></td>
<td>通过 HTTP 暴露 JMX bean（需要引入 Jolokia，不适用于 WebFlux），需要引入依赖 <code>jolokia-core</code></td>
</tr>
<tr>
<td><code>logfile</code></td>
<td>返回日志文件的内容（如果已设置 <code>logging.file.name</code> 或 <code>logging.file.path</code> 属性），支持使用 HTTP Range标头来检索部分日志文件的内容。</td>
</tr>
<tr>
<td><code>prometheus</code></td>
<td>以 Prometheus 服务器可以抓取的格式公开指标，需要依赖 <code>micrometer-registry-prometheus</code></td>
</tr>
</tbody></table>
<p>常用 Endpoint：</p>
<ul>
<li><p>Health：监控状况</p>
</li>
<li><p>Metrics：运行时指标</p>
</li>
<li><p>Loggers：日志记录</p>
</li>
</ul>
<hr>
<h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>SpringBoot 项目开发完毕后，支持两种方式部署到服务器：</p>
<ul>
<li>jar 包 (官方推荐，默认)</li>
<li>war 包</li>
</ul>
<p><strong>更改 pom 文件中的打包方式为 war</strong></p>
<ul>
<li><p>修改启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootDeployApplication</span> <span class="keyword">extends</span> <span class="title class_">SpringBootServletInitializer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootDeployApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> SpringApplicationBuilder <span class="title function_">configure</span><span class="params">(SpringApplicationBuilder b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b.sources(SpringbootDeployApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定打包的名称</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>springboot<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/08/02/Frame/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: Frame</span><br><span class="line">date: 2022-01-01 00:00:00</span><br><span class="line">tags: Frame</span><br><span class="line">categories: Frame</span><br><span class="line">comment</span><br></pre></td></tr></table></figure>

<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="Mvn介绍"><a href="#Mvn介绍" class="headerlink" title="Mvn介绍"></a>Mvn介绍</h3><p>Maven：本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目对象模型（POM）</p>
<p>POM：Project Object Model 项目对象模型。Maven 是用 Java 语言编写的，管理的东西以面向对象的形式进行设计，最终把一个项目看成一个对象，这个对象叫做 POM</p>
<p>pom.xml：Maven 需要一个  pom.xml 文件，Maven 通过加载这个配置文件可以知道项目的相关信息，这个文件代表就一个项目。如果做 8 个项目，对应的是 8 个 pom.xml 文件</p>
<p>依赖管理：Maven 对项目所有依赖资源的一种管理，它和项目之间是一种双向关系，即做项目时可以管理所需要的其他资源，当其他项目需要依赖我们项目时，Maven 也会把我们的项目当作一种资源去进行管理。</p>
<p>管理资源的存储位置：本地仓库，私服，中央仓库</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Maven%E4%BB%8B%E7%BB%8D.png"></p>
<p>基本作用：</p>
<ul>
<li><p>项目构建：提供标准的，跨平台的自动化构建项目的方式</p>
</li>
<li><p>依赖管理：方便快捷的管理项目依赖的资源（jar 包），避免资源间的版本冲突等问题</p>
</li>
<li><p>统一开发结构：提供标准的，统一的项目开发结构</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Maven%E6%A0%87%E5%87%86%E7%BB%93%E6%9E%84.png"></p>
</li>
</ul>
<p>各目录存放资源类型说明：</p>
<ul>
<li><p>src&#x2F;main&#x2F;java：项目 java 源码</p>
</li>
<li><p>src&#x2F;main&#x2F;resources：项目的相关配置文件（比如 mybatis 配置，xml 映射配置，自定义配置文件等）</p>
</li>
<li><p>src&#x2F;main&#x2F;webapp：web 资源（比如 html、css、js 等）</p>
</li>
<li><p>src&#x2F;test&#x2F;java：测试代码</p>
</li>
<li><p>src&#x2F;test&#x2F;resources：测试相关配置文件</p>
</li>
<li><p>src&#x2F;pom.xml：项目 pom 文件</p>
</li>
</ul>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1Ah411S7ZE">https://www.bilibili.com/video/BV1Ah411S7ZE</a></p>
<hr>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>仓库：用于存储资源，主要是各种 jar 包。有本地仓库，私服，中央仓库，私服和中央仓库都是远程仓库</p>
<ul>
<li><p>中央仓库：Maven 团队自身维护的仓库，属于开源的</p>
</li>
<li><p>私服：各公司&#x2F;部门等小范围内存储资源的仓库，私服也可以从中央仓库获取资源，作用：</p>
<ul>
<li>保存具有版权的资源，包含购买或自主研发的 jar</li>
<li>一定范围内共享资源，能做到仅对内不对外开放</li>
</ul>
</li>
<li><p>本地仓库：开发者自己电脑上存储资源的仓库，也可从远程仓库获取资源</p>
</li>
</ul>
<p>坐标：Maven 中的坐标用于描述仓库中资源的位置</p>
<ul>
<li><p>作用：使用唯一标识，唯一性定义资源位置，通过该标识可以将资源的识别与下载工作交由机器完成</p>
<ul>
<li><a href="https://mvnrepository.com：查询">https://mvnrepository.com：查询</a> maven 某一个资源的坐标，输入资源名称进行检索</li>
</ul>
</li>
<li><p>依赖设置：</p>
<ul>
<li>groupId：定义当前资源隶属组织名称（通常是域名反写，如：org.mybatis）</li>
</ul>
</li>
<li><p>artifactId：定义当前资源的名称（通常是项目或模块名称，如：crm、sms）</p>
<ul>
<li>version：定义当前资源的版本号</li>
</ul>
</li>
<li><p>packaging：定义资源的打包方式，取值一般有如下三种</p>
<ul>
<li><p>jar：该资源打成 jar 包，默认是 jar</p>
</li>
<li><p>war：该资源打成 war 包</p>
</li>
<li><p>pom：该资源是一个父资源（表明使用 Maven 分模块管理），打包时只生成一个 pom.xml 不生成 jar 或其他包结构</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>Maven 的官网：<a href="http://maven.apache.org/">http://maven.apache.org/</a></p>
<p>下载安装：Maven 是一个绿色软件，解压即安装</p>
<p>目录结构：</p>
<ul>
<li>bin：可执行程序目录</li>
<li>boot：Maven 自身的启动加载器</li>
<li>conf：Maven 配置文件的存放目录</li>
<li>lib：Maven运行所需库的存放目录</li>
</ul>
<p>配置 MAVEN_HOME：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Maven%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png"></p>
<p>Path 下配置：<code>%MAVEN_HOME%\bin</code></p>
<p>环境变量配置好之后需要测试环境配置结果，在 DOS 命令窗口下输入以下命令查看输出：<code>mvn -v</code></p>
<hr>
<h3 id="仓库配置"><a href="#仓库配置" class="headerlink" title="仓库配置"></a>仓库配置</h3><p>默认情况 Maven 本地仓库在系统用户目录下的 <code>.m2/repository</code>，修改 Maven 的配置文件 <code>conf/settings.xml</code> 来修改仓库位置</p>
<ul>
<li><p>修改本地仓库位置：找到 <localRepository> 标签，修改默认值</localRepository></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">| The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">| Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>E:\Workspace\Java\Project\.m2\repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：在仓库的同级目录即 <code>.m2</code> 也应该包含一个 <code>settings.xml</code> 配置文件，局部用户配置优先与全局配置</p>
<ul>
<li>全局 setting 定义了 Maven 的公共配置</li>
<li>用户 setting 定义了当前用户的配置</li>
</ul>
</li>
<li><p>修改远程仓库：在配置文件中找到 <code>&lt;mirrors&gt;</code> 标签，在这组标签下添加国内镜像</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>  <span class="comment">&lt;!--必须是central--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改默认 JDK：在配置文件中找到 <code>&lt;profiles&gt;</code> 标签，添加配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-10<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>10<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>10<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>10<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><h3 id="手动搭建"><a href="#手动搭建" class="headerlink" title="手动搭建"></a>手动搭建</h3><ol>
<li><p>在 E 盘下创建目录 mvnproject 进入该目录，作为我们的操作目录</p>
</li>
<li><p>创建我们的 Maven 项目，创建一个目录 <code>project-java</code> 作为我们的项目文件夹，并进入到该目录</p>
</li>
<li><p>创建 Java 代码（源代码）所在目录，即创建 <code>src/main/java</code></p>
</li>
<li><p>创建配置文件所在目录，即创建 <code>src/main/resources</code></p>
</li>
<li><p>创建测试源代码所在目录，即创建 <code>src/test/java</code></p>
</li>
<li><p>创建测试存放配置文件存放目录，即 <code>src/test/resources</code></p>
</li>
<li><p>在 <code>src/main/java</code> 中创建一个包（注意在 Windos 文件夹下就是创建目录）<code>demo</code>，在该目录下创建 <code>Demo.java</code> 文件，作为演示所需 Java 程序，内容如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">say</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello &quot;</span>+name);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;hello &quot;</span>+name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>src/test/java</code> 中创建一个测试包（目录）<code>demo</code>，在该包下创建测试程序 <code>DemoTest.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoTest</span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSay</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> d.say(<span class="string">&quot;maven&quot;</span>);</span><br><span class="line">		Assert.assertEquals(<span class="string">&quot;hello maven&quot;</span>,ret);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 <code>project-java/src</code> 下创建 <code>pom.xml</code> 文件，格式如下：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 	</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--指定pom的模型版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--打包方式，web工程打包为war，java工程打包为jar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--组织id--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--项目id--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--版本号:release,snapshot--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--设置当前工程的所有依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--具体的依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>搭建完成 Maven 的项目结构，通过 Maven 来构建项目。Maven 的构建命令以 <code>mvn</code> 开头，后面添加功能参数，可以一次性执行多个命令，用空格分离</p>
<ul>
<li><code>mvn compile</code>：编译</li>
<li><code>mvn clean</code>：清理</li>
<li><code>mvn test</code>：测试</li>
<li><code>mvn package</code>：打包</li>
<li><code>mvn install</code>：安装到本地仓库</li>
</ul>
<p>注意：执行某一条命令，则会把前面所有的都执行一遍</p>
</li>
</ol>
<hr>
<h3 id="IDEA搭建"><a href="#IDEA搭建" class="headerlink" title="IDEA搭建"></a>IDEA搭建</h3><h4 id="不用原型"><a href="#不用原型" class="headerlink" title="不用原型"></a>不用原型</h4><ol>
<li><p>在 IDEA 中配置 Maven，选择 maven3.6.1 防止依赖问题</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/IDEA配置Maven.png" alt="IDEA配置Maven" style="zoom:67%;">
</li>
<li><p>创建 Maven，New Module → Maven → 不选中 Create from archetype</p>
</li>
<li><p>填写项目的坐标</p>
<ul>
<li>GroupId：demo</li>
<li>ArtifactId：project-java</li>
</ul>
</li>
<li><p>查看各目录颜色标记是否正确</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/IDEA%E5%88%9B%E5%BB%BAMaven%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png"></p>
</li>
<li><p>IDEA 右侧侧栏有 Maven Project，打开后有 Lifecycle 生命周期</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/IDEA-Maven%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p>
</li>
<li><p>自定义 Maven 命令：Run → Edit Configurations → 左上角 +  → Maven</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/IDEA%E9%85%8D%E7%BD%AEMaven%E5%91%BD%E4%BB%A4.png"></p>
</li>
</ol>
<hr>
<h4 id="使用原型"><a href="#使用原型" class="headerlink" title="使用原型"></a>使用原型</h4><p>普通工程：</p>
<ol>
<li><p>创建 Maven 项目的时候选择使用原型骨架</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/IDEA%E5%88%9B%E5%BB%BAMaven-quickstart.png"></p>
</li>
<li><p>创建完成后发现通过这种方式缺少一些目录，需要手动去补全目录，并且要对补全的目录进行标记</p>
</li>
</ol>
<p>Web 工程：</p>
<ol>
<li><p>选择 Web 对应的原型骨架（选择 Maven 开头的是简化的）</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/IDEA%E5%88%9B%E5%BB%BAMaven-webapp.png"></p>
</li>
<li><p>通过原型创建 Web 项目得到的目录结构是不全的，因此需要我们自行补全，同时要标记正确</p>
</li>
<li><p>Web 工程创建之后需要启动运行，使用 tomcat 插件来运行项目，在 <code>pom.xml</code> 中添加插件的坐标：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> 		</span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 </span></span></span><br><span class="line"><span class="string"><span class="tag">                             http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>web01<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>web01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--构建--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--具体的插件配置--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--https://mvnrepository.com/  搜索--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span> <span class="comment">&lt;!--80端口默认不显示--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>插件配置以后，在 IDEA 右侧 <code>maven-project</code> 操作面板看到该插件，并且可以利用该插件启动项目，web01 → Plugins → tomcat7 → tomcat7:run</p>
</li>
</ol>
<hr>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h3><p>依赖是指在当前项目中运行所需的 jar，依赖配置的格式如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置当前项目所依赖的所有jar--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置具体的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖所属群组id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖所属项目id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖版本号--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p>依赖具有传递性，分两种：</p>
<ul>
<li><p>直接依赖：在当前项目中通过依赖配置建立的依赖关系</p>
</li>
<li><p>间接依赖：被依赖的资源如果依赖其他资源，则表明当前项目间接依赖其他资源</p>
<p>注意：直接依赖和间接依赖其实也是一个相对关系</p>
</li>
</ul>
<p>依赖传递的冲突问题：在依赖传递过程中产生了冲突，有三种优先法则</p>
<ul>
<li><p>路径优先：当依赖中出现相同资源时，层级越深，优先级越低，反之则越高</p>
</li>
<li><p>声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖靠后的</p>
</li>
<li><p>特殊优先：当同级配置了相同资源的不同版本时，后配置的覆盖先配置的</p>
</li>
</ul>
<p><strong>可选依赖</strong>：对外隐藏当前所依赖的资源，不透明</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--默认是false，true以后就变得不透明--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>排除依赖</strong>：主动断开依赖的资源，被排除的资源无需指定版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="comment">&lt;!--排除这个资源--&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>依赖的 jar 默认情况可以在任何地方可用，可以通过 <code>scope</code> 标签设定其作用范围，有三种：</p>
<ul>
<li><p>主程序范围有效（src&#x2F;main 目录范围内）</p>
</li>
<li><p>测试程序范围内有效（src&#x2F;test 目录范围内）</p>
</li>
<li><p>是否参与打包（package 指令范围内）</p>
</li>
</ul>
<p><code>scope</code> 标签的取值有四种：<code>compile,test,provided,runtime</code></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Maven%E4%BE%9D%E8%B5%96%E8%8C%83%E5%9B%B4.png"></p>
<p><strong>依赖范围的传递性：</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Maven%E4%BE%9D%E8%B5%96%E8%8C%83%E5%9B%B4%E7%9A%84%E4%BC%A0%E9%80%92%E6%80%A7.png"></p>
<hr>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="相关事件"><a href="#相关事件" class="headerlink" title="相关事件"></a>相关事件</h3><p>Maven 的构建生命周期描述的是一次构建过程经历了多少个事件</p>
<p>最常用的一套流程：compile → test-compile → test → package → install</p>
<ul>
<li><p>clean：清理工作</p>
<ul>
<li>pre-clean：执行一些在 clean 之前的工作</li>
<li>clean：移除上一次构建产生的所有文件</li>
<li>post-clean：执行一些在 clean 之后立刻完成的工作</li>
</ul>
</li>
<li><p>default：核心工作，例如编译，测试，打包，部署等，每个事件在执行之前都会<strong>将之前的所有事件依次执行一遍</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Maven-default%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p>
</li>
<li><p>site：产生报告，发布站点等</p>
<ul>
<li>pre-site：执行一些在生成站点文档之前的工作</li>
<li>site：生成项目的站点文档</li>
<li>post-site：执行一些在生成站点文档之后完成的工作，并为部署做准备</li>
<li>site-deploy：将生成的站点文档部署到特定的服务器上</li>
</ul>
</li>
</ul>
<hr>
<h3 id="执行事件"><a href="#执行事件" class="headerlink" title="执行事件"></a>执行事件</h3><p>Maven 的插件用来执行生命周期中的相关事件</p>
<ul>
<li><p>插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件</p>
</li>
<li><p>Maven 默认在各个生命周期上都绑定了预先设定的插件来完成相应功能</p>
</li>
<li><p>插件还可以完成一些自定义功能</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>           </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>           </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>           </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>           </span><br><span class="line">            <span class="comment">&lt;!--执行--&gt;</span>          </span><br><span class="line">            <span class="tag">&lt;<span class="name">excutions</span>&gt;</span>               </span><br><span class="line">                <span class="comment">&lt;!--具体执行位置--&gt;</span>              </span><br><span class="line">                <span class="tag">&lt;<span class="name">excution</span>&gt;</span>                   </span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span>                      </span><br><span class="line">                        <span class="comment">&lt;!--对源码进行打包，打包放在target目录--&gt;</span>                    	</span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>                      </span><br><span class="line">                        <span class="comment">&lt;!--对测试代码进行打包--&gt;</span>                       </span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>test-jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>                 </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>                  </span><br><span class="line">                    <span class="comment">&lt;!--执行的生命周期--&gt;</span>                 </span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-test-resources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>                 </span><br><span class="line">                <span class="tag">&lt;/<span class="name">excution</span>&gt;</span>         </span><br><span class="line">            <span class="tag">&lt;/<span class="name">excutions</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="模块开发"><a href="#模块开发" class="headerlink" title="模块开发"></a>模块开发</h2><h3 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h3><p>工程模块与模块划分：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Maven%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86.png"></p>
<ul>
<li><p>ssm_pojo 拆分</p>
<ul>
<li>新建模块，拷贝原始项目中对应的相关内容到 ssm_pojo 模块中</li>
<li>实体类（User）</li>
<li>配置文件（无）</li>
</ul>
</li>
<li><p>ssm_dao 拆分</p>
<ul>
<li><p>新建模块</p>
</li>
<li><p>拷贝原始项目中对应的相关内容到 ssm_dao 模块中</p>
<ul>
<li><p>数据层接口（UserDao）</p>
</li>
<li><p>配置文件：保留与数据层相关配置文件(3 个）</p>
</li>
<li><p>注意：分页插件在配置中与 SqlSessionFactoryBean 绑定，需要保留</p>
</li>
<li><p>pom.xml：引入数据层相关坐标即可，删除 SpringMVC 相关坐标</p>
<ul>
<li>Spring</li>
<li>MyBatis</li>
<li>Spring 整合 MyBatis</li>
<li>MySQL</li>
<li>druid</li>
<li>pagehelper</li>
<li>直接依赖 ssm_pojo（对 ssm_pojo 模块执行 install 指令，将其安装到本地仓库）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>    <span class="comment">&lt;!--导入资源文件pojo--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--spring环境--&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--mybatis环境--&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--mysql环境--&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--spring整合jdbc--&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--spring整合mybatis--&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--druid连接池--&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--分页插件坐标--&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>ssm_service 拆分</p>
<ul>
<li><p>新建模块</p>
</li>
<li><p>拷贝原始项目中对应的相关内容到 ssm_service 模块中</p>
<ul>
<li><p>业务层接口与实现类（UserService、UserServiceImpl）</p>
</li>
<li><p>配置文件：保留与数据层相关配置文件(1 个）</p>
</li>
<li><p>pom.xml：引入数据层相关坐标即可，删除 SpringMVC 相关坐标</p>
<ul>
<li><p>spring</p>
</li>
<li><p>junit</p>
</li>
<li><p>spring 整合 junit</p>
</li>
<li><p>直接依赖 ssm_dao（对 ssm_dao 模块执行 install 指令，将其安装到本地仓库）</p>
</li>
<li><p>间接依赖 ssm_pojo（由 ssm_dao 模块负责依赖关系的建立）</p>
</li>
</ul>
</li>
<li><p>修改 service 模块 Spring 核心配置文件名，添加模块名称，格式：applicationContext-service.xml</p>
</li>
<li><p>修改 dao 模块 Spring 核心配置文件名，添加模块名称，格式：applicationContext-dao.xml</p>
</li>
<li><p>修改单元测试引入的配置文件名称，由单个文件修改为多个文件</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ssm_control 拆分</p>
<ul>
<li><p>新建模块（使用 webapp 模板）</p>
</li>
<li><p>拷贝原始项目中对应的相关内容到 ssm_controller 模块中</p>
<ul>
<li><p>现层控制器类与相关设置类（UserController、异常相关……）</p>
</li>
<li><p>配置文件：保留与表现层相关配置文件(1 个）、服务器相关配置文件（1 个）</p>
</li>
<li><p>pom.xml：引入数据层相关坐标即可，删除 SpringMVC 相关坐标</p>
<ul>
<li><p>spring</p>
</li>
<li><p>springmvc</p>
</li>
<li><p>jackson</p>
</li>
<li><p>servlet</p>
</li>
<li><p>tomcat 服务器插件</p>
</li>
<li><p>直接依赖 ssm_service（对 ssm_service 模块执行 install 指令，将其安装到本地仓库）</p>
</li>
<li><p>间接依赖 ssm_dao、ssm_pojo</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--导入资源文件service--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>         </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm_service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--springmvc环境--&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--jackson相关坐标3个--&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--servlet环境--&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--设置插件--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>    </span><br><span class="line">        <span class="comment">&lt;!--具体的插件配置--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 web.xml 配置文件中加载 Spring 环境的配置文件名称，使用*通配，加载所有 applicationContext- 开始的配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:applicationContext-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>spring-mvc</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;controller&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>作用：聚合用于快速构建 Maven 工程，一次性构建多个项目&#x2F;模块</p>
<p>制作方式：</p>
<ul>
<li><p>创建一个空模块，打包类型定义为 pom</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义当前模块进行构建操作时关联的其他模块名称</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;............&quot;</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义该工程用于构建管理--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--管理的工程列表--&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span>       </span><br><span class="line">        <span class="comment">&lt;!--具体的工程名称--&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../ssm_pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../ssm_dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../ssm_service<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../ssm_controller<span class="tag">&lt;/<span class="name">module</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意事项：参与聚合操作的模块最终执行顺序与模块间的依赖关系有关，与配置顺序无关</p>
<hr>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>作用：通过继承可以实现在子工程中沿用父工程中的配置</p>
<ul>
<li>Maven 中的继承与 Java 中的继承相似，在子工程中配置继承关系</li>
</ul>
<p>制作方式：</p>
<ul>
<li><p>在子工程中声明其父工程坐标与对应的位置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义该工程的父工程--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.seazean<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--填写父工程的pom文件--&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../ssm/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>继承依赖的定义：在父工程中定义依赖管理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--声明此处进行依赖管理，版本锁定--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--具体的依赖--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>      </span><br><span class="line">        <span class="comment">&lt;!--spring环境--&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>       </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>   </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>     </span><br><span class="line">        <span class="comment">&lt;!--等等所有--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>继承依赖的使用：在子工程中定义依赖关系，<strong>无需声明依赖版本</strong>，版本参照父工程中依赖的版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--spring环境--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>继承的资源：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">groupId：项目组ID，项目坐标的核心元素</span><br><span class="line">version：项目版本，项目坐标的核心因素</span><br><span class="line">description：项目的描述信息</span><br><span class="line">organization：项目的组织信息</span><br><span class="line">inceptionYear：项目的创始年份</span><br><span class="line">url：项目的URL地址</span><br><span class="line">developers：项目的开发者信息</span><br><span class="line">contributors：项目的贡献者信息</span><br><span class="line">distributionManagement：项目的部署配置</span><br><span class="line">issueManagement：项目的缺陷跟踪系统信息</span><br><span class="line">ciManagement：项目的持续集成系统信息</span><br><span class="line">scm：项目的版本控制系统信息</span><br><span class="line">malilingLists：项目的邮件列表信息</span><br><span class="line">properties：自定义的Maven属性</span><br><span class="line">dependencies：项目的依赖配置</span><br><span class="line">dependencyManagement：项目的依赖管理配置</span><br><span class="line">repositories：项目的仓库配置</span><br><span class="line">build：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等</span><br><span class="line">reporting：包括项目的报告输出目录配置、报告插件配置等</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承与聚合：</p>
<p>作用：</p>
<ul>
<li><p>聚合用于快速构建项目</p>
</li>
<li><p>继承用于快速配置</p>
</li>
</ul>
<p>相同点：</p>
<ul>
<li><p>聚合与继承的 pom.xml 文件打包方式均为 pom，可以将两种关系制作到同一个 pom 文件中</p>
</li>
<li><p>聚合与继承均属于设计型模块，并无实际的模块内容</p>
</li>
</ul>
<p>不同点：</p>
<ul>
<li><p>聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些</p>
</li>
<li><p>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><p>版本统一的重要性： </p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Maven%E7%89%88%E6%9C%AC%E7%BB%9F%E4%B8%80%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7.png"></p>
</li>
<li><p>属性类别：</p>
<ol>
<li>自定义属性  </li>
<li>内置属性</li>
<li>setting 属性</li>
<li>Java 系统属性</li>
<li>环境变量属性</li>
</ol>
</li>
<li><p>自定义属性：</p>
<p>作用：等同于定义变量，方便统一维护</p>
<p>定义格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义自定义属性，放在dependencyManagement上方--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>聚合与继承的 pom.xml 文件打包方式均为 pom，可以将两种关系制作到同一个 pom 文件中</p>
</li>
<li><p>聚合与继承均属于设计型模块，并无实际的模块内容</p>
</li>
</ul>
<p>调用格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内置属性：</p>
<p>作用：使用 Maven 内置属性，快速配置</p>
<p>调用格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;project.basedir&#125; or $&#123;project.basedir&#125;  <span class="comment">&lt;!--../ssm根目录--&gt;</span>$&#123;version&#125; or $&#123;project.version&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>vresion 是 1.0-SNAPSHOT</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>setting 属性</p>
<ul>
<li>使用 Maven 配置文件 setting.xml 中的标签属性，用于动态配置</li>
</ul>
<p>调用格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;settings.localRepository&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 系统属性：</p>
<p>作用：读取 Java 系统属性</p>
<p>调用格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;user.home&#125;</span><br></pre></td></tr></table></figure>

<p>系统属性查询方式 cmd 命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:system </span><br></pre></td></tr></table></figure>
</li>
<li><p>环境变量属性</p>
<p>作用：使用 Maven 配置文件 setting.xml 中的标签属性，用于动态配置</p>
<p>调用格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;env.JAVA_HOME&#125; </span><br></pre></td></tr></table></figure>

<p>环境变量属性查询方式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:system </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="工程版本"><a href="#工程版本" class="headerlink" title="工程版本"></a>工程版本</h3><p>SNAPSHOT（快照版本）</p>
<ul>
<li><p>项目开发过程中，为方便团队成员合作，解决模块间相互依赖和时时更新的问题，开发者对每个模块进行构建的时候，输出的临时性版本叫快照版本（测试阶段版本）</p>
</li>
<li><p>快照版本会随着开发的进展不断更新</p>
</li>
</ul>
<p>RELEASE（发布版本）</p>
<ul>
<li>项目开发到进入阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的，即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本</li>
</ul>
<p>约定规范：</p>
<ul>
<li><p>&lt;主版本&gt;.&lt;次版本&gt;.&lt;增量版本&gt;.&lt;里程碑版本&gt;</p>
</li>
<li><p>主版本：表示项目重大架构的变更，如：Spring5 相较于 Spring4 的迭代</p>
</li>
<li><p>次版本：表示有较大的功能增加和变化，或者全面系统地修复漏洞</p>
</li>
<li><p>增量版本：表示有重大漏洞的修复</p>
</li>
<li><p>里程碑版本：表明一个版本的里程碑（版本内部）。这样的版本同下一个正式版本相比，相对来说不是很稳定，有待更多的测试</p>
</li>
</ul>
<hr>
<h3 id="资源配置"><a href="#资源配置" class="headerlink" title="资源配置"></a>资源配置</h3><p>作用：在任意配置文件中加载 pom 文件中定义的属性</p>
<ul>
<li><p>父文件 pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://192.168.0.137:3306/ssm_db?useSSL=false<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>开启配置文件加载 pom 属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置资源文件对应的信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span>   </span><br><span class="line">        <span class="comment">&lt;!--设定配置文件对应的位置目录，支持使用属性动态设定路径--&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!--开启对配置文件的资源加载过滤--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>properties 文件中调用格式：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driverjdbc.url=$&#123;jdbc.url&#125;</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">rootjdbc.password=123456</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h3><ul>
<li><p>环境配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建多环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--定义具体的环境：生产环境--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span>     </span><br><span class="line">        <span class="comment">&lt;!--定义环境对应的唯一名称--&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>pro_env<span class="tag">&lt;/<span class="name">id</span>&gt;</span>    </span><br><span class="line">        <span class="comment">&lt;!--定义环境中专用的属性值--&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span>           </span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.1.1.1:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>     </span><br><span class="line">        <span class="comment">&lt;!--设置默认启动--&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span>      </span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--定义具体的环境：开发环境--&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev_env<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        ……  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>加载指定环境</p>
<p>作用：加载指定环境配置</p>
<p>调用格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn 指令 –P 环境定义<span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<p>范例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn install –P pro_env</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h2><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn 指令 –D skipTests</span><br></pre></td></tr></table></figure>

<p>注意事项：执行的指令生命周期必须包含测试环节</p>
<p>IEDA 界面：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/IDEA%E4%BD%BF%E7%94%A8%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C%E8%B7%B3%E8%BF%87%E6%B5%8B%E8%AF%95.png"></p>
<p>配置跳过：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--&lt;groupId&gt;org.apache.maven&lt;/groupId&gt;--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span><span class="comment">&lt;!--设置跳过测试--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span> <span class="comment">&lt;!--包含指定的测试用例--&gt;</span>      </span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/User*Test.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span><span class="comment">&lt;!--排除指定的测试用例--&gt;</span>      </span><br><span class="line">            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/User*TestCase.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><h3 id="Nexus"><a href="#Nexus" class="headerlink" title="Nexus"></a>Nexus</h3><p>Nexus 是 Sonatype 公司的一款 Maven 私服产品</p>
<p>下载地址：<a href="https://help.sonatype.com/repomanager3/download">https://help.sonatype.com/repomanager3/download</a> </p>
<p>启动服务器（命令行启动）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nexus.exe /run nexus</span><br></pre></td></tr></table></figure>

<p>访问服务器（默认端口：8081）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">http://localhost:8081</span><br></pre></td></tr></table></figure>

<p>修改基础配置信息</p>
<ul>
<li>安装路径下 etc 目录中 nexus-default.properties 文件保存有 nexus 基础配置信息，例如默认访问端口</li>
</ul>
<p>修改服务器运行配置信息</p>
<ul>
<li>安装路径下 bin 目录中 nexus.vmoptions 文件保存有 nexus 服务器启动的配置信息，例如默认占用内存空间</li>
</ul>
<hr>
<h3 id="资源操作"><a href="#资源操作" class="headerlink" title="资源操作"></a>资源操作</h3><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Maven%E7%A7%81%E6%9C%8D%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96.png"></p>
<p>仓库分类：</p>
<ul>
<li><p>宿主仓库 hosted </p>
<ul>
<li>保存无法从中央仓库获取的资源<ul>
<li>自主研发</li>
<li>第三方非开源项目</li>
</ul>
</li>
</ul>
</li>
<li><p>代理仓库 proxy </p>
<ul>
<li>代理远程仓库，通过 nexus 访问其他公共仓库，例如中央仓库</li>
</ul>
</li>
<li><p>仓库组 group </p>
<ul>
<li>将若干个仓库组成一个群组，简化配置</li>
<li>仓库组不能保存资源，属于设计型仓库</li>
</ul>
</li>
</ul>
<p>资源上传，上传资源时提供对应的信息</p>
<ul>
<li><p>保存的位置（宿主仓库）</p>
</li>
<li><p>资源文件</p>
</li>
<li><p>对应坐标</p>
</li>
</ul>
<hr>
<h3 id="IDEA操作"><a href="#IDEA操作" class="headerlink" title="IDEA操作"></a>IDEA操作</h3><h4 id="上传下载"><a href="#上传下载" class="headerlink" title="上传下载"></a>上传下载</h4><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/IDEA%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%B5%84%E6%BA%90%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD.png"></p>
<hr>
<h4 id="访问私服"><a href="#访问私服" class="headerlink" title="访问私服"></a>访问私服</h4><h5 id="本地访问"><a href="#本地访问" class="headerlink" title="本地访问"></a>本地访问</h5><p>配置本地仓库访问私服的权限（setting.xml）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>heima-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>heima-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置本地仓库资源来源（setting.xml）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-heima<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h5 id="工程访问"><a href="#工程访问" class="headerlink" title="工程访问"></a>工程访问</h5><p>配置当前项目访问私服上传资源的保存位置（pom.xml）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>heima-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/heima-release/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>heima-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/heima-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>发布资源到私服命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn deploy</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h3><p>程序中的日志可以用来记录程序在运行时候的详情，并可以进行永久存储。</p>
<table>
<thead>
<tr>
<th></th>
<th>输出语句</th>
<th>日志技术</th>
</tr>
</thead>
<tbody><tr>
<td>取消日志</td>
<td>需要修改代码，灵活性比较差</td>
<td>不需要修改代码，灵活性比较好</td>
</tr>
<tr>
<td>输出位置</td>
<td>只能是控制台</td>
<td>可以将日志信息写入到文件或者数据库中</td>
</tr>
<tr>
<td>多线程</td>
<td>和业务代码处于一个线程中</td>
<td>多线程方式记录日志，不影响业务代码的性能</td>
</tr>
</tbody></table>
<p>Log4j 是 Apache 的一个开源项目。使用 Log4j，通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。我们可以控制日志信息输送的目的地是控制台、文件等位置，也可以控制每一条日志的输出格式。</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/日志体系结构.png" style="zoom:50%;">



<hr>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件的三个核心：</p>
<ul>
<li><p>配置根 Logger</p>
<ul>
<li><p>格式：log4j.rootLogger&#x3D;日志级别，appenderName1，appenderName2，…</p>
</li>
<li><p>日志级别：常见的五个级别：<strong>DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</strong>（可以自定义）<br>Log4j 规则：只输出级别不低于设定级别的日志信息</p>
</li>
<li><p>appenderName1：指定日志信息要输出地址。可以同时指定多个输出目的地，用逗号隔开：</p>
<p>例如：log4j.rootLogger＝INFO，ca，fa</p>
</li>
</ul>
</li>
<li><p>Appenders（输出源）：日志要输出的地方，如控制台（Console）、文件（Files）等</p>
<ul>
<li><p>Appenders 取值：</p>
<ul>
<li>org.apache.log4j.ConsoleAppender（控制台）</li>
<li>org.apache.log4j.FileAppender（文件）</li>
</ul>
</li>
<li><p>ConsoleAppender 常用参数</p>
<ul>
<li><code>ImmediateFlush=true</code>：表示所有消息都会被立即输出，设为 false 则不输出，默认值是 true</li>
<li><code>Target=System.err</code>：默认值是 System.out</li>
</ul>
</li>
<li><p>FileAppender常用的选项</p>
<ul>
<li><p><code>ImmediateFlush=true</code>：表示所有消息都会被立即输出。设为 false 则不输出，默认值是 true</p>
</li>
<li><p><code>Append=false</code>：true 表示将消息添加到指定文件中，原来的消息不覆盖。默认值是 true</p>
</li>
<li><p><code>File=E:/logs/logging.log4j</code>：指定消息输出到 logging.log4j 文件中</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Layouts (布局)：日志输出的格式，常用的布局管理器：</p>
<ul>
<li>org.apache.log4j.PatternLayout（可以灵活地指定布局模式）</li>
</ul>
</li>
<li><p>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）</p>
</li>
<li><p>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）</p>
</li>
<li><p>PatternLayout 常用的选项</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/日志-PatternLayout常用的选项.png" style="zoom:80%;"></li>
</ul>
<hr>
<h3 id="日志应用"><a href="#日志应用" class="headerlink" title="日志应用"></a>日志应用</h3><ul>
<li><p>log4j 的配置文件,名字为 log4j.properties, 放在 src 根目录下</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">log4j.rootLogger</span>=<span class="string">I</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### direct log messages to my ###</span></span><br><span class="line"><span class="attr">log4j.appender.my</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="attr">log4j.appender.my.ImmediateFlush</span> = <span class="string">true</span></span><br><span class="line"><span class="attr">log4j.appender.my.Target</span>=<span class="string">System.out</span></span><br><span class="line"><span class="attr">log4j.appender.my.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.my.layout.ConversionPattern</span>=<span class="string">%d %t %5p %c&#123;1&#125;:%L - %m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># fileAppender演示</span></span><br><span class="line"><span class="attr">log4j.appender.fileAppender</span>=<span class="string">org.apache.log4j.FileAppender</span></span><br><span class="line"><span class="attr">log4j.appender.fileAppender.ImmediateFlush</span> = <span class="string">true</span></span><br><span class="line"><span class="attr">log4j.appender.fileAppender.Append</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">log4j.appender.fileAppender.File</span>=<span class="string">E:/log4j-log.log</span></span><br><span class="line"><span class="attr">log4j.appender.fileAppender.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.fileAppender.layout.ConversionPattern</span>=<span class="string">%d %5p %c&#123;1&#125;:%L - %m%n</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Log4JTest01</span> &#123;    </span><br><span class="line">    <span class="comment">//使用log4j的api来获取日志的对象   </span></span><br><span class="line">    <span class="comment">//弊端：如果以后我们更换日志的实现类，那么下面的代码就需要跟着改   </span></span><br><span class="line">    <span class="comment">//不推荐使用   </span></span><br><span class="line">    <span class="comment">//private static final Logger LOGGER = Logger.getLogger(Log4JTest01.class);    </span></span><br><span class="line">    <span class="comment">//使用slf4j里面的api来获取日志的对象 </span></span><br><span class="line">    <span class="comment">//好处：如果以后我们更换日志的实现类，那么下面的代码不需要跟着修改   </span></span><br><span class="line">    <span class="comment">//推荐使用    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(Log4JTest01.class);  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">        <span class="comment">//1.导入jar包        </span></span><br><span class="line">        <span class="comment">//2.编写配置文件        </span></span><br><span class="line">        <span class="comment">//3.在代码中获取日志的对象        </span></span><br><span class="line">        <span class="comment">//4.按照日志级别设置日志信息        </span></span><br><span class="line">        LOGGER.debug(<span class="string">&quot;debug级别的日志&quot;</span>);        </span><br><span class="line">        LOGGER.info(<span class="string">&quot;info级别的日志&quot;</span>);        </span><br><span class="line">        LOGGER.warn(<span class="string">&quot;warn级别的日志&quot;</span>);        </span><br><span class="line">        LOGGER.error(<span class="string">&quot;error级别的日志&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Netty 是一个异步事件驱动的网络应用程序框架，用于快速开发可维护、高性能的网络服务器和客户端</p>
<p>Netty 官网：<a href="https://netty.io/">https://netty.io/</a></p>
<p>Netty 的对 JDK 自带的 NIO 的 API 进行封装，解决上述问题，主要特点有：</p>
<ul>
<li>设计优雅，适用于各种传输类型的统一 API， 阻塞和非阻塞 Socket 基于灵活且可扩展的事件模型</li>
<li>使用方便，详细记录的 Javadoc、用户指南和示例，没有其他依赖项</li>
<li>高性能，吞吐量更高，延迟更低，减少资源消耗，最小化不必要的内存复制</li>
<li>安全，完整的 SSL&#x2F;TLS 和 StartTLS 支持</li>
</ul>
<p>Netty 的功能特性：</p>
<ul>
<li>传输服务：支持 BIO 和 NIO</li>
<li>容器集成：支持 OSGI、JBossMC、Spring、Guice 容器</li>
<li>协议支持：HTTP、Protobuf、二进制、文本、WebSocket 等一系列协议都支持，也支持通过实行编码解码逻辑来实现自定义协议</li>
<li>Core 核心：可扩展事件模型、通用通信 API、支持零拷贝的 ByteBuf 缓冲对象</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-功能特性.png" style="zoom:50%;">





<hr>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="阻塞模型"><a href="#阻塞模型" class="headerlink" title="阻塞模型"></a>阻塞模型</h3><p>传统阻塞型 I&#x2F;O 模式，每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-传统阻塞IO服务模型.png" style="zoom:50%;">

<p>模型缺点：</p>
<ul>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 read 操作上，造成线程资源浪费</li>
</ul>
<p>参考文章：<a href="https://www.jianshu.com/p/2965fca6bb8f">https://www.jianshu.com/p/2965fca6bb8f</a></p>
<hr>
<h3 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h3><h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4><p>Reactor 模式，通过一个或多个输入同时传递给服务处理器的<strong>事件驱动处理模式</strong>。 服务端程序处理传入的多路请求，并将它们同步分派给对应的处理线程，Reactor 模式也叫 Dispatcher 模式，即 I&#x2F;O 多路复用统一监听事件，收到事件后分发（Dispatch 给某线程）</p>
<p><strong>I&#x2F;O 复用结合线程池</strong>，就是 Reactor 模式基本设计思想：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-Reactor模型.png" style="zoom: 50%;">

<p>Reactor 模式关键组成：</p>
<ul>
<li>Reactor：在一个单独的线程中运行，负责<strong>监听和分发事件</strong>，分发给适当的处理程序来对 I&#x2F;O 事件做出反应</li>
<li>Handler：处理程序执行 I&#x2F;O 要完成的实际事件，Reactor 通过调度适当的处理程序来响应 I&#x2F;O 事件，处理程序执行<strong>非阻塞操作</strong></li>
</ul>
<p>Reactor 模式具有如下的优点：</p>
<ul>
<li>响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的</li>
<li>编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程的切换开销</li>
<li>可扩展性，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源</li>
<li>可复用性，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性</li>
</ul>
<p>根据 Reactor 的数量和处理资源池线程的数量不同，有三种典型的实现：</p>
<ul>
<li>单 Reactor 单线程</li>
<li>单 Reactor 多线程</li>
<li>主从 Reactor 多线程</li>
</ul>
<hr>
<h4 id="单R单线程"><a href="#单R单线程" class="headerlink" title="单R单线程"></a>单R单线程</h4><p>Reactor 对象通过 select 监控客户端请求事件，收到事件后通过 dispatch 进行分发：</p>
<ul>
<li><p>如果是建立连接请求事件，则由 Acceptor 通过 accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理</p>
</li>
<li><p>如果不是建立连接事件，则 Reactor 会分发给连接对应的 Handler 来响应，Handler 会完成 read、业务处理、send 的完整流程</p>
<p>说明：<strong>Handler 和 Acceptor 属于同一个线程</strong></p>
</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-单Reactor单线程.png" style="zoom:50%;">

<p>模型优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</p>
<p>模型缺点：</p>
<ul>
<li>性能问题：只有一个线程，无法发挥多核 CPU 的性能，Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li>
<li>可靠性问题：线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li>
</ul>
<p>使用场景：客户端的数量有限，业务处理非常快速，比如 Redis，业务处理的时间复杂度 O(1)</p>
<hr>
<h4 id="单R多线程"><a href="#单R多线程" class="headerlink" title="单R多线程"></a>单R多线程</h4><p>执行流程通同单 Reactor 单线程，不同的是：</p>
<ul>
<li><p>Handler 只负责响应事件，不做具体业务处理，通过 read 读取数据后，会分发给后面的 Worker 线程池进行业务处理</p>
</li>
<li><p>Worker 线程池会分配独立的线程完成真正的业务处理，将响应结果发给 Handler 进行处理，最后由 Handler 收到响应结果后通过 send 将响应结果返回给 Client</p>
</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-单Reactor多线程.png" style="zoom:50%;">

<p>模型优点：可以充分利用多核 CPU 的处理能力</p>
<p>模型缺点：</p>
<ul>
<li>多线程数据共享和访问比较复杂</li>
<li>Reactor 承担所有事件的监听和响应，在单线程中运行，高并发场景下容易成为性能瓶颈</li>
</ul>
<hr>
<h4 id="主从模型"><a href="#主从模型" class="headerlink" title="主从模型"></a>主从模型</h4><p>采用多个 Reactor ，执行流程：</p>
<ul>
<li><p>Reactor 主线程 MainReactor 通过 select <strong>监控建立连接事件</strong>，收到事件后通过 Acceptor 接收，处理建立连接事件，处理完成后 MainReactor 会将连接分配给 Reactor 子线程的 SubReactor（有多个）处理</p>
</li>
<li><p>SubReactor 将连接加入连接队列进行监听其他事件，并创建一个 Handler 用于处理该连接的事件，当有新的事件发生时，SubReactor 会调用连接对应的 Handler 进行响应</p>
</li>
<li><p>Handler 通过 read 读取数据后，会分发给 Worker 线程池进行业务处理</p>
</li>
<li><p>Worker 线程池会分配独立的线程完成真正的业务处理，将响应结果发给 Handler 进行处理，最后由 Handler 收到响应结果后通过 send 将响应结果返回给 Client</p>
</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-主从Reactor多线程.png" style="zoom: 50%;">

<p>模型优点</p>
<ul>
<li><strong>父线程与子线程</strong>的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理</li>
<li>父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据</li>
</ul>
<p>使用场景：Nginx 主从 Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持</p>
<hr>
<h3 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h3><p>Reactor 模式中，Reactor 等待某个事件的操作状态发生变化（文件描述符可读写，socket 可读写），然后把事件传递给事先注册的 Handler 来做实际的读写操作，其中的读写操作都需要应用程序同步操作，所以 <strong>Reactor 是非阻塞同步网络模型（NIO）</strong></p>
<p>把 I&#x2F;O 操作改为异步，交给操作系统来完成就能进一步提升性能，这就是异步网络模型 Proactor（AIO）：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-Proactor模型.png" style="zoom:50%;">

<p>工作流程：</p>
<ul>
<li>ProactorInitiator 创建 Proactor 和 Handler 对象，并将 Proactor 和 Handler 通过 Asynchronous Operation Processor（AsyOptProcessor）注册到内核</li>
<li>AsyOptProcessor 处理注册请求，并处理 I&#x2F;O 操作，完成I&#x2F;O后通知 Proactor</li>
<li>Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理，最后由 Handler 完成业务处理</li>
</ul>
<p>对比：Reactor 在事件发生时就通知事先注册的处理器（读写在应用程序线程中处理完成）；Proactor 是在事件发生时基于异步 I&#x2F;O 完成读写操作（内核完成），I&#x2F;O 完成后才回调应用程序的处理器进行业务处理</p>
<p>模式优点：异步 I&#x2F;O 更加充分发挥 DMA（Direct Memory Access 直接内存存取）的优势</p>
<p>模式缺点：</p>
<ul>
<li>编程复杂性，由于异步操作流程的事件的初始化和事件完成在时间和空间上都是相互分离的，因此开发异步应用程序更加复杂，应用程序还可能因为反向的流控而变得更加难以调试</li>
<li>内存使用，缓冲区在读或写操作的时间段内必须保持住，可能造成持续的不确定性，并且每个并发操作都要求有独立的缓存，Reactor 模式在 socket 准备好读或写之前是不要求开辟缓存的</li>
<li>操作系统支持，Windows 下通过 IOCP 实现了真正的异步 I&#x2F;O，而在 Linux 系统下，Linux2.6 才引入异步 I&#x2F;O，目前还不完善，所以在 Linux 下实现高并发网络编程都是以 Reactor 模型为主</li>
</ul>
<hr>
<h3 id="Netty-1"><a href="#Netty-1" class="headerlink" title="Netty"></a>Netty</h3><p>Netty 主要基于主从 Reactors 多线程模型做了一定的改进，Netty 的工作架构图：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-工作模型.png" style="zoom:50%;">

<p>工作流程：</p>
<ol>
<li><p>Netty 抽象出两组线程池 BossGroup 专门负责接收客户端的连接，WorkerGroup 专门负责网络的读写</p>
</li>
<li><p>BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup，该 Group 相当于一个事件循环组，含有多个事件循环，每一个事件循环是 NioEventLoop，所以可以有多个线程</p>
</li>
<li><p>NioEventLoop 表示一个<strong>循环处理任务的线程</strong>，每个 NioEventLoop 都有一个 Selector，用于监听绑定在其上的 Socket 的通讯</p>
</li>
<li><p>每个 Boss NioEventLoop 循环执行的步骤：</p>
<ul>
<li>轮询 accept 事件</li>
<li>处理 accept 事件，与 client 建立连接，生成 NioScocketChannel，并将其<strong>注册到某个 Worker 中</strong>的某个 NioEventLoop 上的 Selector，连接就与 NioEventLoop 绑定</li>
<li>处理任务队列的任务，即 runAllTasks</li>
</ul>
</li>
<li><p>每个 Worker NioEventLoop 循环执行的步骤：</p>
<ul>
<li>轮询 read、write 事件</li>
<li>处理 I&#x2F;O 事件，即 read，write 事件，在对应 NioSocketChannel 处理</li>
<li>处理任务队列的任务，即 runAllTasks</li>
</ul>
</li>
<li><p>每个 Worker NioEventLoop 处理业务时，会使用 Pipeline（管道），Pipeline 中包含了 Channel，即通过 Pipeline 可以获取到对应通道，管道中维护了很多的处理器 Handler</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-Channel与Pipeline.png" style="zoom: 50%;"></li>
</ol>
<hr>
<h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>开发简单的服务器端和客户端，基本介绍：</p>
<ul>
<li>Channel 理解为数据的通道，把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 Pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf</li>
<li>Handler 理解为数据的处理工序，Pipeline 负责发布事件传播给每个 Handler，Handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法），分 Inbound 和 Outbound 两类</li>
<li>EventLoop 理解为处理数据的执行者，既可以执行 IO 操作，也可以进行任务处理。每个执行者有任务队列，队列里可以堆放多个 Channel 的待处理任务，任务分为普通任务、定时任务。按照 Pipeline 顺序，依次按照 Handler 的规划（代码）处理数据</li>
</ul>
<p>代码实现：</p>
<ul>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.20.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>Server.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 1. 启动器，负责组装 netty 组件，启动服务器</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                <span class="comment">// 2. 线程组，boss 只负责【处理 accept 事件】， worker 只【负责 channel 上的读写】</span></span><br><span class="line">                .group(boss, worker)</span><br><span class="line">           	 	<span class="comment">//.option() 		// 给 ServerSocketChannel 配置参数</span></span><br><span class="line">            	<span class="comment">//.childOption()   	// 给 SocketChannel 配置参数</span></span><br><span class="line">                <span class="comment">// 3. 选择服务器的 ServerSocketChannel 实现</span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">// 4. boss 负责处理连接，worker(child) 负责处理读写，决定了能执行哪些操作(handler)</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="comment">// 5. channel 代表和客户端进行数据读写的通道 Initializer 初始化，负责添加别的 handler</span></span><br><span class="line">                    <span class="comment">// 7. 连接建立后，执行初始化方法</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="comment">// 添加具体的 handler</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());<span class="comment">// 将 ByteBuf 转成字符串</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123; <span class="comment">// 自定义 handler</span></span><br><span class="line">                            <span class="comment">// 读事件</span></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                                <span class="comment">// 打印转换好的字符串</span></span><br><span class="line">                                System.out.println(msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 6. 绑定监听端口</span></span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Client.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建启动器类</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                <span class="comment">// 2. 添加 EventLoop</span></span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">            	<span class="comment">//.option()，给 SocketChannel 配置参数</span></span><br><span class="line">                <span class="comment">// 3. 选择客户端 channel 实现</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">// 4. 添加处理器</span></span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="comment">// 4.1 连接建立后被调用</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="comment">// 将 Hello World 转为 ByteBuf</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 5. 连接到服务器，然后调用 4.1</span></span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>))</span><br><span class="line">                <span class="comment">// 6. 阻塞方法，直到连接建立</span></span><br><span class="line">                .sync()</span><br><span class="line">                <span class="comment">// 7. 代表连接对象</span></span><br><span class="line">                .channel()</span><br><span class="line">                <span class="comment">// 8. 向服务器发送数据</span></span><br><span class="line">                .writeAndFlush(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1py4y1E7oA">https://www.bilibili.com/video/BV1py4y1E7oA</a></p>
<hr>
<h2 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h2><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>事件循环对象 EventLoop，<strong>本质是一个单线程执行器同时维护了一个 Selector</strong>，有 run 方法处理 Channel 上源源不断的 IO 事件</p>
<p>事件循环组 EventLoopGroup 是一组 EventLoop，Channel 会调用 Boss EventLoopGroup 的 register 方法来绑定其中一个 Worker 的 EventLoop，后续这个 Channel 上的 IO 事件都由此 EventLoop 来处理，保证了事件处理时的线程安全</p>
<p>EventLoopGroup 类 API：</p>
<ul>
<li><p><code>EventLoop next()</code>：获取集合中下一个 EventLoop，EventLoopGroup 实现了 Iterable 接口提供遍历 EventLoop 的能力</p>
</li>
<li><p><code>Future&lt;?&gt; shutdownGracefully()</code>：优雅关闭的方法，会首先切换 EventLoopGroup 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行，从而确保整体应用是在正常有序的状态下退出的</p>
</li>
<li><p><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>：提交任务</p>
</li>
<li><p><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay</code>：提交定时任务</p>
</li>
</ul>
<hr>
<h4 id="任务传递"><a href="#任务传递" class="headerlink" title="任务传递"></a>任务传递</h4><p>把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventLoopServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="string">&quot;handler1&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                log.debug(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                                ctx.fireChannelRead(msg);   <span class="comment">// 让消息【传递】给下一个 handler</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;).addLast(group, <span class="string">&quot;handler2&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                log.debug(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ChannelHandlerContext <span class="title function_">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> &#123;</span><br><span class="line">    invokeChannelRead(findContextInbound(MASK_CHANNEL_READ), msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>), next);</span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    <span class="comment">// 下一个 handler 的事件循环是否与当前的事件循环是同一个线程</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="comment">// 是，直接调用</span></span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是，将要执行的代码作为任务提交给下一个 handler 处理</span></span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><h4 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h4><p>Channel 类 API：</p>
<ul>
<li><code>ChannelFuture close()</code>：关闭通道</li>
<li><code>ChannelPipeline pipeline()</code>：添加处理器</li>
<li><code>ChannelFuture write(Object msg)</code>：数据写入缓冲区</li>
<li><code>ChannelFuture writeAndFlush(Object msg)</code>：数据写入缓冲区并且刷出</li>
</ul>
<p>ChannelFuture 类 API：</p>
<ul>
<li><code>ChannelFuture sync()</code>：同步阻塞等待连接成功</li>
<li><code>ChannelFuture addListener(GenericFutureListener listener)</code>：异步等待</li>
</ul>
<p>代码实现：</p>
<ul>
<li>connect 方法是异步的，不等连接建立完成就返回，因此 channelFuture 对象中不能立刻获得到正确的 Channel 对象，需要等待</li>
<li>连接未建立 channel 打印为 <code>[id: 0x2e1884dd]</code>；建立成功打印为 <code>[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 1. 连接服务器，【异步非阻塞】，main 调用 connect 方法，真正执行连接的是 nio 线程</span></span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="comment">// 2.1 使用 sync 方法【同步】处理结果，阻塞当前线程，直到 nio 线程连接建立完毕</span></span><br><span class="line">        channelFuture.sync();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">        System.out.println(channel); <span class="comment">// 【打印】</span></span><br><span class="line">        <span class="comment">// 向服务器发送数据</span></span><br><span class="line">        channel.writeAndFlush(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        </span><br><span class="line">**************************************************************************************二选一</span><br><span class="line">        <span class="comment">// 2.2 使用 addListener 方法【异步】处理结果</span></span><br><span class="line">        channelFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// nio 线程连接建立好以后，回调该方法</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> future.channel();</span><br><span class="line">                	channel.writeAndFlush(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 建立失败，需要关闭</span></span><br><span class="line">                    future.channel().close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="关闭操作"><a href="#关闭操作" class="headerlink" title="关闭操作"></a>关闭操作</h4><p>关闭 EventLoopGroup 的运行，分为同步关闭和异步关闭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloseFutureClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                <span class="comment">// ....</span></span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.sync().channel();</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (line.equals(<span class="string">&quot;q&quot;</span>)) &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.writeAndFlush(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;input&quot;</span>).start();</span><br><span class="line">        <span class="comment">// 获取 CloseFuture 对象</span></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">closeFuture</span> <span class="operator">=</span> channel.closeFuture();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 同步处理关闭</span></span><br><span class="line">        System.out.println(<span class="string">&quot;waiting close...&quot;</span>);</span><br><span class="line">        closeFuture.sync();</span><br><span class="line">        System.out.println(<span class="string">&quot;处理关闭后的操作&quot;</span>);</span><br><span class="line">****************************************************</span><br><span class="line">        <span class="comment">// 2. 异步处理关闭</span></span><br><span class="line">        closeFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;处理关闭后的操作&quot;</span>);</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Netty 中的 Future 与 JDK 中的 Future 同名，但是功能的实现不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.util.concurrent;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">java</span>.util.concurrent.Future&lt;V&gt;</span><br></pre></td></tr></table></figure>

<p>Future 类 API：</p>
<ul>
<li><code>V get()</code>：阻塞等待获取任务执行结果</li>
<li><code>V getNow()</code>：非阻塞获取任务结果，还未产生结果时返回 null</li>
<li><code>Throwable cause()</code>：非阻塞获取失败信息，如果没有失败，返回 null</li>
<li><code>Future&lt;V&gt; sync()</code>：等待任务结束，如果任务失败，抛出异常</li>
<li><code>boolean cancel(boolean mayInterruptIfRunning)</code>：取消任务</li>
<li><code>Future&lt;V&gt; addListener(GenericFutureListener listener)</code>：添加回调，异步接收结果</li>
<li><code>boolean isSuccess()</code>：判断任务是否成功</li>
<li><code>boolean isCancellable()</code>：判断任务是否取消</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyFutureDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> group.next();</span><br><span class="line">        Future&lt;Integer&gt; future = eventLoop.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行计算&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">70</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        future.getNow();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;等待结果&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;&quot;</span> + future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="扩展子类"><a href="#扩展子类" class="headerlink" title="扩展子类"></a>扩展子类</h4><p>Promise 类是 Future 的子类，可以脱离任务独立存在，作为两个线程间传递结果的容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Promise</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Future</span>&lt;V&gt;</span><br></pre></td></tr></table></figure>

<p>Promise 类 API：</p>
<ul>
<li><code>Promise&lt;V&gt; setSuccess(V result)</code>：设置成功结果</li>
<li><code>Promise&lt;V&gt; setFailure(Throwable cause)</code>：设置失败结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyPromiseDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 准备 EventLoop 对象</span></span><br><span class="line">        <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>().next();</span><br><span class="line">        <span class="comment">// 2. 主动创建 promise</span></span><br><span class="line">        DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventLoop);</span><br><span class="line">        <span class="comment">// 3. 任意一个线程执行计算，计算完毕后向 promise 填充结果</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            promise.setSuccess(<span class="number">200</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 接受结果的线程</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;等待结果&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;&quot;</span> + promise.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>ChannelHandler 用来处理 Channel 上的各种事件，分为入站出站两种，所有 ChannelHandler 连接成双向链表就是 Pipeline</p>
<ul>
<li>入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果</li>
<li>出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工（入站和出站是对于服务端来说的）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">        .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">// 1. 通过 channel 拿到 pipeline</span></span><br><span class="line">                <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                <span class="comment">// 2. 添加处理器 head -&gt; h1 -&gt; h2 -&gt; h3 -&gt; h4 -&gt; tail</span></span><br><span class="line">                pipeline.addLast(<span class="string">&quot;h1&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> buf.toString(Charset.defaultCharset());</span><br><span class="line">                        <span class="comment">// 将数据传递给下一个【入站】handler，如果不调用该方法则链会断开</span></span><br><span class="line">                        <span class="built_in">super</span>.channelRead(ctx, s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                pipeline.addLast(<span class="string">&quot;h2&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                        <span class="comment">// 从【尾部开始向前触发】出站处理器</span></span><br><span class="line">                        ch.writeAndFlush(ctx.alloc().buffer().writeBytes(<span class="string">&quot;server&quot;</span>.getBytes()));</span><br><span class="line">                        <span class="comment">// 该方法会让管道从【当前 handler 向前】寻找出站处理器</span></span><br><span class="line">                        <span class="comment">// ctx.writeAndFlush();</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                pipeline.addLast(<span class="string">&quot;h3&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">                        <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                pipeline.addLast(<span class="string">&quot;h4&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">                        <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端依次打印：1 2 4 3 ，所以<strong>入站是按照 addLast 的顺序执行的，出站是按照 addLast 的逆序执行</strong></p>
<p>一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中关联着一个 ChannelHandler</p>
<p>入站事件和出站事件在一个双向链表中，两种类型的 handler 互不干扰：</p>
<ul>
<li>入站事件会从链表 head 往后传递到最后一个入站的 handler</li>
<li>出站事件会从链表 tail 往前传递到最前一个出站的 handler</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-ChannelPipeline.png"></p>
<hr>
<h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>ByteBuf 是对字节数据的封装，优点：</p>
<ul>
<li>池化，可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li>
<li>读写指针分离，不需要像 ByteBuffer 一样切换读写模式</li>
<li>可以自动扩容</li>
<li>支持链式调用，使用更流畅</li>
<li>零拷贝思想，例如 slice、duplicate、CompositeByteBuf</li>
</ul>
<hr>
<h4 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h4><p>创建方式</p>
<ul>
<li><code>ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(10)</code>：创建了一个默认的 ByteBuf，初始容量是 10</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ByteBuf <span class="title function_">buffer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (directByDefault) &#123;</span><br><span class="line">        <span class="keyword">return</span> directBuffer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heapBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(10)</code>：创建池化基于堆的 ByteBuf</p>
</li>
<li><p><code>ByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(10)</code>：创建池化基于直接内存的 ByteBuf</p>
</li>
<li><p><strong>推荐</strong>的创建方式：在添加处理器的方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>直接内存对比堆内存：</p>
<ul>
<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li>
<li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li>
</ul>
<p>池化的意义在于可以<strong>重用 ByteBuf</strong>，高并发时池化功能更节约内存，减少内存溢出的可能，与非池化对比：</p>
<ul>
<li>非池化，每次都要创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，堆内存会增加 GC 压力</li>
<li>池化，可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li>
</ul>
<p>池化功能的开启，可以通过下面的系统环境变量来设置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;	 <span class="comment"># VM 参数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现</li>
<li>4.1 之前，池化功能还不成熟，默认是非池化实现</li>
</ul>
<hr>
<h4 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h4><p>ByteBuf 由四部分组成，最开始读写指针（<strong>双指针</strong>）都在 0 位置</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-ByteBuf%E7%BB%84%E6%88%90.png"></p>
<p>写入方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>writeBoolean(boolean value)</td>
<td>写入 boolean 值</td>
<td>用一字节 01|00 代表 true|false</td>
</tr>
<tr>
<td>writeByte(int value)</td>
<td>写入 byte 值</td>
<td></td>
</tr>
<tr>
<td>writeInt(int value)</td>
<td>写入 int 值</td>
<td>Big Endian，即 0x250，写入后 00 00 02 50</td>
</tr>
<tr>
<td>writeIntLE(int value)</td>
<td>写入 int 值</td>
<td>Little Endian，即 0x250，写入后 50 02 00 00</td>
</tr>
<tr>
<td>writeBytes(ByteBuf src)</td>
<td>写入 ByteBuf</td>
<td></td>
</tr>
<tr>
<td>writeBytes(byte[] src)</td>
<td>写入 byte[]</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuffer src)</td>
<td>写入 NIO 的 ByteBuffer</td>
<td></td>
</tr>
<tr>
<td>int writeCharSequence(CharSequence s, Charset c)</td>
<td>写入字符串</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用</li>
<li>写入几位写指针后移几位，指向可以写入的位置</li>
<li>网络传输，默认习惯是 Big Endian</li>
</ul>
<p>扩容：写入数据时，容量不够了（初始容量是 10），这时会引发<strong>扩容</strong></p>
<ul>
<li>如果写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16</li>
<li>如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10 &#x3D; 1024（2^9&#x3D;512 不够）</li>
<li>扩容不能超过 max capacity 会报错</li>
</ul>
<p>读取方法：</p>
<ul>
<li><code>byte readByte()</code>：读取一个字节，读指针后移</li>
<li><code>byte getByte(int index)</code>：读取指定索引位置的字节，读指针不动</li>
<li><code>ByteBuf markReaderIndex()</code>：标记读数据的位置</li>
<li><code>ByteBuf resetReaderIndex()</code>：重置到标记位置，可以重复读取标记位置向后的数据</li>
</ul>
<hr>
<h4 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h4><p>Netty 中三种内存的回收：</p>
<ul>
<li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存</li>
<li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li>
<li>PooledByteBuf 和子类使用了池化机制，需要更复杂的规则来回收内存</li>
</ul>
<p>Netty 采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口，回收的规则：</p>
<ul>
<li>每个 ByteBuf 对象的初始计数为 1</li>
<li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li>
<li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li>
<li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> .ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 逻辑处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    buf.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pipeline 的存在，需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性，处理规则：</p>
<ul>
<li><p>创建 ByteBuf 放入 Pipeline</p>
</li>
<li><p>入站 ByteBuf 处理原则</p>
<ul>
<li><p>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release，反之不传递需要</p>
</li>
<li><p>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，此时必须 release</p>
</li>
<li><p>如果出现异常，ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</p>
</li>
<li><p>假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.debug();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// io.netty.util.ReferenceCountUtil#release(java.lang.Object)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ReferenceCounted) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ReferenceCounted) msg).release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>出站 ByteBuf 处理原则</p>
<ul>
<li>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</li>
</ul>
</li>
<li><p>不确定 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</p>
</li>
</ul>
<hr>
<h4 id="拷贝操作"><a href="#拷贝操作" class="headerlink" title="拷贝操作"></a>拷贝操作</h4><p>零拷贝方法：</p>
<ul>
<li><p><code>ByteBuf slice(int index, int length)</code>：对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，<strong>共用原始 ByteBuf 的内存</strong>，切片后的 ByteBuf 维护独立的 read，write 指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">    buf.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;);</span><br><span class="line">    <span class="comment">// 在切片过程中并没有发生数据复制</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">f1</span> <span class="operator">=</span> buf.slice(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    f1.retain();</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">f2</span> <span class="operator">=</span> buf.slice(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    f2.retain();</span><br><span class="line">    <span class="comment">// 对 f1 进行相关的操作也会体现在 buf 上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ByteBuf duplicate()</code>：截取原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的</p>
</li>
<li><p><code>CompositeByteBuf addComponents(boolean increaseWriterIndex, ByteBuf... buffers)</code>：合并多个 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">    buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">    buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">CompositeByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line">    <span class="comment">// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0</span></span><br><span class="line">    buf.addComponents(<span class="literal">true</span>, buf1, buf2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CompositeByteBuf 是一个组合的 ByteBuf，内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据</p>
<ul>
<li>优点：对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li>
<li>缺点：复杂了很多，多次操作会带来性能的损耗</li>
</ul>
</li>
</ul>
<p>深拷贝：</p>
<ul>
<li><code>ByteBuf copy()</code>：将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关</li>
</ul>
<p>池化相关：</p>
<ul>
<li><p>Unpooled 是一个工具类，提供了非池化的 ByteBuf 创建、组合、复制等操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf，零拷贝思想</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.wrappedBuffer(buf1, buf2);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="粘包半包"><a href="#粘包半包" class="headerlink" title="粘包半包"></a>粘包半包</h2><h3 id="现象演示"><a href="#现象演示" class="headerlink" title="现象演示"></a>现象演示</h3><p>在 TCP 传输中，客户端发送消息时，实际上是将数据写入 TCP 的缓存，此时数据的大小和缓存的大小就会造成粘包和半包</p>
<ul>
<li><p>当数据超过 TCP 缓存容量时，就会被拆分成多个包，通过 Socket 多次发送到服务端，服务端每次从缓存中取数据，产生半包问题</p>
</li>
<li><p>当数据小于 TCP 缓存容量时，缓存中可以存放多个包，客户端和服务端一次通信就可能传递多个包，这时候服务端就可能一次读取多个包，产生粘包的问题</p>
</li>
</ul>
<p>代码演示：</p>
<ul>
<li><p>客户端代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        send();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="comment">// 【在连接 channel 建立成功后，会触发 active 方法】</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 发送内容随机的数据包</span></span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span>];</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; r.nextInt(<span class="number">9</span>) + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                                    bytes[j] = (<span class="type">byte</span>) c;</span><br><span class="line">                                &#125;</span><br><span class="line">                                c++;</span><br><span class="line">                                buf.writeBytes(bytes);</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buf);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            <span class="comment">// 调整系统的接受缓冲区【滑动窗口】</span></span><br><span class="line">            <span class="comment">//serverBootstrap.option(ChannelOption.SO_RCVBUF, 10);</span></span><br><span class="line">            <span class="comment">// 调整 netty 的接受缓冲区（ByteBuf）</span></span><br><span class="line">            <span class="comment">//serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, </span></span><br><span class="line">            <span class="comment">//                            new AdaptiveRecvByteBufAllocator(16, 16, 16));</span></span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="comment">// 【这里可以添加解码器】</span></span><br><span class="line">                    <span class="comment">// LoggingHandler 用来打印消息</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">            channelFuture.sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">            log.debug(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>粘包效果展示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">09:<span class="number">57</span>:<span class="number">27.140</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler - [id: <span class="number">0xddbaaef6</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8701</span>] READ: 100B	<span class="comment">// 读了 100 字节，发生粘包</span></span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">31</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> |<span class="number">00000.</span>...<span class="number">.1</span>.....|</span><br><span class="line">|<span class="number">00000010</span>| <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">32</span> <span class="number">32</span> <span class="number">32</span> <span class="number">32</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">33</span> <span class="number">00</span> |...<span class="number">.2222</span>.....<span class="number">.3</span>.|</span><br><span class="line">|<span class="number">00000020</span>| <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">34</span> <span class="number">34</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> |.......<span class="number">.44</span>......|</span><br><span class="line">|<span class="number">00000030</span>| <span class="number">00</span> <span class="number">00</span> <span class="number">35</span> <span class="number">35</span> <span class="number">35</span> <span class="number">35</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">36</span> <span class="number">36</span> <span class="number">36</span> <span class="number">00</span> |.<span class="number">.5555</span>.....<span class="number">.666</span>.|</span><br><span class="line">|<span class="number">00000040</span>| <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">37</span> <span class="number">37</span> <span class="number">37</span> <span class="number">37</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> |.....<span class="number">.7777</span>......|</span><br><span class="line">|<span class="number">00000050</span>| <span class="number">38</span> <span class="number">38</span> <span class="number">38</span> <span class="number">38</span> <span class="number">38</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">39</span> <span class="number">39</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> |<span class="number">88888.</span>...<span class="number">.99</span>....|</span><br><span class="line">|<span class="number">00000060</span>| <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure></li>
</ul>
<p>解决方法：通过调整系统的接受缓冲区的滑动窗口和 Netty 的接受缓冲区保证每条包只含有一条数据，滑动窗口的大小仅决定了 Netty 读取的<strong>最小单位</strong>，实际每次读取的一般是它的整数倍</p>
<hr>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h4><p>发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点就是效率很低</p>
<p>客户端代码改造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 分 10 次发送</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="固定长度"><a href="#固定长度" class="headerlink" title="固定长度"></a>固定长度</h4><p>服务器端加入定长解码器，每一条消息采用固定长度。如果是半包消息，会缓存半包消息并等待下个包到达之后进行拼包合并，直到读取一个完整的消息包；如果是粘包消息，空余的位置会进行补 0，会浪费空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">10</span>));</span><br><span class="line">        <span class="comment">// LoggingHandler 用来打印消息</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">29</span>:<span class="number">06.522</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler - [id: <span class="number">0x38a70fbf</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10144</span>] READ: 10B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">31</span> <span class="number">31</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   |<span class="number">11.</span>.......      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:<span class="number">29</span>:<span class="number">06.522</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler - [id: <span class="number">0x38a70fbf</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10144</span>] READ: 10B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">32</span> <span class="number">32</span> <span class="number">32</span> <span class="number">32</span> <span class="number">32</span> <span class="number">32</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   |<span class="number">222222.</span>...      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h4><p>服务端加入行解码器，默认以 <code>\n</code> 或 <code>\r\n</code> 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">8</span>));</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>客户端在每条消息之后，加入 <code>\n</code> 分隔符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= r.nextInt(<span class="number">16</span>)+<span class="number">1</span>; j++) &#123;</span><br><span class="line">            buffer.writeByte((<span class="type">byte</span>) c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 10 代表 &#x27;\n&#x27;</span></span><br><span class="line">        buffer.writeByte(<span class="number">10</span>);</span><br><span class="line">        c++;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.writeAndFlush(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="预设长度"><a href="#预设长度" class="headerlink" title="预设长度"></a>预设长度</h4><p>LengthFieldBasedFrameDecoder 解码器自定义长度解决 TCP 粘包黏包问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> maxFrameLength		<span class="comment">// 数据最大长度</span></span><br><span class="line"><span class="type">int</span> lengthFieldOffset 	<span class="comment">// 长度字段偏移量，从第几个字节开始是内容的长度字段</span></span><br><span class="line"><span class="type">int</span> lengthFieldLength	<span class="comment">// 长度字段本身的长度</span></span><br><span class="line"><span class="type">int</span> lengthAdjustment 	<span class="comment">// 长度字段为基准，几个字节后才是内容</span></span><br><span class="line"><span class="type">int</span> initialBytesToStrip	<span class="comment">// 从头开始剥离几个字节解码后显示</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lengthFieldOffset   = <span class="number">1</span> (= the length of HDR1)</span><br><span class="line">lengthFieldLength   = <span class="number">2</span></span><br><span class="line">lengthAdjustment    = <span class="number">1</span> (= the length of HDR2)</span><br><span class="line">initialBytesToStrip = <span class="number">3</span> (= the length of HDR1 + LEN)</span><br><span class="line"></span><br><span class="line">BEFORE <span class="title function_">DECODE</span> <span class="params">(<span class="number">16</span> bytes)</span>                       AFTER <span class="title function_">DECODE</span> <span class="params">(<span class="number">13</span> bytes)</span><span class="comment">//解码</span></span><br><span class="line">+------+--------+------+----------------+      +------+----------------+</span><br><span class="line">| HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content |</span><br><span class="line">| <span class="number">0xCA</span> | <span class="number">0x000C</span> | <span class="number">0xFE</span> | <span class="string">&quot;HELLO, WORLD&quot;</span> |      | <span class="number">0xFE</span> | <span class="string">&quot;HELLO, WORLD&quot;</span> |</span><br><span class="line">+------+--------+------+----------------+      +------+----------------+</span><br></pre></td></tr></table></figure>

<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LengthFieldDecoderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(</span><br><span class="line">                <span class="comment">// int 占 4 字节，版本号一个字节</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>,<span class="number">5</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 个字节的内容长度， 实际内容</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        send(buffer, <span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">        send(buffer, <span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出缓存</span></span><br><span class="line">        channel.writeInbound(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(ByteBuf buffer, String content)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = content.getBytes();  <span class="comment">// 实际内容</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> bytes.length;          <span class="comment">// 实际内容长度</span></span><br><span class="line">        buffer.writeInt(length);</span><br><span class="line">        buffer.writeByte(<span class="number">1</span>);                <span class="comment">// 表示版本号</span></span><br><span class="line">        buffer.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">49</span>:<span class="number">59.344</span> [main] DEBUG io.netty.handler.logging.LoggingHandler - [id: 0xembedded, L:embedded - R:embedded] READ: 12B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">48</span> <span class="number">65</span> 6c 6c <span class="number">6f</span> 2c <span class="number">20</span> <span class="number">77</span> <span class="number">6f</span> <span class="number">72</span> 6c <span class="number">64</span>             |Hello, world    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:<span class="number">49</span>:<span class="number">59.344</span> [main] DEBUG io.netty.handler.logging.LoggingHandler - [id: 0xembedded, L:embedded - R:embedded] READ: 3B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">48</span> <span class="number">69</span> <span class="number">21</span>                                        |Hi!             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>访问 URL：<a href="http://localhost:8080/">http://localhost:8080/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">                    <span class="comment">// 只针对某一种类型的请求处理，此处针对 HttpRequest</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;HttpRequest&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpRequest msg)</span> &#123;</span><br><span class="line">                            <span class="comment">// 获取请求</span></span><br><span class="line">                            log.debug(msg.uri());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 返回响应</span></span><br><span class="line">                            <span class="type">DefaultFullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(</span><br><span class="line">                                msg.protocolVersion(), HttpResponseStatus.OK);</span><br><span class="line"></span><br><span class="line">                            <span class="type">byte</span>[] bytes = <span class="string">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>.getBytes();</span><br><span class="line"></span><br><span class="line">                            response.headers().setInt(CONTENT_LENGTH, bytes.length);</span><br><span class="line">                            response.content().writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 写回响应</span></span><br><span class="line">                            ctx.writeAndFlush(response);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;n3.server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>处理器代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodec</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageCodec</span>&lt;Message&gt; &#123;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充, 1 字节</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 获取内容的字节数组，msg 对象序列化</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(), <span class="keyword">new</span> <span class="title class_">MessageCodec</span>());</span><br><span class="line">    <span class="comment">// encode</span></span><br><span class="line">    <span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    channel.writeOutbound(message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// decode</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MessageCodec</span>().encode(<span class="literal">null</span>, message, buf);</span><br><span class="line">    <span class="comment">// 入站</span></span><br><span class="line">    channel.writeInbound(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginRequestMessage</span> <span class="keyword">extends</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// set + get </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE.png"></p>
<hr>
<h4 id="Sharable"><a href="#Sharable" class="headerlink" title="Sharable"></a>Sharable</h4><p>@Sharable 注解的添加时机：</p>
<ul>
<li><p>当 handler 不保存状态时，就可以安全地在多线程下被共享</p>
</li>
<li><p>对于编解码器类不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler，它们的构造方法对 @Sharable 有限制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">ByteToMessageCodec</span><span class="params">(<span class="type">boolean</span> preferDirect)</span> &#123;</span><br><span class="line">    ensureNotSharable();</span><br><span class="line">    outboundMsgMatcher = TypeParameterMatcher.find(<span class="built_in">this</span>, ByteToMessageCodec.class, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">    encoder = <span class="keyword">new</span> <span class="title class_">Encoder</span>(preferDirect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">ensureNotSharable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果类上有该注解</span></span><br><span class="line">    <span class="keyword">if</span> (isSharable()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果能确保编解码器不会保存状态，可以继承 MessageToMessageCodec 父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="comment">// 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodecSharable</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">out</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        <span class="comment">// 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">		<span class="comment">// ....</span></span><br><span class="line">        outList.add(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="场景优化"><a href="#场景优化" class="headerlink" title="场景优化"></a>场景优化</h2><h3 id="空闲检测"><a href="#空闲检测" class="headerlink" title="空闲检测"></a>空闲检测</h3><h4 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h4><p>连接假死就是客户端数据发不出去，服务端也一直收不到数据，保持这种状态，假死的连接占用的资源不能自动释放，而且向假死连接发送数据，得到的反馈是发送超时</p>
<p>解决方案：每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死</p>
<p>IdleStateHandler 是 Netty 提供的处理空闲状态的处理器，用来判断是不是读空闲时间或写空闲时间过长</p>
<ul>
<li>参数一 long readerIdleTime：读空闲，表示多长时间没有读</li>
<li>参数二 long writerIdleTime：写空闲，表示多长时间没有写</li>
<li>参数三 long allIdleTime：读写空闲，表示多长时间没有读写</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">MessageCodec</span>());</span><br><span class="line">        <span class="comment">// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件，</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// ChannelDuplexHandler 【可以同时作为入站和出站】处理器</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelDuplexHandler</span>() &#123;</span><br><span class="line">            <span class="comment">// 用来触发特殊事件</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">                <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">                <span class="comment">// 触发了读空闲事件</span></span><br><span class="line">                <span class="keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;已经 5s 没有读到数据了&quot;</span>);</span><br><span class="line">                    ctx.channel().close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h4><p>客户端定时向服务器端发送数据，<strong>时间间隔要小于服务器定义的空闲检测的时间间隔</strong>，就能防止误判连接假死，这就是心跳机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">MessageCodec</span>());</span><br><span class="line">        <span class="comment">// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelDuplexHandler</span>() &#123;</span><br><span class="line">            <span class="comment">// 用来触发特殊事件</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">                <span class="comment">// 触发了写空闲事件</span></span><br><span class="line">                <span class="keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                    <span class="comment">// 3s 没有写数据了，【发送一个心跳包】</span></span><br><span class="line">                    ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">PingMessage</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="普通方式"><a href="#普通方式" class="headerlink" title="普通方式"></a>普通方式</h4><p>序列化，反序列化主要用在消息正文的转换上</p>
<ul>
<li>序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）</li>
<li>反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理</li>
</ul>
<p>代码实现：</p>
<ul>
<li><p>抽象一个 Serializer 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">    <span class="comment">// 反序列化方法</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span>;</span><br><span class="line">    <span class="comment">// 序列化方法</span></span><br><span class="line">    &lt;T&gt; <span class="type">byte</span>[] serialize(T object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供两个实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SerializerAlgorithm</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">	<span class="comment">// Java 实现</span></span><br><span class="line">    Java &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">                <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> in.readObject();</span><br><span class="line">                <span class="keyword">return</span> (T) object;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;SerializerAlgorithm.Java 反序列化错误&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out).writeObject(object);</span><br><span class="line">                <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;SerializerAlgorithm.Java 序列化错误&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// Json 实现(引入了 Gson 依赖)</span></span><br><span class="line">    Json &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, StandardCharsets.UTF_8), clazz);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(object).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要从协议的字节中得到是哪种序列化算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SerializerAlgorithm <span class="title function_">getByInt</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        SerializerAlgorithm[] array = SerializerAlgorithm.values();</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span> || type &gt; array.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;超过 SerializerAlgorithm 范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[type];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="ProtoBuf"><a href="#ProtoBuf" class="headerlink" title="ProtoBuf"></a>ProtoBuf</h4><h5 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>Codec（编解码器）的组成部分有两个：Decoder（解码器）和 Encoder（编码器）。Encoder 负责把业务数据转换成字节码数据，Decoder 负责把字节码数据转换成业务数据</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-编码解码.png" style="zoom: 67%;">



<p>Protobuf 是 Google 发布的开源项目，全称  Google Protocol Buffers ，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。很适合做数据存储或 RPC（远程过程调用 remote procedure call）数据交换格式。目前很多公司从 HTTP + Json 转向 TCP + Protobuf ，效率会更高</p>
<p>Protobuf 是以 message 的方式来管理数据，支持跨平台、跨语言（客户端和服务器端可以是不同的语言编写的），高性能、高可靠性</p>
<p>工作过程：使用 Protobuf 编译器自动生成代码，Protobuf 是将类的定义使用 .proto 文件进行描述，然后通过 protoc.exe 编译器根据  .proto 自动生成 .java 文件</p>
<hr>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><ul>
<li><p>单个 message：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; 								<span class="comment">// 版本</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;StudentPOJO&quot;</span>;	<span class="comment">// 生成的外部类名，同时也是文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Student</span> &#123; 	<span class="comment">// 在 StudentPOJO 外部类种生成一个内部类 Student，是真正发送的 POJO 对象</span></span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>; 	<span class="comment">// Student 类中有一个属性：名字为 id 类型为 int32(protobuf类型) ，1表示属性序号，不是值</span></span><br><span class="line">    <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-Protobuf编译文件.png" style="zoom:80%;">

<p>编译 <code>protoc.exe --java_out=.Student.proto</code>（cmd 窗口输入） 将生成的 StudentPOJO 放入到项目使用</p>
<p>Server 端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>() <span class="comment">//...</span></span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;	<span class="comment">// 创建一个通道初始化对象</span></span><br><span class="line">        <span class="comment">// 给pipeline 设置处理器</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 在pipeline加入ProtoBufDecoder，指定对哪种对象进行解码</span></span><br><span class="line">            ch.pipeline().addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">ProtobufDecoder</span>(</span><br><span class="line">                							StudentPOJO.Student.getDefaultInstance()));</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyServerHandler</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client 端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>().group(group) 			<span class="comment">// 设置线程组</span></span><br><span class="line">    .channel(NioSocketChannel.class) 	<span class="comment">// 设置客户端通道的实现类(反射)</span></span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 在pipeline中加入 ProtoBufEncoder</span></span><br><span class="line">            ch.pipeline().addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">ProtobufEncoder</span>());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>()); <span class="comment">// 加入自定义的业务处理器</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个 message：Protobuf 可以使用 message 管理其他的 message。假设某个项目需要传输 20 个对象，可以在一个文件里定义 20 个 message，最后再用一个总的 message 来决定在实际传输时真正需要传输哪一个对象</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> optimize_for = SPEED; 					<span class="comment">// 加快解析</span></span><br><span class="line"><span class="keyword">option</span> java_package=<span class="string">&quot;com.atguigu.netty.codec2&quot;</span>;	<span class="comment">// 指定生成到哪个包下</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname=<span class="string">&quot;MyDataInfo&quot;</span>; 		<span class="comment">// 外部类名, 文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">MyMessage</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个枚举类型，DataType 如果是 0 则表示一个 Student 对象实例，DataType 这个名称自定义</span></span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">DataType</span> &#123;</span><br><span class="line">        StudentType = <span class="number">0</span>; <span class="comment">//在 proto3 要求 enum 的编号从 0 开始</span></span><br><span class="line">        WorkerType = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 data_type 来标识传的是哪一个枚举类型，这里才真正开始定义 Message 的数据类型</span></span><br><span class="line">    DataType data_type = <span class="number">1</span>;  <span class="comment">// 所有后面的数字都只是编号而已</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// oneof 关键字，表示每次枚举类型进行传输时，限制最多只能传输一个对象。</span></span><br><span class="line">    <span class="comment">// dataBody名称也是自定义的</span></span><br><span class="line">    <span class="comment">// MyMessage 里出现的类型只有两个 DataType 类型，Student 或者 Worker 类型，在真正传输的时候只会有一个出现</span></span><br><span class="line">    <span class="keyword">oneof</span> dataBody &#123;</span><br><span class="line">        Student student = <span class="number">2</span>;  <span class="comment">//注意这后面的数字也都只是编号而已，上面DataType data_type = 1  占了第一个序号了</span></span><br><span class="line">        Worker worker = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;		<span class="comment">// Student类的属性</span></span><br><span class="line">    <span class="type">string</span> name = <span class="number">2</span>; 	<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="type">string</span> name=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int32</span> age=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<p>Server 端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">ProtobufDecoder</span>(MyDataInfo.MyMessage.getDefaultInstance()));</span><br></pre></td></tr></table></figure>

<p>Client 端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">ProtobufEncoder</span>());</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>HTTP 协议是无状态的，浏览器和服务器间的请求响应一次，下一次会重新创建连接。实现基于 WebSocket 的长连接的全双工的交互，改变 HTTP 协议多次请求的约束</p>
<p>开发需求：</p>
<ul>
<li>实现长连接，服务器与浏览器相互通信客户端</li>
<li>浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</li>
</ul>
<p>代码实现：</p>
<ul>
<li><p>WebSocket：</p>
<ul>
<li><p>WebSocket 的数据是<strong>以帧（frame）形式传递</strong>，WebSocketFrame 下面有六个子类，代表不同的帧格式</p>
</li>
<li><p>浏览器请求 URL：ws:&#x2F;&#x2F;localhost:8080&#x2F;xxx</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebSocket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建两个线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup);</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO));</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 基于 http 协议，使用 http 的编码和解码器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">                    <span class="comment">// 是以块方式写，添加 ChunkedWriteHandler 处理器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ChunkedWriteHandler</span>());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// http 数据在传输过程中是分段, HttpObjectAggregator 就是可以将多个段聚合</span></span><br><span class="line">                    <span class="comment">//  这就就是为什么，当浏览器发送大量数据时，就会发出多次 http 请求</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">8192</span>));</span><br><span class="line">        </span><br><span class="line">                    <span class="comment">// WebSocketServerProtocolHandler 核心功能是【将 http 协议升级为 ws 协议】，保持长连接</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">WebSocketServerProtocolHandler</span>(<span class="string">&quot;/hello&quot;</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 自定义的handler ，处理业务逻辑</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyTextWebSocketFrameHandler</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动服务器</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTextWebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;TextWebSocketFrame&gt; &#123;</span><br><span class="line">    <span class="comment">// TextWebSocketFrame 类型，表示一个文本帧(frame)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器收到消息 &quot;</span> + msg.text());</span><br><span class="line">        <span class="comment">// 回复消息</span></span><br><span class="line">        ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(<span class="string">&quot;服务器时间&quot;</span> + LocalDateTime.now() + <span class="string">&quot; &quot;</span> + msg.text()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当web客户端连接后， 触发方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// id 表示唯一的值，LongText 是唯一的 ShortText 不是唯一</span></span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asShortText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerRemoved 被调用&quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常发生 &quot;</span> + cause.getMessage());</span><br><span class="line">        ctx.close(); <span class="comment">// 关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTML：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> socket;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 判断当前浏览器是否支持websocket</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">WebSocket</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//go on</span></span></span><br><span class="line"><span class="language-javascript">        socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:8080/hello&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//相当于channelReado, ev 收到服务器端回送的消息</span></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> rt = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            rt.<span class="property">value</span> = rt.<span class="property">value</span> + <span class="string">&quot;\n&quot;</span> + ev.<span class="property">data</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//相当于连接开启(感知到连接开启)</span></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> rt = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            rt.<span class="property">value</span> = <span class="string">&quot;连接开启了..&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//相当于连接关闭(感知到连接关闭)</span></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="property">onclose</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> rt = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            rt.<span class="property">value</span> = rt.<span class="property">value</span> + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;连接关闭了..&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;当前浏览器不支持websocket&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 发送消息到服务器</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">send</span>(<span class="params">message</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 先判断socket是否创建好</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(!<span class="variable language_">window</span>.<span class="property">socket</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(socket.<span class="property">readyState</span> == <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 通过socket 发送消息</span></span></span><br><span class="line"><span class="language-javascript">            socket.<span class="title function_">send</span>(message)</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;连接没有开启&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 300px; width: 300px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;发生消息&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;send(this.form.message.value)&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;responseText&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 300px; width: 300px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;清空内容&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h3><h4 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h4><p>参数配置方式：</p>
<ul>
<li>客户端通过 .option() 方法配置参数，给 SocketChannel 配置参数</li>
<li>服务器端：<ul>
<li>new ServerBootstrap().option()： 给 ServerSocketChannel 配置参数</li>
<li>new ServerBootstrap().childOption()：给 SocketChannel 配置参数</li>
</ul>
</li>
</ul>
<p>CONNECT_TIMEOUT_MILLIS 参数：</p>
<ul>
<li><p>属于 SocketChannal 参数</p>
</li>
<li><p>在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常</p>
</li>
<li><p>SO_TIMEOUT 主要用在阻塞 IO，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，可以调整超时时间</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionTimeoutTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>());</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">            future.sync().channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.debug(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="SO-BACKLOG"><a href="#SO-BACKLOG" class="headerlink" title="SO_BACKLOG"></a>SO_BACKLOG</h4><p>属于 ServerSocketChannal 参数，通过 <code>option(ChannelOption.SO_BACKLOG, value)</code> 来设置大小</p>
<p>在 Linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制</p>
<ul>
<li>sync queue：半连接队列，大小通过 <code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code> 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制</li>
<li>accept queue：全连接队列，大小通过 <code>/proc/sys/net/core/somaxconn</code> 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值。如果 accpet queue 队列满了，server 将<strong>发送一个拒绝连接的错误信息</strong>到 client</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p>
<hr>
<h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4><p>ALLOCATOR：属于 SocketChannal 参数，用来分配 ByteBuf， ctx.alloc()</p>
<p>RCVBUF_ALLOCATOR：属于 SocketChannal 参数</p>
<ul>
<li>控制 Netty 接收缓冲区大小</li>
<li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定</li>
</ul>
<hr>
<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是一种先进先出的数据结构，常见的应用场景：</p>
<ul>
<li><p>应用解耦：系统的耦合性越高，容错性就越低</p>
<p>实例：用户创建订单后，耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障都会造成下单异常，影响用户使用体验。使用消息队列解耦合，比如物流系统发生故障，需要几分钟恢复，将物流系统要处理的数据缓存到消息队列中，用户的下单操作正常完成。等待物流系统正常后处理存在消息队列中的订单消息即可，终端系统感知不到物流系统发生过几分钟故障</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E8%A7%A3%E8%80%A6.png"></p>
</li>
<li><p>流量削峰：应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮，使用消息队列可以将大量请求缓存起来，分散到很长一段时间处理，这样可以提高系统的稳定性和用户体验</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0.png"></p>
</li>
<li><p>数据分发：让数据在多个系统更加之间进行流通，数据的产生方不需要关心谁来使用数据，只需要将数据发送到消息队列，数据使用方直接在消息队列中直接获取数据</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E6%95%B0%E6%8D%AE%E5%88%86%E5%8F%91.png"></p>
</li>
</ul>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1L4411y7mn">https://www.bilibili.com/video/BV1L4411y7mn</a></p>
<hr>
<h3 id="安装测试"><a href="#安装测试" class="headerlink" title="安装测试"></a>安装测试</h3><p>安装需要 Java 环境，下载解压后进入安装目录，进行启动：</p>
<ul>
<li><p>启动 NameServer</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.启动 NameServer</span></span><br><span class="line"><span class="built_in">nohup</span> sh bin/mqnamesrv &amp;</span><br><span class="line"><span class="comment"># 2.查看启动日志</span></span><br><span class="line"><span class="built_in">tail</span> -f ~/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure>

<p>RocketMQ 默认的虚拟机内存较大，需要编辑如下两个配置文件，修改 JVM 内存大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑runbroker.sh和runserver.sh修改默认JVM大小</span></span><br><span class="line">vi runbroker.sh</span><br><span class="line">vi runserver.sh</span><br></pre></td></tr></table></figure>

<p>参考配置：JAVA_OPT&#x3D;”${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize&#x3D;128m  -XX:MaxMetaspaceSize&#x3D;320m”</p>
</li>
<li><p>启动 Broker</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.启动 Broker</span></span><br><span class="line"><span class="built_in">nohup</span> sh bin/mqbroker -n localhost:9876 autoCreateTopicEnable=<span class="literal">true</span> &amp;</span><br><span class="line"><span class="comment"># 2.查看启动日志</span></span><br><span class="line"><span class="built_in">tail</span> -f ~/logs/rocketmqlogs/broker.log </span><br></pre></td></tr></table></figure>
</li>
<li><p>发送消息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.设置环境变量</span></span><br><span class="line"><span class="built_in">export</span> NAMESRV_ADDR=localhost:9876</span><br><span class="line"><span class="comment"># 2.使用安装包的 Demo 发送消息</span></span><br><span class="line">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure>
</li>
<li><p>接受消息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">  <span class="comment"># 1.设置环境变量</span></span><br><span class="line">  <span class="built_in">export</span> NAMESRV_ADDR=localhost:9876</span><br><span class="line">  <span class="comment"># 2.接收消息</span></span><br><span class="line">  sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br><span class="line"></span><br><span class="line">* 关闭 RocketMQ：</span><br><span class="line"></span><br><span class="line">  ```sh</span><br><span class="line">  <span class="comment"># 1.关闭 NameServer</span></span><br><span class="line">  sh bin/mqshutdown namesrv</span><br><span class="line">  <span class="comment"># 2.关闭 Broker</span></span><br><span class="line">  sh bin/mqshutdown broker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 相关概念</span></span><br><span class="line"></span><br><span class="line">RocketMQ 主要由 Producer、Broker、Consumer 三部分组成，其中 Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息，NameServer 负责管理 Broker</span><br><span class="line"></span><br><span class="line">* 代理服务器（Broker Server）：消息中转角色，负责**存储消息、转发消息**。在 RocketMQ 系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备，也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等</span><br><span class="line">* 名字服务（Name Server）：充当**路由消息**的提供者。生产者或消费者能够通过名字服务查找各主题相应的 Broker IP 列表</span><br><span class="line">* 消息生产者（Producer）：负责**生产消息**，把业务应用系统里产生的消息发送到 Broker 服务器。RocketMQ 提供多种发送方式，同步发送、异步发送、顺序发送、单向发送，同步和异步方式均需要 Broker 返回确认信息，单向发送不需要；可以通过 MQ 的负载均衡模块选择相应的 Broker 集群队列进行消息投递，投递的过程支持快速失败并且低延迟</span><br><span class="line">* 消息消费者（Consumer）：负责**消费消息**，一般是后台系统负责异步消费，一个消息消费者会从 Broker 服务器拉取消息、并将其提供给应用程序。从用户应用的角度而提供了两种消费形式：</span><br><span class="line">  * 拉取式消费（Pull Consumer）：应用通主动调用 Consumer 的拉消息方法从 Broker 服务器拉消息，主动权由应用控制，一旦获取了批量消息，应用就会启动消费过程</span><br><span class="line">  * 推动式消费（Push Consumer）：该模式下 Broker 收到数据后会主动推送给消费端，实时性较高</span><br><span class="line">* 生产者组（Producer Group）：同一类 Producer 的集合，发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，**则 Broker 服务器会联系同一生产者组的其他生产者实例以提交或回溯消费**</span><br><span class="line">* 消费者组（Consumer Group）：同一类 Consumer 的集合，消费者实例必须订阅完全相同的 Topic，消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面更容易的实现负载均衡和容错。RocketMQ 支持两种消息模式：</span><br><span class="line">  *  集群消费（Clustering）：相同 Consumer Group 的每个 Consumer 实例平均分摊消息</span><br><span class="line">  *  广播消费（Broadcasting）：相同 Consumer Group 的每个 Consumer 实例都接收全量的消息</span><br><span class="line"></span><br><span class="line">每个 Broker 可以存储多个 Topic 的消息，每个 Topic 的消息也可以分片存储于不同的 Broker，Message Queue（消息队列）是用于存储消息的物理地址，每个 Topic 中的消息地址存储于多个 Message Queue 中</span><br><span class="line"></span><br><span class="line">* 主题（Topic）：表示一类消息的集合，每个主题包含若干条消息，每条消息只属于一个主题，是 RocketMQ 消息订阅的基本单位</span><br><span class="line"></span><br><span class="line">* 消息（Message）：消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ 中每个消息拥有唯一的 Message ID，且可以携带具有业务标识的 Key，系统提供了通过 Message ID 和 Key 查询消息的功能</span><br><span class="line"></span><br><span class="line">* 标签（Tag）：为消息设置的标志，用于同一主题下区分不同类型的消息。标签能够有效地保持代码的清晰度和连贯性，并优化 RocketMQ 提供的查询系统，消费者可以根据 Tag 实现对不同子主题的不同消费逻辑，实现更好的扩展性</span><br><span class="line"></span><br><span class="line">* 普通顺序消息（Normal Ordered Message）：消费者通过同一个消息队列（Topic 分区）收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的</span><br><span class="line"></span><br><span class="line">* 严格顺序消息（Strictly Ordered Message）：消费者收到的所有消息均是有顺序的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">官方文档：https://github.com/apache/rocketmq/tree/master/docs/cn（基础知识部分的笔记参考官方文档编写）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">****</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 消息操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 基本样例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 订阅发布</span></span><br><span class="line"></span><br><span class="line">消息的发布是指某个生产者向某个 Topic 发送消息，消息的订阅是指某个消费者关注了某个 Topic 中带有某些 Tag 的消息，进而从该 Topic 消费数据</span><br><span class="line"></span><br><span class="line">导入 MQ 客户端依赖：</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>消息发送者步骤分析：</p>
<ol>
<li>创建消息生产者 Producer，并制定生产者组名</li>
<li>指定 Nameserver 地址</li>
<li>启动 Producer</li>
<li>创建消息对象，指定主题 Topic、Tag 和消息体</li>
<li>发送消息</li>
<li>关闭生产者 Producer</li>
</ol>
<p>消息消费者步骤分析：</p>
<ol>
<li>创建消费者 Consumer，制定消费者组名</li>
<li>指定 Nameserver 地址</li>
<li>订阅主题 Topic 和 Tag</li>
<li>设置回调函数，处理消息</li>
<li>启动消费者 Consumer</li>
</ol>
<p>官方文档：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md">https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md</a></p>
<hr>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><h5 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h5><p>使用 RocketMQ 发送三种类型的消息：同步消息、异步消息和单向消息，其中前两种消息是可靠的，因为会有发送是否成功的应答</p>
<p>这种可靠性同步地发送方式使用的比较广泛，比如：重要的消息通知，短信通知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncProducer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    	<span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">    	producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    	<span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    	    <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">    	    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(</span><br><span class="line">                <span class="string">&quot;TopicTest&quot;</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">&quot;TagA&quot;</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">        		(<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span>);</span><br><span class="line">            </span><br><span class="line">        	<span class="comment">// 发送消息到一个Broker</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line">            <span class="comment">// 通过sendResult返回消息是否成功送达</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    	producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h5><p>异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待 Broker 的响应</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncProducer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    	<span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    	<span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">        <span class="type">int</span> <span class="variable">messageCount</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">		<span class="comment">// 根据消息数量实例化倒计时计算器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch2</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch2</span>(messageCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; messageCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;OrderID188&quot;</span>,</span><br><span class="line">                                      <span class="string">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// SendCallback接收异步返回结果的回调</span></span><br><span class="line">            producer.send(msg, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">                <span class="comment">// 发送成功回调函数</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%-10d OK %s %n&quot;</span>, index, sendResult.getMsgId());</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%-10d Exception %s %n&quot;</span>, index, e);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待5s</span></span><br><span class="line">        countDownLatch.await(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="单向发送"><a href="#单向发送" class="headerlink" title="单向发送"></a>单向发送</h5><p>单向发送主要用在不特别关心发送结果的场景，例如日志发送</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnewayProducer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    	<span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    	<span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        	<span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">        	<span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest&quot;</span>,<span class="string">&quot;TagA&quot;</span>,</span><br><span class="line">                          (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">        	<span class="comment">// 发送单向消息，没有任何返回结果</span></span><br><span class="line">        	producer.sendOneway(msg);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    	producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException &#123;</span><br><span class="line">    	<span class="comment">// 实例化消费者</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 订阅一个或者多个Topic，以及Tag来过滤需要消费的消息</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    	<span class="comment">// 注册消息监听器，回调实现类来处理从broker拉取回来的消息</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="comment">// 接受消息内容</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="comment">// 标记该消息已经被成功消费</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动消费者实例</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><h4 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h4><p>消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了三条消息分别是订单创建、订单付款、订单完成。消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的，RocketMQ 可以严格的保证消息有序。</p>
<p>顺序消息分为全局顺序消息与分区顺序消息，</p>
<ul>
<li>全局顺序：对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费，适用于性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景</li>
<li>分区顺序：对于指定的一个 Topic，所有消息根据 Sharding key 进行分区，同一个分组内的消息按照严格的 FIFO 顺序进行发布和消费。Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念，适用于性能要求高的场景</li>
</ul>
<p>在默认的情况下消息发送会采取 Round Robin 轮询方式把消息发送到不同的 queue（分区队列），而消费消息是从多个 queue 上拉取消息，这种情况发送和消费是不能保证顺序。但是如果控制发送的顺序消息只依次发送到同一个 queue 中，消费的时候只从这个 queue 上依次拉取，则就保证了顺序。当<strong>发送和消费参与的 queue 只有一个</strong>，则是全局有序；如果多个queue 参与，则为分区有序，即相对每个 queue，消息都是有序的</p>
<hr>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>一个订单的顺序流程是：创建、付款、推送、完成，订单号相同的消息会被先后发送到同一个队列中，消费时同一个 OrderId 获取到的肯定是同一个队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">		<span class="comment">// 标签集合</span></span><br><span class="line">        String[] tags = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;TagC&quot;</span>, <span class="string">&quot;TagD&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订单列表</span></span><br><span class="line">        List&lt;OrderStep&gt; orderList = <span class="keyword">new</span> <span class="title class_">Producer</span>().buildOrders();</span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 加个时间前缀</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> dateStr + <span class="string">&quot; Hello RocketMQ &quot;</span> + orderList.get(i);</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;OrderTopic&quot;</span>, tags[i % tags.length], <span class="string">&quot;KEY&quot;</span> + i, body.getBytes());</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数一：消息对象</span></span><br><span class="line"><span class="comment">             * 参数二：消息队列的选择器</span></span><br><span class="line"><span class="comment">             * 参数三：选择队列的业务标识（订单 ID）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg, <span class="keyword">new</span> <span class="title class_">MessageQueueSelector</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * mqs：队列集合</span></span><br><span class="line"><span class="comment">                 * msg：消息对象</span></span><br><span class="line"><span class="comment">                 * arg：业务标识的参数</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">public</span> MessageQueue <span class="title function_">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> &#123;</span><br><span class="line">                    <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> (Long) arg;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">index</span> <span class="operator">=</span> id % mqs.size(); <span class="comment">// 根据订单id选择发送queue</span></span><br><span class="line">                    <span class="keyword">return</span> mqs.get((<span class="type">int</span>) index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, orderList.get(i).getOrderId());<span class="comment">//订单id</span></span><br><span class="line"></span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;SendResult status:%s, queueId:%d, body:%s&quot;</span>,</span><br><span class="line">                    sendResult.getSendStatus(),</span><br><span class="line">                    sendResult.getMessageQueue().getQueueId(),</span><br><span class="line">                    body));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订单的步骤</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OrderStep</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> orderId;</span><br><span class="line">        <span class="keyword">private</span> String desc;</span><br><span class="line">        <span class="comment">// set + get</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成模拟订单数据</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderStep&gt; <span class="title function_">buildOrders</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;OrderStep&gt; orderList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OrderStep&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">OrderStep</span> <span class="variable">orderDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103111065L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;付款&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103117235L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103111065L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;付款&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103117235L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;付款&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103111065L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;推送&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103117235L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> orderList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序消息消费，带事务方式（应用可控制Offset什么时候提交）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerInOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;please_rename_unique_group_name_3&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费</span></span><br><span class="line">        <span class="comment">// 如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">		<span class="comment">// 订阅三个tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;OrderTopic&quot;</span>, <span class="string">&quot;TagA || TagC || TagD&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;</span><br><span class="line">                context.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="comment">// 可以看到每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;consumeThread=&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;queueId=&quot;</span> + msg.getQueueId() + <span class="string">&quot;, content:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h3><h4 id="原理解析-1"><a href="#原理解析-1" class="headerlink" title="原理解析"></a>原理解析</h4><p>定时消息（延迟队列）是指消息发送到 Broker 后，不会立即被消费，等待特定时间投递给真正的 Topic</p>
<p>RocketMQ 并不支持任意时间的延时，需要设置几个固定的延时等级，从 1s 到 2h 分别对应着等级 1 到 18，消息消费失败会进入延时消息队列，消息发送时间与设置的延时等级和重试次数有关，详见代码 <code>SendMessageProcessor.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">messageDelayLevel</span> <span class="operator">=</span> <span class="string">&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Broker 可以配置 messageDelayLevel，该属性是 Broker 的属性，不属于某个 Topic</p>
<p>发消息时，可以设置延迟等级 <code>msg.setDelayLevel(level)</code>，level 有以下三种情况：</p>
<ul>
<li>level &#x3D;&#x3D; 0：消息为非延迟消息</li>
<li>1&lt;&#x3D;level&lt;&#x3D;maxLevel：消息延迟特定时间，例如 level&#x3D;&#x3D;1，延迟 1s</li>
<li>level &gt; maxLevel：则 level&#x3D;&#x3D; maxLevel，例如 level&#x3D;&#x3D;20，延迟 2h</li>
</ul>
<p>定时消息会暂存在名为 SCHEDULE_TOPIC_XXXX 的 Topic 中，并根据 delayTimeLevel 存入特定的 queue，队列的标识 <code>queueId = delayTimeLevel – 1</code>，即<strong>一个 queue 只存相同延迟的消息</strong>，保证具有相同发送延迟的消息能够顺序消费。Broker 会为每个延迟级别提交一个定时任务，调度地消费 SCHEDULE_TOPIC_XXXX，将消息写入真实的 Topic</p>
<p>注意：定时消息在第一次写入和调度写入真实 Topic 时都会计数，因此发送数量、tps 都会变高</p>
<hr>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>提交了一个订单就可以发送一个延时消息，1h 后去检查这个订单的状态，如果还是未付款就取消订单释放库存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledMessageProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 实例化一个生产者来产生延时消息</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;ExampleProducerGroup&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalMessagesToSend</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;DelayTopic&quot;</span>, (<span class="string">&quot;Hello scheduled message &quot;</span> + i).getBytes());</span><br><span class="line">            <span class="comment">// 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)</span></span><br><span class="line">            message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            producer.send(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭生产者</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledMessageConsumer</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="comment">// 实例化消费者</span></span><br><span class="line">      <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;ExampleConsumer&quot;</span>);</span><br><span class="line">      consumer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">      <span class="comment">// 订阅Topics</span></span><br><span class="line">      consumer.subscribe(<span class="string">&quot;DelayTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">      <span class="comment">// 注册消息监听者</span></span><br><span class="line">      consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; messages, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">              <span class="keyword">for</span> (MessageExt message : messages) &#123;</span><br><span class="line">                  <span class="comment">// 打印延迟的时间段</span></span><br><span class="line">                  System.out.println(<span class="string">&quot;Receive message[msgId=&quot;</span> + message.getMsgId() + <span class="string">&quot;] &quot;</span> + (System.currentTimeMillis() - message.getBornTimestamp()) + <span class="string">&quot;ms later&quot;</span>);&#125;</span><br><span class="line">              <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 启动消费者</span></span><br><span class="line">      consumer.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h3><p>批量发送消息能显著提高传递小消息的性能，限制是这些批量消息应该有相同的 topic，相同的 waitStoreMsgOK，而且不能是延时消息，并且这一批消息的总大小不应超过 4MB</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;ExampleProducerGroup&quot;</span>)</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//启动producer</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        List&lt;Message&gt; msgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Message&gt;();</span><br><span class="line">        <span class="comment">// 创建消息对象，指定主题Topic、Tag和消息体</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;BatchTopic&quot;</span>, <span class="string">&quot;Tag1&quot;</span>, (<span class="string">&quot;Hello World&quot;</span> + <span class="number">1</span>).getBytes());</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;BatchTopic&quot;</span>, <span class="string">&quot;Tag1&quot;</span>, (<span class="string">&quot;Hello World&quot;</span> + <span class="number">2</span>).getBytes());</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;BatchTopic&quot;</span>, <span class="string">&quot;Tag1&quot;</span>, (<span class="string">&quot;Hello World&quot;</span> + <span class="number">3</span>).getBytes());</span><br><span class="line"></span><br><span class="line">        msgs.add(msg1);</span><br><span class="line">        msgs.add(msg2);</span><br><span class="line">        msgs.add(msg3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">result</span> <span class="operator">=</span> producer.send(msgs);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送结果:&quot;</span> + result);</span><br><span class="line">        <span class="comment">// 关闭生产者producer</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发送大批量数据时，可能不确定消息是否超过了大小限制（4MB），所以需要将消息列表分割一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListSplitter</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;List&lt;Message&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE_LIMIT</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Message&gt; messages;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> currIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListSplitter</span><span class="params">(List&lt;Message&gt; messages)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messages = messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currIndex &lt; messages.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Message&gt; <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> getStartIndex();</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextIndex</span> <span class="operator">=</span> startIndex;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messages.get(nextIndex);</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmpSize</span> <span class="operator">=</span> calcMessageSize(message);</span><br><span class="line">            <span class="comment">// 单个消息超过了最大的限制</span></span><br><span class="line">            <span class="keyword">if</span> (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                totalSize += tmpSize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Message&gt; subList = messages.subList(startIndex, nextIndex);</span><br><span class="line">        currIndex = nextIndex;</span><br><span class="line">        <span class="keyword">return</span> subList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getStartIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">currMessage</span> <span class="operator">=</span> messages.get(currIndex);</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmpSize</span> <span class="operator">=</span> calcMessageSize(currMessage);</span><br><span class="line">        <span class="keyword">while</span> (tmpSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">            currIndex += <span class="number">1</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messages.get(curIndex);</span><br><span class="line">            tmpSize = calcMessageSize(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcMessageSize</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmpSize</span> <span class="operator">=</span> message.getTopic().length() + message.getBody().length;</span><br><span class="line">        Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">            tmpSize += entry.getKey().length() + entry.getValue().length();</span><br><span class="line">        &#125;</span><br><span class="line">        tmpSize = tmpSize + <span class="number">20</span>; <span class="comment">// 增加⽇日志的开销20字节</span></span><br><span class="line">        <span class="keyword">return</span> tmpSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//把大的消息分裂成若干个小的消息</span></span><br><span class="line">        <span class="type">ListSplitter</span> <span class="variable">splitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListSplitter</span>(messages);</span><br><span class="line">        <span class="keyword">while</span> (splitter.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;Message&gt; listItem = splitter.next();</span><br><span class="line">                producer.send(listItem);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">//处理error</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="过滤消息"><a href="#过滤消息" class="headerlink" title="过滤消息"></a>过滤消息</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>RocketMQ 定义了一些基本语法来支持过滤特性，可以很容易地扩展：</p>
<ul>
<li>数值比较，比如：&gt;，&gt;&#x3D;，&lt;，&lt;&#x3D;，BETWEEN，&#x3D;</li>
<li>字符比较，比如：&#x3D;，&lt;&gt;，IN</li>
<li>IS NULL 或者 IS NOT NULL</li>
<li>逻辑符号 AND，OR，NOT</li>
</ul>
<p>常量支持类型为：</p>
<ul>
<li>数值，比如 123，3.1415</li>
<li>字符，比如 ‘abc’，必须用单引号包裹起来</li>
<li>NULL，特殊的常量</li>
<li>布尔值，TRUE 或 FALSE</li>
</ul>
<p>只有使用 push 模式的消费者才能用使用 SQL92 标准的 sql 语句，接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> MessageSelector messageSelector)</span></span><br></pre></td></tr></table></figure>

<p>例如：消费者接收包含 TAGA 或 TAGB 或 TAGC 的消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;CID_EXAMPLE&quot;</span>);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;TOPIC&quot;</span>, <span class="string">&quot;TAGA || TAGB || TAGC&quot;</span>);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="原理解析-2"><a href="#原理解析-2" class="headerlink" title="原理解析"></a>原理解析</h4><p>RocketMQ 分布式消息队列的消息过滤方式是在 Consumer 端订阅消息时再做消息过滤的，所以是在 Broker 端实现的，优点是减少了对于 Consumer 无用消息的网络传输，缺点是增加了 Broker 的负担，而且实现相对复杂</p>
<p>RocketMQ 在 Producer 端写入消息和在 Consumer 端订阅消息采用<strong>分离存储</strong>的机制实现，Consumer 端订阅消息是需要通过 ConsumeQueue 这个消息消费的逻辑队列拿到一个索引，然后再从 CommitLog 里面读取真正的消息实体内容</p>
<p>ConsumeQueue 的存储结构如下，有 8 个字节存储的 Message Tag 的哈希值，基于 Tag 的消息过滤就是基于这个字段</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E6%B6%88%E8%B4%B9%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84.png"></p>
<ul>
<li><p>Tag 过滤：Consumer 端订阅消息时指定 Topic 和 TAG，然后将订阅请求构建成一个 SubscriptionData，发送一个 Pull 消息的请求给 Broker 端。Broker 端用这些数据先构建一个 MessageFilter，然后传给文件存储层 Store。Store 从 ConsumeQueue 读取到一条记录后，会用它记录的消息 tag hash 值去做过滤。因为在服务端只是根据 hashcode 进行判断，无法精确对 tag 原始字符串进行过滤，所以消费端拉取到消息后，还需要对消息的原始 tag 字符串进行比对，如果不同，则丢弃该消息，不进行消息消费</p>
</li>
<li><p>SQL92 过滤：工作流程和 Tag 过滤大致一样，只是在 Store 层的具体过滤方式不一样。真正的 SQL expression 的构建和执行由 rocketmq-filter 模块负责，每次过滤都去执行 SQL 表达式会影响效率，所以 RocketMQ 使用了 BloomFilter 来避免了每次都去执行</p>
</li>
</ul>
<hr>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>发送消息时，通过 putUserProperty 来设置消息的属性，SQL92 的表达式上下文为消息的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;FilterTopic&quot;</span>, <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">               (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            <span class="comment">// 设置一些属性</span></span><br><span class="line">            msg.putUserProperty(<span class="string">&quot;i&quot;</span>, String.valueOf(i));</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 SQL 筛选过滤消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 过滤属性大于 5  的消息</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;FilterTopic&quot;</span>, MessageSelector.bySql(<span class="string">&quot;i&gt;5&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置回调函数，处理消息</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="comment">//接受消息内容</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;consumeThread=&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;,&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动消费者consumer</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>RocketMQ 支持分布式事务消息，采用了 2PC 的思想来实现了提交事务消息，同时增加一个<strong>补偿逻辑</strong>来处理二阶段超时或者失败的消息，如下图所示：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.png"></p>
<p>事务消息的大致方案分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程</p>
<ol>
<li><p>事务消息发送及提交：</p>
<ul>
<li><p>发送消息（Half 消息），服务器将消息的主题和队列改为半消息状态，并放入半消息队列</p>
</li>
<li><p>服务端响应消息写入结果（如果写入失败，此时 Half 消息对业务不可见）</p>
</li>
<li><p>根据发送结果执行本地事务</p>
</li>
<li><p>根据本地事务状态执行 Commit 或者 Rollback</p>
</li>
</ul>
</li>
</ol>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E4%BA%8B%E5%8A%A1%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p>
<ol start="2">
<li><p>补偿机制：用于解决消息 Commit 或者 Rollback 发生超时或者失败的情况，比如出现网络问题</p>
<ul>
<li>Broker 服务端通过<strong>对比 Half 消息和 Op 消息</strong>，对未确定状态的消息推进 CheckPoint</li>
<li>没有 Commit&#x2F;Rollback 的事务消息，服务端根据根据半消息的生产者组，到 ProducerManager 中获取生产者（同一个 Group 的 Producer）的会话通道，发起一次回查（<strong>单向请求</strong>）</li>
<li>Producer 收到回查消息，检查事务消息状态表内对应的本地事务的状态</li>
<li>根据本地事务状态，重新 Commit 或者 Rollback</li>
</ul>
<p>RocketMQ 并不会无休止的进行事务状态回查，最大回查 15 次，如果 15 次回查还是无法得知事务状态，则默认回滚该消息，</p>
<p>回查服务：<code>TransactionalMessageCheckService#run</code></p>
</li>
</ol>
<hr>
<h4 id="两阶段"><a href="#两阶段" class="headerlink" title="两阶段"></a>两阶段</h4><h5 id="一阶段"><a href="#一阶段" class="headerlink" title="一阶段"></a>一阶段</h5><p>事务消息相对普通消息最大的特点就是<strong>一阶段发送的消息对用户是不可见的</strong>，因为对于 Half 消息，会备份原消息的主题与消息消费队列，然后改变主题为 RMQ_SYS_TRANS_HALF_TOPIC，由于消费组未订阅该主题，故消费端无法消费 Half 类型的消息</p>
<p>RocketMQ 会开启一个<strong>定时任务</strong>，从 Topic 为 RMQ_SYS_TRANS_HALF_TOPIC 中拉取消息进行消费，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息</p>
<p>RocketMQ 的具体实现策略：如果写入的是事务消息，对消息的 Topic 和 Queue 等属性进行替换，同时将原来的 Topic 和 Queue 信息存储到<strong>消息的属性</strong>中，因为消息的主题被替换，所以消息不会转发到该原主题的消息消费队列，消费者无法感知消息的存在，不会消费</p>
<hr>
<h5 id="二阶段"><a href="#二阶段" class="headerlink" title="二阶段"></a>二阶段</h5><p>一阶段写入不可见的消息后，二阶段操作：</p>
<ul>
<li><p>如果执行 Commit 操作，则需要让消息对用户可见，构建出 Half 消息的索引。一阶段的 Half 消息写到一个特殊的 Topic，构建索引时需要读取出 Half 消息，然后通过一次普通消息的写入操作将 Topic 和 Queue 替换成真正的目标 Topic 和 Queue，生成一条对用户可见的消息。其实就是利用了一阶段存储的消息的内容，在二阶段时恢复出一条完整的普通消息，然后走一遍消息写入流程</p>
</li>
<li><p>如果是 Rollback 则需要撤销一阶段的消息，因为消息本就不可见，所以并<strong>不需要真正撤销消息</strong>（实际上 RocketMQ 也无法去删除一条消息，因为是顺序写文件的）。RocketMQ 为了区分这条消息没有确定状态的消息，采用 Op 消息标识已经确定状态的事务消息（Commit 或者 Rollback）</p>
</li>
</ul>
<p><strong>事务消息无论是 Commit 或者 Rollback 都会记录一个 Op 操作</strong>，两者的区别是 Commit 相对于 Rollback 在写入 Op 消息前将原消息的主题和队列恢复。如果一条事务消息没有对应的 Op 消息，说明这个事务的状态还无法确定（可能是二阶段失败了）</p>
<p>RocketMQ 将 Op 消息写入到全局一个特定的 Topic 中，通过源码中的方法 <code>TransactionalMessageUtil.buildOpTopic()</code>，这个主题是一个内部的 Topic（像 Half 消息的 Topic 一样），不会被用户消费。Op 消息的内容为对应的 Half 消息的存储的 Offset，这样<strong>通过 Op  消息能索引到 Half 消息</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-OP%E6%B6%88%E6%81%AF.png"></p>
<hr>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><p>事务消息共有三种状态，提交状态、回滚状态、中间状态：</p>
<ul>
<li>TransactionStatus.CommitTransaction：提交事务，允许消费者消费此消息。</li>
<li>TransactionStatus.RollbackTransaction：回滚事务，代表该消息将被删除，不允许被消费</li>
<li>TransactionStatus.Unknown：中间状态，代表需要检查消息队列来确定状态</li>
</ul>
<p>使用限制：</p>
<ol>
<li>事务消息不支持延时消息和批量消息</li>
<li>Broker 配置文件中的参数 <code>transactionTimeout</code> 为特定时间，事务消息将在特定时间长度之后被检查。当发送事务消息时，还可以通过设置用户属性 <code>CHECK_IMMUNITY_TIME_IN_SECONDS</code> 来改变这个限制，该参数优先于 <code>transactionTimeout</code> 参数</li>
<li>为了避免单个消息被检查太多次而导致半队列消息累积，默认将单个消息的检查次数限制为 15 次，开发者可以通过 Broker 配置文件的 <code>transactionCheckMax</code> 参数来修改此限制。如果已经检查某条消息超过 N 次（N &#x3D; <code>transactionCheckMax</code>）， 则 Broker 将丢弃此消息，在默认情况下会打印错误日志。可以通过重写 <code>AbstractTransactionalMessageCheckListener</code> 类来修改这个行为</li>
<li>事务性消息可能不止一次被检查或消费</li>
<li>提交给用户的目标主题消息可能会失败，可以查看日志的记录。事务的高可用性通过 RocketMQ 本身的高可用性机制来保证，如果希望事务消息不丢失、并且事务完整性得到保证，可以使用同步的双重写入机制</li>
<li>事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享。与其他类型的消息不同，事务消息允许反向查询，MQ 服务器能通过消息的生产者 ID 查询到消费者</li>
</ol>
<hr>
<h5 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h5><p>实现事务的监听接口，当发送半消息成功时：</p>
<ul>
<li><code>executeLocalTransaction</code> 方法来执行本地事务，返回三个事务状态之一</li>
<li><code>checkLocalTransaction</code> 方法检查本地事务状态，响应消息队列的检查请求，返回三个事务状态之一</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">TransactionListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">transactionIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Integer&gt; localTrans = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> transactionIndex.getAndIncrement();</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> value % <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 将事务ID和状态存入 map 集合</span></span><br><span class="line">        localTrans.put(msg.getTransactionId(), status);</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 从 map 集合读出当前事务对应的状态</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> localTrans.get(msg.getTransactionId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != status) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <strong>TransactionMQProducer</strong> 类创建事务性生产者，并指定唯一的 <code>ProducerGroup</code>，就可以设置自定义线程池来处理这些检查请求，执行本地事务后，需要根据执行结果对消息队列进行回复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建消息生产者</span></span><br><span class="line">       	<span class="type">TransactionMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">       	<span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">100</span>, TimeUnit.SECONDS);</span><br><span class="line">        producer.setExecutorService(executorService);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建事务监听器</span></span><br><span class="line">		<span class="type">TransactionListener</span> <span class="variable">transactionListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionListenerImpl</span>();</span><br><span class="line">        <span class="comment">// 生产者的监听器</span></span><br><span class="line">        producer.setTransactionListener(transactionListener);</span><br><span class="line">       	<span class="comment">// 启动生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line">        String[] tags = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;TagB&quot;</span>, <span class="string">&quot;TagC&quot;</span>, <span class="string">&quot;TagD&quot;</span>, <span class="string">&quot;TagE&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TransactionTopic&quot;</span>, tags[i % tags.length], <span class="string">&quot;KEY&quot;</span> + i,</span><br><span class="line">                                (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                <span class="comment">// 发送消息</span></span><br><span class="line">                <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.sendMessageInTransaction(msg, <span class="literal">null</span>);</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       	<span class="comment">//Thread.sleep(1000000);</span></span><br><span class="line">        <span class="comment">//producer.shutdown();暂时不关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码和前面的实例相同的</p>
<hr>
<h2 id="系统特性"><a href="#系统特性" class="headerlink" title="系统特性"></a>系统特性</h2><h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><h4 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h4><p>NameServer 是一个简单的 Topic 路由注册中心，支持 Broker 的动态注册与发现，生产者或消费者能够通过名字服务查找各主题相应的 Broker IP 列表</p>
<p>NameServer 主要包括两个功能：</p>
<ul>
<li>Broker 管理，NameServer 接受 Broker 集群的注册信息，保存下来作为路由信息的基本数据，提供<strong>心跳检测机制</strong>检查 Broker 是否还存活，每 10 秒清除一次两小时没有活跃的 Broker</li>
<li>路由信息管理，每个 NameServer 将保存关于 Broker 集群的整个路由信息和用于客户端查询的队列信息，然后 Producer 和 Conumser 通过 NameServer 就可以知道整个 Broker 集群的路由信息，从而进行消息的投递和消费</li>
</ul>
<p>NameServer 特点：</p>
<ul>
<li>NameServer 通常是集群的方式部署，<strong>各实例间相互不进行信息通讯</strong></li>
<li>Broker 向每一台 NameServer（集群）注册自己的路由信息，所以每个 NameServer 实例上面<strong>都保存一份完整的路由信息</strong></li>
<li>当某个 NameServer 因某种原因下线了，Broker 仍可以向其它 NameServer 同步其路由信息</li>
</ul>
<p>BrokerServer 主要负责消息的存储、投递和查询以及服务高可用保证，在 RocketMQ 系统中接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备，也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等</p>
<p>Broker 包含了以下几个重要子模块：</p>
<ul>
<li><p>Remoting Module：整个 Broker 的实体，负责处理来自 Clients 端的请求</p>
</li>
<li><p>Client Manager：负责管理客户端（Producer&#x2F;Consumer）和维护 Consumer 的 Topic 订阅信息</p>
</li>
<li><p>Store Service：提供方便简单的 API 接口处理消息存储到物理硬盘和查询功能</p>
</li>
<li><p>HA Service：高可用服务，提供 Master Broker 和 Slave Broker 之间的数据同步功能</p>
</li>
<li><p>Index Service：根据特定的 Message key 对投递到 Broker 的消息进行索引服务，以提供消息的快速查询</p>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-Broker%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p>
<hr>
<h4 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h4><p>RocketMQ 的工作流程：</p>
<ul>
<li>启动 NameServer 监听端口，等待 Broker、Producer、Consumer 连上来，相当于一个路由控制中心</li>
<li>Broker 启动，跟<strong>所有的 NameServer 保持长连接</strong>，每隔 30s 时间向 NameServer 上报 Topic 路由信息（心跳包）。心跳包中包含当前 Broker 信息（IP、端口等）以及存储所有 Topic 信息。注册成功后，NameServer 集群中就有 Topic 跟 Broker 的映射关系</li>
<li>收发消息前，先创建 Topic，创建 Topic 时需要指定该 Topic 要存储在哪些 Broker 上，也可以在发送消息时自动创建 Topic</li>
<li>Producer 启动时先跟 NameServer 集群中的<strong>其中一台</strong>建立长连接，并从 NameServer 中获取当前发送的 Topic 存在哪些 Broker 上，同时 Producer 会默认每隔 30s 向 NameServer <strong>定时拉取</strong>一次路由信息</li>
<li>Producer 发送消息时，根据消息的 Topic 从本地缓存的 TopicPublishInfoTable 获取路由信息，如果没有则会从 NameServer 上重新拉取并更新，轮询队列列表并选择一个队列 MessageQueue，然后与队列所在的 Broker 建立长连接，向 Broker 发消息</li>
<li>Consumer 跟 Producer 类似，跟其中一台 NameServer 建立长连接，<strong>定时获取路由信息</strong>，根据当前订阅 Topic 存在哪些 Broker 上，直接跟 Broker 建立连接通道，在完成客户端的负载均衡后，选择其中的某一个或者某几个 MessageQueue 来拉取消息并进行消费</li>
</ul>
<hr>
<h4 id="生产消费"><a href="#生产消费" class="headerlink" title="生产消费"></a>生产消费</h4><p>At least Once：至少一次，指每个消息必须投递一次，Consumer 先 Pull 消息到本地，消费完成后才向服务器返回 ACK，如果没有消费一定不会 ACK 消息</p>
<p>回溯消费：指 Consumer 已经消费成功的消息，由于业务上需求需要重新消费，Broker 在向 Consumer 投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于 Consumer 系统故障，恢复后需要重新消费 1 小时前的数据，RocketMQ 支持按照时间回溯消费，时间维度精确到毫秒</p>
<p>分布式队列因为有高可靠性的要求，所以数据要进行<strong>持久化存储</strong></p>
<ol>
<li>消息生产者发送消息</li>
<li>MQ 收到消息，将消息进行持久化，在存储中新增一条记录</li>
<li>返回 ACK 给生产者</li>
<li>MQ push 消息给对应的消费者，然后等待消费者返回 ACK</li>
<li>如果消息消费者在指定时间内成功返回 ACK，那么 MQ 认为消息消费成功，在存储中删除消息；如果 MQ 在指定时间内没有收到 ACK，则认为消息消费失败，会尝试重新 push 消息，重复执行 4、5、6 步骤</li>
<li>MQ 删除消息</li>
</ol>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E6%B6%88%E6%81%AF%E5%AD%98%E5%8F%96.png"></p>
<hr>
<h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>RocketMQ 中 Broker 负责存储消息转发消息，所以以下的结构是存储在 Broker Server 上的，生产者和消费者与 Broker 进行消息的收发是通过主题对应的 Message Queue 完成，类似于通道</p>
<p>RocketMQ 消息的存储是由 ConsumeQueue 和 CommitLog 配合完成 的，CommitLog 是消息真正的<strong>物理存储</strong>文件，ConsumeQueue 是消息的逻辑队列，类似数据库的<strong>索引节点</strong>，存储的是指向物理存储的地址。<strong>每个 Topic 下的每个 Message Queue 都有一个对应的 ConsumeQueue 文件</strong></p>
<p>每条消息都会有对应的索引信息，Consumer 通过 ConsumeQueue 这个结构来读取消息实体内容</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"></p>
<ul>
<li>CommitLog：消息主体以及元数据的存储主体，存储 Producer 端写入的消息内容，消息内容不是定长的。消息主要是<strong>顺序写入</strong>日志文件，单个文件大小默认 1G，偏移量代表下一次写入的位置，当文件写满了就继续写入下一个文件</li>
<li>ConsumerQueue：消息消费队列，存储消息在 CommitLog 的索引。RocketMQ 消息消费时要遍历 CommitLog 文件，并根据主题 Topic 检索消息，这是非常低效的。引入 ConsumeQueue 作为消费消息的索引，<strong>保存了指定 Topic 下的队列消息在 CommitLog 中的起始物理偏移量 offset</strong>，消息大小 size 和消息 Tag 的 HashCode 值，每个 ConsumeQueue 文件大小约 5.72M</li>
<li>IndexFile：为了消息查询提供了一种通过 Key 或时间区间来查询消息的方法，通过 IndexFile 来查找消息的方法<strong>不影响发送与消费消息的主流程</strong>。IndexFile 的底层存储为在文件系统中实现的 HashMap 结构，故 RocketMQ 的索引文件其底层实现为 <strong>hash 索引</strong></li>
</ul>
<p>RocketMQ 采用的是混合型的存储结构，即为 Broker 单个实例下所有的队列共用一个日志数据文件（CommitLog）来存储。混合型存储结构（多个 Topic 的消息实体内容都存储于一个 CommitLog 中）针对 Producer 和 Consumer 分别采用了<strong>数据和索引部分相分离</strong>的存储结构，Producer 发送消息至 Broker 端，然后 Broker 端使用同步或者异步的方式对消息刷盘持久化，保存至 CommitLog 中。只要消息被持久化至磁盘文件 CommitLog 中，Producer 发送的消息就不会丢失，Consumer 也就肯定有机会去消费这条消息</p>
<p>服务端支持长轮询模式，当消费者无法拉取到消息后，可以等下一次消息拉取，Broker 允许等待 30s 的时间，只要这段时间内有新消息到达，将直接返回给消费端。RocketMQ 的具体做法是，使用 Broker 端的后台服务线程 ReputMessageService 不停地分发请求并异步构建 ConsumeQueue（逻辑消费队列）和 IndexFile（索引文件）数据</p>
<hr>
<h4 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h4><p>操作系统分为用户态和内核态，文件操作、网络操作需要涉及这两种形态的切换，需要进行数据复制。一台服务器把本机磁盘文件的内容发送到客户端，分为两个步骤：</p>
<ul>
<li><p>read：读取本地文件内容</p>
</li>
<li><p>write：将读取的内容通过网络发送出去</p>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C.png"></p>
<p>补充：Prog → NET → I&#x2F;O → 零拷贝部分的笔记详解相关内容</p>
<p>通过使用 mmap 的方式，可以省去向用户态的内存复制，RocketMQ 充分利用<strong>零拷贝技术</strong>，提高消息存盘和网络发送的速度</p>
<p>RocketMQ 通过 MappedByteBuffer 对文件进行读写操作，利用了 NIO 中的 FileChannel 模型将磁盘上的物理文件直接映射到用户态的内存地址中，将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率</p>
<p>MappedByteBuffer 内存映射的方式<strong>限制</strong>一次只能映射 1.5~2G 的文件至用户态的虚拟内存，所以 RocketMQ 默认设置单个 CommitLog 日志数据文件为 1G。RocketMQ 的文件存储使用定长结构来存储，方便一次将整个文件映射至内存</p>
<hr>
<h4 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h4><p>页缓存（PageCache）是 OS 对文件的缓存，每一页的大小通常是 4K，用于加速对文件的读写。因为 OS 将一部分的内存用作 PageCache，所以程序对文件进行顺序读写的速度几乎接近于内存的读写速度</p>
<ul>
<li>对于数据的写入，OS 会先写入至 Cache 内，随后通过异步的方式由 pdflush 内核线程将 Cache 内的数据刷盘至物理磁盘上</li>
<li>对于数据的读取，如果一次读取文件时出现未命中 PageCache 的情况，OS 从物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行<strong>预读取</strong>（局部性原理，最大 128K）</li>
</ul>
<p>在 RocketMQ 中，ConsumeQueue 逻辑消费队列存储的数据较少，并且是顺序读取，在 PageCache 机制的预读取作用下，Consume Queue 文件的读性能几乎接近读内存，即使在有消息堆积情况下也不会影响性能。但是 CommitLog 消息存储的日志数据文件读取内容时会产生较多的随机访问读取，严重影响性能。选择合适的系统 IO 调度算法和固态硬盘，比如设置调度算法为 Deadline，随机读的性能也会有所提升</p>
<hr>
<h4 id="刷盘机制"><a href="#刷盘机制" class="headerlink" title="刷盘机制"></a>刷盘机制</h4><p>两种持久化的方案：</p>
<ul>
<li>关系型数据库 DB：IO 读写性能比较差，如果 DB 出现故障，则 MQ 的消息就无法落盘存储导致线上故障，可靠性不高</li>
<li>文件系统：消息刷盘至所部署虚拟机&#x2F;物理机的文件系统来做持久化，分为异步刷盘和同步刷盘两种模式。消息刷盘为消息存储提供了一种高效率、高可靠性和高性能的数据持久化方式，除非部署 MQ 机器本身或是本地磁盘挂了，一般不会出现无法持久化的问题</li>
</ul>
<p>RocketMQ 采用文件系统的方式，无论同步还是异步刷盘，都使用<strong>顺序 IO</strong>，因为磁盘的顺序读写要比随机读写快很多</p>
<ul>
<li><p>同步刷盘：只有在消息真正持久化至磁盘后 RocketMQ 的 Broker 端才会真正返回给 Producer 端一个成功的 ACK 响应，保障 MQ 消息的可靠性，但是性能上会有较大影响，一般适用于金融业务应用该模式较多</p>
</li>
<li><p>异步刷盘：利用 OS 的 PageCache，只要消息写入内存 PageCache 即可将成功的 ACK 返回给 Producer 端，降低了读写延迟，提高了 MQ 的性能和吞吐量。消息刷盘采用<strong>后台异步线程</strong>提交的方式进行，当内存里的消息量积累到一定程度时，触发写磁盘动作</p>
</li>
</ul>
<p>通过 Broker 配置文件里的 flushDiskType 参数设置采用什么方式，可以配置成 SYNC_FLUSH、ASYNC_FLUSH 中的一个</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E5%88%B7%E7%9B%98%E6%9C%BA%E5%88%B6.png"></p>
<p>官方文档：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md">https://github.com/apache/rocketmq/blob/master/docs/cn/design.md</a></p>
<hr>
<h3 id="集群设计"><a href="#集群设计" class="headerlink" title="集群设计"></a>集群设计</h3><h4 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h4><p>常用的以下几种模式：</p>
<ul>
<li><p>单 Master 模式：这种方式风险较大，一旦 Broker 重启或者宕机，会导致整个服务不可用</p>
</li>
<li><p>多 Master 模式：一个集群无 Slave，全是 Master</p>
<ul>
<li><p>优点：配置简单，单个 Master 宕机或重启维护对应用无影响，在磁盘配置为 RAID10 时，即使机器宕机不可恢复情况下，由于 RAID10 磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高</p>
</li>
<li><p>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响</p>
</li>
</ul>
</li>
<li><p>多 Master 多 Slave 模式（同步）：每个 Master 配置一个 Slave，有多对 Master-Slave，HA 采用<strong>同步双写</strong>方式，即只有主备都写成功，才向应用返回成功</p>
<ul>
<li>优点：数据与服务都无单点故障，Master 宕机情况下，消息无延迟，服务可用性与数据可用性都非常高</li>
<li>缺点：性能比异步复制略低（大约低 10% 左右），发送单个消息的 RT 略高，目前不能实现主节点宕机，备机自动切换为主机</li>
</ul>
</li>
<li><p>多 Master 多 Slave 模式（异步）：HA 采用异步复制的方式，会造成主备有短暂的消息延迟（毫秒级别）</p>
<ul>
<li>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时 Master 宕机后，消费者仍然可以从 Slave 消费，而且此过程对应用透明，不需要人工干预，性能同多 Master 模式几乎一样</li>
<li>缺点：Master 宕机，磁盘损坏情况下会丢失少量消息</li>
</ul>
</li>
</ul>
<hr>
<h4 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h4><p>RocketMQ 网络部署特点：</p>
<ul>
<li><p>NameServer 是一个几乎<strong>无状态节点</strong>，节点之间相互独立，无任何信息同步</p>
</li>
<li><p>Broker 部署相对复杂，Broker 分为 Master 与 Slave，Master 可以部署多个，一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master，Master 与 Slave 的对应关系通过指定相同 BrokerName、不同 BrokerId 来定义，BrokerId 为 0 是 Master，非 0 表示 Slave。<strong>每个 Broker 与 NameServer 集群中的所有节点建立长连接</strong>，定时注册 Topic 信息到所有 NameServer</p>
<p>说明：部署架构上也支持一 Master 多 Slave，但只有 BrokerId&#x3D;1 的从服务器才会参与消息的读负载（读写分离）</p>
</li>
<li><p>Producer 与 NameServer 集群中的其中<strong>一个节点（随机选择）建立长连接</strong>，定期从 NameServer 获取 Topic 路由信息，并向提供 Topic 服务的 Master 建立长连接，且定时向 Master <strong>发送心跳</strong>。Producer 完全无状态，可集群部署</p>
</li>
<li><p>Consumer 与 NameServer 集群中的其中一个节点（随机选择）建立长连接，定期从 NameServer 获取 Topic 路由信息，并向提供  Topic 服务的 Master、Slave 建立长连接，且定时向 Master、Slave 发送心跳</p>
<p>Consumer 既可以从 Master 订阅消息，也可以从 Slave 订阅消息，在向 Master 拉取消息时，Master 服务器会根据拉取偏移量与最大偏移量的距离（判断是否读老消息，产生读 I&#x2F;O），以及从服务器是否可读等因素建议下一次是从 Master 还是 Slave 拉取</p>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84.png"></p>
<p>官方文档：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/architecture.md">https://github.com/apache/rocketmq/blob/master/docs/cn/architecture.md</a></p>
<hr>
<h4 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h4><p>NameServer 节点是无状态的，且各个节点直接的数据是一致的，部分 NameServer 不可用也可以保证 MQ 服务正常运行</p>
<p>BrokerServer 的高可用通过 Master 和 Slave 的配合：</p>
<ul>
<li>Slave 只负责读，当 Master 不可用，对应的 Slave 仍能保证消息被正常消费</li>
<li>配置多组 Master-Slave 组，其他的 Master-Slave 组也会保证消息的正常发送和消费</li>
<li>目前不支持把 Slave 自动转成 Master，需要手动停止 Slave 角色的 Broker，更改配置文件，用新的配置文件启动 Broker</li>
</ul>
<p>生产端的高可用：在创建 Topic 的时候，把 Topic 的<strong>多个 Message Queue 创建在多个 Broker 组</strong>上（相同 Broker 名称，不同 brokerId 的机器），当一个 Broker 组的 Master 不可用后，其他组的 Master 仍然可用，Producer 仍然可以发送消息</p>
<p>消费端的高可用：在 Consumer 的配置文件中，并不需要设置是从 Master Broker 读还是从 Slave 读，当 Master 不可用或者繁忙的时候，Consumer 会被自动切换到从 Slave 读。有了自动切换的机制，当一个 Master 机器出现故障后，Consumer 仍然可以从 Slave 读取消息，不影响 Consumer 程序，达到了消费端的高可用性</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E9%AB%98%E5%8F%AF%E7%94%A8.png"></p>
<hr>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>如果一个 Broker 组有 Master 和 Slave，消息需要从 Master 复制到 Slave 上，有同步和异步两种复制方式：</p>
<ul>
<li><p>同步复制方式：Master 和 Slave 均写成功后才反馈给客户端写成功状态。在同步复制方式下，如果 Master 出故障， Slave 上有全部的备份数据，容易恢复，但是同步复制会增大数据写入延迟，降低系统吞吐量</p>
</li>
<li><p>异步复制方式：只要 Master 写成功，即可反馈给客户端写成功状态，系统拥有较低的延迟和较高的吞吐量，但是如果 Master 出了故障，有些数据因为没有被写入 Slave，有可能会丢失</p>
</li>
</ul>
<p>同步复制和异步复制是通过 Broker 配置文件里的 brokerRole 参数进行设置的，可以设置成 ASYNC_MASTE、RSYNC_MASTER、SLAVE 三个值中的一个</p>
<p>一般把刷盘机制配置成 ASYNC_FLUSH，主从复制为 SYNC_MASTER，这样即使有一台机器出故障，仍然能保证数据不丢</p>
<p>RocketMQ 支持消息的高可靠，影响消息可靠性的几种情况：</p>
<ol>
<li>Broker 非正常关闭</li>
<li>Broker 异常 Crash</li>
<li>OS Crash</li>
<li>机器掉电，但是能立即恢复供电情况</li>
<li>机器无法开机（可能是 CPU、主板、内存等关键设备损坏）</li>
<li>磁盘设备损坏</li>
</ol>
<p>前四种情况都属于硬件资源可立即恢复情况，RocketMQ 在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式）</p>
<p>后两种属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ 在这两种情况下，通过主从异步复制，可保证 99% 的消息不丢，但是仍然会有极少量的消息可能丢失。通过<strong>同步双写技术</strong>可以完全避免单点，但是会影响性能，适合对消息可靠性要求极高的场合，RocketMQ 从 3.0 版本开始支持同步双写</p>
<hr>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h4 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h4><p>RocketMQ 中的负载均衡可以分为 Producer 端发送消息时候的负载均衡和 Consumer 端订阅消息的负载均衡</p>
<p>Producer 端在发送消息时，会先根据 Topic 找到指定的 TopicPublishInfo，在获取了 TopicPublishInfo 路由信息后，RocketMQ 的客户端在默认方式调用 <code>selectOneMessageQueue()</code> 方法从 TopicPublishInfo 中的 messageQueueList 中选择一个队列 MessageQueue 进行发送消息</p>
<p>默认会<strong>轮询所有的 Message Queue 发送</strong>，以让消息平均落在不同的 queue 上，而由于 queue可以散落在不同的 Broker，所以消息就发送到不同的 Broker 下，图中箭头线条上的标号代表顺序，发布方会把第一条消息发送至 Queue 0，然后第二条消息发送至 Queue 1，以此类推：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-producer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png"></p>
<p>容错策略均在 MQFaultStrategy 这个类中定义，有一个 sendLatencyFaultEnable 开关变量：</p>
<ul>
<li>如果开启，会在<strong>随机（只有初始化索引变量时才随机，正常都是递增）递增取模</strong>的基础上，再过滤掉 not available 的 Broker</li>
<li>如果关闭，采用随机递增取模的方式选择一个队列（MessageQueue）来发送消息</li>
</ul>
<p>LatencyFaultTolerance 机制是实现消息发送高可用的核心关键所在，对之前失败的，按一定的时间做退避。例如上次请求的 latency 超过 550Lms，就退避 3000Lms；超过 1000L，就退避 60000L</p>
<hr>
<h4 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h4><p>在 RocketMQ 中，Consumer 端的两种消费模式（Push&#x2F;Pull）都是基于拉模式来获取消息的，而在 Push 模式只是对 Pull 模式的一种封装，其本质实现为消息拉取线程在从服务器拉取到一批消息，提交到消息消费线程池后，又继续向服务器再次尝试拉取消息，如果未拉取到消息，则延迟一下又继续拉取</p>
<p>在两种基于拉模式的消费方式（Push&#x2F;Pull）中，均需要 Consumer 端在知道从 Broker 端的哪一个消息队列中去获取消息，所以在 Consumer 端来做负载均衡，即 Broker 端中多个 MessageQueue 分配给同一个 Consumer Group 中的哪些 Consumer 消费</p>
<ul>
<li><p>广播模式下要求一条消息需要投递到一个消费组下面所有的消费者实例，所以不存在负载均衡，在实现上，Consumer 分配 queue 时，所有 Consumer 都分到所有的 queue。</p>
</li>
<li><p>在集群消费模式下，每条消息只需要投递到订阅这个 Topic 的 Consumer Group 下的一个实例即可，RocketMQ 采用主动拉取的方式拉取并消费消息，在拉取的时候需要明确指定拉取哪一条 Message Queue</p>
</li>
</ul>
<p>集群模式下，每当消费者实例的数量有变更，都会触发一次所有实例的负载均衡，这时候会按照 queue 的数量和实例的数量平均分配 queue 给每个实例。默认的分配算法是 AllocateMessageQueueAveragely：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E5%B9%B3%E5%9D%87%E9%98%9F%E5%88%97%E5%88%86%E9%85%8D.png"></p>
<p>  还有一种平均的算法是 AllocateMessageQueueAveragelyByCircle，以环状轮流均分 queue 的形式：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E5%B9%B3%E5%9D%87%E9%98%9F%E5%88%97%E8%BD%AE%E6%B5%81%E5%88%86%E9%85%8D.png"></p>
<p>集群模式下，<strong>queue 都是只允许分配一个实例</strong>，如果多个实例同时消费一个 queue 的消息，由于拉取哪些消息是 Consumer 主动控制的，会导致同一个消息在不同的实例下被消费多次</p>
<p>通过增加 Consumer 实例去分摊 queue 的消费，可以起到水平扩展的消费能力的作用。而当有实例下线时，会重新触发负载均衡，这时候原来分配到的 queue 将分配到其他实例上继续消费。但是如果 Consumer 实例的数量比 Message Queue 的总数量还多的话，多出来的 Consumer 实例将无法分到 queue，也就无法消费到消息，也就无法起到分摊负载的作用了，所以需要<strong>控制让 queue 的总数量大于等于 Consumer 的数量</strong></p>
<hr>
<h4 id="原理解析-3"><a href="#原理解析-3" class="headerlink" title="原理解析"></a>原理解析</h4><p>在 Consumer 启动后，会通过定时任务不断地向 RocketMQ 集群中的所有 Broker 实例发送心跳包。Broker 端在收到 Consumer 的心跳消息后，会将它维护在 ConsumerManager 的本地缓存变量 consumerTable，同时并将封装后的客户端网络通道信息保存在本地缓存变量 channelInfoTable 中，为 Consumer 端的负载均衡提供可以依据的元数据信息</p>
<p>Consumer 端实现负载均衡的核心类 <strong>RebalanceImpl</strong></p>
<p>在 Consumer 实例的启动流程中的会启动 MQClientInstance 实例，完成负载均衡服务线程 RebalanceService 的启动（<strong>每隔 20s 执行一次</strong>负载均衡），RebalanceService 线程的 run() 方法最终调用的是 RebalanceImpl 类的 rebalanceByTopic() 方法，该方法是实现 Consumer 端负载均衡的核心。rebalanceByTopic() 方法会根据广播模式还是集群模式做不同的逻辑处理。主要看集群模式：</p>
<ul>
<li><p>从 rebalanceImpl 实例的本地缓存变量 topicSubscribeInfoTable 中，获取该 Topic 主题下的消息消费队列集合 mqSet</p>
</li>
<li><p>根据 Topic 和 consumerGroup 为参数调用 <code>mQClientFactory.findConsumerIdList()</code> 方法向 Broker 端发送获取该消费组下消费者 ID 列表的 RPC 通信请求（Broker 端基于前面 Consumer 端上报的心跳包数据而构建的 consumerTable 做出响应返回，业务请求码 <code>GET_CONSUMER_LIST_BY_GROUP</code>）</p>
</li>
<li><p>先对 Topic 下的消息消费队列、消费者 ID 排序，然后用消息队列分配策略算法（默认是消息队列的平均分配算法），计算出待拉取的消息队列。平均分配算法类似于分页的算法，将所有 MessageQueue 排好序类似于记录，将所有消费端 Consumer 排好序类似页数，并求出每一页需要包含的平均 size 和每个页面记录的范围 range，最后遍历整个 range 而计算出当前 Consumer 端应该分配到的记录（这里即为 MessageQueue）</p>
</li>
<li><p>调用 updateProcessQueueTableInRebalance() 方法，先将分配到的消息队列集合 mqSet 与 processQueueTable 做一个过滤比对</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%87%8D%E6%96%B0%E5%B9%B3%E8%A1%A1%E7%AE%97%E6%B3%95.png"></p>
</li>
<li><p>processQueueTable 标注的红色部分，表示与分配到的消息队列集合 mqSet 互不包含，将这些队列设置 Dropped 属性为 true，然后查看这些队列是否可以移除出 processQueueTable 缓存变量。具体执行 removeUnnecessaryMessageQueue() 方法，即每隔 1s  查看是否可以获取当前消费处理队列的锁，拿到的话返回 true；如果等待 1s 后，仍然拿不到当前消费处理队列的锁则返回 false。如果返回 true，则从 processQueueTable 缓存变量中移除对应的 Entry</p>
</li>
<li><p>processQueueTable 的绿色部分，表示与分配到的消息队列集合 mqSet 的交集，判断该 ProcessQueue 是否已经过期了，在 Pull 模式的不用管，如果是 Push 模式的，设置 Dropped 属性为 true，并且调用 removeUnnecessaryMessageQueue() 方法，像上面一样尝试移除 Entry</p>
</li>
<li><p>为过滤后的消息队列集合 mqSet 中每个 MessageQueue 创建 ProcessQueue 对象存入 RebalanceImpl 的 processQueueTable 队列中（其中调用 RebalanceImpl 实例的 <code>computePullFromWhere(MessageQueue mq)</code> 方法获取该 MessageQueue 对象的下一个进度消费值 offset，随后填充至接下来要创建的 pullRequest 对象属性中），并<strong>创建拉取请求对象</strong> pullRequest 添加到拉取列表 pullRequestList 中，最后执行 dispatchPullRequest() 方法，将 Pull 消息的请求对象 PullRequest 放入 PullMessageService 服务线程的<strong>阻塞队列</strong> pullRequestQueue 中，待该服务线程取出后向 Broker 端发起 Pull 消息的请求</p>
<p>对比下 RebalancePushImpl 和 RebalancePullImpl 两个实现类的 dispatchPullRequest() 方法，RebalancePullImpl 类里面的该方法为空</p>
</li>
</ul>
<p>消息消费队列在同一消费组不同消费者之间的负载均衡，其核心设计理念是在<strong>一个消息消费队列在同一时间只允许被同一消费组内的一个消费者消费，一个消息消费者能同时消费多个消息队列</strong></p>
<hr>
<h3 id="消息查询"><a href="#消息查询" class="headerlink" title="消息查询"></a>消息查询</h3><h4 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h4><p>RocketMQ 支持按照两种维度进行消息查询：按照 Message ID 查询消息、按照 Message Key 查询消息</p>
<ul>
<li><p>RocketMQ 中的 MessageID 的长度总共有 16 字节，其中包含了消息存储主机地址（IP 地址和端口），消息 Commit Log offset</p>
<p>实现方式：Client 端从 MessageID 中解析出 Broker 的地址（IP 地址和端口）和 Commit Log 的偏移地址，封装成一个 RPC 请求后通过 Remoting 通信层发送（业务请求码 VIEW_MESSAGE_BY_ID）。Broker 端走的是 QueryMessageProcessor，读取消息的过程用其中的 CommitLog 的 offset 和 size 去 CommitLog 中找到真正的记录并解析成一个完整的消息返回</p>
</li>
<li><p>按照 Message Key 查询消息，IndexFile 索引文件为提供了通过 Message Key 查询消息的服务</p>
<p>实现方式：通过 Broker 端的 QueryMessageProcessor 业务处理器来查询，读取消息的过程用 <strong>Topic 和 Key</strong> 找到 IndexFile 索引文件中的一条记录，根据其中的 CommitLog Offset 从 CommitLog 文件中读取消息的实体内容</p>
</li>
</ul>
<hr>
<h4 id="索引机制"><a href="#索引机制" class="headerlink" title="索引机制"></a>索引机制</h4><p>RocketMQ 的索引文件逻辑结构，类似 JDK 中 HashMap 的实现，具体结构如下：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-IndexFile%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6.png"></p>
<p>IndexFile 文件的存储在 <code>$HOME\store\index$&#123;fileName&#125;</code>，文件名 fileName 是以创建时的时间戳命名，文件大小是固定的，等于 <code>40+500W*4+2000W*20= 420000040</code> 个字节大小。如果消息的 properties 中设置了 UNIQ_KEY 这个属性，就用 <code>topic + “#” + UNIQ_KEY</code> 作为 key 来做写入操作；如果消息设置了 KEYS 属性（多个 KEY 以空格分隔），也会用 <code>topic + “#” + KEY</code> 来做索引</p>
<p>整个 Index File 的结构如图，40 Byte 的 Header 用于保存一些总的统计信息，<code>4*500W</code> 的 Slot Table 并不保存真正的索引数据，而是保存每个槽位对应的单向链表的<strong>头指针</strong>，即一个 Index File 可以保存 2000W 个索引，<code>20*2000W</code> 是<strong>真正的索引数据</strong></p>
<p>索引数据包含了 Key Hash&#x2F;CommitLog Offset&#x2F;Timestamp&#x2F;NextIndex offset 这四个字段，一共 20 Byte</p>
<ul>
<li>NextIndex offset 即前面读出来的 slotValue，如果有 hash 冲突，就可以用这个字段将所有冲突的索引用链表的方式串起来</li>
<li>Timestamp 记录的是消息 storeTimestamp 之间的差，并不是一个绝对的时间</li>
</ul>
<p>参考文档：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md">https://github.com/apache/rocketmq/blob/master/docs/cn/design.md</a></p>
<hr>
<h3 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h3><h4 id="消息重投"><a href="#消息重投" class="headerlink" title="消息重投"></a>消息重投</h4><p>生产者在发送消息时，同步消息和异步消息失败会重投，oneway 没有任何保证。消息重投保证消息尽可能发送成功、不丢失，但当出现消息量大、网络抖动时，可能会造成消息重复；生产者主动重发、Consumer 负载变化也会导致重复消息。</p>
<p>如下方法可以设置消息重投策略：</p>
<ul>
<li>retryTimesWhenSendFailed：同步发送失败重投次数，默认为 2，因此生产者会最多尝试发送 retryTimesWhenSendFailed + 1 次。不会选择上次失败的 Broker，尝试向其他 Broker 发送，<strong>最大程度保证消息不丢</strong>。超过重投次数抛出异常，由客户端保证消息不丢。当出现 RemotingException、MQClientException 和部分 MQBrokerException 时会重投</li>
<li>retryTimesWhenSendAsyncFailed：异步发送失败重试次数，异步重试不会选择其他 Broker，仅在同一个 Broker 上做重试，<strong>不保证消息不丢</strong></li>
<li>retryAnotherBrokerWhenNotStoreOK：消息刷盘（主或备）超时或 slave 不可用（返回状态非 SEND_OK），是否尝试发送到其他  Broker，默认 false，十分重要消息可以开启</li>
</ul>
<p>注意点：</p>
<ul>
<li>如果同步模式发送失败，则选择到下一个 Broker，如果异步模式发送失败，则<strong>只会在当前 Broker 进行重试</strong></li>
<li>发送消息超时时间默认 3000 毫秒，就不会再尝试重试</li>
</ul>
<hr>
<h4 id="消息重试-1"><a href="#消息重试-1" class="headerlink" title="消息重试"></a>消息重试</h4><p>Consumer 消费消息失败后，提供了一种重试机制，令消息再消费一次。Consumer 消费消息失败可以认为有以下几种情况：</p>
<ul>
<li>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99% 也不成功，所以需要提供一种定时重试机制，即过 10 秒后再重试</li>
<li>由于依赖的下游应用服务不可用，例如 DB 连接不可用，外系统网络不可达等。这种情况即使跳过当前失败的消息，消费其他消息同样也会报错，这种情况建议应用 sleep 30s，再消费下一条消息，这样可以减轻 Broker 重试消息的压力</li>
</ul>
<p>RocketMQ 会为每个消费组都设置一个 Topic 名称为 <code>%RETRY%+consumerGroup</code> 的重试队列（这个 Topic 的重试队列是<strong>针对消费组</strong>，而不是针对每个 Topic 设置的），用于暂时保存因为各种异常而导致 Consumer 端无法消费的消息</p>
<ul>
<li><p>顺序消息的重试，当消费者消费消息失败后，消息队列 RocketMQ 会自动不断进行消息重试（每次间隔时间为 1 秒），这时应用会出现消息消费被阻塞的情况。所以在使用顺序消息时，必须保证应用能够及时监控并处理消费失败的情况，避免阻塞现象的发生</p>
</li>
<li><p>无序消息（普通、定时、延时、事务消息）的重试，可以通过设置返回状态达到消息重试的结果。无序消息的重试只针对集群消费方式生效，广播方式不提供失败重试特性，即消费失败后，失败消息不再重试，继续消费新的消息</p>
</li>
</ul>
<p><strong>无序消息情况下</strong>，因为异常恢复需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ 对于重试消息的处理是先保存至 Topic 名称为 <code>SCHEDULE_TOPIC_XXXX</code> 的延迟队列中，后台定时任务<strong>按照对应的时间进行 Delay 后</strong>重新保存至 <code>%RETRY%+consumerGroup</code> 的重试队列中</p>
<p>消息队列 RocketMQ 默认允许每条消息最多重试 16 次，每次重试的间隔时间如下表示：</p>
<table>
<thead>
<tr>
<th align="center">第几次重试</th>
<th align="center">与上次重试的间隔时间</th>
<th align="center">第几次重试</th>
<th align="center">与上次重试的间隔时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">10 秒</td>
<td align="center">9</td>
<td align="center">7 分钟</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">30 秒</td>
<td align="center">10</td>
<td align="center">8 分钟</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1 分钟</td>
<td align="center">11</td>
<td align="center">9 分钟</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">2 分钟</td>
<td align="center">12</td>
<td align="center">10 分钟</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">3 分钟</td>
<td align="center">13</td>
<td align="center">20 分钟</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">4 分钟</td>
<td align="center">14</td>
<td align="center">30 分钟</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">5 分钟</td>
<td align="center">15</td>
<td align="center">1 小时</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">6 分钟</td>
<td align="center">16</td>
<td align="center">2 小时</td>
</tr>
</tbody></table>
<p>如果消息重试 16 次后仍然失败，消息将<strong>不再投递</strong>，如果严格按照上述重试时间间隔计算，某条消息在一直消费失败的前提下，将会在接下来的 4 小时 46 分钟之内进行 16 次重试，超过这个时间范围消息将不再重试投递</p>
<p>时间间隔不支持自定义配置，最大重试次数可通过自定义参数 <code>MaxReconsumeTimes</code> 取值进行配置，若配置超过 16 次，则超过的间隔时间均为 2 小时</p>
<p>说明：一条消息无论重试多少次，<strong>消息的 Message ID 是不会改变的</strong></p>
<hr>
<h4 id="重试操作"><a href="#重试操作" class="headerlink" title="重试操作"></a>重试操作</h4><p>集群消费方式下，消息消费失败后期望消息重试，需要在消息监听器接口的实现中明确进行配置（三种方式任选一种）：</p>
<ul>
<li>返回 Action.ReconsumeLater （推荐）</li>
<li>返回 null</li>
<li>抛出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理消息</span></span><br><span class="line">        doConsumeMessage(message);</span><br><span class="line">        <span class="comment">//方式1：返回 Action.ReconsumeLater，消息将重试</span></span><br><span class="line">        <span class="keyword">return</span> Action.ReconsumeLater;</span><br><span class="line">        <span class="comment">//方式2：返回 null，消息将重试</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//方式3：直接抛出异常， 消息将重试</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Consumer Message exceotion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集群消费方式下，消息失败后期望消息不重试，需要捕获消费逻辑中可能抛出的异常，最终返回 Action.CommitMessage，此后这条消息将不会再重试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doConsumeMessage(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// 捕获消费逻辑中的所有异常，并返回 Action.CommitMessage;</span></span><br><span class="line">            <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消息处理正常，直接返回 Action.CommitMessage;</span></span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义消息最大重试次数，RocketMQ 允许 Consumer 启动的时候设置最大重试次数，重试时间间隔将按照如下策略：</p>
<ul>
<li>最大重试次数小于等于 16 次，则重试时间间隔同上表描述</li>
<li>最大重试次数大于 16 次，超过 16 次的重试时间间隔均为每次 2 小时</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">// 配置对应 Group ID 的最大消息重试次数为 20 次</span></span><br><span class="line">properties.put(PropertyKeyConst.MaxReconsumeTimes,<span class="string">&quot;20&quot;</span>);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> ONSFactory.createConsumer(properties);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>消息最大重试次数的设置对相同 Group ID 下的所有 Consumer 实例有效。例如只对相同 Group ID 下两个 Consumer 实例中的其中一个设置了 MaxReconsumeTimes，那么该配置对两个 Consumer 实例均生效</li>
<li>配置采用覆盖的方式生效，即最后启动的 Consumer 实例会覆盖之前的启动实例的配置</li>
</ul>
<p>消费者收到消息后，可按照如下方式获取消息的重试次数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取消息的重试次数</span></span><br><span class="line">        System.out.println(message.getReconsumeTimes());</span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）</p>
<p>当一条消息初次消费失败，消息队列 RocketMQ 会自动进行消息重试，达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时 RocketMQ 不会立刻将消息丢弃，而是将其发送到该消费者对应的死信队列中</p>
<p>死信消息具有以下特性：</p>
<ul>
<li>不会再被消费者正常消费</li>
<li>有效期与正常消息相同，均为 3 天，3 天后会被自动删除，所以请在死信消息产生后的 3 天内及时处理</li>
</ul>
<p>死信队列具有以下特性：</p>
<ul>
<li><strong>一个死信队列对应一个 Group ID， 而不是对应单个消费者实例</strong></li>
<li>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列</li>
<li>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic</li>
</ul>
<p>一条消息进入死信队列，需要排查可疑因素并解决问题后，可以在消息队列 RocketMQ 控制台重新发送该消息，让消费者重新消费一次</p>
<hr>
<h3 id="幂等消费"><a href="#幂等消费" class="headerlink" title="幂等消费"></a>幂等消费</h3><p>消息队列 RocketMQ 消费者在接收到消息以后，需要根据业务上的唯一 Key 对消息做幂等处理</p>
<p>At least Once 机制保证消息不丢失，但是可能会造成消息重复，RocketMQ 中无法避免消息重复（Exactly-Once），在互联网应用中，尤其在网络不稳定的情况下，几种情况：</p>
<ul>
<li><p>发送时消息重复：当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或客户端宕机，导致服务端对客户端应答失败。此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息</p>
</li>
<li><p>投递时消息重复：消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。为了保证消息至少被消费一次，消息队列 RocketMQ 的服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息</p>
</li>
<li><p>负载均衡时消息重复：当消息队列 RocketMQ 的 Broker 或客户端重启、扩容或缩容时，会触发 Rebalance，此时消费者可能会收到重复消息</p>
</li>
</ul>
<p>处理方式：</p>
<ul>
<li><p>因为 Message ID 有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以 Message ID 作为处理依据，最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息 Key 进行设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">message.setKey(<span class="string">&quot;ORDERID_100&quot;</span>);</span><br><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br></pre></td></tr></table></figure>
</li>
<li><p>订阅方收到消息时可以根据消息的 Key 进行幂等处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">&quot;ons_test&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> message.getKey()</span><br><span class="line">        <span class="comment">// 根据业务唯一标识的 key 做幂等处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>生产者流控，因为 Broker 处理能力达到瓶颈；消费者流控，因为消费能力达到瓶颈</p>
<p>生产者流控：</p>
<ul>
<li>CommitLog 文件被锁时间超过 osPageCacheBusyTimeOutMills 时，参数默认为 1000ms，返回流控</li>
<li>如果开启 transientStorePoolEnable &#x3D;&#x3D; true，且 Broker 为异步刷盘的主机，且 transientStorePool 中资源不足，拒绝当前 send 请求，返回流控</li>
<li>Broker 每隔 10ms 检查 send 请求队列头部请求的等待时间，如果超过 waitTimeMillsInSendQueue，默认 200ms，拒绝当前 send 请求，返回流控。</li>
<li>Broker 通过拒绝 send 请求方式实现流量控制</li>
</ul>
<p>注意：生产者流控，不会尝试消息重投</p>
<p>消费者流控：</p>
<ul>
<li>消费者本地缓存消息数超过 pullThresholdForQueue 时，默认 1000</li>
<li>消费者本地缓存消息大小超过 pullThresholdSizeForQueue 时，默认 100MB</li>
<li>消费者本地缓存消息跨度超过 consumeConcurrentlyMaxSpan 时，默认 2000</li>
</ul>
<p>消费者流控的结果是降低拉取频率</p>
<hr>
<h2 id="原理解析-4"><a href="#原理解析-4" class="headerlink" title="原理解析"></a>原理解析</h2><h3 id="Namesrv"><a href="#Namesrv" class="headerlink" title="Namesrv"></a>Namesrv</h3><h4 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h4><h5 id="启动方法"><a href="#启动方法" class="headerlink" title="启动方法"></a>启动方法</h5><p>NamesrvStartup 类中有 Namesrv 服务的启动方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果启动时 使用 -c  -p  设置参数了，这些参数存储在 args 中</span></span><br><span class="line">    main0(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> NamesrvController <span class="title function_">main0</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 namesrv 控制器，用来初始化 namesrv 启动 namesrv 关闭 namesrv</span></span><br><span class="line">        <span class="type">NamesrvController</span> <span class="variable">controller</span> <span class="operator">=</span> createNamesrvController(args);</span><br><span class="line">		<span class="comment">// 启动 controller</span></span><br><span class="line">        start(controller);</span><br><span class="line">        <span class="keyword">return</span> controller;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="comment">// 出现异常，停止系统</span></span><br><span class="line">        System.exit(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NamesrvStartup#createNamesrvController：读取配置信息，初始化 Namesrv 控制器</p>
<ul>
<li><p><code>ServerUtil.parseCmdLine(&quot;mqnamesrv&quot;, args, buildCommandlineOptions(options)，..)</code>：解析启动时的参数信息</p>
</li>
<li><p><code>namesrvConfig = new NamesrvConfig()</code>：创建 Namesrv 配置对象</p>
<ul>
<li><code>private String rocketmqHome</code>：获取 ROCKETMQ_HOME 值</li>
<li><code>private boolean orderMessageEnable = false</code>：<strong>顺序消息</strong>功能是否开启</li>
</ul>
</li>
<li><p><code>nettyServerConfig = new NettyServerConfig()</code>：Netty 的服务器配置对象</p>
</li>
<li><p><code>nettyServerConfig.setListenPort(9876)</code>：Namesrv 服务器的<strong>监听端口设置为 9876</strong></p>
</li>
<li><p><code>if (commandLine.hasOption(&#39;c&#39;))</code>：读取命令行 -c 的参数值</p>
<p><code>in = new BufferedInputStream(new FileInputStream(file))</code>：读取指定目录的配置文件</p>
<p><code>properties.load(in)</code>：将配置文件信息加载到 properties 对象，相关属性会复写到 Namesrv 配置和 Netty 配置对象</p>
<p><code>namesrvConfig.setConfigStorePath(file)</code>：将配置文件的路径保存到配置保存字段</p>
</li>
<li><p><code>if (null == namesrvConfig.getRocketmqHome())</code>：检查 ROCKETMQ_HOME 配置是否是空，是空就报错</p>
</li>
<li><p><code>lc = (LoggerContext) LoggerFactory.getILoggerFactory()</code>：创建日志对象</p>
</li>
<li><p><code>controller = new NamesrvController(namesrvConfig, nettyServerConfig)</code>：<strong>创建 Namesrv 控制器</strong></p>
</li>
</ul>
<p>NamesrvStartup#start：启动 Namesrv 控制器</p>
<ul>
<li><p><code>boolean initResult = controller.initialize()</code>：初始化方法</p>
</li>
<li><p><code> Runtime.getRuntime().addShutdownHook(new ShutdownHookThread())</code>：JVM HOOK 平滑关闭的逻辑， 当 JVM 被关闭时，主动调用 controller.shutdown() 方法，让服务器平滑关机</p>
</li>
<li><p><code>controller.start()</code>：启动服务器</p>
</li>
</ul>
<p>源码解析参考视频：<a href="https://space.bilibili.com/457326371">https://space.bilibili.com/457326371</a></p>
<hr>
<h5 id="控制器类"><a href="#控制器类" class="headerlink" title="控制器类"></a>控制器类</h5><p>NamesrvController 用来初始化和启动 Namesrv 服务器</p>
<ul>
<li><p>成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutorService;	<span class="comment">// 调度线程池，用来执行定时任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RouteInfoManager routeInfoManager;					<span class="comment">// 管理【路由信息】的对象</span></span><br><span class="line"><span class="keyword">private</span> RemotingServer remotingServer;								<span class="comment">// 【网络层】封装对象</span></span><br><span class="line"><span class="keyword">private</span> BrokerHousekeepingService brokerHousekeepingService;		<span class="comment">// 用于监听 channel 状态</span></span><br></pre></td></tr></table></figure>

<p><code>private ExecutorService remotingExecutor</code>：业务线程池，<strong>netty 线程解析报文成 RemotingCommand 对象，然后将该对象交给业务线程池再继续处理</strong></p>
</li>
<li><p>初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 加载本地kv配置（我还不明白 kv 配置是啥）</span></span><br><span class="line">    <span class="built_in">this</span>.kvConfigManager.load();</span><br><span class="line">    <span class="comment">// 创建网络服务器对象，【将 netty 的配置和监听器传入】</span></span><br><span class="line">    <span class="comment">// 监听器监听 channel 状态的改变，会向事件队列发起事件，最后交由 service 处理</span></span><br><span class="line">    <span class="built_in">this</span>.remotingServer = <span class="keyword">new</span> <span class="title class_">NettyRemotingServer</span>(<span class="built_in">this</span>.nettyServerConfig, <span class="built_in">this</span>.brokerHousekeepingService);</span><br><span class="line">    <span class="comment">// 【创建业务线程池，默认线程数 8】</span></span><br><span class="line">    <span class="built_in">this</span>.remotingExecutor = Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads().);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册协议处理器（缺省协议处理器），【处理器是 DefaultRequestProcessor】，线程使用的是刚创建的业务的线程池</span></span><br><span class="line">    <span class="built_in">this</span>.registerProcessor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时任务1：每 10 秒钟检查 broker 存活状态，将 IDLE 状态的 broker 移除【扫描机制，心跳检测】</span></span><br><span class="line">    <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 扫描 brokerLiveTable 表，将两小时没有活动的 broker 关闭，</span></span><br><span class="line">            <span class="comment">// 通过 next.getKey() 获取 broker 的地址，然后【关闭服务器与broker物理节点的 channel】</span></span><br><span class="line">            NamesrvController.<span class="built_in">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时任务2：每 10 分钟打印一遍 kv 配置。</span></span><br><span class="line">    <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            NamesrvController.<span class="built_in">this</span>.kvConfigManager.printAllPeriodically();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 服务器网络层启动。</span></span><br><span class="line">    <span class="built_in">this</span>.remotingServer.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.fileWatchService != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.fileWatchService.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h4><h5 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h5><p>RocketMQ 的 RPC 通信采用 Netty 组件作为底层通信库，同样也遵循了 Reactor 多线程模型，NettyRemotingServer 类负责框架的通信服务，同时又在这之上做了一些扩展和优化</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-Reactor%E8%AE%BE%E8%AE%A1.png"></p>
<p>RocketMQ 基于 NettyRemotingServer 的 Reactor 多线程模型：</p>
<ul>
<li><p>一个 Reactor 主线程（eventLoopGroupBoss）负责监听 TCP 网络连接请求，建立好连接创建 SocketChannel（RocketMQ 会自动根据 OS 的类型选择 NIO 和 Epoll，也可以通过参数配置），并注册到 Selector 上，然后监听真正的网络数据</p>
</li>
<li><p>拿到网络数据交给 Worker 线程池（eventLoopGroupSelector，默认设置为 3），在真正执行业务逻辑之前需要进行 SSL 验证、编解码、空闲检查、网络连接管理，这些工作交给 defaultEventExecutorGroup（默认设置为 8）去做</p>
</li>
<li><p>处理业务操作放在业务线程池中执行，根据 RomotingCommand 的<strong>业务请求码 code</strong> 去 processorTable 这个本地缓存变量中找到对应的 processor，封装成 task 任务提交给对应的 processor 处理线程池来执行（sendMessageExecutor，以发送消息为例）</p>
</li>
<li><p>从入口到业务逻辑的几个步骤中线程池一直再增加，这跟每一步逻辑复杂性相关，越复杂，需要的并发通道越宽</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>线程数</th>
<th>线程名</th>
<th>线程具体说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>NettyBoss_%d</td>
<td>Reactor 主线程</td>
</tr>
<tr>
<td>N</td>
<td>NettyServerEPOLLSelector_%d_%d</td>
<td>Reactor 线程池</td>
</tr>
<tr>
<td>M1</td>
<td>NettyServerCodecThread_%d</td>
<td>Worker 线程池</td>
</tr>
<tr>
<td>M2</td>
<td>RemotingExecutorThread_%d</td>
<td>业务 processor 处理线程池</td>
</tr>
</tbody></table>
<p>RocketMQ 的异步通信流程：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.png"></p>
<p>&#x3D;&#x3D;todo：后期对 Netty 有了更深的认知后会进行扩充，现在暂时 copy 官方文档&#x3D;&#x3D;</p>
<p>官方文档：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md#2-%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6">https://github.com/apache/rocketmq/blob/master/docs/cn/design.md#2-%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6</a></p>
<hr>
<h5 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h5><p>NettyRemotingServer 类成员变量：</p>
<ul>
<li><p>服务器相关属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServerBootstrap serverBootstrap;				<span class="comment">// netty 服务端启动对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup eventLoopGroupSelector;		<span class="comment">// netty worker 组线程池，【默认 3 个线程】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup eventLoopGroupBoss;			<span class="comment">// netty boss 组线程池，【一般是 1 个线程】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> NettyServerConfig nettyServerConfig;			<span class="comment">// netty 服务端网络配置</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">0</span>;										<span class="comment">// 服务器绑定的端口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>公共线程池：注册处理器时如果未指定线程池，则业务处理使用公共线程池，线程数量默认是 4 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService publicExecutor;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件监听器：Nameserver 使用 BrokerHouseKeepingService，Broker 使用 ClientHouseKeepingService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelEventListener channelEventListener;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件处理线程池：默认是 8</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> DefaultEventExecutorGroup defaultEventExecutorGroup;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器：执行循环任务，并且将定时器线程设置为守护线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="string">&quot;ServerHouseKeepingService&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理器：多个 Channel 共享的处理器 Handler，多个通道使用同一个对象</p>
</li>
<li><p>Netty 配置对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServerConfig</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="comment">// 服务端启动时监听的端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">listenPort</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line">    <span class="comment">// 【业务线程池】 线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverWorkerThreads</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 根据该值创建 remotingServer 内部的一个 publicExecutor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverCallbackExecutorThreads</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// netty 【worker】线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverSelectorThreads</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 【单向访问】时的并发限制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverOnewaySemaphoreValue</span> <span class="operator">=</span> <span class="number">256</span>;</span><br><span class="line">    <span class="comment">// 【异步访问】时的并发限制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverAsyncSemaphoreValue</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// channel 最大的空闲存活时间 默认是 2min</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverChannelMaxIdleTimeSeconds</span> <span class="operator">=</span> <span class="number">120</span>;</span><br><span class="line">    <span class="comment">// 发送缓冲区大小 65535</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverSocketSndBufSize</span> <span class="operator">=</span> NettySystemConfig.socketSndbufSize;</span><br><span class="line">    <span class="comment">// 接收缓冲区大小 65535</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverSocketRcvBufSize</span> <span class="operator">=</span> NettySystemConfig.socketRcvbufSize;</span><br><span class="line">    <span class="comment">// 是否启用 netty 内存池 默认开启</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">serverPooledByteBufAllocatorEnable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认 linux 会启用 【epoll】</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">useEpollNativeSelector</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>构造方法：</p>
<ul>
<li><p>无监听器构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NettyRemotingServer</span><span class="params">(<span class="keyword">final</span> NettyServerConfig nettyServerConfig)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nettyServerConfig, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有参构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NettyRemotingServer</span><span class="params">(<span class="keyword">final</span> NettyServerConfig nettyServerConfig,</span></span><br><span class="line"><span class="params">                           <span class="keyword">final</span> ChannelEventListener channelEventListener)</span> &#123;</span><br><span class="line">    <span class="comment">// 服务器对客户端主动发起请求时并发限制。【单向请求和异步请求】的并发限制</span></span><br><span class="line">    <span class="built_in">super</span>(nettyServerConfig.getServerOnewaySemaphoreValue(), nettyServerConfig.getServerAsyncSemaphoreValue());</span><br><span class="line">	<span class="comment">// Netty 的启动器，负责组装 netty 组件</span></span><br><span class="line">    <span class="built_in">this</span>.serverBootstrap = <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    <span class="comment">// 成员变量的赋值</span></span><br><span class="line">    <span class="built_in">this</span>.nettyServerConfig = nettyServerConfig;</span><br><span class="line">    <span class="built_in">this</span>.channelEventListener = channelEventListener;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共线程池的线程数量，默认给的0，这里最终修改为4.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">publicThreadNums</span> <span class="operator">=</span> nettyServerConfig.getServerCallbackExecutorThreads();</span><br><span class="line">    <span class="keyword">if</span> (publicThreadNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        publicThreadNums = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建公共线程池，指定线程工厂，设置线程名称前缀：NettyServerPublicExecutor_[数字]</span></span><br><span class="line">    <span class="built_in">this</span>.publicExecutor = Executors.newFixedThreadPool(publicThreadNums, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>()&#123;.&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个 netty 的线程组，一个是boss组，一个是worker组，【linux 系统默认启用 epoll】</span></span><br><span class="line">    <span class="keyword">if</span> (useEpoll()) &#123;...&#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">	<span class="comment">// SSL 相关</span></span><br><span class="line">    loadSslContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="启动方法-1"><a href="#启动方法-1" class="headerlink" title="启动方法"></a>启动方法</h5><p>核心方法的解析：</p>
<ul>
<li><p>start()：启动方法，<strong>创建 BootStrap，并添加 NettyServerHandler 处理器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Channel Pipeline 内的 handler 使用的线程资源，【线程分配给 handler 处理事件】</span></span><br><span class="line">    <span class="built_in">this</span>.defaultEventExecutorGroup = <span class="keyword">new</span> <span class="title class_">DefaultEventExecutorGroup</span>(...);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建通用共享的处理器 handler，【非常重要的 NettyServerHandler】</span></span><br><span class="line">    prepareSharableHandlers();</span><br><span class="line"></span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">childHandler</span> <span class="operator">=</span></span><br><span class="line">        <span class="comment">// 配置工作组 boss（数量1） 和 worker（数量3） 组</span></span><br><span class="line">        <span class="built_in">this</span>.serverBootstrap.group(<span class="built_in">this</span>.eventLoopGroupBoss, <span class="built_in">this</span>.eventLoopGroupSelector)</span><br><span class="line">        <span class="comment">// 设置服务端 ServerSocketChannel 类型， Linux 用 epoll</span></span><br><span class="line">        .channel(useEpoll() ? EpollServerSocketChannel.class : NioServerSocketChannel.class)</span><br><span class="line">        <span class="comment">// 设置服务端 channel 选项</span></span><br><span class="line">        .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">        <span class="comment">// 客户端 channel 选项</span></span><br><span class="line">        .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">        <span class="comment">// 设置服务器端口</span></span><br><span class="line">        .localAddress(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="built_in">this</span>.nettyServerConfig.getListenPort()))</span><br><span class="line">        <span class="comment">// 向 channel pipeline 添加了很多 handler，【包括 NettyServerHandler】</span></span><br><span class="line">        .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;&#125;);</span><br><span class="line">            </span><br><span class="line">	<span class="comment">// 客户端开启 内存池，使用的内存池是  PooledByteBufAllocator.DEFAULT</span></span><br><span class="line">    <span class="keyword">if</span> (nettyServerConfig.isServerPooledByteBufAllocatorEnable()) &#123;</span><br><span class="line">        childHandler.childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 同步等待建立连接，并绑定端口。</span></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="built_in">this</span>.serverBootstrap.bind().sync();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">addr</span> <span class="operator">=</span> (InetSocketAddress) sync.channel().localAddress();</span><br><span class="line">        <span class="comment">// 将服务器成功绑定的端口号赋值给字段 port。</span></span><br><span class="line">        <span class="built_in">this</span>.port = addr.getPort();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// housekeepingService 不为空，则创建【网络异常事件处理器】</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.channelEventListener != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 线程一直轮询 nettyEvent 状态，根据 CONNECT,CLOSE,IDLE,EXCEPTION 四种事件类型</span></span><br><span class="line">        <span class="comment">// CONNECT 不做操作，其余都是回调 onChannelDestroy 【关闭服务器与 Broker 物理节点的 Channel】</span></span><br><span class="line">        <span class="built_in">this</span>.nettyEventExecutor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交定时任务，每一秒 执行一次。扫描 responseTable 表，将过期的数据移除</span></span><br><span class="line">    <span class="built_in">this</span>.timer.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       		NettyRemotingServer.<span class="built_in">this</span>.scanResponseTable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">3</span>, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>registerProcessor()：注册业务处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerProcessor</span><span class="params">(<span class="type">int</span> requestCode, NettyRequestProcessor processor, ExecutorService executor)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorThis</span> <span class="operator">=</span> executor;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == executor) &#123;</span><br><span class="line">        <span class="comment">// 未指定线程池资源，将公共线程池赋值</span></span><br><span class="line">        executorThis = <span class="built_in">this</span>.publicExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pair 对象，第一个参数代表的是处理器， 第二个参数是线程池，默认是公共的线程池</span></span><br><span class="line">    Pair&lt;NettyRequestProcessor, ExecutorService&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;NettyRequestProcessor, ExecutorService&gt;(processor, executorThis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key 是请求码，value 是 Pair 对象</span></span><br><span class="line">    <span class="built_in">this</span>.processorTable.put(requestCode, pair);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getProcessorPair()：<strong>根据请求码获取对应的处理器和线程池资源</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Pair&lt;NettyRequestProcessor, ExecutorService&gt; <span class="title function_">getProcessorPair</span><span class="params">(<span class="type">int</span> requestCode)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> processorTable.get(requestCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h5><p>在 RocketMQ 消息队列中支持通信的方式主要有同步（sync）、异步（async）、单向（oneway）三种，其中单向通信模式相对简单，一般用在发送心跳包场景下，无需关注其 Response</p>
<p>服务器主动向客户端发起请求时，使用三种方法</p>
<ul>
<li><p>invokeSync()： 同步调用，<strong>服务器需要阻塞等待调用的返回结果</strong></p>
<ul>
<li><code>int opaque = request.getOpaque()</code>：获取请求 ID（与请求码不同）</li>
<li><code>responseFuture = new ResponseFuture(...)</code>：<strong>创建响应对象</strong>，没有回调函数和 Once</li>
<li><code>this.responseTable.put(opaque, responseFuture)</code>：<strong>加入到响应映射表中</strong>，key 为请求 ID</li>
<li><code>SocketAddress addr = channel.remoteAddress()</code>：获取客户端的地址信息</li>
<li><code>channel.writeAndFlush(request).addListener(...)</code>：将<strong>业务 Command 信息</strong>写入通道，业务线程将数据交给 Netty ，Netty 的 IO 线程接管写刷数据的操作，<strong>监听器由 IO 线程在写刷后回调</strong><ul>
<li><code>if (f.isSuccess())</code>：写入成功会将响应对象设置为成功状态直接 return，写入失败设置为失败状态</li>
<li><code>responseTable.remove(opaque)</code>：将当前请求的 responseFuture <strong>从映射表移除</strong></li>
<li><code>responseFuture.setCause(f.cause())</code>：设置错误的信息</li>
<li><code>responseFuture.putResponse(null)</code>：响应 Command 设置为 null</li>
</ul>
</li>
<li><code>responseCommand = responseFuture.waitResponse(timeoutMillis)</code>：当前线程设置超时时间挂起，<strong>同步等待响应</strong></li>
<li><code>if (null == responseCommand)</code>：超时或者出现异常，直接报错</li>
<li><code>return responseCommand</code>：返回响应 Command 信息</li>
</ul>
</li>
<li><p>invokeAsync()：异步调用，有回调对象，无返回值</p>
<ul>
<li><code>boolean acquired = this.semaphoreAsync.tryAcquire(timeoutMillis, TimeUnit.MILLISECONDS)</code>：获取信号量的许可证，信号量用来<strong>限制异步请求</strong>的数量</li>
<li><code>if (acquired)</code>：许可证获取失败说明并发较高，会抛出异常</li>
<li><code>once = new SemaphoreReleaseOnlyOnce(this.semaphoreAsync)</code>：Once 对象封装了释放信号量的操作</li>
<li><code>costTime = System.currentTimeMillis() - beginStartTime</code>：计算一下耗费的时间，超时不再发起请求</li>
<li><code>responseFuture = new ResponseFuture()</code>：<strong>创建响应对象，包装了回调函数和 Once 对象</strong></li>
<li><code>this.responseTable.put(opaque, responseFuture)</code>：加入到响应映射表中，key 为请求 ID</li>
<li><code>channel.writeAndFlush(request).addListener(...)</code>：写刷数据<ul>
<li><code>if (f.isSuccess())</code>：写刷成功，设置 responseFuture 发生状态为 true</li>
<li><code>requestFail(opaque)</code>：写入失败，使用 publicExecutor <strong>公共线程池异步执行回调对象的函数</strong></li>
<li><code>responseFuture.release()</code>：出现异常会释放信号量</li>
</ul>
</li>
</ul>
</li>
<li><p>invokeOneway()：单向调用，不关注响应结果</p>
<ul>
<li><code>request.markOnewayRPC()</code>：设置单向标记，对端检查标记可知该请是单向请求</li>
<li><code>boolean acquired = this.semaphoreOneway.tryAcquire(timeoutMillis, TimeUnit.MILLISECONDS)</code>：获取信号量的许可证，信号量用来<strong>限制单向请求</strong>的数量</li>
</ul>
</li>
</ul>
<hr>
<h4 id="处理器类"><a href="#处理器类" class="headerlink" title="处理器类"></a>处理器类</h4><h5 id="协议设计-1"><a href="#协议设计-1" class="headerlink" title="协议设计"></a>协议设计</h5><p>在 Client 和 Server 之间完成一次消息发送时，需要对发送的消息进行一个协议约定，所以自定义 RocketMQ 的消息协议。在 RocketMQ 中，为了高效地在网络中传输消息和对收到的消息读取，就需要对消息进行编解码，RemotingCommand 这个类在消息传输过程中对所有数据内容的封装，不但包含了所有的数据结构，还包含了编码解码操作</p>
<table>
<thead>
<tr>
<th>Header字段</th>
<th>类型</th>
<th>Request 说明</th>
<th>Response 说明</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>int</td>
<td>请求操作码，应答方根据不同的请求码进行不同的处理</td>
<td>应答响应码，0 表示成功，非 0 则表示各种错误</td>
</tr>
<tr>
<td>language</td>
<td>LanguageCode</td>
<td>请求方实现的语言</td>
<td>应答方实现的语言</td>
</tr>
<tr>
<td>version</td>
<td>int</td>
<td>请求方程序的版本</td>
<td>应答方程序的版本</td>
</tr>
<tr>
<td>opaque</td>
<td>int</td>
<td>相当于 requestId，在同一个连接上的不同请求标识码，与响应消息中的相对应</td>
<td>应答不做修改直接返回</td>
</tr>
<tr>
<td>flag</td>
<td>int</td>
<td>区分是普通 RPC 还是 onewayRPC 的标志</td>
<td>区分是普通 RPC 还是 onewayRPC的标志</td>
</tr>
<tr>
<td>remark</td>
<td>String</td>
<td>传输自定义文本信息</td>
<td>传输自定义文本信息</td>
</tr>
<tr>
<td>extFields</td>
<td>HashMap&lt;String, String&gt;</td>
<td>请求自定义扩展信息</td>
<td>响应自定义扩展信息</td>
</tr>
</tbody></table>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE.png"></p>
<p>传输内容主要可以分为以下四部分：</p>
<ul>
<li><p>消息长度：总长度，四个字节存储，占用一个 int 类型</p>
</li>
<li><p>序列化类型&amp;消息头长度：同样占用一个 int 类型，第一个字节表示序列化类型，后面三个字节表示消息头长度</p>
</li>
<li><p>消息头数据：经过序列化后的消息头数据</p>
</li>
<li><p>消息主体数据：消息主体的二进制字节数据内容</p>
</li>
</ul>
<p>官方文档：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md">https://github.com/apache/rocketmq/blob/master/docs/cn/design.md</a></p>
<hr>
<h5 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h5><p>NettyServerHandler 类用来处理 Channel 上的事件，在 NettyRemotingServer 启动时注册到 Netty 中，可以处理 RemotingCommand 相关的数据，针对某一种类型的<strong>请求处理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;RemotingCommand&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 服务器处理接受到的请求信息</span></span><br><span class="line">        processMessageReceived(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processMessageReceived</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">RemotingCommand</span> <span class="variable">cmd</span> <span class="operator">=</span> msg;</span><br><span class="line">    <span class="keyword">if</span> (cmd != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 根据请求的类型进行处理</span></span><br><span class="line">        <span class="keyword">switch</span> (cmd.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> REQUEST_COMMAND:<span class="comment">// 客户端发起的请求，走这里</span></span><br><span class="line">                processRequestCommand(ctx, cmd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RESPONSE_COMMAND:<span class="comment">// 客户端响应的数据，走这里【当前类本身是服务器类也是客户端类】</span></span><br><span class="line">                processResponseCommand(ctx, cmd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NettyRemotingAbstract#processRequestCommand：<strong>处理请求的数据</strong></p>
<ul>
<li><p><code>matched = this.processorTable.get(cmd.getCode())</code>：根据业务请求码获取 Pair 对象，包含<strong>处理器和线程池资源</strong></p>
</li>
<li><p><code>pair = null == matched ? this.defaultRequestProcessor : matched</code>：未找到处理器则使用缺省处理器</p>
</li>
<li><p><code>int opaque = cmd.getOpaque()</code>：获取请求 ID</p>
</li>
<li><p><code>Runnable run = new Runnable()</code>：创建任务对象，任务在提交到线程池后开始执行</p>
<ul>
<li><p><code>doBeforeRpcHooks()</code>：RPC HOOK 前置处理</p>
</li>
<li><p><code>callback = new RemotingResponseCallback()</code>：<strong>封装响应客户端的逻辑</strong></p>
<ul>
<li><code>doAfterRpcHooks()</code>：RPC HOOK 后置处理</li>
<li><code>if (!cmd.isOnewayRPC())</code>：条件成立说明不是单向请求，需要结果</li>
<li><code>response.setOpaque(opaque)</code>：将请求 ID 设置到 response</li>
<li><code>response.markResponseType()</code>：<strong>设置当前请求是响应</strong></li>
<li><code>ctx.writeAndFlush(response)</code>： <strong>将响应数据交给 Netty IO 线程，完成数据写和刷</strong></li>
</ul>
</li>
<li><p><code>if (pair.getObject1() instanceof AsyncNettyRequestProcessor)</code>：Nameserver 默认使用 DefaultRequestProcessor 处理器，是一个 AsyncNettyRequestProcessor 子类</p>
</li>
<li><p><code>processor = (AsyncNettyRequestProcessor)pair.getObject1()</code>：获取处理器</p>
</li>
<li><p><code>processor.asyncProcessRequest(ctx, cmd, callback)</code>：异步调用，首先 processRequest，然后 callback 响应客户端</p>
<p><code>DefaultRequestProcessor.processRequest</code>：<strong>根据业务码处理请求，执行对应的操作</strong></p>
<p><code>ClientRemotingProcessor.processRequest</code>：处理事务回查消息，或者回执消息，需要消费者回执一条消息给生产者</p>
</li>
</ul>
</li>
<li><p><code>requestTask = new RequestTask(run, ctx.channel(), cmd)</code>：将任务对象、通道、请求封装成 RequestTask 对象</p>
</li>
<li><p><code>pair.getObject2().submit(requestTask)</code>：<strong>获取处理器对应的线程池，将 task 提交，从 IO 线程切换到业务线程</strong></p>
</li>
</ul>
<p>NettyRemotingAbstract#processResponseCommand：<strong>处理响应的数据</strong></p>
<ul>
<li><code>int opaque = cmd.getOpaque()</code>：获取请求 ID</li>
<li><code>responseFuture = responseTable.get(opaque)</code>：<strong>从响应映射表中获取对应的对象</strong></li>
<li><code>responseFuture.setResponseCommand(cmd)</code>：设置响应的 Command 对象</li>
<li><code>responseTable.remove(opaque)</code>：从映射表中移除对象，代表处理完成</li>
<li><code>if (responseFuture.getInvokeCallback() != null)</code>：包含回调对象，异步执行回调对象</li>
<li><code>responseFuture.putResponse(cmd)</code>：不包含回调对象，<strong>同步调用时，唤醒等待的业务线程</strong></li>
</ul>
<p>流程：客户端 invokeSync → 服务器的 processRequestCommand → 客户端的 processResponseCommand → 结束</p>
<hr>
<h4 id="路由信息"><a href="#路由信息" class="headerlink" title="路由信息"></a>路由信息</h4><h5 id="信息管理"><a href="#信息管理" class="headerlink" title="信息管理"></a>信息管理</h5><p>RouteInfoManager 类负责管理路由信息，NamesrvController 的构造方法中创建该类的实例对象，管理服务端的路由数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouteInfoManager</span> &#123;</span><br><span class="line">    <span class="comment">// Broker 两个小时不活跃，视为离线，被定时任务删除</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">BROKER_CHANNEL_EXPIRED_TIME</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 读写锁，保证线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">// 主题队列数据，一个主题对应多个队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable;</span><br><span class="line">    <span class="comment">// Broker 数据列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable;</span><br><span class="line">    <span class="comment">// 集群</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable;</span><br><span class="line">    <span class="comment">// Broker 存活信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable;</span><br><span class="line">    <span class="comment">// 服务过滤</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h5><p>DefaultRequestProcessor REGISTER_BROKER 方法解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RemotingCommand <span class="title function_">registerBroker</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建响应请求的对象，设置为响应类型，【先设置响应的状态码时系统错误码】</span></span><br><span class="line">    <span class="comment">// 反射创建 RegisterBrokerResponseHeader 对象设置到 response.customHeader 属性中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">RemotingCommand</span> <span class="variable">response</span> <span class="operator">=</span> RemotingCommand.createResponseCommand(RegisterBrokerResponseHeader.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取出反射创建的 RegisterBrokerResponseHeader 用户自定义header对象。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">RegisterBrokerResponseHeader</span> <span class="variable">responseHeader</span> <span class="operator">=</span> (RegisterBrokerResponseHeader) response.readCustomHeader();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射创建 RegisterBrokerRequestHeader 对象，并且将 request.extFields 中的数据写入到该对象中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">RegisterBrokerRequestHeader</span> <span class="variable">requestHeader</span> <span class="operator">=</span> request.decodeCommandCustomHeader(RegisterBrokerRequestHeader.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CRC 校验，计算请求中的 CRC 值和请求头中包含的是否一致</span></span><br><span class="line">    <span class="keyword">if</span> (!checksum(ctx, request, requestHeader)) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(<span class="string">&quot;crc32 not match&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TopicConfigSerializeWrapper topicConfigWrapper;</span><br><span class="line">    <span class="keyword">if</span> (request.getBody() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 【解析请求体 body】，解码出来的数据就是当前机器的主题信息</span></span><br><span class="line">        topicConfigWrapper = TopicConfigSerializeWrapper.decode(request.getBody(), TopicConfigSerializeWrapper.class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        topicConfigWrapper = <span class="keyword">new</span> <span class="title class_">TopicConfigSerializeWrapper</span>();</span><br><span class="line">        topicConfigWrapper.getDataVersion().setCounter(<span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>));</span><br><span class="line">        topicConfigWrapper.getDataVersion().setTimestamp(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册方法</span></span><br><span class="line">    <span class="comment">// 参数1 集群、参数2：节点ip地址、参数3：brokerName、参数4：brokerId 注意brokerId=0的节点为主节点</span></span><br><span class="line">    <span class="comment">// 参数5：ha节点ip地址、参数6当前节点主题信息、参数7：过滤服务器列表、参数8：当前服务器和客户端通信的channel</span></span><br><span class="line">    <span class="type">RegisterBrokerResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.namesrvController.getRouteInfoManager().registerBroker(..);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结果信息 写到 responseHeader 中</span></span><br><span class="line">    responseHeader.setHaServerAddr(result.getHaServerAddr());</span><br><span class="line">    responseHeader.setMasterAddr(result.getMasterAddr());</span><br><span class="line">    <span class="comment">// 获取 kv配置，写入 response body 中，【kv 配置是顺序消息相关的】</span></span><br><span class="line">    <span class="type">byte</span>[] jsonValue = <span class="built_in">this</span>.namesrvController.getKvConfigManager().getKVListByNamespace(NamesrvUtil.NAMESPACE_ORDER_TOPIC);</span><br><span class="line">    response.setBody(jsonValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// code 设置为 SUCCESS</span></span><br><span class="line">    response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">    response.setRemark(<span class="literal">null</span>);</span><br><span class="line">	<span class="comment">// 返回 response ，【返回的 response 由 callback 对象处理】</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RouteInfoManager#registerBroker：注册 Broker 的信息</p>
<ul>
<li><p><code>RegisterBrokerResult result = new RegisterBrokerResult()</code>：返回结果的封装对象</p>
</li>
<li><p><code>this.lock.writeLock().lockInterruptibly()</code>：加写锁后<strong>同步执行</strong></p>
</li>
<li><p><code>brokerNames = this.clusterAddrTable.get(clusterName)</code>：获取当前集群上的 Broker 名称列表，是空就新建列表</p>
</li>
<li><p><code>brokerNames.add(brokerName)</code>：将当前 Broker 名字加入到集群列表</p>
</li>
<li><p><code>brokerData = this.brokerAddrTable.get(brokerName)</code>：获取当前 Broker 的 brokerData，是空就新建放入映射表</p>
</li>
<li><p><code>brokerAddrsMap = brokerData.getBrokerAddrs()</code>：获取当前 Broker 的物理节点 map 表，进行遍历，如果物理节点角色发生变化（slave → master），先将旧数据从物理节点 map 中移除，然后重写放入，<strong>保证节点的唯一性</strong></p>
</li>
<li><p><code>if (null != topicConfigWrapper &amp;&amp; MixAll.MASTER_ID == brokerId)</code>：Broker 上的 Topic 不为 null，并且当前物理节点是  Broker 上的 master 节点</p>
<p><code>tcTable = topicConfigWrapper.getTopicConfigTable()</code>：获取当前 Broker 信息中的主题映射表</p>
<p><code>if (tcTable != null)</code>：映射表不空就加入或者更新到 Namesrv 内</p>
</li>
<li><p><code> prevBrokerLiveInfo = this.brokerLiveTable.put(brokerAddr)</code>：添加<strong>当前节点的 BrokerLiveInfo</strong> ，返回上一次心跳时当前 Broker 节点的存活对象数据。<strong>NamesrvController  中的定时任务会扫描映射表 brokerLiveTable</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BrokerLiveInfo</span> <span class="variable">prevBrokerLiveInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.brokerLiveTable.put(brokerAddr, <span class="keyword">new</span> <span class="title class_">BrokerLiveInfo</span>(</span><br><span class="line">    System.currentTimeMillis(),topicConfigWrapper.getDataVersion(), channel,haServerAddr));</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>if (MixAll.MASTER_ID != brokerId)</code>：当前 Broker 不是 master 节点，<strong>获取主节点的信息</strong>设置到结果对象</p>
</li>
<li><p><code>this.lock.writeLock().unlock()</code>：释放写锁</p>
</li>
</ul>
<hr>
<h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><h4 id="MappedFile"><a href="#MappedFile" class="headerlink" title="MappedFile"></a>MappedFile</h4><h5 id="成员属性-1"><a href="#成员属性-1" class="headerlink" title="成员属性"></a>成员属性</h5><p>MappedFile 类是最基础的存储类，继承自 ReferenceResource 类，用来<strong>保证线程安全</strong></p>
<p>MappedFile 类成员变量：</p>
<ul>
<li><p>内存相关：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OS_PAGE_SIZE</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">4</span>;<span class="comment">// 内存页大小：默认是 4k</span></span><br><span class="line"><span class="keyword">private</span> AtomicLong TOTAL_MAPPED_VIRTUAL_MEMORY;	<span class="comment">// 当前进程下所有的 mappedFile 占用的总虚拟内存大小</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger TOTAL_MAPPED_FILES;		<span class="comment">// 当前进程下所有的 mappedFile 个数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数据位点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> AtomicInteger wrotePosition;	<span class="comment">// 当前 mappedFile 的数据写入点</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> AtomicInteger committedPosition;<span class="comment">// 当前 mappedFile 的数据提交点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger flushedPosition;	<span class="comment">// 数据落盘位点，在这之前的数据是持久化的安全数据</span></span><br><span class="line">												<span class="comment">// flushedPosition-wrotePosition 之间的数据属于脏页</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文件相关：CL 是 CommitLog，CQ 是 ConsumeQueue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String fileName;	<span class="comment">// 文件名称，CL和CQ文件名是【第一条消息的物理偏移量】，索引文件是【年月日时分秒】</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> fileFromOffset;<span class="comment">// 文件名转long，代表该对象的【起始偏移量】	</span></span><br><span class="line"><span class="keyword">private</span> File file;			<span class="comment">// 文件对象</span></span><br></pre></td></tr></table></figure>

<p><strong>MF 中以物理偏移量作为文件名，可以更好的寻址和进行判断</strong></p>
</li>
<li><p>内存映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> FileChannel fileChannel;			<span class="comment">// 文件通道</span></span><br><span class="line"><span class="keyword">private</span> MappedByteBuffer mappedByteBuffer;	<span class="comment">// 内存映射缓冲区，访问虚拟内存</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>ReferenceResource 类成员变量：</p>
<ul>
<li><p>引用数量：当 <code>refCount &lt;= 0</code> 时，表示该资源可以释放了，没有任何其他程序依赖它了，用原子类保证线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">refCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">1</span>);	<span class="comment">// 初始值为 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>存活状态：表示资源的存活状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">available</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>是否清理：默认值 false，当执行完子类对象的 cleanup() 清理方法后，该值置为 true ，表示资源已经全部释放</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">cleanupOver</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一次关闭资源的时间：用来记录超时时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">firstShutdownTimestamp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><p>MappedFile 类核心方法：</p>
<ul>
<li><p>appendMessage()：提供上层向内存映射中追加消息的方法，消息如何追加由 AppendMessageCallback 控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：消息     参数二：追加消息回调</span></span><br><span class="line"><span class="keyword">public</span> AppendMessageResult <span class="title function_">appendMessage</span><span class="params">(MessageExtBrokerInner msg, AppendMessageCallback cb)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字节数组写入到文件通道</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">appendMessage</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] data)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>flush()：刷盘接口，参数 flushLeastPages  代表刷盘的最小页数 ，等于 0 时属于强制刷盘；&gt; 0 时需要脏页（计算方法在数据位点）达到该值才进行物理刷盘；文件写满时强制刷盘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">flush</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> flushLeastPages)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>selectMappedBuffer()：该方法以 pos 为开始位点 ，到有效数据为止，创建一个切片 ByteBuffer 作为数据副本，供业务访问数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SelectMappedBufferResult <span class="title function_">selectMappedBuffer</span><span class="params">(<span class="type">int</span> pos)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>destroy()：销毁映射文件对象，并删除关联的系统文件，参数是强制关闭资源的时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">destroy</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> intervalForcibly)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>cleanup()：<strong>释放堆外内存</strong>，更新总虚拟内存和总内存映射文件数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cleanup</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> currentRef)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>warmMappedFile()：内存预热，当要新建的 MappedFile 对象大于 1g 时执行该方法。mappedByteBuffer 已经通过mmap映射，此时操作系统中只是记录了该文件和该 Buffer 的映射关系，而并没有映射到物理内存中，对该 MappedFile 的每个 Page Cache 进行写入一个字节分配内存，<strong>将映射文件全部加载到内存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">warmMappedFile</span><span class="params">(FlushDiskType type, <span class="type">int</span> pages)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mlock()：锁住指定的内存区域避免被操作系统调到 swap 空间，减少了缺页异常的产生</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mlock</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>swap space 是磁盘上的一块区域，可以是一个分区或者一个文件或者是组合。当系统物理内存不足时，Linux 会将内存中不常访问的数据保存到 swap 区域上，这样系统就可以有更多的物理内存为各个进程服务，而当系统需要访问 swap 上存储的内容时，需要通过<strong>缺页中断</strong>将 swap 上的数据加载到内存中</p>
</li>
</ul>
<p>ReferenceResource 类核心方法：</p>
<ul>
<li><p>hold()：增加引用记数 refCount，方法加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">hold</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>shutdown()：关闭资源，参数代表强制关闭资源的时间间隔</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 系统当前时间 - firstShutdownTimestamp 时间  &gt; intervalForcibly 进行【强制关闭】</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> intervalForcibly)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>release()：引用计数减 1，当 refCount  为 0 时，调用子类的 cleanup 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="MapQueue"><a href="#MapQueue" class="headerlink" title="MapQueue"></a>MapQueue</h4><h5 id="成员属性-2"><a href="#成员属性-2" class="headerlink" title="成员属性"></a>成员属性</h5><p>MappedFileQueue 用来管理 MappedFile 文件</p>
<p>成员变量：</p>
<ul>
<li><p>管理目录：CommitLog 是 <code>../store/commitlog</code>， ConsumeQueue 是 <code>../store/xxx_topic/0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String storePath;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mappedFileSize;	<span class="comment">// 目录下每个文件大小，CL文件默认 1g，CQ文件 默认 600w字节</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;MappedFile&gt; mappedFiles;	<span class="comment">//目录下的每个 mappedFile 都加入该集合</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数据位点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">flushedWhere</span> <span class="operator">=</span> <span class="number">0</span>;		<span class="comment">// 目录的刷盘位点，值为 mf.fileName + mf.wrotePosition</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">committedWhere</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">// 目录的提交位点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>消息存储：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">storeTimestamp</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">// 当前目录下最后一条 msg 的存储时间</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建服务：新建 MappedFile 实例，继承自 ServiceThread 是一个任务对象，run 方法用来创建实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AllocateMappedFileService allocateMappedFileService;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h5><p>核心方法：</p>
<ul>
<li><p>load()：Broker 启动时，加载本地磁盘数据，该方法读取 storePath 目录下的文件，创建 MappedFile 对象放入集合内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">load</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>getLastMappedFile()：获取当前正在顺序写入的 MappedFile 对象，如果最后一个 MappedFile 写满了，或者不存在 MappedFile 对象，则创建新的 MappedFile</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：文件起始偏移量；参数二：当list为空时，是否新建 MappedFile</span></span><br><span class="line"><span class="keyword">public</span> MappedFile <span class="title function_">getLastMappedFile</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> startOffset, <span class="type">boolean</span> needCreate)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>flush()：根据 flushedWhere 属性查找合适的 MappedFile，调用该 MappedFile 的落盘方法，并更新全局的 flushedWhere</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数：0 表示强制刷新， &gt; 0 脏页数据必须达到 flushLeastPages 才刷新</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">flush</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> flushLeastPages)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>findMappedFileByOffset()：根据偏移量查询对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> MappedFile <span class="title function_">findMappedFileByOffset</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> offset, <span class="keyword">final</span> <span class="type">boolean</span> returnFirstOnNotFound)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>deleteExpiredFileByTime()：CL 删除过期文件，根据文件的保留时长决定是否删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：过期时间； 参数二：删除两个文件之间的时间间隔； 参数三：mf.destory传递的参数； 参数四：true 强制删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteExpiredFileByTime</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> expiredTime,<span class="keyword">final</span> <span class="type">int</span> deleteFilesInterval, <span class="keyword">final</span> <span class="type">long</span> intervalForcibly, <span class="keyword">final</span> <span class="type">boolean</span> cleanImmediately)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>deleteExpiredFileByOffset()：CQ 删除过期文件，遍历每个 MF 文件，获取当前文件最后一个数据单元的物理偏移量，小于 offset 说明当前 MF 文件内都是过期数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：consumeLog 目录下最小物理偏移量，就是第一条消息的 offset； </span></span><br><span class="line"><span class="comment">// 参数二：ConsumerQueue 文件内每个数据单元固定大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteExpiredFileByOffset</span><span class="params">(<span class="type">long</span> offset, <span class="type">int</span> unitSize)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="CommitLog"><a href="#CommitLog" class="headerlink" title="CommitLog"></a>CommitLog</h4><h5 id="成员属性-3"><a href="#成员属性-3" class="headerlink" title="成员属性"></a>成员属性</h5><p>成员变量：</p>
<ul>
<li><p>魔数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MESSAGE_MAGIC_CODE</span> <span class="operator">=</span> -<span class="number">626843481</span>;	<span class="comment">// 消息的第一个字段是大小，第二个字段就是魔数	</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">BLANK_MAGIC_CODE</span> <span class="operator">=</span> -<span class="number">875286124</span>;	<span class="comment">// 文件尾消息的魔法值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>MappedFileQueue：用于管理 <code>../store/commitlog</code> 目录下的文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> MappedFileQueue mappedFileQueue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>存储服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> DefaultMessageStore defaultMessageStore;	<span class="comment">// 存储模块对象，上层服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FlushCommitLogService flushCommitLogService;	<span class="comment">// 刷盘服务，默认实现是异步刷盘</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>回调器：控制消息的哪些字段添加到 MappedFile</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AppendMessageCallback appendMessageCallback;</span><br></pre></td></tr></table></figure>
</li>
<li><p>队列偏移量字典表：key 是主题队列 id，value 是偏移量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HashMap&lt;String, Long&gt; topicQueueTable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Long&gt;(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>锁相关：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">beginTimeInLock</span> <span class="operator">=</span> <span class="number">0</span>;		 	<span class="comment">// 写数据时加锁的开始时间</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> PutMessageLock putMessageLock;		<span class="comment">// 写锁，两个实现类：自旋锁和重入锁</span></span><br></pre></td></tr></table></figure>

<p>因为发送消息是需要持久化的，在 Broker 端持久化时会获取该锁，<strong>保证发送的消息的线程安全</strong></p>
</li>
</ul>
<p>构造方法：</p>
<ul>
<li><p>有参构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CommitLog</span><span class="params">(<span class="keyword">final</span> DefaultMessageStore defaultMessageStore)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 MappedFileQueue 对象</span></span><br><span class="line">    <span class="comment">// 参数1：../store/commitlog； 参数2：【1g】； 参数3：allocateMappedFileService</span></span><br><span class="line">    <span class="built_in">this</span>.mappedFileQueue = <span class="keyword">new</span> <span class="title class_">MappedFileQueue</span>(...);</span><br><span class="line">    <span class="comment">// 默认 异步刷盘，创建这个对象</span></span><br><span class="line">   	<span class="built_in">this</span>.flushCommitLogService = <span class="keyword">new</span> <span class="title class_">FlushRealTimeService</span>();</span><br><span class="line">    <span class="comment">// 控制消息哪些字段追加到 mappedFile，【消息最大是 4M】</span></span><br><span class="line">   	<span class="built_in">this</span>.appendMessageCallback = <span class="keyword">new</span> <span class="title class_">DefaultAppendMessageCallback</span>(...);</span><br><span class="line">    <span class="comment">// 默认使用自旋锁</span></span><br><span class="line">    <span class="built_in">this</span>.putMessageLock = ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-2"><a href="#成员方法-2" class="headerlink" title="成员方法"></a>成员方法</h5><p>CommitLog 类核心方法：</p>
<ul>
<li><p>start()：会启动刷盘服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>shutdown()：关闭刷盘服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>load()：加载 CommitLog 目录下的文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">load</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>getMessage()：根据 offset 查询单条信息，返回的结果对象内部封装了一个 ByteBuffer，该 Buffer 表示 <code>[offset, offset + size]</code> 区间的 MappedFile 的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SelectMappedBufferResult <span class="title function_">getMessage</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> offset, <span class="keyword">final</span> <span class="type">int</span> size)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>deleteExpiredFile()：删除过期文件，方法由 DefaultMessageStore 的定时任务调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteExpiredFile</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>asyncPutMessage()：<strong>存储消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;PutMessageResult&gt; <span class="title function_">asyncPutMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>msg.setStoreTimestamp(System.currentTimeMillis())</code>：设置存储时间，后面获取到写锁后这个事件会重写</li>
<li><code>msg.setBodyCRC(UtilAll.crc32(msg.getBody()))</code>：获取消息的 CRC 值</li>
<li><code>topic、queueId</code>：获取主题和队列 ID</li>
<li><code>if (msg.getDelayTimeLevel() &gt; 0) </code>：<strong>获取消息的延迟级别，这里是延迟消息实现的关键</strong></li>
<li><code>topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC</code>：<strong>修改消息的主题为 <code>SCHEDULE_TOPIC_XXXX</code></strong></li>
<li><code>queueId = ScheduleMessageService.delayLevel2QueueId()</code>：<strong>队列 ID 为延迟级别 -1</strong></li>
<li><code>MessageAccessor.putProperty</code>：<strong>将原来的消息主题和 ID 存入消息的属性 <code>REAL_TOPIC</code> 中</strong></li>
<li><code>mappedFile = this.mappedFileQueue.getLastMappedFile()</code>：获取当前顺序写的 MappedFile 对象</li>
<li><code>putMessageLock.lock()</code>：<strong>获取写锁</strong></li>
<li><code>msg.setStoreTimestamp(beginLockTimestamp)</code>：设置消息的存储时间为获取锁的时间</li>
<li><code>if (null == mappedFile || mappedFile.isFull())</code>：文件写满了创建新的 MF 对象</li>
<li><code>result = mappedFile.appendMessage(msg, this.appendMessageCallback)</code>：<strong>消息追加</strong>，核心逻辑在回调器类</li>
<li><code>putMessageLock.unlock()</code>：释放写锁</li>
<li><code>this.defaultMessageStore.unlockMappedFile(..)</code>：将 MappedByteBuffer 从 lock 切换为 unlock 状态</li>
<li><code>putMessageResult = new PutMessageResult(PutMessageStatus.PUT_OK, result)</code>：结果封装</li>
<li><code>flushResultFuture = submitFlushRequest(result, msg)</code>：<strong>唤醒刷盘线程</strong></li>
<li><code>replicaResultFuture = submitReplicaRequest(result, msg)</code>：HA 消息同步</li>
</ul>
</li>
<li><p>recoverNormally()：正常关机时的恢复方法，存储模块启动时<strong>先恢复所有的 ConsumeQueue 数据，再恢复 CommitLog 数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数表示恢复阶段 ConsumeQueue 中已知的最大的消息 offset</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverNormally</span><span class="params">(<span class="type">long</span> maxPhyOffsetOfConsumeQueue)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>int index = mappedFiles.size() - 3</code>：从倒数第三个 file 开始向后恢复</p>
</li>
<li><p><code>dispatchRequest = this.checkMessageAndReturnSize()</code>：每次从切片内解析出一条 msg 封装成 DispatchRequest 对象</p>
</li>
<li><p><code>size = dispatchRequest.getMsgSize()</code>：获取消息的大小，检查 DispatchRequest 对象的状态</p>
<p>情况 1：正常数据，则 <code>mappedFileOffset += size</code></p>
<p>情况 2：文件尾数据，处理下一个文件，mappedFileOffset 置为 0，magic_code 表示文件尾</p>
</li>
<li><p><code>processOffset += mappedFileOffset</code>：计算出正确的数据存储位点，并设置 MappedFileQueue 的目录刷盘位点</p>
</li>
<li><p><code>this.mappedFileQueue.truncateDirtyFiles(processOffset)</code>：调整 MFQ 中文件的刷盘位点</p>
</li>
<li><p><code>if (maxPhyOffsetOfConsumeQueue &gt;= processOffset)</code>：删除冗余数据，将超过全局位点的 CQ 下的文件删除，将包含全局位点的 CQ 下的文件重新定位</p>
</li>
</ul>
</li>
<li><p>recoverAbnormally()：异常关机时的恢复方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverAbnormally</span><span class="params">(<span class="type">long</span> maxPhyOffsetOfConsumeQueue)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>int index = mappedFiles.size() - 1</code>：从尾部开始遍历 MFQ，验证 MF 的第一条消息，找到第一个验证通过的文件对象</li>
<li><code>dispatchRequest = this.checkMessageAndReturnSize()</code>：每次解析出一条 msg 封装成 DispatchRequest 对象</li>
<li><code>this.defaultMessageStore.doDispatch(dispatchRequest)</code>：<strong>重建 ConsumerQueue 和 Index，避免上次异常停机导致 CQ 和 Index 与 CommitLog 不对齐</strong></li>
<li>剩余逻辑与正常关机的恢复方法相似</li>
</ul>
</li>
</ul>
<hr>
<h5 id="服务线程"><a href="#服务线程" class="headerlink" title="服务线程"></a>服务线程</h5><p>AppendMessageCallback 消息追加服务实现类为 DefaultAppendMessageCallback</p>
<ul>
<li><p>doAppend()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AppendMessageResult <span class="title function_">doAppend</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>long wroteOffset = fileFromOffset + byteBuffer.position()</code>：消息写入的位置，物理偏移量 phyOffset</li>
<li><code>String msgId</code>：<strong>消息 ID，规则是客户端 IP + 消息偏移量 phyOffset</strong></li>
<li><code>byte[] topicData</code>：序列化消息，将消息的字段压入到  msgStoreItemMemory 这个 Buffer 中</li>
<li><code>byteBuffer.put(this.msgStoreItemMemory.array(), 0, msgLen)</code>：将 msgStoreItemMemory 中的数据写入 MF 对象的内存映射的 Buffer 中，数据还没落盘</li>
<li><code>AppendMessageResult result</code>：构造结果对象，包括存储位点、是否成功、队列偏移量等信息</li>
<li><code>CommitLog.this.topicQueueTable.put(key, ++queueOffset)</code>：更新队列偏移量</li>
</ul>
</li>
</ul>
<p>FlushRealTimeService 刷盘 CL 数据，默认是异步刷盘类 FlushRealTimeService</p>
<ul>
<li><p>run()：运行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>while (!this.isStopped())</code>：stopped为 true 才跳出循环</p>
</li>
<li><p><code>boolean flushCommitLogTimed</code>：控制线程的休眠方式，默认是 false，使用 <code>CountDownLatch.await()</code> 休眠，设置为 true 时使用 <code>Thread.sleep()</code> 休眠</p>
</li>
<li><p><code>int interval</code>：获取配置中的刷盘时间间隔</p>
</li>
<li><p><code>int flushPhysicQueueLeastPages</code>：<strong>获取最小刷盘页数，默认是 4 页</strong>，脏页达到指定页数才刷盘</p>
</li>
<li><p><code>int flushPhysicQueueThoroughInterval</code>：获取强制刷盘周期，默认是 10 秒，达到周期后强制刷盘，不考虑脏页</p>
</li>
<li><p><code>if (flushCommitLogTimed)</code>：<strong>休眠逻辑</strong>，避免 CPU 占用太长时间，导致无法执行其他更紧急的任务</p>
</li>
<li><p><code>CommitLog.this.mappedFileQueue.flush(flushPhysicQueueLeastPages)</code>：<strong>刷盘</strong></p>
</li>
<li><p><code>for (int i = 0; i &lt; RETRY_TIMES_OVER &amp;&amp; !result; i++)</code>：stopped 停止标记为 true 时，需要确保所有的数据都已经刷盘，所以此处尝试 10 次强制刷盘，</p>
<p><code>result = CommitLog.this.mappedFileQueue.flush(0)</code>：<strong>强制刷盘</strong></p>
</li>
</ul>
</li>
</ul>
<p>同步刷盘类 GroupCommitService</p>
<ul>
<li><p>run()：运行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>while (!this.isStopped())</code>：stopped为 true 才跳出循环</p>
<p><code>this.waitForRunning(10)</code>：线程休眠 10 毫秒，最后调用 <code>onWaitEnd()</code> 进行<strong>请求的交换</strong> <code>swapRequests()</code></p>
<p><code>this.doCommit()</code>：做提交逻辑</p>
<ul>
<li><p><code>if (!this.requestsRead.isEmpty()) </code>：读请求集合不为空</p>
<p><code>for (GroupCommitRequest req : this.requestsRead)</code>：遍历所有的读请求，请求中的属性：</p>
<ul>
<li><code>private final long nextOffset</code>：本条消息存储之后，下一条消息开始的 offset</li>
<li><code>private CompletableFuture&lt;PutMessageStatus&gt; flushOKFuture</code>：Future 对象</li>
</ul>
<p><code>boolean flushOK = ...</code>：当前请求关注的数据是否全部落盘，<strong>落盘成功唤醒消费者线程</strong></p>
<p><code>for (int i = 0; i &lt; 2 &amp;&amp; !flushOK; i++)</code>：尝试进行两次强制刷盘，保证刷盘成功</p>
<p><code>CommitLog.this.mappedFileQueue.flush(0)</code>：强制刷盘</p>
<p><code>req.wakeupCustomer(flushOK ? ...)</code>：设置 Future 结果，在 Future 阻塞的线程在这里会被唤醒</p>
<p><code>this.requestsRead.clear()</code>：清理 reqeustsRead 列表，方便交换时成为 requestsWrite 使用</p>
</li>
<li><p><code>else</code>：读请求集合为空</p>
<p><code>CommitLog.this.mappedFileQueue.flush(0)</code>：强制刷盘</p>
</li>
</ul>
</li>
<li><p><code>this.swapRequests()</code>：交换读写请求</p>
</li>
<li><p><code>this.doCommit()</code>：交换后做一次提交</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="ConsQueue"><a href="#ConsQueue" class="headerlink" title="ConsQueue"></a>ConsQueue</h4><h5 id="成员属性-4"><a href="#成员属性-4" class="headerlink" title="成员属性"></a>成员属性</h5><p>ConsumerQueue 是消息消费队列，存储消息在 CommitLog 的索引，便于快速定位消息</p>
<p>成员变量：</p>
<ul>
<li><p>数据单元：ConsumerQueueData 数据单元的固定大小是 20 字节，默认申请 20 字节的缓冲区</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CQ_STORE_UNIT_SIZE</span> <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件管理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MappedFileQueue mappedFileQueue;	<span class="comment">// 文件管理器，管理 CQ 目录下的文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String storePath;					<span class="comment">// 目录，比如../store/consumequeue/xxx_topic/0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mappedFileSize;				<span class="comment">// 每一个 CQ 存储文件大小，默认 20 * 30w = 600w byte</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>存储主模块：上层的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultMessageStore defaultMessageStore;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String topic;					<span class="comment">// CQ 主题</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> queueId;					<span class="comment">// CQ 队列，每一个队列都有一个 ConsumeQueue 对象进行管理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer byteBufferIndex;	<span class="comment">// 临时缓冲区，插新的 CQData 时使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">maxPhysicOffset</span> <span class="operator">=</span> -<span class="number">1</span>;			<span class="comment">// 当前ConsumeQueue内存储的最大消息物理偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">minLogicOffset</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">// 当前ConsumeQueue内存储的最小消息物理偏移量</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>构造方法：</p>
<ul>
<li><p>有参构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConsumeQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 申请了一个 20 字节大小的 临时缓冲区</span></span><br><span class="line">    <span class="built_in">this</span>.byteBufferIndex = ByteBuffer.allocate(CQ_STORE_UNIT_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-3"><a href="#成员方法-3" class="headerlink" title="成员方法"></a>成员方法</h5><p>ConsumeQueue 启动阶段方法：</p>
<ul>
<li>load()：第一步，加载 storePath 目录下的文件，初始化 MappedFileQueue</li>
<li>recover()：第二步，恢复 ConsumeQueue 数据<ul>
<li>从倒数第三个 MF 文件开始向后遍历，依次读取 MF 中 20 个字节的 CQData 数据，检查 offset 和 size 是否是有效数据</li>
<li>找到无效的 CQData 的位点，该位点就是 CQ 的刷盘点和数据顺序写入点</li>
<li>删除无效的 MF 文件，调整当前顺序写的 MF 文件的数据位点</li>
</ul>
</li>
</ul>
<p>其他方法：</p>
<ul>
<li><p>truncateDirtyLogicFiles()：CommitLog 恢复阶段调用，将 ConsumeQueue 有效数据文件与 CommitLog 对齐，将超出部分的数据文删除掉，并调整当前文件的数据位点。Broker 启动阶段先恢复 CQ 的数据，再恢复 CL 数据，但是<strong>数据要以 CL 为基准</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是最大消息物理偏移量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">truncateDirtyLogicFiles</span><span class="params">(<span class="type">long</span> phyOffet)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>flush()：刷盘，调用 MFQ 的刷盘方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">flush</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> flushLeastPages)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>deleteExpiredFile()：删除过期文件，将小于 offset 的所有 MF 文件删除，offset 是 CommitLog 目录下最小的物理偏移量，小于该值的 CL 文件已经没有了，所以 CQ 也没有存在的必要</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteExpiredFile</span><span class="params">(<span class="type">long</span> offset)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>putMessagePositionInfoWrapper()：<strong>向 CQ 中追加 CQData 数据</strong>，由存储主模块 DefaultMessageStore 内部的异步线程调用，负责构建 ConsumeQueue 文件和 Index 文件的，该线程会持续关注 CommitLog 文件，当 CommitLog 文件内有新数据写入，就读出来封装成 DispatchRequest 对象，转发给 ConsumeQueue 或者 IndexService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putMessagePositionInfoWrapper</span><span class="params">(DispatchRequest request)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>getIndexBuffer()：转换 startIndex 为 offset，获取包含该 offset 的 MappedFile 文件，读取 <code>[offset%maxSize, mfPos]</code> 范围的数据，包装成结果对象返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SelectMappedBufferResult <span class="title function_">getIndexBuffer</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> startIndex)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="IndexFile"><a href="#IndexFile" class="headerlink" title="IndexFile"></a>IndexFile</h4><h5 id="成员属性-5"><a href="#成员属性-5" class="headerlink" title="成员属性"></a>成员属性</h5><p>IndexFile 类成员属性</p>
<ul>
<li><p>哈希：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">hashSlotSize</span> <span class="operator">=</span> <span class="number">4</span>;	<span class="comment">// 每个 hash 桶的大小是 4 字节，【用来存放索引的编号】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> hashSlotNum;			<span class="comment">// hash 桶的个数，默认 500 万</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>索引：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">indexSize</span> <span class="operator">=</span> <span class="number">20</span>;		<span class="comment">// 每个 index 条目的大小是 20 字节</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">invalidIndex</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">// 无效索引编号：0 特殊值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> indexNum;				<span class="comment">// 默认值：2000w</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IndexHeader indexHeader;	<span class="comment">// 索引头</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MappedFile mappedFile;			<span class="comment">// 【索引文件使用的 MF 文件】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FileChannel fileChannel;			<span class="comment">// 文件通道</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MappedByteBuffer mappedByteBuffer;<span class="comment">// 从 MF 中获取的内存映射缓冲区</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>构造方法：</p>
<ul>
<li><p>有参构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// endPhyOffset 上个索引文件 最后一条消息的 物理偏移量</span></span><br><span class="line"><span class="comment">// endTimestamp 上个索引文件 最后一条消息的 存储时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">IndexFile</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="type">int</span> hashSlotNum, <span class="keyword">final</span> <span class="type">int</span> indexNum,</span></span><br><span class="line"><span class="params">                 <span class="keyword">final</span> <span class="type">long</span> endPhyOffset, <span class="keyword">final</span> <span class="type">long</span> endTimestamp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 文件大小 40 + 500w * 4 + 2000w * 20</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">fileTotalSize</span> <span class="operator">=</span></span><br><span class="line">        IndexHeader.INDEX_HEADER_SIZE + (hashSlotNum * hashSlotSize) + (indexNum * indexSize);</span><br><span class="line">    <span class="comment">// 创建 mf 对象，会在disk上创建文件</span></span><br><span class="line">    <span class="built_in">this</span>.mappedFile = <span class="keyword">new</span> <span class="title class_">MappedFile</span>(fileName, fileTotalSize);</span><br><span class="line">    <span class="comment">// 创建 索引头对象，传递 索引文件mf 的切片数据</span></span><br><span class="line">    <span class="built_in">this</span>.indexHeader = <span class="keyword">new</span> <span class="title class_">IndexHeader</span>(byteBuffer);</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-4"><a href="#成员方法-4" class="headerlink" title="成员方法"></a>成员方法</h5><p>IndexFile 类方法</p>
<ul>
<li><p>load()：加载 IndexHeader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>flush()：MappedByteBuffer 内的数据强制落盘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>isWriteFull()：检查当前的 IndexFile 已写索引数是否 &gt;&#x3D; indexNum，达到该值则当前 IndexFile 不能继续追加 IndexData 了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isWriteFull</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>destroy()：删除文件时使用的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">destroy</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> intervalForcibly)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>putKey()：添加索引数据，解决哈希冲突使用<strong>头插法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：消息的 key，uniq_key 或者 keys=&quot;aaa bbb ccc&quot; 会分别为 aaa bbb ccc 创建索引</span></span><br><span class="line"><span class="comment">// 参数二：消息的物理偏移量；  参数三：消息存储时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">putKey</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="type">long</span> phyOffset, <span class="keyword">final</span> <span class="type">long</span> storeTimestamp)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>int slotPos = keyHash % this.hashSlotNum</code>：对 key 计算哈希后，取模得到对应的哈希槽 slot 下标，然后计算出哈希槽的存储位置 absSlotPos</li>
<li><code>int slotValue = this.mappedByteBuffer.getInt(absSlotPos)</code>：获取槽中的值，如果是无效值说明没有哈希冲突</li>
<li><code>timeDiff = timeDiff / 1000</code>：计算当前 msg 存储时间减去索引文件内第一条消息存储时间的差值，转化为秒进行存储</li>
<li><code>int absIndexPos</code>：计算当前索引数据存储的位置，开始填充索引数据到对应的位置</li>
<li><code>this.mappedByteBuffer.putInt(absIndexPos + 4 + 8 + 4, slotValue)</code>：<strong>hash 桶的原值，头插法</strong></li>
<li><code>this.mappedByteBuffer.putInt(absSlotPos, this.indexHeader...)</code>：在 slot 放入当前索引的索引编号</li>
<li><code>if (this.indexHeader.getIndexCount() &lt;= 1)</code>：索引文件插入的第一条数据，需要设置起始偏移量和存储时间</li>
<li><code>if (invalidIndex == slotValue)</code>：没有哈希冲突，说明占用了一个新的 hash slot</li>
<li><code>this.indexHeader</code>：设置索引头的相关属性</li>
</ul>
</li>
<li><p>selectPhyOffset()：从索引文件查询消息的物理偏移量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：查询结果全部放到该list内； 参数二：查询key； 参数三：结果最大数限制； 参数四五：时间范围</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectPhyOffset</span><span class="params">(<span class="keyword">final</span> List&lt;Long&gt; phyOffsets, <span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="type">int</span> maxNum,<span class="keyword">final</span> <span class="type">long</span> begin, <span class="keyword">final</span> <span class="type">long</span> end, <span class="type">boolean</span> lock)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>if (this.mappedFile.hold())</code>： MF 的引用记数 +1，查询期间 MF 资源<strong>不能被释放</strong></li>
<li><code>int slotValue = this.mappedByteBuffer.getInt(absSlotPos)</code>：获取槽中的值，可能是无效值或者索引编号，如果是无效值说明查询未命中</li>
<li><code>int absIndexPos</code>：计算出索引编号对应索引数据的开始位点</li>
<li><code>this.mappedByteBuffer</code>：读取索引数据</li>
<li><code>long timeRead = this.indexHeader.getBeginTimestamp() + timeDiff</code>：计算出准确的存储时间</li>
<li><code>boolean timeMatched = (timeRead &gt;= begin) &amp;&amp; (timeRead &lt;= end)</code>：时间范围的匹配</li>
<li><code>phyOffsets.add(phyOffsetRead)</code>：将命中的消息索引的消息偏移量加入到 list 集合中</li>
<li><code>nextIndexToRead = prevIndexRead</code>：遍历前驱节点</li>
</ul>
</li>
</ul>
<hr>
<h4 id="IndexServ"><a href="#IndexServ" class="headerlink" title="IndexServ"></a>IndexServ</h4><h5 id="成员属性-6"><a href="#成员属性-6" class="headerlink" title="成员属性"></a>成员属性</h5><p>IndexService 类用来管理 IndexFile 文件</p>
<p>成员变量：</p>
<ul>
<li><p>存储主模块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultMessageStore defaultMessageStore;</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引文件存储目录：<code>../store/index</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String storePath;</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引对象集合：目录下的每个文件都有一个 IndexFile 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IndexFile&gt; indexFileList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;IndexFile&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> hashSlotNum;		<span class="comment">// 每个索引文件包含的 哈希桶数量 ：500w</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> indexNum;			<span class="comment">// 每个索引文件包含的 索引条目数量 ：2000w</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-5"><a href="#成员方法-5" class="headerlink" title="成员方法"></a>成员方法</h5><ul>
<li><p>load()：加载 storePath 目录下的文件，为每个文件创建一个 IndexFile 实例对象，并加载 IndexHeader 信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">load</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> lastExitOK)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>deleteExpiredFile()：删除过期索引文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数 offset 表示 CommitLog 内最早的消息的 phyOffset</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteExpiredFile</span><span class="params">(<span class="type">long</span> offset)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.readWriteLock.readLock().lock()</code>：加锁判断</li>
<li><code>long endPhyOffset = this.indexFileList.get(0).getEndPhyOffset()</code>：获取目录中第一个文件的结束偏移量</li>
<li><code>if (endPhyOffset &lt; offset)</code>：索引目录内存在过期的索引文件，并且当前的 IndexFile 都是过期的数据</li>
<li><code>for (int i = 0; i &lt; (files.length - 1); i++)</code>：遍历文件列表，删除过期的文件</li>
</ul>
</li>
<li><p>buildIndex()：存储主模块 DefaultMessageStore 内部的异步线程调用，构建 Index 数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildIndex</span><span class="params">(DispatchRequest req)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>indexFile = retryGetAndCreateIndexFile()</code>：获取或者创建顺序写的索引文件对象</p>
</li>
<li><p><code>buildKey(topic, req.getUniqKey())</code>：<strong>构建索引 key，<code>topic + # + uniqKey</code></strong></p>
</li>
<li><p><code>indexFile = putKey()</code>：插入索引文件</p>
</li>
<li><p><code>if (keys != null &amp;&amp; keys.length() &gt; 0)</code>：消息存在自定义索引 keys</p>
<p><code>for (int i = 0; i &lt; keyset.length; i++)</code>：遍历每个索引，为每个 key 调用一次 putKey</p>
</li>
</ul>
</li>
<li><p>getAndCreateLastIndexFile()：获取当前顺序写的 IndexFile，没有就创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> IndexFile <span class="title function_">getAndCreateLastIndexFile</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="HAService"><a href="#HAService" class="headerlink" title="HAService"></a>HAService</h4><h5 id="HAService-1"><a href="#HAService-1" class="headerlink" title="HAService"></a>HAService</h5><h6 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h6><p>HAService 类成员变量：</p>
<ul>
<li><p>主节点属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// master 节点当前有多少个 slave 节点与其进行数据同步</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">connectionCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// master 节点会给每个发起连接的 slave 节点的通道创建一个 HAConnection，【控制 master 端向 slave 端传输数据】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;HAConnection&gt; connectionList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// master 向 slave 节点推送的最大的 offset，表示数据同步的进度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">push2SlaveMaxOffset</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>内部类属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装了绑定服务器指定端口，监听 slave 的连接的逻辑，没有使用 Netty，使用了原生态的 NIO 去做</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AcceptSocketService acceptSocketService;</span><br><span class="line"><span class="comment">// 控制生产者线程阻塞等待的逻辑</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> GroupTransferService groupTransferService;</span><br><span class="line"><span class="comment">// slave 节点的客户端对象，【slave 端才会正常运行该实例】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HAClient haClient;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程通信对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">WaitNotifyObject</span> <span class="variable">waitNotifyObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitNotifyObject</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>成员方法：</p>
<ul>
<li><p>start()：启动高可用服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 监听从节点</span></span><br><span class="line">    <span class="built_in">this</span>.acceptSocketService.beginAccept();</span><br><span class="line">    <span class="comment">// 启动监听服务</span></span><br><span class="line">    <span class="built_in">this</span>.acceptSocketService.start();</span><br><span class="line">    <span class="comment">// 启动转移服务</span></span><br><span class="line">    <span class="built_in">this</span>.groupTransferService.start();</span><br><span class="line">    <span class="comment">// 启动从节点客户端实例</span></span><br><span class="line">    <span class="built_in">this</span>.haClient.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h6><p>AcceptSocketService 类用于<strong>监听从节点的连接</strong>，创建 HAConnection 连接对象</p>
<p>成员变量：</p>
<ul>
<li><p>端口信息：Master 绑定监听的端口信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SocketAddress socketAddressListen;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端通道：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ServerSocketChannel serverSocketChannel;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多路复用器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Selector selector;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>成员方法：</p>
<ul>
<li><p>beginAccept()：开始监听连接，<strong>NIO</strong> 标准模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beginAccept</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>run()：服务启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.selector.select(1000)</code>：多路复用器阻塞获取就绪的通道，最多等待 1 秒钟</li>
<li><code>Set&lt;SelectionKey&gt; selected = this.selector.selectedKeys()</code>：获取选择器中所有注册的通道中已经就绪好的事件</li>
<li><code>for (SelectionKey k : selected)</code>：遍历所有就绪的事件</li>
<li><code>if ((k.readyOps() &amp; SelectionKey.OP_ACCEPT) != 0)</code>：说明 <code>OP_ACCEPT</code> 事件就绪</li>
<li><code>SocketChannel sc = ((ServerSocketChannel) k.channel()).accept()</code>：<strong>获取到客户端连接的通道</strong></li>
<li><code>HAConnection conn = new HAConnection(HAService.this, sc)</code>：<strong>为每个连接 master 服务器的 slave 创建连接对象</strong></li>
<li><code>conn.start()</code>：<strong>启动 HAConnection 对象</strong>，内部启动两个服务为读数据服务、写数据服务</li>
<li><code>HAService.this.addConnection(conn)</code>：加入到 HAConnection 集合内</li>
</ul>
</li>
</ul>
<hr>
<h6 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h6><p>GroupTransferService 用来控制数据同步</p>
<p>成员方法：</p>
<ul>
<li><p>doWaitTransfer()：等待主从数据同步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doWaitTransfer</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>if (!this.requestsRead.isEmpty())</code>：读请求不为空</li>
<li><code>boolean transferOK = HAService.this.push2SlaveMaxOffset... &gt;= req.getNextOffset()</code>：<strong>主从同步是否完成</strong></li>
<li><code>req.wakeupCustomer(transferOK ? ...)</code>：唤醒消费者</li>
<li><code>this.requestsRead.clear()</code>：清空读请求</li>
</ul>
</li>
<li><p>swapRequests()：交换读写请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapRequests</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="HAClient"><a href="#HAClient" class="headerlink" title="HAClient"></a>HAClient</h5><h6 id="成员属性-7"><a href="#成员属性-7" class="headerlink" title="成员属性"></a>成员属性</h6><p>HAClient 是 slave 端运行的代码，用于<strong>和 master 服务器建立长连接</strong>，上报本地同步进度，消费服务器发来的 msg 数据</p>
<p>成员变量：</p>
<ul>
<li><p>缓冲区：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">READ_MAX_BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;	<span class="comment">// 默认大小：4 MB</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ByteBuffer</span> <span class="variable">byteBufferRead</span> <span class="operator">=</span> ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);</span><br><span class="line"><span class="keyword">private</span> <span class="type">ByteBuffer</span> <span class="variable">byteBufferBackup</span> <span class="operator">=</span> ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>主节点地址：格式为 <code>ip:port</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;String&gt; masterAddress = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;()</span><br></pre></td></tr></table></figure>
</li>
<li><p>NIO 属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer reportOffset;	<span class="comment">// 通信使用NIO，所以消息使用块传输，上报 slave offset 使用</span></span><br><span class="line"><span class="keyword">private</span> SocketChannel socketChannel;	<span class="comment">// 客户端与 master 的会话通道				</span></span><br><span class="line"><span class="keyword">private</span> Selector selector;				<span class="comment">// 多路复用器</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通信时间：上次会话通信时间，用于控制 socketChannel 是否关闭的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastWriteTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br></pre></td></tr></table></figure>
</li>
<li><p>进度信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">currentReportedOffset</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">// slave 当前的进度信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">dispatchPosition</span> <span class="operator">=</span> <span class="number">0</span>;		<span class="comment">// 控制 byteBufferRead position 指针</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="成员方法-6"><a href="#成员方法-6" class="headerlink" title="成员方法"></a>成员方法</h6><ul>
<li><p>run()：启动方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>if (this.connectMaster())</code>：连接主节点，连接失败会休眠 5 秒</p>
<ul>
<li><code>String addr = this.masterAddress.get()</code>：获取 master 暴露的 HA 地址端口信息</li>
<li><code>this.socketChannel = RemotingUtil.connect(socketAddress)</code>：建立连接</li>
<li><code>this.socketChannel.register(this.selector, SelectionKey.OP_READ)</code>：注册到多路复用器，<strong>关注读事件</strong></li>
<li><code>this.currentReportedOffset</code>： 初始化上报进度字段为 slave 的 maxPhyOffset</li>
</ul>
</li>
<li><p><code>if (this.isTimeToReportOffset())</code>：slave 每 5 秒会上报一次 slave 端的同步进度信息给 master</p>
<p><code>boolean result = this.reportSlaveMaxOffset()</code>：<strong>上报同步信息</strong>，上报失败关闭连接</p>
</li>
<li><p><code>this.selector.select(1000)</code>：多路复用器阻塞获取就绪的通道，最多等待 1 秒钟，<strong>获取到就绪事件或者超时后结束</strong></p>
</li>
<li><p><code>boolean ok = this.processReadEvent()</code>：处理读事件</p>
</li>
<li><p><code>if (!reportSlaveMaxOffsetPlus())</code>：检查是否重新上报同步进度</p>
</li>
</ul>
</li>
<li><p>reportSlaveMaxOffset()：上报 slave 同步进度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">reportSlaveMaxOffset</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> maxOffset)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先向缓冲区写入 slave 端最大偏移量，写完以后切换为指定置为初始状态</p>
</li>
<li><p><code>for (int i = 0; i &lt; 3 &amp;&amp; this.reportOffset.hasRemaining(); i++)</code>：尝试三次写数据</p>
<p><code>this.socketChannel.write(this.reportOffset)</code>：<strong>写数据</strong></p>
</li>
<li><p><code>return !this.reportOffset.hasRemaining()</code>：写成功之后 pos &#x3D; limit</p>
</li>
</ul>
</li>
<li><p>processReadEvent()：处理 master 发送给 slave 数据，返回 true 表示处理成功   false 表示 Socket 处于半关闭状态，需要上层重建 haClient</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">processReadEvent</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>int readSizeZeroTimes = 0</code>：控制 while 循环的一个条件变量，当值为 3 时跳出循环</p>
</li>
<li><p><code>while (this.byteBufferRead.hasRemaining())</code>：byteBufferRead 有空间可以去 Socket 读缓冲区加载数据</p>
</li>
<li><p><code>int readSize = this.socketChannel.read(this.byteBufferRead)</code>：<strong>从通道读数据</strong></p>
</li>
<li><p><code>if (readSize &gt; 0)</code>：加载成功，有新数据</p>
<p><code>readSizeZeroTimes = 0</code>：置为 0</p>
<p><code>boolean result = this.dispatchReadRequest()</code>：处理数据的核心逻辑</p>
</li>
<li><p><code>else if (readSize == 0) </code>：连续无新数据 3 次，跳出循环</p>
</li>
<li><p><code>else</code>：readSize &#x3D; -1 就表示 Socket 处于半关闭状态，对端已经关闭了</p>
</li>
</ul>
</li>
<li><p>dispatchReadRequest()：<strong>处理数据的核心逻辑</strong>，master 与 slave 传输的数据格式 <code>&#123;[phyOffset][size][data...]&#125;</code>，phyOffset 表示数据区间的开始偏移量，data 代表数据块，最大 32kb，可能包含多条消息的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dispatchReadRequest</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>final int msgHeaderSize = 8 + 4</code>：协议头大小 12</p>
</li>
<li><p><code>int readSocketPos = this.byteBufferRead.position()</code>：记录缓冲区处理数据前的 pos 位点，用于恢复指针</p>
</li>
<li><p><code>int diff = ...</code>：当前 byteBufferRead 还剩多少 byte 未处理，每处理一条帧数据都会更新 dispatchPosition</p>
</li>
<li><p><code>if (diff &gt;= msgHeaderSize)</code>：缓冲区还有完整的协议头 header 数据</p>
</li>
<li><p><code>if (diff &gt;= (msgHeaderSize + bodySize))</code>：说明<strong>缓冲区内是包含当前帧的全部数据的</strong>，开始处理帧数据 </p>
<p><code>HAService...appendToCommitLog(masterPhyOffset, bodyData)</code>：<strong>存储数据到 CommitLog</strong>，并构建 Index 和 CQ</p>
<p><code>this.byteBufferRead.position(readSocketPos)</code>：恢复 byteBufferRead 的 pos 指针</p>
<p><code>this.dispatchPosition += msgHeaderSize + bodySize</code>：加一帧数据长度，处理下一条数据使用</p>
<p><code>if (!reportSlaveMaxOffsetPlus())</code>：上报 slave 同步信息</p>
</li>
<li><p><code>if (!this.byteBufferRead.hasRemaining())</code>：缓冲区写满了，重新分配缓冲区</p>
</li>
</ul>
</li>
<li><p>reallocateByteBuffer()：重新分配缓冲区</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reallocateByteBuffer</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>int remain = READ_MAX_BUFFER_SIZE - this.dispatchPosition</code>：表示缓冲区尚未处理过的字节数量</p>
</li>
<li><p><code>if (remain &gt; 0)</code>：条件成立，说明缓冲区<strong>最后一帧数据是半包数据</strong>，但是不能丢失数据</p>
<p><code>this.byteBufferBackup.put(this.byteBufferRead)</code>：<strong>将半包数据拷贝到 backup 缓冲区</strong></p>
</li>
<li><p><code>this.swapByteBuffer()</code>：交换 backup 成为 read</p>
</li>
<li><p><code>this.byteBufferRead.position(remain)</code>：设置 pos 为 remain ，后续加载数据 pos 从remain 开始向后移动</p>
</li>
<li><p><code>this.dispatchPosition = 0</code>：当前缓冲区交换之后，相当于是一个全新的 byteBuffer，所以分配指针归零</p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="HAConn"><a href="#HAConn" class="headerlink" title="HAConn"></a>HAConn</h5><h6 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h6><p>HAConnection 类成员变量：</p>
<ul>
<li><p>会话通道：master 和 slave 之间通信的 SocketChannel </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SocketChannel socketChannel;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端地址：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String clientAddr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> WriteSocketService writeSocketService;	<span class="comment">// 写数据服务</span></span><br><span class="line"><span class="keyword">private</span> ReadSocketService readSocketService;	<span class="comment">// 读数据服务</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>请求位点：在 slave 上报本地的进度之后被赋值，该值大于 0 后同步逻辑才会运行，master 如果不知道 slave 节点当前消息的存储进度，就无法给 slave 推送数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">slaveRequestOffset</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应答位点： 保存最新的 slave 上报的 offset 信息，slaveAckOffset 之前的数据都可以认为 slave 已经同步完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">slaveAckOffset</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>核心方法：</p>
<ul>
<li><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HAConnection</span><span class="params">(<span class="keyword">final</span> HAService haService, <span class="keyword">final</span> SocketChannel socketChannel)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一些东西</span></span><br><span class="line">    <span class="comment">// 设置 socket 读写缓冲区为 64kb 大小</span></span><br><span class="line">    <span class="built_in">this</span>.socketChannel.socket().setReceiveBufferSize(<span class="number">1024</span> * <span class="number">64</span>);</span><br><span class="line">    <span class="built_in">this</span>.socketChannel.socket().setSendBufferSize(<span class="number">1024</span> * <span class="number">64</span>);</span><br><span class="line">    <span class="comment">// 创建读写服务</span></span><br><span class="line">    <span class="built_in">this</span>.writeSocketService = <span class="keyword">new</span> <span class="title class_">WriteSocketService</span>(<span class="built_in">this</span>.socketChannel);</span><br><span class="line">    <span class="built_in">this</span>.readSocketService = <span class="keyword">new</span> <span class="title class_">ReadSocketService</span>(<span class="built_in">this</span>.socketChannel);</span><br><span class="line">    <span class="comment">// 自增</span></span><br><span class="line">    <span class="built_in">this</span>.haService.getConnectionCount().incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.readSocketService.start();</span><br><span class="line">    <span class="built_in">this</span>.writeSocketService.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="ReadSocket"><a href="#ReadSocket" class="headerlink" title="ReadSocket"></a>ReadSocket</h6><p>ReadSocketService 类是一个任务对象，slave 向 master 传输的帧格式为 <code>[long][long][long]</code>，上报的是 slave 本地的同步进度，同步进度是一个 long 值</p>
<p>成员变量：</p>
<ul>
<li><p>读缓冲：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">READ_MAX_BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;	<span class="comment">// 默认大小 1MB</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ByteBuffer</span> <span class="variable">byteBufferRead</span> <span class="operator">=</span> ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>NIO 属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Selector selector;			<span class="comment">// 多路复用器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SocketChannel socketChannel;	<span class="comment">// master 与 slave 之间的会话 SocketChannel</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>处理位点：缓冲区处理位点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">processPosition</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上次读操作的时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">lastReadTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>核心方法：</p>
<ul>
<li><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReadSocketService</span><span class="params">(<span class="keyword">final</span> SocketChannel socketChannel)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.socketChannel.register(this.selector, SelectionKey.OP_READ)</code>：通道注册到多路复用器，关注读事件</li>
<li><code>this.setDaemon(true)</code>：设置为守护线程</li>
</ul>
</li>
<li><p>运行方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>this.selector.select(1000)</code>：多路复用器阻塞获取就绪的通道，最多等待 1 秒钟，获取到就绪事件或者超时后结束</p>
</li>
<li><p><code>boolean ok = this.processReadEvent()</code>：<strong>读数据的核心方法</strong>，返回 true 表示处理成功   false 表示 Socket 处于半关闭状态，需要上层重建 HAConnection 对象</p>
<ul>
<li><p><code>int readSizeZeroTimes = 0</code>：控制 while 循环，当连续从 Socket 读取失败 3 次（未加载到数据）跳出循环</p>
</li>
<li><p><code>if (!this.byteBufferRead.hasRemaining())</code>：byteBufferRead 已经全部使用完，需要清理数据并更新位点</p>
</li>
<li><p><code>while (this.byteBufferRead.hasRemaining())</code>：byteBufferRead 有空间可以去 Socket 读缓冲区加载数据</p>
</li>
<li><p><code>int readSize = this.socketChannel.read(this.byteBufferRead)</code>：<strong>从通道读数据</strong></p>
</li>
<li><p><code>if (readSize &gt; 0)</code>：加载成功，有新数据</p>
<p><code>if ((byteBufferRead.position() - processPosition) &gt;= 8)</code>：缓冲区的可读数据最少包含一个数据帧</p>
<ul>
<li><code>int pos = ...</code>：<strong>获取可读帧数据中最后一个完整的帧数据的位点，后面的数据丢弃</strong></li>
</ul>
</li>
<li><p><code>long readOffset = ...byteBufferRead.getLong(pos - 8)</code>：读取最后一帧数据，slave 端当前的同步进度信息</p>
<ul>
<li><code>this.processPosition = pos</code>：更新处理位点</li>
<li><code>HAConnection.this.slaveAckOffset = readOffset</code>：更新应答位点</li>
<li><code>if (HAConnection.this.slaveRequestOffset &lt; 0)</code>：条件成立<strong>给 slaveRequestOffset 赋值</strong></li>
<li><code>HAConnection...notifyTransferSome(slaveAckOffset)</code>：<strong>唤醒阻塞的生产者线程</strong></li>
</ul>
</li>
<li><p><code>else if (readSize == 0) </code>：读取 3 次无新数据跳出循环</p>
</li>
<li><p><code>else</code>：readSize &#x3D; -1 就表示 Socket 处于半关闭状态，对端已经关闭了</p>
</li>
</ul>
</li>
<li><p><code>if (interval &gt; 20)</code>：超过 20 秒未发生通信，直接结束循环</p>
</li>
</ul>
</li>
</ul>
<hr>
<h6 id="WriteSocket"><a href="#WriteSocket" class="headerlink" title="WriteSocket"></a>WriteSocket</h6><p>WriteSocketService 类是一个任务对象，master 向 slave 传输的数据帧格式为 <code>&#123;[phyOffset][size][data...]&#125;&#123;[phyOffset][size][data...]&#125;</code></p>
<ul>
<li>phyOffset：数据区间的开始偏移量，并不表示某一条具体的消息，表示的数据块开始的偏移量位置</li>
<li>size：同步的数据块的大小</li>
<li>data：数据块，最大 32kb，可能包含多条消息的数据</li>
</ul>
<p>成员变量：</p>
<ul>
<li><p>协议头：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">headerSize</span> <span class="operator">=</span> <span class="number">8</span> + <span class="number">4</span>;		<span class="comment">// 协议头大小：12</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer byteBufferHeader;	<span class="comment">// 帧头缓冲区</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>NIO 属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Selector selector;			<span class="comment">// 多路复用器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SocketChannel socketChannel;	<span class="comment">// master 与 slave 之间的会话 SocketChannel</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>处理位点：下一次传输同步数据的位置信息，master 给当前 slave 同步的位点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">nextTransferFromWhere</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上次写操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">lastWriteOver</span> <span class="operator">=</span> <span class="literal">true</span>;							<span class="comment">// 上一轮数据是否传输完毕</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastWriteTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();	<span class="comment">// 上次写操作的时间</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>核心方法：</p>
<ul>
<li><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">WriteSocketService</span><span class="params">(<span class="keyword">final</span> SocketChannel socketChannel)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.socketChannel.register(this.selector, SelectionKey.OP_WRITE)</code>：通道注册到多路复用器，关注写事件</li>
<li><code>this.setDaemon(true)</code>：设置为守护线程</li>
</ul>
</li>
<li><p>运行方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>this.selector.select(1000)</code>：多路复用器阻塞获取就绪的通道，最多等待 1 秒钟，获取到就绪事件或者超时后结束</p>
</li>
<li><p><code>if (-1 == HAConnection.this.slaveRequestOffset)</code>：<strong>等待 slave 同步完数据</strong></p>
</li>
<li><p><code>if (-1 == this.nextTransferFromWhere)</code>：条件成立，需要初始化该变量</p>
<p><code>if (0 == HAConnection.this.slaveRequestOffset)</code>：slave 是一个全新节点，从正在顺序写的 MF 开始同步数据</p>
<p><code>long masterOffset = ...</code>：获取 master 最大的 offset，并计算归属的 mappedFile 文件的开始 offset</p>
<p><code>this.nextTransferFromWhere = masterOffset</code>：<strong>赋值给下一次传输同步数据的位置信息</strong></p>
<p><code>this.nextTransferFromWhere = HAConnection.this.slaveRequestOffset</code>：大部分情况走这个赋值逻辑</p>
</li>
<li><p><code>if (this.lastWriteOver)</code>：上一次待发送数据全部发送完成</p>
<p><code>if (interval &gt; 5)</code>：<strong>超过 5 秒未同步数据，发送一个 header 心跳数据包，维持长连接</strong></p>
</li>
<li><p><code>else</code>：上一轮的待发送数据未全部发送，需要同步数据到 slave 节点</p>
</li>
<li><p><code>SelectMappedBufferResult selectResult</code>：<strong>到 CommitLog 中查询 nextTransferFromWhere 开始位置的数据</strong></p>
</li>
<li><p><code>if (size &gt; 32k)</code>：一次最多同步 32k 数据</p>
</li>
<li><p><code>this.nextTransferFromWhere += size</code>：增加 size，下一轮传输跳过本帧数据</p>
</li>
<li><p><code>selectResult.getByteBuffer().limit(size)</code>：设置 byteBuffer 可访问数据区间为 [pos, size]</p>
</li>
<li><p><code>this.selectMappedBufferResult = selectResult</code>：<strong>待发送的数据</strong></p>
</li>
<li><p><code>this.byteBufferHeader.put</code>：<strong>构建帧头数据</strong></p>
</li>
<li><p><code>this.lastWriteOver = this.transferData()</code>：处理数据，返回是否处理完成</p>
</li>
</ul>
</li>
<li><p>同步方法：<strong>同步数据到 slave 节点</strong>，返回 true 表示本轮数据全部同步完成，false 表示本轮同步未完成（Header 和 Body 其中一个未同步完成都会返回 false）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">transferData</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>int writeSizeZeroTimes= 0</code>：控制 while 循环，当写失败连续 3 次时，跳出循环）跳出循环</p>
</li>
<li><p><code>while (this.byteBufferHeader.hasRemaining())</code>：<strong>帧头数据缓冲区有待发送的数据</strong></p>
</li>
<li><p><code>int writeSize = this.socketChannel.write(this.byteBufferHeader)</code>：向通道写帧头数据</p>
</li>
<li><p><code>if (null == this.selectMappedBufferResult)</code>：说明是心跳数据，返回心跳数据是否发送完成</p>
</li>
<li><p><code>if (!this.byteBufferHeader.hasRemaining())</code>：<strong>Header写成功之后，才进行写 Body</strong></p>
</li>
<li><p><code>while (this.selectMappedBufferResult.getByteBuffer().hasRemaining())</code>：<strong>数据缓冲区有待发送的数据</strong></p>
</li>
<li><p><code>int writeSize = this.socketChannel.write(this.selectMappedBufferResult...)</code>：向通道写帧头数据</p>
</li>
<li><p><code>if (writeSize &gt; 0)</code>：写数据成功，但是不代表 SMBR 中的数据全部写完成</p>
</li>
<li><p><code>boolean result</code>：判断是否发送完成，返回该值</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="MesStore"><a href="#MesStore" class="headerlink" title="MesStore"></a>MesStore</h4><h5 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h5><p>DefaultMessageStore 类核心是整个存储服务的调度类</p>
<ul>
<li><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultMessageStore</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.allocateMappedFileService.start()</code>：启动<strong>创建 MappedFile 文件服务</strong></li>
<li><code>this.indexService.start()</code>：启动索引服务</li>
</ul>
</li>
<li><p>load()：先加载 CommitLog，再加载 ConsumeQueue，最后加载 IndexFile，加载完进入恢复阶段，先恢复 CQ，在恢复 CL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">load</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>start()：核心启动方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>lock = lockFile.getChannel().tryLock(0, 1, false)</code>：获取文件锁，获取失败说明当前目录已经启动过 Broker</p>
</li>
<li><p><code>long maxPhysicalPosInLogicQueue = commitLog.getMinOffset()</code>：遍历全部的 CQ 对象，获取 CQ 中消息的最大偏移量</p>
</li>
<li><p><code>this.reputMessageService.start()</code>：设置分发服务的分发位点，启动<strong>分发服务</strong>，构建 ConsumerQueue 和 IndexFile</p>
</li>
<li><p><code>if (dispatchBehindBytes() &lt;= 0)</code>：线程等待分发服务将分发数据全部处理完毕</p>
</li>
<li><p><code>this.recoverTopicQueueTable()</code>：因为修改了 CQ 数据，所以再次构建队列偏移量字段表</p>
</li>
<li><p><code>this.haService.start()</code>：启动 <strong>HA 服务</strong></p>
</li>
<li><p><code>this.handleScheduleMessageService()</code>：启动<strong>消息调度服务</strong></p>
</li>
<li><p><code>this.flushConsumeQueueService.start()</code>：启动 CQ <strong>消费队列刷盘服务</strong></p>
</li>
<li><p><code>this.commitLog.start()</code>：启动 <strong>CL 刷盘服务</strong></p>
</li>
<li><p><code>this.storeStatsService.start()</code>：启动状态存储服务</p>
</li>
<li><p><code>this.createTempFile()</code>：创建 AbortFile，正常关机时 JVM HOOK 会删除该文件，<strong>异常宕机时该文件不会删除</strong>，开机数据恢复阶段根据是否存在该文件，执行不同的恢复策略</p>
</li>
<li><p><code>this.addScheduleTask()</code>：添加定时任务</p>
<ul>
<li><p><code>DefaultMessageStore.this.cleanFilesPeriodically()</code>：<strong>定时清理过期文件</strong>，周期是 10 秒</p>
<ul>
<li><code>this.cleanCommitLogService.run()</code>：启动清理过期的 CL 文件服务</li>
<li><code>this.cleanConsumeQueueService.run()</code>：启动清理过期的 CQ 文件服务</li>
</ul>
</li>
<li><p><code>DefaultMessageStore.this.checkSelf()</code>：每 10 分种进行健康检查</p>
</li>
<li><p><code>DefaultMessageStore.this.cleanCommitLogService.isSpaceFull()</code>：<strong>磁盘预警定时任务</strong>，每 10 秒一次</p>
<ul>
<li><p><code>if (physicRatio &gt; this.diskSpaceWarningLevelRatio)</code>：检查磁盘是否到达 waring 阈值，默认 90%</p>
<p><code>boolean diskok = ...runningFlags.getAndMakeDiskFull()</code>：设置磁盘写满标记</p>
</li>
<li><p><code>boolean diskok = ...this.runningFlags.getAndMakeDiskOK()</code>：设置磁盘可写标记</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>this.shutdown = false</code>：刚启动，设置为 false</p>
</li>
</ul>
</li>
<li><p>shutdown()：关闭各种服务和线程资源，设置存储模块状态为关闭状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>destroy()：销毁 Broker 的工作目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="服务线程-1"><a href="#服务线程-1" class="headerlink" title="服务线程"></a>服务线程</h5><p>ServiceThread 类被很多服务继承，本身是一个 Runnable 任务对象，继承者通过重写 run 方法来实现服务的逻辑</p>
<ul>
<li><p>run()：一般实现方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过参数 stopped 控制服务的停止，使用 volatile 修饰保证可见性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stopped</span> <span class="operator">=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>shutdown()：停止线程，首先设置 stopped 为 true，然后进行唤醒，默认不直接打断线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>waitForRunning()：挂起线程，设置唤醒标记 hasNotified 为 false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">waitForRunning</span><span class="params">(<span class="type">long</span> interval)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>wakeup()：唤醒线程，设置 hasNotified 为 true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="构建服务"><a href="#构建服务" class="headerlink" title="构建服务"></a>构建服务</h5><p>AllocateMappedFileService <strong>创建 MappedFile 服务</strong></p>
<ul>
<li><p>mmapOperation()：核心服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">mmapOperation</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>req = this.requestQueue.take()</code>： <strong>从 requestQueue 阻塞队列（优先级）中获取 AllocateRequest 任务</strong></li>
<li><code>if (...isTransientStorePoolEnable())</code>：条件成立使用直接内存写入数据， 从直接内存中 commit 到 FileChannel 中</li>
<li><code>mappedFile = new MappedFile(req.getFilePath(), req.getFileSize())</code>：根据请求的路径和大小创建对象</li>
<li><code>mappedFile.warmMappedFile()</code>：判断 mappedFile 大小，只有 CommitLog 才进行文件预热</li>
<li><code>req.setMappedFile(mappedFile)</code>：将创建好的 MF 对象的赋值给请求对象的成员属性</li>
<li><code>req.getCountDownLatch().countDown()</code>：<strong>唤醒请求的阻塞线程</strong></li>
</ul>
</li>
<li><p>putRequestAndReturnMappedFile()：MappedFileQueue 中用来创建 MF 对象的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> MappedFile <span class="title function_">putRequestAndReturnMappedFile</span><span class="params">(String nextFilePath, String nextNextFilePath, <span class="type">int</span> fileSize)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>AllocateRequest nextReq = new AllocateRequest(...)</code>：创建 nextFilePath 的 AllocateRequest 对象，放入请求列表和阻塞队列，然后创建 nextNextFilePath 的 AllocateRequest 对象，放入请求列表和阻塞队列</li>
<li><code>AllocateRequest result = this.requestTable.get(nextFilePath)</code>：从请求列表获取 nextFilePath 的请求对象</li>
<li><code>result.getCountDownLatch().await(...)</code>：<strong>线程挂起</strong>，直到超时或者 nextFilePath 对应的 MF 文件创建完成</li>
<li><code>return result.getMappedFile()</code>：返回创建好的 MF 文件对象</li>
</ul>
</li>
</ul>
<p>ReputMessageService 消息分发服务，用于构<strong>建 ConsumerQueue 和 IndexFile 文件</strong></p>
<ul>
<li><p>run()：<strong>循环执行 doReput 方法</strong>，所以发送的消息存储进 CL 就可以产生对应的 CQ，每执行一次线程休眠 1 毫秒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>doReput()：实现分发的核心逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReput</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>for (boolean doNext = true; this.isCommitLogAvailable() &amp;&amp; doNext; )</code>：循环遍历</li>
<li><code>SelectMappedBufferResult result</code>： 从 CommitLog 拉取数据，数据范围 <code>[reputFromOffset, 包含该偏移量的 MF 的最大 Pos]</code>，封装成结果对象</li>
<li><code>DispatchRequest dispatchRequest</code>：从结果对象读取出一条 DispatchRequest 数据</li>
<li><code>DefaultMessageStore.this.doDispatch(dispatchRequest)</code>：将数据交给分发器进行分发，用于<strong>构建 CQ 和索引文件</strong></li>
<li><code>this.reputFromOffset += size</code>：更新数据范围</li>
</ul>
</li>
</ul>
<hr>
<h5 id="刷盘服务"><a href="#刷盘服务" class="headerlink" title="刷盘服务"></a>刷盘服务</h5><p>FlushConsumeQueueService 刷盘 CQ 数据</p>
<ul>
<li><p>run()：每隔 1 秒执行一次刷盘服务，跳出循环后还会执行一次强制刷盘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>doFlush()：刷盘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFlush</span><span class="params">(<span class="type">int</span> retryTimes)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>int flushConsumeQueueLeastPages</code>：脏页阈值，默认是 2</p>
</li>
<li><p><code>if (retryTimes == RETRY_TIMES_OVER)</code>：<strong>重试次数是 3</strong> 时设置强制刷盘，设置脏页阈值为 0</p>
</li>
<li><p><code>int flushConsumeQueueThoroughInterval</code>：两次刷新的<strong>时间间隔超过 60 秒</strong>会强制刷盘</p>
</li>
<li><p><code>for (ConsumeQueue cq : maps.values())</code>：遍历所有的 CQ，进行刷盘</p>
</li>
<li><p><code>DefaultMessageStore.this.getStoreCheckpoint().flush()</code>：强制刷盘时将 StoreCheckpoint 瞬时数据刷盘</p>
</li>
</ul>
</li>
</ul>
<p>FlushCommitLogService 刷盘 CL 数据，默认是异步刷盘</p>
<ul>
<li><p>run()：运行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>while (!this.isStopped())</code>：stopped为 true 才跳出循环</p>
</li>
<li><p><code>boolean flushCommitLogTimed</code>：控制线程的休眠方式，默认是 false，使用 <code>CountDownLatch.await()</code> 休眠，设置为 true 时使用 <code>Thread.sleep()</code> 休眠</p>
</li>
<li><p><code>int interval</code>：获取配置中的刷盘时间间隔</p>
</li>
<li><p><code>int flushPhysicQueueLeastPages</code>：获取最小刷盘页数，默认是 4 页，脏页达到指定页数才刷盘</p>
</li>
<li><p><code>int flushPhysicQueueThoroughInterval</code>：获取强制刷盘周期，默认是 10 秒，达到周期后强制刷盘，不考虑脏页</p>
</li>
<li><p><code>if (flushCommitLogTimed)</code>：休眠逻辑，避免 CPU 占用太长时间，导致无法执行其他更紧急的任务</p>
</li>
<li><p><code>CommitLog.this.mappedFileQueue.flush(flushPhysicQueueLeastPages)</code>：<strong>刷盘</strong></p>
</li>
<li><p><code>for (int i = 0; i &lt; RETRY_TIMES_OVER &amp;&amp; !result; i++)</code>：stopped 停止标记为 true 时，需要确保所有的数据都已经刷盘，所以此处尝试 10 次强制刷盘，</p>
<p><code>result = CommitLog.this.mappedFileQueue.flush(0)</code>：<strong>强制刷盘</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="清理服务"><a href="#清理服务" class="headerlink" title="清理服务"></a>清理服务</h5><p>CleanCommitLogService 清理过期的 CL 数据，定时任务 10 秒调用一次，<strong>先清理 CL，再清理 CQ</strong>，因为 CQ 依赖于 CL 的数据</p>
<ul>
<li><p>run()：运行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>deleteExpiredFiles()：删除过期 CL 文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteExpiredFiles</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>long fileReservedTime</code>：默认 72，代表文件的保留时间</li>
<li><code>boolean timeup = this.isTimeToDelete()</code>：当前时间是否是凌晨 4 点</li>
<li><code>boolean spacefull = this.isSpaceToDelete()</code>：CL 或者 CQ 的目录磁盘使用率达到阈值标准 85%</li>
<li><code>boolean manualDelete = this.manualDeleteFileSeveralTimes &gt; 0</code>：手动删除文件</li>
<li><code>fileReservedTime *= 60 * 60 * 1000</code>：默认保留 72 小时</li>
<li><code>deleteCount = DefaultMessageStore.this.commitLog.deleteExpiredFile()</code>：<strong>调用 MFQ 对象的删除方法</strong></li>
</ul>
</li>
</ul>
<p>CleanConsumeQueueService 清理过期的 CQ 数据</p>
<ul>
<li><p>run()：运行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>deleteExpiredFiles()：删除过期 CQ 文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteExpiredFiles</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>int deleteLogicsFilesInterval</code>：清理 CQ 的时间间隔，默认 100 毫秒</li>
<li><code>long minOffset = DefaultMessageStore.this.commitLog.getMinOffset()</code>：获取 CL 文件中最小的物理偏移量</li>
<li><code>if (minOffset &gt; this.lastPhysicalMinOffset)</code>：CL 最小的偏移量大于 CQ 最小的，说明有过期数据</li>
<li><code>this.lastPhysicalMinOffset = minOffset</code>：更新 CQ 的最小偏移量</li>
<li><code>for (ConsumeQueue logic : maps.values())</code>：遍历所有的 CQ 文件</li>
<li><code>logic.deleteExpiredFile(minOffset)</code>：<strong>调用 MFQ 对象的删除方法</strong></li>
<li><code>DefaultMessageStore.this.indexService.deleteExpiredFile(minOffset)</code>：<strong>删除过期的索引文件</strong></li>
</ul>
</li>
</ul>
<hr>
<h5 id="获取消息"><a href="#获取消息" class="headerlink" title="获取消息"></a>获取消息</h5><p>DefaultMessageStore#getMessage 用于获取消息，在 PullMessageProcessor#processRequest 方法中被调用 （提示：建议学习消费者源码时再阅读）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// offset: 客户端拉消息使用位点；   maxMsgNums: 32；  messageFilter: 一般这里是 tagCode 过滤 </span></span><br><span class="line"><span class="keyword">public</span> GetMessageResult <span class="title function_">getMessage</span><span class="params">(<span class="keyword">final</span> String group, <span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="type">int</span> queueId, <span class="keyword">final</span> <span class="type">long</span> offset, <span class="keyword">final</span> <span class="type">int</span> maxMsgNums, <span class="keyword">final</span> MessageFilter messageFilter)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>if (this.shutdown)</code>：检查运行状态</p>
</li>
<li><p><code>GetMessageResult getResult</code>：创建查询结果对象</p>
</li>
<li><p><code>final long maxOffsetPy = this.commitLog.getMaxOffset()</code>：<strong>获取 CommitLog 最大物理偏移量</strong></p>
</li>
<li><p><code>ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId)</code>：根据主题和队列 ID 获取 ConsumeQueue对象</p>
</li>
<li><p><code>minOffset, maxOffset</code>：获取当前 ConsumeQueue 的最小 offset 和 最大 offset，<strong>判断是否满足本次 Pull 的 offset</strong></p>
<p><code>if (maxOffset == 0)</code>：说明队列内无数据，设置状态为 NO_MESSAGE_IN_QUEUE，外层进行长轮询</p>
<p><code>else if (offset &lt; minOffset)</code>：说明 offset 太小了，设置状态为 OFFSET_TOO_SMALL</p>
<p><code>else if (offset == maxOffset)</code>：消费进度持平，设置状态为 OFFSET_OVERFLOW_ONE，外层进行长轮询</p>
<p><code>else if (offset &gt; maxOffset)</code>：说明 offset 越界了，设置状态为 OFFSET_OVERFLOW_BADLY</p>
</li>
<li><p><code>SelectMappedBufferResult bufferConsumeQueue</code>：查询 CQData <strong>获取包含该 offset 的 MappedFile 文件</strong>，如果该文件不是顺序写的文件，就读取 <code>[offset%maxSize, 文件尾]</code> 范围的数据，反之读取 <code>[offset%maxSize, 文件名+wrotePosition尾]</code> </p>
<p>先查 CQ 的原因：因为 CQ 时 CL 的索引，通过 CQ 查询 CL 更加快捷</p>
</li>
<li><p><code>if (bufferConsumeQueue != null)</code>：只有再 CQ 删除过期数据的逻辑执行时，条件才不成立，一般都是成立的</p>
</li>
<li><p><code>long nextPhyFileStartOffset = Long.MIN_VALUE</code>：下一个 commitLog 物理文件名，初始值为最小值</p>
</li>
<li><p><code>long maxPhyOffsetPulling = 0</code>：本次拉消息最后一条消息的物理偏移量</p>
</li>
<li><p><code>for ()</code>：<strong>处理数据</strong>，每次处理 20 字节处理字节数大于 16000 时跳出循环</p>
</li>
<li><p><code>offsetPy, sizePy, tagsCode</code>：读取 20 个字节后，获取消息物理偏移量、消息大小、消息 tagCode</p>
</li>
<li><p><code>boolean isInDisk = checkInDiskByCommitOffset(...)</code>：<strong>检查消息是热数据还是冷数据</strong>，false 为热数据</p>
<ul>
<li><code>long memory</code>：Broker 系统 40% 内存的字节数，写数据时内存不够会使用 LRU 算法淘汰数据，将淘汰数据持久化到磁盘</li>
<li><code>return (maxOffsetPy - offsetPy) &gt; memory</code>：返回 true 说明数据已经持久化到磁盘，为冷数据</li>
</ul>
</li>
<li><p><code>if (this.isTheBatchFull())</code>：<strong>控制是否跳出循环</strong></p>
<ul>
<li><p><code>if (0 == bufferTotal || 0 == messageTotal)</code>：本次 pull 消息未拉取到任何东西，需要外层 for 循环继续，返回 false</p>
</li>
<li><p><code>if (maxMsgNums &lt;= messageTotal)</code>：结果对象内消息数已经超过了最大消息数量，可以结束循环了</p>
</li>
<li><p><code>if (isInDisk)</code>：冷数据</p>
<p><code>if ((bufferTotal + sizePy) &gt; ...)</code>：冷数据一次 pull 请求最大允许获取 64kb 的消息</p>
<p><code>if (messageTotal &gt; ...)</code>：冷数据一次 pull 请求最大允许获取8 条消息</p>
</li>
<li><p><code>else</code>：热数据</p>
<p><code>if ((bufferTotal + sizePy) &gt; ...)</code>：热数据一次 pull 请求最大允许获取 256kb 的消息</p>
<p><code>if (messageTotal &gt; ...)</code>：冷数据一次 pull 请求最大允许获取32 条消息</p>
</li>
</ul>
</li>
<li><p><code>if (messageFilter != null)</code>：按照消息 tagCode 进行过滤</p>
</li>
<li><p><code>selectResult = this.commitLog.getMessage(offsetPy, sizePy)</code>：根据 CQ 消息物理偏移量和消息大小<strong>到 commitLog 中查询这条 msg</strong></p>
</li>
<li><p><code>if (null == selectResult)</code>：条件成立说明 commitLog 执行了删除过期文件的定时任务，因为是先清理的 CL，所以 CQ 还有该索引数据</p>
</li>
<li><p><code>nextPhyFileStartOffset = this.commitLog.rollNextFile(offsetPy)</code>：获取包含该 offsetPy 的下一个数据文件的文件名</p>
</li>
<li><p><code>getResult.addMessage(selectResult)</code>：<strong>将本次循环查询出来的 msg 加入到 getResult 内</strong></p>
</li>
<li><p><code>status = GetMessageStatus.FOUND</code>：查询状态设置为 FOUND</p>
</li>
<li><p><code>nextPhyFileStartOffset = Long.MIN_VALUE</code>：设置为最小值，跳过期 CQData 数据的逻辑</p>
</li>
<li><p><code>nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE)</code>：计算客户端下一次 pull 时使用的位点信息</p>
</li>
<li><p><code>getResult.setSuggestPullingFromSlave(diff &gt; memory)</code>：<strong>选择主从节点的建议</strong></p>
<ul>
<li><code>diff &gt; memory =&gt; true</code>：表示本轮查询最后一条消息为冷数据，Broker 建议客户端下一次 pull 时到 slave 节点</li>
<li><code>diff &gt; memory =&gt; false</code>：表示本轮查询最后一条消息为热数据，Broker 建议客户端下一次 pull 时到 master 节点</li>
</ul>
</li>
<li><p><code>getResult.setStatus(status)</code>：设置结果状态</p>
</li>
<li><p><code>getResult.setNextBeginOffset(nextBeginOffset)</code>：设置客户端下一次 pull 时的 offset</p>
</li>
<li><p><code>getResult.setMaxOffset(maxOffset)</code>：设置 queue 的最大 offset 和最小 offset</p>
</li>
<li><p><code>return getResult</code>：返回结果对象</p>
</li>
</ul>
<hr>
<h4 id="Broker-1"><a href="#Broker-1" class="headerlink" title="Broker"></a>Broker</h4><p>BrokerStartup 启动方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    start(createBrokerController(args));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BrokerController <span class="title function_">start</span><span class="params">(BrokerController controller)</span> &#123;</span><br><span class="line">    controller.start();	<span class="comment">// 启动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BrokerStartup#createBrokerController：构造控制器，并初始化</p>
<ul>
<li><code>final BrokerController controller()</code>：创建实例对象</li>
<li><code>boolean initResult = controller.initialize()</code>：控制器初始化<ul>
<li><code>this.registerProcessor()</code>：<strong>注册了处理器，包括发送消息、拉取消息、查询消息等核心处理器</strong></li>
<li><code>initialTransaction()</code>：初始化了事务服务，用于进行<strong>事务回查</strong></li>
</ul>
</li>
</ul>
<p>BrokerController#start：核心启动方法</p>
<ul>
<li><p><code>this.messageStore.start()</code>：<strong>启动存储服务</strong></p>
</li>
<li><p><code>this.remotingServer.start()</code>：启动 Netty 通信服务</p>
</li>
<li><p><code>this.fileWatchService.start()</code>：启动文件监听服务</p>
</li>
<li><p><code>startProcessorByHa(messageStoreConfig.getBrokerRole())</code>：<strong>启动事务回查</strong></p>
</li>
<li><p><code>this.scheduledExecutorService.scheduleAtFixedRate()</code>：每隔 30s 向 NameServer 上报 Topic 路由信息，<strong>心跳机制</strong></p>
<p><code>BrokerController.this.registerBrokerAll(true, false, brokerConfig.isForceRegister())</code></p>
</li>
</ul>
<hr>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><h4 id="生产者类"><a href="#生产者类" class="headerlink" title="生产者类"></a>生产者类</h4><h5 id="生产者类-1"><a href="#生产者类-1" class="headerlink" title="生产者类"></a>生产者类</h5><p>DefaultMQProducer 是生产者的默认实现类</p>
<p>成员变量：</p>
<ul>
<li><p>生产者实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">transient</span> DefaultMQProducerImpl defaultMQProducerImpl</span><br></pre></td></tr></table></figure>
</li>
<li><p>生产者组：发送事务消息，Broker 端进行事务回查（补偿机制）时，选择当前生产者组的下一个生产者进行事务回查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String producerGroup;</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认主题：isAutoCreateTopicEnable 开启时，当发送消息指定的 Topic 在 Namesrv 未找到路由信息，使用该值创建 Topic 信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">createTopicKey</span> <span class="operator">=</span> TopicValidator.AUTO_CREATE_TOPIC_KEY_TOPIC;</span><br><span class="line"><span class="comment">// 值为【TBW102】，Just for testing or demo program</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>消息重投：系统特性消息重试部分详解了三个参数的作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">retryTimesWhenSendFailed</span> <span class="operator">=</span> <span class="number">2</span>;		<span class="comment">// 同步发送失败后重试的发送次数，加上第一次发送，一共三次</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">retryTimesWhenSendAsyncFailed</span> <span class="operator">=</span> <span class="number">2</span>;	<span class="comment">// 异步</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">retryAnotherBrokerWhenNotStoreOK</span> <span class="operator">=</span> <span class="literal">false</span>;	<span class="comment">// 消息未存储成功，选择其他 Broker 重试</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>消息队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">defaultTopicQueueNums</span> <span class="operator">=</span> <span class="number">4</span>;		<span class="comment">// 默认 Broker 创建的队列数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>消息属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sendMsgTimeout</span> <span class="operator">=</span> <span class="number">3000</span>;					<span class="comment">// 发送消息的超时限制</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">compressMsgBodyOverHowmuch</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">4</span>;	<span class="comment">// 压缩阈值，当 msg body 超过 4k 后使用压缩</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxMessageSize</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;		<span class="comment">// 消息体的最大限制，默认 4M</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">TraceDispatcher</span> <span class="variable">traceDispatcher</span> <span class="operator">=</span> <span class="literal">null</span>;		<span class="comment">// 消息轨迹</span></span><br><span class="line"></span><br><span class="line">构造方法：</span><br><span class="line"></span><br><span class="line">* 构造方法：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String namespace, <span class="keyword">final</span> String producerGroup, RPCHook rpcHook)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.namespace = namespace;</span><br><span class="line">      <span class="built_in">this</span>.producerGroup = producerGroup;</span><br><span class="line">      <span class="comment">// 创建生产者实现对象</span></span><br><span class="line">      defaultMQProducerImpl = <span class="keyword">new</span> <span class="title class_">DefaultMQProducerImpl</span>(<span class="built_in">this</span>, rpcHook);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>成员方法：</p>
<ul>
<li><p>start()：启动方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">    <span class="comment">// 重置生产者组名，如果传递了命名空间，则 【namespace%group】</span></span><br><span class="line">    <span class="built_in">this</span>.setProducerGroup(withNamespace(<span class="built_in">this</span>.producerGroup));</span><br><span class="line">    <span class="comment">// 生产者实现对象启动</span></span><br><span class="line">    <span class="built_in">this</span>.defaultMQProducerImpl.start();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != traceDispatcher) &#123;</span><br><span class="line">      	<span class="comment">// 消息轨迹的逻辑</span></span><br><span class="line">   		traceDispatcher.start(<span class="built_in">this</span>.getNamesrvAddr(), <span class="built_in">this</span>.getAccessChannel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>send()：<strong>发送消息</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SendResult <span class="title function_">send</span><span class="params">(Message msg)</span>&#123;</span><br><span class="line">    <span class="comment">// 校验消息</span></span><br><span class="line">    Validators.checkMessage(msg, <span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 设置消息 Topic</span></span><br><span class="line">    msg.setTopic(withNamespace(msg.getTopic()));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.defaultMQProducerImpl.send(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>request()：请求方法，<strong>需要消费者回执消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Message <span class="title function_">request</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">    msg.setTopic(withNamespace(msg.getTopic()));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.defaultMQProducerImpl.request(msg, mq, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="实现者类"><a href="#实现者类" class="headerlink" title="实现者类"></a>实现者类</h5><p>DefaultMQProducerImpl 类是默认的生产者实现类</p>
<p>成员变量：</p>
<ul>
<li><p>实例对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultMQProducer defaultMQProducer;	<span class="comment">// 持有默认生产者对象，用来获取对象中的配置信息</span></span><br><span class="line"><span class="keyword">private</span> MQClientInstance mQClientFactory;			<span class="comment">// 客户端实例对象，生产者启动后需要注册到该客户端对象内</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主题发布信息映射表：key 是 Topic，value 是发布信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, TopicPublishInfo&gt; topicPublishInfoTable = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, TopicPublishInfo&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步发送消息：相关信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; asyncSenderThreadPoolQueue;<span class="comment">// 异步发送消息，异步线程池使用的队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService defaultAsyncSenderExecutor;	<span class="comment">// 异步发送消息默认使用的线程池</span></span><br><span class="line"><span class="keyword">private</span> ExecutorService asyncSenderExecutor;				<span class="comment">// 异步消息发送线程池，指定后就不使用默认线程池了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器：执行定时任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="string">&quot;RequestHouseKeepingService&quot;</span>, <span class="literal">true</span>);	<span class="comment">// 守护线程</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>状态信息：服务的状态，默认创建状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ServiceState</span> <span class="variable">serviceState</span> <span class="operator">=</span> ServiceState.CREATE_JUST;</span><br></pre></td></tr></table></figure>
</li>
<li><p>压缩等级：ZIP 压缩算法的等级，默认是 5，越高压缩效果好，但是压缩的更慢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">zipCompressLevel</span> <span class="operator">=</span> Integer.parseInt(System.getProperty..., <span class="string">&quot;5&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>容错策略：选择队列的容错策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">MQFaultStrategy</span> <span class="variable">mqFaultStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MQFaultStrategy</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>钩子：用来进行前置或者后置处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;SendMessageHook&gt; sendMessageHookList;			<span class="comment">// 发送消息的钩子，留给用户扩展使用</span></span><br><span class="line">ArrayList&lt;CheckForbiddenHook&gt; checkForbiddenHookList;	<span class="comment">// 对比上面的钩子，可以抛异常，控制消息是否可以发送</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RPCHook rpcHook;						 	<span class="comment">// 传递给 NettyRemotingClient</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>构造方法：</p>
<ul>
<li><p>默认构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultMQProducerImpl</span><span class="params">(<span class="keyword">final</span> DefaultMQProducer defaultMQProducer)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认 RPC HOOK 是空</span></span><br><span class="line">    <span class="built_in">this</span>(defaultMQProducer, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有参构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultMQProducerImpl</span><span class="params">(<span class="keyword">final</span> DefaultMQProducer defaultMQProducer, RPCHook rpcHook)</span> &#123;</span><br><span class="line">    <span class="comment">// 属性赋值</span></span><br><span class="line">    <span class="built_in">this</span>.defaultMQProducer = defaultMQProducer;</span><br><span class="line">    <span class="built_in">this</span>.rpcHook = rpcHook;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建【异步消息线程池任务队列】，长度是 5w</span></span><br><span class="line">    <span class="built_in">this</span>.asyncSenderThreadPoolQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">50000</span>);</span><br><span class="line">    <span class="comment">// 创建默认的异步消息任务线程池</span></span><br><span class="line">    <span class="built_in">this</span>.defaultAsyncSenderExecutor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">        <span class="comment">// 核心线程数和最大线程数都是 系统可用的计算资源（8核16线程的系统就是 16）...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5><ul>
<li><p>start()：启动方法，参数默认是 true，代表正常的启动路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> startFactory)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>this.serviceState = ServiceState.START_FAILED</code>：先修改为启动失败，成功后再修改，这种思想很常见</p>
</li>
<li><p><code>this.checkConfig()</code>：判断生产者组名不能是空，也不能是 default_PRODUCER</p>
</li>
<li><p><code>if (!getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP))</code>：条件成立说明当前生产者不是内部产生者，内部生产者是<strong>处理消息回退</strong>的这种情况使用的生产者</p>
<p><code>this.defaultMQProducer.changeInstanceNameToPID()</code>：修改生产者实例名称为当前进程的 PID</p>
</li>
<li><p><code> this.mQClientFactory = ...</code>：获取当前进程的 MQ 客户端实例对象，从 factoryTable 中获取 key 为 客户端 ID，格式是<code>ip@pid</code>，<strong>一个 JVM 进程只有一个 PID，也只有一个 MQClientInstance</strong></p>
</li>
<li><p><code>boolean registerOK = mQClientFactory.registerProducer(...)</code>：将生产者注册到 RocketMQ 客户端实例内</p>
</li>
<li><p><code>this.topicPublishInfoTable.put(...)</code>：添加一个主题发布信息，key 是 <strong>TBW102</strong> ，value 是一个空对象</p>
</li>
<li><p><code>mQClientFactory.start()</code>：启动 RocketMQ 客户端实例对象</p>
</li>
<li><p><code>this.mQClientFactory.sendHeartbeatToAllBrokerWithLock()</code>：RocketMQ <strong>客户端实例向已知的 Broker 节点发送一次心跳</strong>（也是定时任务）</p>
</li>
<li><p><code>this.timer.scheduleAtFixedRate()</code>： request 发送的消息需要消费着回执信息，启动定时任务每秒一次删除超时请求</p>
<ul>
<li>生产者 msg 添加信息关联 ID 发送到 Broker</li>
<li>消费者从 Broker 拿到消息后会检查 msg 类型是一个需要回执的消息，处理完消息后会根据 msg 关联 ID 和客户端 ID 生成一条响应结果消息发送到 Broker，Broker 判断为回执消息，会根据客户端ID 找到 channel 推送给生产者</li>
<li>生产者拿到回执消息后，读取出来关联 ID 找到对应的 RequestFuture，将阻塞线程唤醒</li>
</ul>
</li>
</ul>
</li>
<li><p>sendDefaultImpl()：发送消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数1：消息；参数2：发送模式（同步异步单向）；参数3：回调函数，异步发送时需要；参数4：发送超时时间, 默认 3 秒</span></span><br><span class="line"><span class="keyword">private</span> SendResult <span class="title function_">sendDefaultImpl</span><span class="params">(msg, communicationMode, sendCallback,timeout)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>this.makeSureStateOK()</code>：校验生产者状态是运行中，否则抛出异常</p>
</li>
<li><p><code>topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic())</code>：<strong>获取当前消息主题的发布信息</strong></p>
<ul>
<li><p><code>this.topicPublishInfoTable.get(topic)</code>：先尝试从本地主题发布信息映射表获取信息，获取不到继续执行</p>
</li>
<li><p><code>this.mQClientFactory.update...FromNameServer(topic)</code>：然后从 Namesrv 更新该 Topic 的路由数据</p>
</li>
<li><p><code>this.mQClientFactory.update...FromNameServer(...)</code>：<strong>路由数据是空，获取默认 TBW102 的数据</strong></p>
<p><code>return topicPublishInfo</code>：返回 TBW102 主题的发布信息</p>
</li>
</ul>
</li>
<li><p><code>String[] brokersSent = new String[timesTotal]</code>：下标索引代表第几次发送，值代表这次发送选择 Broker name</p>
</li>
<li><p><code>for (; times &lt; timesTotal; times++)</code>：循环发送，<strong>发送成功或者发送尝试次数达到上限，结束循环</strong></p>
</li>
<li><p><code>String lastBrokerName = null == mq ? null : mq.getBrokerName()</code>：获取上次发送失败的 BrokerName</p>
</li>
<li><p><code>mqSelected = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName)</code>：从发布信息中选择一个队列，生产者的<strong>负载均衡策略</strong>，参考系统特性章节</p>
</li>
<li><p><code>brokersSent[times] = mq.getBrokerName()</code>：将本次选择的 BrokerName 存入数组</p>
</li>
<li><p><code>msg.setTopic(this.defaultMQProducer.withNamespace(msg.getTopic()))</code>：<strong>产生重投，重投消息需要加上标记</strong></p>
</li>
<li><p><code>sendResult = this.sendKernelImpl</code>：核心发送方法</p>
</li>
<li><p><code>switch (communicationMode)</code>：异步或者单向消息直接返回 null，异步通过回调函数处理，同步发送进入逻辑判断</p>
<p><code>if (sendResult.getSendStatus() != SendStatus.SEND_OK)</code>：<strong>服务端 Broker 存储失败，需要重试其他 Broker</strong></p>
</li>
<li><p><code>throw new MQClientException()</code>：未找到当前主题的路由数据，无法发送消息，抛出异常</p>
</li>
</ul>
</li>
<li><p>sendKernelImpl()：<strong>核心发送方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数1：消息；参数2：选择的队列；参数3：发送模式（同步异步单向）；参数4：回调函数，异步发送时需要；参数5：主题发布信息；参数6：剩余超时时间限制</span></span><br><span class="line"><span class="keyword">private</span> SendResult <span class="title function_">sendKernelImpl</span><span class="params">(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>brokerAddr = this.mQClientFactory(...)</code>：<strong>获取指定 BrokerName 对应的 mater 节点的地址</strong>，master 节点的 ID 为 0，集群模式下，<strong>发送消息要发到主节点</strong></p>
</li>
<li><p><code>brokerAddr = MixAll.brokerVIPChannel()</code>：Broker 启动时会绑定两个服务器端口，一个是普通端口，一个是 VIP 端口，服务器端根据不同端口创建不同的的 NioSocketChannel</p>
</li>
<li><p><code>byte[] prevBody = msg.getBody()</code>：获取消息体</p>
</li>
<li><p><code>if (!(msg instanceof MessageBatch))</code>：非批量消息，需要重新设置消息 ID</p>
<p><code>MessageClientIDSetter.setUniqID(msg)</code>：<strong>msg id 由两部分组成</strong>，一部分是 ip 地址、进程号、Classloader 的 hashcode，另一部分是时间差（当前时间减去当月一号的时间）和计数器的值</p>
</li>
<li><p><code>if (this.tryToCompressMessage(msg))</code>：判断消息是否压缩，压缩需要设置压缩标记</p>
</li>
<li><p><code>hasCheckForbiddenHook、hasSendMessageHook</code>：执行钩子方法</p>
</li>
<li><p><code>requestHeader = new SendMessageRequestHeader()</code>：设置发送消息的消息头</p>
</li>
<li><p><code>if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX))</code>：重投的发送消息</p>
</li>
<li><p><code>switch (communicationMode)</code>：异步发送一种处理方式，单向和同步同样的处理逻辑</p>
<p><code>sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage()</code>：<strong>发送消息</strong></p>
<ul>
<li><code>request = RemotingCommand.createRequestCommand()</code>：创建一个 RequestCommand 对象</li>
<li><code>request.setBody(msg.getBody())</code>：<strong>将消息放入请求体</strong></li>
<li><code>switch (communicationMode)</code>：<strong>根据不同的模式 invoke 不同的方法</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>request()：请求方法，消费者回执消息，这种消息是异步消息</p>
<ul>
<li><p><code>requestResponseFuture = new RequestResponseFuture(correlationId, timeout, null)</code>：创建请求响应对象</p>
</li>
<li><p><code>getRequestFutureTable().put(correlationId, requestResponseFuture)</code>：放入RequestFutureTable 映射表中</p>
</li>
<li><p><code>this.sendDefaultImpl(msg, CommunicationMode.ASYNC, new SendCallback())</code>：<strong>发送异步消息，有回调函数</strong></p>
</li>
<li><p><code>return waitResponse(msg, timeout, requestResponseFuture, cost)</code>：用来挂起请求的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> Message <span class="title function_">waitResponseMessage</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="comment">// 请求挂起</span></span><br><span class="line">      <span class="built_in">this</span>.countDownLatch.await(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.responseMsg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">* 当消息被消费后，客户端处理响应时通过消息的关联 ID，从映射表中获取消息的 RequestResponseFuture，执行下面的方法唤醒挂起线程</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putResponseMessage</span><span class="params">(<span class="keyword">final</span> Message responseMsg)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.responseMsg = responseMsg;</span><br><span class="line">      <span class="built_in">this</span>.countDownLatch.countDown();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="路由信息-1"><a href="#路由信息-1" class="headerlink" title="路由信息"></a>路由信息</h4><p>TopicPublishInfo 类用来存储路由信息</p>
<p>成员变量：</p>
<ul>
<li><p>顺序消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">orderTopic</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;MessageQueue&gt; messageQueueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();			<span class="comment">// 主题全部的消息队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">ThreadLocalIndex</span> <span class="variable">sendWhichQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalIndex</span>();	<span class="comment">// 消息队列索引</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 【消息队列类】</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageQueue</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;MessageQueue&gt;, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> String topic;</span><br><span class="line">    <span class="keyword">private</span> String brokerName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> queueId;<span class="comment">// 队列 ID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>路由数据：主题对应的路由数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TopicRouteData topicRouteData;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicRouteData</span> <span class="keyword">extends</span> <span class="title class_">RemotingSerializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderTopicConf;</span><br><span class="line">    <span class="keyword">private</span> List&lt;QueueData&gt; queueDatas;		<span class="comment">// 队列数据</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;BrokerData&gt; brokerDatas;	<span class="comment">// Broker 数据</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueData</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;QueueData&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String brokerName;	<span class="comment">// 节点名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> readQueueNums;	<span class="comment">// 读队列数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> writeQueueNums;	<span class="comment">// 写队列数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> perm;			<span class="comment">// 权限</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> topicSynFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BrokerData</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;BrokerData&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String cluster;		<span class="comment">// 集群名</span></span><br><span class="line">    <span class="keyword">private</span> String brokerName;	<span class="comment">// Broker节点名称</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Long<span class="comment">/* brokerId */</span>, String<span class="comment">/* broker address */</span>&gt; brokerAddrs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>核心方法：</p>
<ul>
<li><p>selectOneMessageQueue()：<strong>选择消息队列</strong>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是上次失败时的 brokerName，可以为 null</span></span><br><span class="line"><span class="keyword">public</span> MessageQueue <span class="title function_">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> String lastBrokerName)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lastBrokerName == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历消息队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.messageQueueList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 【获取队列的索引，+1】</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="built_in">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line">            <span class="comment">// 获取队列的下标位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> Math.abs(index) % <span class="built_in">this</span>.messageQueueList.size();</span><br><span class="line">            <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 获取消息队列</span></span><br><span class="line">            <span class="type">MessageQueue</span> <span class="variable">mq</span> <span class="operator">=</span> <span class="built_in">this</span>.messageQueueList.get(pos);</span><br><span class="line">            <span class="comment">// 与上次选择的不同就可以返回</span></span><br><span class="line">            <span class="keyword">if</span> (!mq.getBrokerName().equals(lastBrokerName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="公共配置"><a href="#公共配置" class="headerlink" title="公共配置"></a>公共配置</h4><p>公共的配置信息类</p>
<ul>
<li><p>ClientConfig 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientConfig</span> &#123;</span><br><span class="line">    <span class="comment">// Namesrv 地址配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">namesrvAddr</span> <span class="operator">=</span> NameServerAddressUtils.getNameServerAddresses();</span><br><span class="line">    <span class="comment">// 客户端的 IP 地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">clientIP</span> <span class="operator">=</span> RemotingUtil.getLocalAddress();</span><br><span class="line">    <span class="comment">// 客户端实例名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">instanceName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;rocketmq.client.name&quot;</span>, <span class="string">&quot;DEFAULT&quot;</span>);</span><br><span class="line">    <span class="comment">// 客户端回调线程池的数量，平台核心数，8核16线程的电脑返回16</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">clientCallbackExecutorThreads</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="comment">// 命名空间</span></span><br><span class="line">    <span class="keyword">protected</span> String namespace;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">AccessChannel</span> <span class="variable">accessChannel</span> <span class="operator">=</span> AccessChannel.LOCAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取路由信息的间隔时间 30s</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pollNameServerInterval</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 客户端与 broker 之间的心跳周期 30s</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">heartbeatBrokerInterval</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 消费者持久化消费的周期 5s</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">persistConsumerOffsetInterval</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">pullTimeDelayMillsWhenException</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">unitMode</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> String unitName;</span><br><span class="line">    <span class="comment">// vip 通道，broker 启动时绑定两个端口，其中一个是 vip 通道</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">vipChannelEnabled</span> <span class="operator">=</span> Boolean.parseBoolean();</span><br><span class="line">    <span class="comment">// 语言，默认是 Java</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">LanguageCode</span> <span class="variable">language</span> <span class="operator">=</span> LanguageCode.JAVA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NettyClientConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClientConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 客户端工作线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">clientWorkerThreads</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 回调处理线程池 线程数：平台核心数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">clientCallbackExecutorThreads</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="comment">// 单向请求并发数，默认 65535</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">clientOnewaySemaphoreValue</span> <span class="operator">=</span> NettySystemConfig.CLIENT_ONEWAY_SEMAPHORE_VALUE;</span><br><span class="line">    <span class="comment">// 异步请求并发数，默认 65535</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">clientAsyncSemaphoreValue</span> <span class="operator">=</span> NettySystemConfig.CLIENT_ASYNC_SEMAPHORE_VALUE;</span><br><span class="line">    <span class="comment">// 客户端连接服务器的超时时间限制 3秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">connectTimeoutMillis</span> <span class="operator">=</span> <span class="number">3000</span>;</span><br><span class="line">    <span class="comment">// 客户端未激活周期，60s（指定时间内 ch 未激活，需要关闭）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">channelNotActiveInterval</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">60</span>;</span><br><span class="line">    <span class="comment">// 客户端与服务器 ch 最大空闲时间 2分钟</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">clientChannelMaxIdleTimeSeconds</span> <span class="operator">=</span> <span class="number">120</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 底层 Socket 写和收 缓冲区的大小 65535  64k</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">clientSocketSndBufSize</span> <span class="operator">=</span> NettySystemConfig.socketSndbufSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">clientSocketRcvBufSize</span> <span class="operator">=</span> NettySystemConfig.socketRcvbufSize;</span><br><span class="line">    <span class="comment">// 客户端 netty 是否启动内存池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">clientPooledByteBufAllocatorEnable</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 客户端是否超时关闭 Socket 连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">clientCloseSocketIfTimeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="客户端类"><a href="#客户端类" class="headerlink" title="客户端类"></a>客户端类</h4><h5 id="成员属性-8"><a href="#成员属性-8" class="headerlink" title="成员属性"></a>成员属性</h5><p>MQClientInstance 是 RocketMQ 客户端实例，在一个 JVM 进程中只有一个客户端实例，<strong>既服务于生产者，也服务于消费者</strong></p>
<p>成员变量：</p>
<ul>
<li><p>配置信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> instanceIndex;			<span class="comment">// 索引一般是 0，因为客户端实例一般都是一个进程只有一个</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String clientId;				<span class="comment">// 客户端 ID ip@pid</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> bootTimestamp;			<span class="comment">// 客户端的启动时间</span></span><br><span class="line"><span class="keyword">private</span> ServiceState serviceState;			<span class="comment">// 客户端状态</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生产者消费者的映射表：key 是组名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, MQProducerInner&gt; producerTable</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, MQConsumerInner&gt; consumerTable</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, MQAdminExtInner&gt; adminExtTable</span><br></pre></td></tr></table></figure>
</li>
<li><p>网络层配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> NettyClientConfig nettyClientConfig;</span><br></pre></td></tr></table></figure>
</li>
<li><p>核心功能的实现：负责将 MQ 业务层的数据转换为网络层的 RemotingCommand 对象，使用内部持有的 NettyRemotingClient 对象的 invoke 系列方法，完成网络 IO（同步、异步、单向）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MQClientAPIImpl mQClientAPIImpl;</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地路由数据：key 是主题名称，value 路由信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, TopicRouteData&gt; topicRouteTable = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>锁信息：两把锁，锁不同的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lockNamesrv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lockHeartbeat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>调度线程池：单线程，执行定时任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutorService;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Broker 映射表：key 是 BrokerName</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 物理节点映射表，value：Long 是 brokerID，【ID=0 的是主节点，其他是从节点】，String 是地址 ip:port</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, HashMap&lt;Long, String&gt;&gt; brokerAddrTable;</span><br><span class="line"><span class="comment">// 物理节点版本映射表，String 是地址 ip:port，Integer 是版本</span></span><br><span class="line">ConcurrentMap&lt;String, HashMap&lt;String, Integer&gt;&gt; brokerVersionTable;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端的协议处理器</strong>：用于处理 IO 事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClientRemotingProcessor clientRemotingProcessor;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PullMessageService pullMessageService;		<span class="comment">// 拉消息服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RebalanceService rebalanceService;			<span class="comment">// 消费者负载均衡服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConsumerStatsManager consumerStatsManager;	<span class="comment">// 消费者状态管理</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内部生产者实例：处理消费端<strong>消息回退</strong>，用该生产者发送回退消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultMQProducer defaultMQProducer;</span><br></pre></td></tr></table></figure>
</li>
<li><p>心跳次数统计：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">sendHeartbeatTimesTotal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>构造方法：</p>
<ul>
<li><p>MQClientInstance 有参构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MQClientInstance</span><span class="params">(ClientConfig clientConfig, <span class="type">int</span> instanceIndex, String clientId, RPCHook rpcHook)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.clientConfig = clientConfig;</span><br><span class="line">    <span class="built_in">this</span>.instanceIndex = instanceIndex;</span><br><span class="line">    <span class="comment">// Netty 相关的配置信息</span></span><br><span class="line">    <span class="built_in">this</span>.nettyClientConfig = <span class="keyword">new</span> <span class="title class_">NettyClientConfig</span>();</span><br><span class="line">    <span class="comment">// 平台核心数</span></span><br><span class="line">    <span class="built_in">this</span>.nettyClientConfig.setClientCallbackExecutorThreads(...);</span><br><span class="line">    <span class="built_in">this</span>.nettyClientConfig.setUseTLS(clientConfig.isUseTLS());</span><br><span class="line">    <span class="comment">// 【创建客户端协议处理器】</span></span><br><span class="line">    <span class="built_in">this</span>.clientRemotingProcessor = <span class="keyword">new</span> <span class="title class_">ClientRemotingProcessor</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 创建 API 实现对象</span></span><br><span class="line">    <span class="comment">// 参数一：客户端网络配置</span></span><br><span class="line">    <span class="comment">// 参数二：客户端协议处理器，注册到客户端网络层</span></span><br><span class="line">    <span class="comment">// 参数三：rpcHook，注册到客户端网络层</span></span><br><span class="line">    <span class="comment">// 参数四：客户端配置</span></span><br><span class="line">    <span class="built_in">this</span>.mQClientAPIImpl = <span class="keyword">new</span> <span class="title class_">MQClientAPIImpl</span>(<span class="built_in">this</span>.nettyClientConfig, <span class="built_in">this</span>.clientRemotingProcessor, rpcHook, clientConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 内部生产者，指定内部生产者的组</span></span><br><span class="line">    <span class="built_in">this</span>.defaultMQProducer = <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(MixAll.CLIENT_INNER_PRODUCER_GROUP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MQClientAPIImpl 有参构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MQClientAPIImpl</span><span class="params">(nettyClientConfig, clientRemotingProcessor, rpcHook, clientConfig)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.clientConfig = clientConfig;</span><br><span class="line">    topAddressing = <span class="keyword">new</span> <span class="title class_">TopAddressing</span>(MixAll.getWSAddr(), clientConfig.getUnitName());</span><br><span class="line">    <span class="comment">// 创建网络层对象，参数二为 null 说明客户端并不关心 channel event</span></span><br><span class="line">    <span class="built_in">this</span>.remotingClient = <span class="keyword">new</span> <span class="title class_">NettyRemotingClient</span>(nettyClientConfig, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 业务处理器</span></span><br><span class="line">    <span class="built_in">this</span>.clientRemotingProcessor = clientRemotingProcessor;</span><br><span class="line">    <span class="comment">// 注册 RpcHook</span></span><br><span class="line">    <span class="built_in">this</span>.remotingClient.registerRPCHook(rpcHook);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 注册回退消息的请求码</span></span><br><span class="line">    <span class="built_in">this</span>.remotingClient.registerProcessor(RequestCode.PUSH_REPLY_MESSAGE_TO_CLIENT, <span class="built_in">this</span>.clientRemotingProcessor, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-7"><a href="#成员方法-7" class="headerlink" title="成员方法"></a>成员方法</h5><ul>
<li><p>start()：启动方法</p>
<ul>
<li><code>synchronized (this)</code>：加锁保证线程安全，保证只有一个实例对象启动</li>
<li><code>this.mQClientAPIImpl.start()</code>：启动客户端网络层，底层调用 RemotingClient 类 </li>
<li><code>this.startScheduledTask()</code>：启动定时任务</li>
<li><code>this.pullMessageService.start()</code>：启动拉取消息服务</li>
<li><code>this.rebalanceService.start()</code>：启动负载均衡服务</li>
<li><code>this.defaultMQProducer...start(false)</code>：启动内部生产者，参数为 false 代表不启动实例</li>
</ul>
</li>
<li><p>startScheduledTask()：<strong>启动定时任务</strong>，调度线程池是单线程</p>
<ul>
<li><p><code>if (null == this.clientConfig.getNamesrvAddr())</code>：Namesrv 地址是空，需要两分钟拉取一次 Namesrv 地址</p>
</li>
<li><p>定时任务 1：<strong>从 Namesrv 更新客户端本地的路由数据</strong>，周期 30 秒一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取生产者和消费者订阅的主题集合，遍历集合，对比从 namesrv 拉取最新的主题路由数据和本地数据，是否需要更新</span></span><br><span class="line">MQClientInstance.<span class="built_in">this</span>.updateTopicRouteInfoFromNameServer();</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时任务 2：周期 30 秒一次，两个任务</p>
<ul>
<li><strong>清理下线的 Broker 节点</strong>，遍历客户端的 Broker 物理节点映射表，将所有主题数据都不包含的 Broker 物理节点清理掉，如果被清理的 Broker 下所有的物理节点都没有了，就将该 Broker 的映射数据删除掉</li>
<li><strong>向在线的所有的 Broker 发送心跳数据</strong>，同步发送的方式，返回值是 Broker 物理节点的版本号，更新版本映射表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MQClientInstance.<span class="built_in">this</span>.cleanOfflineBroker();</span><br><span class="line">MQClientInstance.<span class="built_in">this</span>.sendHeartbeatToAllBrokerWithLock();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 心跳数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeartbeatData</span> <span class="keyword">extends</span> <span class="title class_">RemotingSerializable</span> &#123;</span><br><span class="line">    <span class="comment">// 客户端 ID  ip@pid</span></span><br><span class="line">    <span class="keyword">private</span> String clientID;</span><br><span class="line">    <span class="comment">// 存储客户端所有生产者数据</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;ProducerData&gt; producerDataSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ProducerData&gt;();</span><br><span class="line">    <span class="comment">// 存储客户端所有消费者数据</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;ConsumerData&gt; consumerDataSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ConsumerData&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时任务 3：消费者持久化消费数据，周期 5 秒一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MQClientInstance.<span class="built_in">this</span>.persistAllConsumerOffset();</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时任务 4：动态调整消费者线程池，周期 1 分钟一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MQClientInstance.<span class="built_in">this</span>.adjustThreadPool();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>updateTopicRouteInfoFromNameServer()：<strong>更新路由数据</strong>，通过加锁保证当前实例只有一个线程去更新</p>
<ul>
<li><p><code>if (isDefault &amp;&amp; defaultMQProducer != null)</code>：需要默认数据</p>
<p><code>topicRouteData = ...getDefaultTopicRouteInfoFromNameServer()</code>：从 Namesrv 获取默认的 TBW102 的路由数据</p>
</li>
<li><p><code>topicRouteData = ...getTopicRouteInfoFromNameServer(topic)</code>：需要<strong>从 Namesrv 获取</strong>路由数据（同步）</p>
</li>
<li><p><code>old = this.topicRouteTable.get(topic)</code>：获取客户端实例本地的该主题的路由数据</p>
</li>
<li><p><code>boolean changed = topicRouteDataIsChange(old, topicRouteData)</code>：对比本地和最新下拉的数据是否一致</p>
</li>
<li><p><code>if (changed)</code>：不一致进入更新逻辑</p>
<p><code>this.brokerAddrTable.put(...)</code>：更新客户端 broker 物理<strong>节点映射表</strong></p>
<p><code>Update Pub info</code>：更新生产者信息</p>
<ul>
<li><code>publishInfo = topicRouteData2TopicPublishInfo(topic, topicRouteData)</code>：将主题路由数据转化为发布数据，会<strong>创建消息队列 MQ</strong>，放入发布数据对象的集合中</li>
<li><code>impl.updateTopicPublishInfo(topic, publishInfo)</code>：生产者将主题的发布数据保存到它本地，方便发送消息使用</li>
</ul>
<p><code>Update sub info</code>：更新消费者信息，创建 MQ 队列，更新订阅信息，用于负载均衡</p>
<p><code>this.topicRouteTable.put(topic, cloneTopicRouteData)</code>：<strong>将数据放入本地路由表</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="网络通信-1"><a href="#网络通信-1" class="headerlink" title="网络通信"></a>网络通信</h4><h5 id="成员属性-9"><a href="#成员属性-9" class="headerlink" title="成员属性"></a>成员属性</h5><p>NettyRemotingClient 类负责客户端的网络通信</p>
<p>成员变量：</p>
<ul>
<li><p>Netty 服务相关属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> NettyClientConfig nettyClientConfig;			<span class="comment">// 客户端的网络层配置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();		<span class="comment">// 客户端网络层启动对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup eventLoopGroupWorker;			<span class="comment">// 客户端网络层 Netty IO 线程组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Channel 映射表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ChannelWrapper&gt; channelTables;<span class="comment">// key 是服务器的地址，value 是通道对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lockChannelTables</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();		  <span class="comment">// 锁，控制并发安全</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器：启动定时任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="string">&quot;ClientHouseKeepingService&quot;</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ExecutorService publicExecutor;		<span class="comment">// 公共线程池</span></span><br><span class="line"><span class="keyword">private</span> ExecutorService callbackExecutor; 	<span class="comment">// 回调线程池，客户端发起异步请求，服务器的响应数据由回调线程池处理</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>事件监听器：客户端这里是 null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelEventListener channelEventListener;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>构造方法</p>
<ul>
<li><p>无参构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NettyRemotingClient</span><span class="params">(<span class="keyword">final</span> NettyClientConfig nettyClientConfig)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nettyClientConfig, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有参构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NettyRemotingClient</span><span class="params">(nettyClientConfig, channelEventListener)</span> &#123;</span><br><span class="line">    <span class="comment">// 父类创建了2个信号量，1、控制单向请求的并发度，2、控制异步请求的并发度</span></span><br><span class="line">    <span class="built_in">super</span>(nettyClientConfig.getClientOnewaySemaphoreValue(), nettyClientConfig.getClientAsyncSemaphoreValue());</span><br><span class="line">    <span class="built_in">this</span>.nettyClientConfig = nettyClientConfig;</span><br><span class="line">    <span class="built_in">this</span>.channelEventListener = channelEventListener;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建公共线程池</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">publicThreadNums</span> <span class="operator">=</span> nettyClientConfig.getClientCallbackExecutorThreads();</span><br><span class="line">    <span class="keyword">if</span> (publicThreadNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        publicThreadNums = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.publicExecutor = Executors.newFixedThreadPool(publicThreadNums,);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Netty IO 线程，1个线程</span></span><br><span class="line">    <span class="built_in">this</span>.eventLoopGroupWorker = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>, );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nettyClientConfig.isUseTLS()) &#123;</span><br><span class="line">  		sslContext = TlsHelper.buildSslContext(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-8"><a href="#成员方法-8" class="headerlink" title="成员方法"></a>成员方法</h5><ul>
<li><p>start()：启动方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// channel pipeline 内的 handler 使用的线程资源，默认 4 个</span></span><br><span class="line">    <span class="built_in">this</span>.defaultEventExecutorGroup = <span class="keyword">new</span> <span class="title class_">DefaultEventExecutorGroup</span>();</span><br><span class="line">    <span class="comment">// 配置 netty 客户端启动类对象</span></span><br><span class="line">    <span class="type">Bootstrap</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.bootstrap.group(<span class="built_in">this</span>.eventLoopGroupWorker).channel(NioSocketChannel.class)</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                <span class="comment">// 加几个handler</span></span><br><span class="line">                pipeline.addLast(</span><br><span class="line">                    <span class="comment">// 服务端的数据，都会来到这个</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">// 注意 Bootstrap 只是配置好客户端的元数据了，【在这里并没有创建任何 channel 对象】</span></span><br><span class="line">    <span class="comment">// 定时任务 扫描 responseTable 中超时的 ResponseFuture，避免客户端线程长时间阻塞</span></span><br><span class="line">    <span class="built_in">this</span>.timer.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">     	NettyRemotingClient.<span class="built_in">this</span>.scanResponseTable();</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">3</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 这里是 null，不启动</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.channelEventListener != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.nettyEventExecutor.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单向通信：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RemotingCommand <span class="title function_">invokeSync</span><span class="params">(String addr, <span class="keyword">final</span> RemotingCommand request, <span class="type">long</span> timeoutMillis)</span> &#123;</span><br><span class="line">    <span class="comment">// 开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">beginStartTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 获取或者创建客户端与服务端（addr）的通道 channel</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="built_in">this</span>.getAndCreateChannel(addr);</span><br><span class="line">    <span class="comment">// 条件成立说明客户端与服务端 channel 通道正常，可以通信</span></span><br><span class="line">    <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行 rpcHook 拓展点</span></span><br><span class="line">            doBeforeRpcHooks(addr, request);</span><br><span class="line">            <span class="comment">// 计算耗时，如果当前耗时已经超过 timeoutMillis 限制，则直接抛出异常，不再进行系统通信</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">costTime</span> <span class="operator">=</span> System.currentTimeMillis() - beginStartTime;</span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt; costTime) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemotingTimeoutException</span>(<span class="string">&quot;invokeSync call timeout&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 参数1：客户端-服务端通道channel</span></span><br><span class="line">            <span class="comment">// 参数二：网络层传输对象，封装着请求数据</span></span><br><span class="line">            <span class="comment">// 参数三：剩余的超时限制</span></span><br><span class="line">            <span class="type">RemotingCommand</span> <span class="variable">response</span> <span class="operator">=</span> <span class="built_in">this</span>.invokeSyncImpl(channel, request, ...);</span><br><span class="line">            <span class="comment">// 后置处理</span></span><br><span class="line">            doAfterRpcHooks(RemotingHelper.parseChannelRemoteAddr(channel), request, response);</span><br><span class="line">            <span class="comment">// 返回响应数据</span></span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingSendRequestException e) &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.closeChannel(addr, channel);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemotingConnectException</span>(addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h4><h5 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h5><p>BrokerStartup 初始化 BrokerController 调用 <code>registerProcessor()</code> 方法将 SendMessageProcessor 注册到 NettyRemotingServer 中，对应的请求 ID 为 <code>SEND_MESSAGE = 10</code>，NettyServerHandler 在处理请求时通过 CMD 会获取处理器执行 processRequest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：处理通道的事件；   参数二：客户端</span></span><br><span class="line"><span class="keyword">public</span> RemotingCommand <span class="title function_">processRequest</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span>  &#123;</span><br><span class="line">    <span class="type">RemotingCommand</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   	response = asyncProcessRequest(ctx, request).get();</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SendMessageProcessor#asyncConsumerSendMsgBack：异步发送消费者的回调消息</p>
<ul>
<li><p><code>final RemotingCommand response</code>：创建一个服务器响应对象</p>
</li>
<li><p><code>final ConsumerSendMsgBackRequestHeader requestHeader</code>：解析出客户端请求头信息，几个<strong>核心字段</strong>：</p>
<ul>
<li><code>private Long offset</code>：回退消息的 CommitLog offset</li>
<li><code>private Integer delayLevel</code>：延迟级别，一般是 0</li>
<li><code>private String originMsgId, originTopic</code>：原始的消息 ID，主题</li>
<li><code>private Integer maxReconsumeTimes</code>：最大重试次数，默认是 16 次</li>
</ul>
</li>
<li><p><code>if ()</code>：鉴权，是否找到订阅组配置、Broker 是否支持写请求、订阅组是否支持消息重试</p>
</li>
<li><p><code>String newTopic = MixAll.getRetryTopic(...)</code>：<strong>获取消费者组的重试主题</strong>，规则是 <code>%RETRY%GroupName</code></p>
</li>
<li><p><code>int queueIdInt = Math.abs()</code>：<strong>重试主题下的队列 ID 是 0</strong></p>
</li>
<li><p><code>TopicConfig topicConfig</code>：获取重试主题的配置信息</p>
</li>
<li><p><code>MessageExt msgExt</code>：根据消息的物理 offset 到存储模块查询，内部先查询出这条消息的 size，然后再根据 offset 和 size 查询出整条 msg</p>
</li>
<li><p><code>final String retryTopic</code>：获取消息的原始主题</p>
</li>
<li><p><code>if (null == retryTopic)</code>：条件成立说明<strong>当前消息是第一次被回退</strong>， 添加 <code>RETRY_TOPIC</code> 属性</p>
</li>
<li><p><code>msgExt.setWaitStoreMsgOK(false)</code>：异步刷盘</p>
</li>
<li><p><code>if (msgExt...() &gt;= maxReconsumeTimes || delayLevel &lt; 0)</code>：消息重试次数超过最大次数，不支持重试</p>
<p><code>newTopic = MixAll.getDLQTopic()</code>：<strong>获取消费者的死信队列</strong>，规则是 <code>%DLQ%GroupName</code></p>
<p><code>queueIdInt, topicConfig</code>：死信队列 ID 为 0，创建死信队列的配置</p>
</li>
<li><p><code>if (0 == delayLevel)</code>：说明延迟级别由 Broker 控制</p>
<p><code>delayLevel = 3 + msgExt.getReconsumeTimes()</code>：<strong>延迟级别默认从 3 级开始</strong>，每重试一次，延迟级别 +1</p>
</li>
<li><p><code>msgExt.setDelayTimeLevel(delayLevel)</code>：<strong>将延迟级别设置进消息属性</strong>，存储时会检查该属性，该属性值 &gt; 0 会<strong>将消息的主题和队列修改为调度主题和调度队列 ID</strong></p>
</li>
<li><p><code>MessageExtBrokerInner msgInner</code>：创建一条空消息，消息属性从 offset 查询出来的 msg 中拷贝</p>
</li>
<li><p><code>msgInner.setReconsumeTimes)</code>：重试次数设置为原 msg 的次数 +1</p>
</li>
<li><p><code>UtilAll.isBlank(originMsgId)</code>：判断消息是否是初次返回到服务器</p>
<ul>
<li>true：说明 msgExt 消息是第一次被返回到服务器，此时使用该 msg 的 id 作为 originMessageId</li>
<li>false：说明原始消息已经被重试不止 1 次，此时使用 offset 查询出来的 msg 中的 originMessageId</li>
</ul>
</li>
<li><p><code>CompletableFuture putMessageResult = ..asyncPutMessage(msgInner)</code>：调用存储模块存储消息</p>
<p><code>DefaultMessageStore#asyncPutMessage</code>：</p>
<ul>
<li><code>PutMessageResult result = this.commitLog.asyncPutMessage(msg)</code>：<strong>将新消息存储到 CommitLog 中</strong></li>
</ul>
</li>
</ul>
<hr>
<h5 id="调度服务"><a href="#调度服务" class="headerlink" title="调度服务"></a>调度服务</h5><p>DefaultMessageStore 中有成员属性 ScheduleMessageService，在 start 方法中会启动该调度服务</p>
<p>成员变量：</p>
<ul>
<li><p>延迟级别属性表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储延迟级别对应的 延迟时间长度 （单位：毫秒）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Integer <span class="comment">/* level */</span>, Long<span class="comment">/* delay timeMillis */</span>&gt; delayLevelTable;</span><br><span class="line"><span class="comment">// 存储延迟级别 queue 的消费进度 offset，该 table 每 10 秒钟，会持久化一次，持久化到本地磁盘</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Integer <span class="comment">/* level */</span>, Long<span class="comment">/* offset */</span>&gt; offsetTable;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最大延迟级别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> maxDelayLevel;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块启动状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器：内部有线程资源，可执行调度任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Timer timer;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>成员方法：</p>
<ul>
<li><p>load()：加载调度消息，<strong>初始化 delayLevelTable 和 offsetTable</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">load</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>start()：启动消息调度服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>if (started.compareAndSet(false, true))</code>：将启动状态设为 true</p>
</li>
<li><p><code>this.timer</code>：创建定时器对象</p>
</li>
<li><p><code>for (... : this.delayLevelTable.entrySet())</code>：为<strong>每个延迟级别创建一个延迟任务</strong>提交到 timer ，周期执行，这样就可以<strong>将延迟消息得到及时的消费</strong></p>
</li>
<li><p><code>this.timer.scheduleAtFixedRate()</code>：提交周期型任务，延迟 10 秒执行，周期为 10 秒，持久化延迟队列消费进度任务</p>
<p><code>ScheduleMessageService.this.persist()</code>：持久化消费进度</p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="调度任务"><a href="#调度任务" class="headerlink" title="调度任务"></a>调度任务</h5><p>DeliverDelayedMessageTimerTask 是一个任务类</p>
<p>成员变量：</p>
<ul>
<li><p>延迟级别：延迟队列任务处理的延迟级别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> delayLevel;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费进度：延迟队列任务处理的延迟队列的消费进度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> offset;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>成员方法：</p>
<ul>
<li><p>run()：执行任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isStarted()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.executeOnTimeup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>executeOnTimeup()：执行任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeOnTimeup</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ConsumeQueue cq</code>：获取出该延迟队列任务处理的<strong>延迟队列 ConsumeQueue</strong></p>
</li>
<li><p><code>SelectMappedBufferResult bufferCQ</code>：根据消费进度查询出 SMBR 对象</p>
</li>
<li><p><code>for (; i &lt; bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE)</code>：每次读取 20 各字节的数据</p>
</li>
<li><p><code>offsetPy, sizePy</code>：延迟消息的物理偏移量和消息大小</p>
</li>
<li><p><code>long tagsCode</code>：延迟消息的交付时间，在 ReputMessageService 转发时根据消息的 DELAY 属性是否 &gt;0 ，会在 tagsCode 字段存储交付时间</p>
</li>
<li><p><code>long deliver... = this.correctDeliverTimestamp(..)</code>：<strong>校准交付时间</strong>，延迟时间过长会调整为当前时间立刻执行</p>
</li>
<li><p><code>long countdown = deliverTimestamp - now</code>：计算差值</p>
</li>
<li><p><code>if (countdown &lt;= 0)</code>：<strong>消息已经到达交付时间了</strong></p>
<p><code>MessageExt msgExt</code>：根据物理偏移量和消息大小获取这条消息</p>
<p><code>MessageExtBrokerInner msgInner</code>：<strong>构建一条新消息</strong>，将原消息的属性拷贝过来</p>
<ul>
<li><code>long tagsCodeValue</code>：不再是交付时间了</li>
<li><code>MessageAccessor.clearProperty(msgInner, DELAY..)</code>：清理新消息的 DELAY 属性，避免存储时重定向到延迟队列</li>
<li><code>msgInner.setTopic()</code>：<strong>修改主题为原始的主题 <code>%RETRY%GroupName</code></strong></li>
<li><code>String queueIdStr</code>：修改队列 ID 为原始的 ID</li>
</ul>
<p><code>PutMessageResult putMessageResult</code>：<strong>将新消息存储到 CommitLog</strong>，消费者订阅的是目标主题，会再次消费该消息</p>
</li>
<li><p><code>else</code>：消息还未到达交付时间</p>
<p><code>ScheduleMessageService.this.timer.schedule()</code>：创建该延迟级别的任务，延迟 countDown 毫秒之后再执行</p>
<p><code>ScheduleMessageService.this.updateOffset()</code>：更新延迟级别队列的消费进度</p>
</li>
<li><p><code>PutMessageResult putMessageResult</code></p>
</li>
<li><p><code>bufferCQ == null</code>：说明通过消费进度没有获取到数据</p>
<p><code>if (offset &lt; cqMinOffset)</code>：如果消费进度比最小位点都小，说明是过期数据，重置为最小位点 </p>
</li>
<li><p><code>ScheduleMessageService.this.timer.schedule()</code>：重新提交该延迟级别对应的延迟队列任务，延迟 100 毫秒后执行</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="事务消息-1"><a href="#事务消息-1" class="headerlink" title="事务消息"></a>事务消息</h4><h5 id="生产者类-2"><a href="#生产者类-2" class="headerlink" title="生产者类"></a>生产者类</h5><p>TransactionMQProducer 类发送事务消息时使用</p>
<p>成员变量：</p>
<ul>
<li><p>事务回查线程池资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">* 事务监听器：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">private</span> TransactionListener transactionListener;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>核心方法：</p>
<ul>
<li><p>start()：启动方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.defaultMQProducerImpl.initTransactionEnv()</code>：初始化生产者实例和回查线程池资源</li>
<li><code>super.start()</code>：启动生产者实例</li>
</ul>
</li>
<li><p>sendMessageInTransaction()：发送事务消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TransactionSendResult <span class="title function_">sendMessageInTransaction</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> Object arg)</span> &#123;</span><br><span class="line">    msg.setTopic(NamespaceUtil.wrapNamespace(<span class="built_in">this</span>.getNamespace(), msg.getTopic()));</span><br><span class="line">    <span class="comment">// 调用实现类的发送方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.defaultMQProducerImpl.sendMessageInTransaction(msg, <span class="literal">null</span>, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>TransactionListener transactionListener = getCheckListener()</code>：获取监听器</p>
</li>
<li><p><code>if (null == localTransactionExecuter &amp;&amp; null == transactionListener)</code>：两者都为 null 抛出异常</p>
</li>
<li><p><code>MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, &quot;true&quot;)</code>：<strong>设置事务标志</strong></p>
</li>
<li><p><code>sendResult = this.send(msg)</code>：发送消息，同步发送</p>
</li>
<li><p><code>switch (sendResult.getSendStatus())</code>：<strong>判断发送消息的结果状态</strong></p>
</li>
<li><p><code>case SEND_OK</code>：消息发送成功</p>
<p><code>msg.setTransactionId(transactionId)</code>：<strong>设置事务 ID 为消息的 UNIQ_KEY 属性</strong></p>
<p><code>localTransactionState = ...executeLocalTransactionBranch(msg, arg)</code>：<strong>执行本地事务</strong></p>
</li>
<li><p><code>case SLAVE_NOT_AVAILABLE</code>：其他情况都需要回滚事务</p>
<p><code>localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE</code>：<strong>事务状态设置为回滚</strong></p>
</li>
<li><p><code>this.endTransaction(sendResult, ...)</code>：结束事务</p>
<ul>
<li><code>EndTransactionRequestHeader requestHeader</code>：构建事务结束头对象</li>
<li><code>this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway()</code>：向 Broker 发起事务结束的单向请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="接受消息"><a href="#接受消息" class="headerlink" title="接受消息"></a>接受消息</h5><p>SendMessageProcessor 是服务端处理客户端发送来的消息的处理器，<code>processRequest()</code> 方法处理请求</p>
<p>核心方法：</p>
<ul>
<li><p><code>asyncProcessRequest()</code>：处理请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;RemotingCommand&gt; <span class="title function_">asyncProcessRequest</span><span class="params">(ChannelHandlerContext ctx,</span></span><br><span class="line"><span class="params">                                                              RemotingCommand request)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> SendMessageContext mqtraceContext;</span><br><span class="line">    <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">            <span class="comment">// 回调消息回退</span></span><br><span class="line">        <span class="keyword">case</span> RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.asyncConsumerSendMsgBack(ctx, request);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 解析出请求头对象</span></span><br><span class="line">            <span class="type">SendMessageRequestHeader</span> <span class="variable">requestHeader</span> <span class="operator">=</span> parseRequestHeader(request);</span><br><span class="line">            <span class="keyword">if</span> (requestHeader == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建上下文对象</span></span><br><span class="line">            mqtraceContext = buildMsgContext(ctx, requestHeader);</span><br><span class="line">            <span class="comment">// 前置处理器</span></span><br><span class="line">            <span class="built_in">this</span>.executeSendMessageHookBefore(ctx, request, mqtraceContext);</span><br><span class="line">            <span class="comment">// 判断是否是批量消息</span></span><br><span class="line">            <span class="keyword">if</span> (requestHeader.isBatch()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.asyncSendBatchMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.asyncSendMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>asyncSendMessage()：异步处理发送消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> CompletableFuture&lt;RemotingCommand&gt; <span class="title function_">asyncSendMessage</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request, SendMessageContext mqtraceContext, SendMessageRequestHeader requestHeader)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>RemotingCommand response</code>：创建响应对象</p>
</li>
<li><p><code>MessageExtBrokerInner msgInner = new MessageExtBrokerInner()</code>：创建 msgInner 对象，并赋值相关的属性，主题和队列 ID 都是请求头中的</p>
</li>
<li><p><code>String transFlag</code>：<strong>获取事务属性</strong></p>
</li>
<li><p><code>if (transFlag != null &amp;&amp; Boolean.parseBoolean(transFlag))</code>：判断事务属性是否是 true，走事务消息的存储流程</p>
<ul>
<li><p><code>putMessageResult = ...asyncPrepareMessage(msgInner)</code>：<strong>事务消息处理流程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;PutMessageResult&gt; <span class="title function_">asyncPutHalfMessage</span><span class="params">(MessageExtBrokerInner messageInner)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用存储模块，将修改后的 msg 存储进 Broker(CommitLog)</span></span><br><span class="line">    <span class="keyword">return</span> store.asyncPutMessage(parseHalfMessageInner(messageInner));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TransactionalMessageBridge#parseHalfMessageInner：</p>
<ul>
<li><code>MessageAccessor.putProperty(...)</code>：<strong>将消息的原主题和队列 ID 放入消息的属性中</strong></li>
<li><code>msgInner.setSysFlag(...)</code>：消息设置为非事务状态</li>
<li><code>msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic())</code>：<strong>消息主题设置为半消息主题</strong></li>
<li><code>msgInner.setQueueId(0)</code>：<strong>队列 ID 设置为 0</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><code>else</code>：普通消息存储</p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="回查处理"><a href="#回查处理" class="headerlink" title="回查处理"></a>回查处理</h5><p>ClientRemotingProcessor 是客户端用于处理请求，创建 MQClientAPIImpl 时将该处理器注册到 Netty 中，<code>processRequest()</code> 方法根据请求的命令码，进行不同的处理，事务回查的处理命令码为 <code>CHECK_TRANSACTION_STATE</code></p>
<p>Broker 端有定时任务发送回查请求</p>
<p>成员方法：</p>
<ul>
<li><p>checkTransactionState()：检查事务状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RemotingCommand <span class="title function_">checkTransactionState</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>final CheckTransactionStateRequestHeader requestHeader</code>：解析出请求头对象</li>
<li><code>final MessageExt messageExt</code>：从请求 body 中解析出服务器回查的事务消息</li>
<li><code>String transactionId</code>：提取 UNIQ_KEY 字段属性值赋值给事务 ID</li>
<li><code>final String group</code>：提取生产者组名</li>
<li><code>MQProducerInner producer = this...selectProducer(group)</code>：根据生产者组获取生产者对象</li>
<li><code>String addr = RemotingHelper.parseChannelRemoteAddr()</code>：解析出要回查的 Broker 服务器的地址</li>
<li><code>producer.checkTransactionState(addr, messageExt, requestHeader)</code>：生产者的事务回查<ul>
<li><code>Runnable request = new Runnable()</code>：<strong>创建回查事务状态任务对象</strong><ul>
<li>获取生产者的 TransactionCheckListener 和 TransactionListener，选择一个不为 null 的监听器进行事务状态回查</li>
<li><code>this.processTransactionState()</code>：处理回查状态<ul>
<li><code>EndTransactionRequestHeader thisHeader</code>：构建 EndTransactionRequestHeader 对象</li>
<li><code>DefaultMQProducerImpl...endTransactionOneway()</code>：向 Broker 发起结束事务单向请求，<strong>二阶段提交</strong></li>
</ul>
</li>
</ul>
</li>
<li><code>this.checkExecutor.submit(request)</code>：提交到线程池运行</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>参考图：<a href="https://www.processon.com/view/link/61c8257e0e3e7474fb9dcbc0">https://www.processon.com/view/link/61c8257e0e3e7474fb9dcbc0</a></p>
<p>参考视频：<a href="https://space.bilibili.com/457326371">https://space.bilibili.com/457326371</a></p>
<hr>
<h5 id="事务提交"><a href="#事务提交" class="headerlink" title="事务提交"></a>事务提交</h5><p>EndTransactionProcessor 类是服务端用来处理客户端发来的提交或者回滚请求</p>
<ul>
<li><p>processRequest()：处理请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RemotingCommand <span class="title function_">processRequest</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>EndTransactionRequestHeader requestHeader</code>：从请求中解析出 EndTransactionRequestHeader</p>
</li>
<li><p><code>if (MessageSysFlag.TRANSACTION_COMMIT_TYPE)</code>：<strong>事务提交</strong></p>
<p><code>result = this.brokerController...commitMessage(requestHeader)</code>：根据 commitLogOffset 提取出 halfMsg 消息</p>
<p><code>MessageExtBrokerInner msgInner</code>：根据 result 克隆出一条新消息</p>
<ul>
<li><p><code>msgInner.setTopic(msgExt.getUserProperty(...))</code>：<strong>设置回原主题</strong></p>
</li>
<li><p><code>msgInner.setQueueId(Integer.parseInt(msgExt.getUserProperty(..)))</code>：<strong>设置回原队列 ID</strong></p>
</li>
<li><p><code>MessageAccessor.clearProperty()</code>：清理上面的两个属性</p>
</li>
</ul>
<p><code>MessageAccessor.clearProperty(msgInner, ...)</code>：<strong>清理事务属性</strong></p>
<p><code>RemotingCommand sendResult = sendFinalMessage(msgInner)</code>：调用存储模块存储至 Broker</p>
<p><code>this.brokerController...deletePrepareMessage(result.getPrepareMessage())</code>：<strong>向删除（OP）队列添加消息</strong>，消息体的数据是 halfMsg 的 queueOffset，<strong>表示半消息队列指定的 offset 的消息已被删除</strong></p>
<ul>
<li><code>if (this...putOpMessage(msgExt, TransactionalMessageUtil.REMOVETAG))</code>：添加一条 OP 数据<ul>
<li><code>MessageQueue messageQueue</code>：新建一个消息队列，OP 队列</li>
<li><code>return addRemoveTagInTransactionOp(messageExt, messageQueue)</code>：添加数据<ul>
<li><code>Message message</code>：创建 OP 消息</li>
<li><code>writeOp(message, messageQueue)</code>：写入 OP 消息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>else if (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE)</code>：<strong>事务回滚</strong></p>
<p><code>this.brokerController...deletePrepareMessage(result.getPrepareMessage())</code>：<strong>也需要向 OP 队列添加消息</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><h4 id="消费者类"><a href="#消费者类" class="headerlink" title="消费者类"></a>消费者类</h4><h5 id="默认消费"><a href="#默认消费" class="headerlink" title="默认消费"></a>默认消费</h5><p>DefaultMQPushConsumer 类是默认的消费者类</p>
<p>成员变量：</p>
<ul>
<li><p>消费者实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">transient</span> DefaultMQPushConsumerImpl defaultMQPushConsumerImpl;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String consumerGroup;									<span class="comment">// 消费者组</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">MessageModel</span> <span class="variable">messageModel</span> <span class="operator">=</span> MessageModel.CLUSTERING;	<span class="comment">// 消费模式，默认集群模式</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>订阅信息：key 是主题，value 是过滤表达式，一般是 tag</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, String &gt; subscription = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;()</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息监听器：<strong>消息处理逻辑</strong>，并发消费 MessageListenerConcurrently，顺序（分区）消费 MessageListenerOrderly</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> MessageListener messageListener;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费位点：当从 Broker 获取当前组内该 queue 的 offset 不存在时，consumeFromWhere 才有效，默认值代表从队列的最后 offset 开始消费，当队列内再有一条新的 msg 加入时，消费者才会去消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ConsumeFromWhere</span> <span class="variable">consumeFromWhere</span> <span class="operator">=</span> ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费时间戳：当消费位点配置的是 CONSUME_FROM_TIMESTAMP 时，并且服务器 Group 内不存在该 queue 的 offset 时，会使用该时间戳进行消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">consumeTimestamp</span> <span class="operator">=</span> UtilAll.timeMillisToHumanString3(System.currentTimeMillis() - (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">30</span>));<span class="comment">// 消费者创建时间 - 30秒，转换成 格式： 年月日小时分钟秒，比如 20220203171201</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>队列分配策略：主题下的队列分配策略，RebalanceImpl 对象依赖该算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AllocateMessageQueueStrategy allocateMessageQueueStrategy;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费进度存储器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> OffsetStore offsetStore;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>核心方法：</p>
<ul>
<li><p>start()：启动消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>shutdown()：关闭消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>registerMessageListener()：注册消息监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerMessageListener</span><span class="params">(MessageListener messageListener)</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>subscribe()：添加订阅信息，<strong>将订阅信息放入负载均衡对象的 subscriptionInner 中</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(String topic, String subExpression)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>unsubscribe()：删除订阅指定主题的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unsubscribe</span><span class="params">(String topic)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>suspend()：停止消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">suspend</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>resume()：恢复消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resume</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h5><p>DefaultMQPushConsumerImpl 是默认消费者的实现类</p>
<p>成员变量：</p>
<ul>
<li><p>客户端实例：整个进程内只有一个客户端实例对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> MQClientInstance mQClientFactory;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者实例：门面对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultMQPushConsumer defaultMQPushConsumer;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>负载均衡</strong>：分配订阅主题的队列给当前消费者，20 秒钟一个周期执行 Rebalance 算法（客户端实例触发）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">RebalanceImpl</span> <span class="variable">rebalanceImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RebalancePushImpl</span>(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> consumerStartTimestamp;	<span class="comment">// 消费者启动时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ServiceState serviceState;	<span class="comment">// 消费者状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">pause</span> <span class="operator">=</span> <span class="literal">false</span>;		<span class="comment">// 是否暂停</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">consumeOrderly</span> <span class="operator">=</span> <span class="literal">false</span>;		<span class="comment">// 是否顺序消费</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>拉取消息</strong>：封装拉消息的 API，服务器 Broker 返回结果中包含下次 Pull 时推荐的 BrokerId，根据本次请求数据的冷热程度进行推荐</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> PullAPIWrapper pullAPIWrapper;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>消息消费</strong>服务：并发消费和顺序消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ConsumeMessageService consumeMessageService;</span><br></pre></td></tr></table></figure>
</li>
<li><p>流控：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">queueFlowControlTimes</span> <span class="operator">=</span> <span class="number">0</span>;			<span class="comment">// 队列流控次数，默认每1000次流控，进行一次日志打印</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">queueMaxSpanFlowControlTimes</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">// 流控使用，控制打印日志</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HOOK：钩子方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 过滤消息 hook</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;FilterMessageHook&gt; filterMessageHookList;</span><br><span class="line"><span class="comment">// 消息执行hook，在消息处理前和处理后分别执行 hook.before  hook.after 系列方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ConsumeMessageHook&gt; consumeMessageHookList;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>核心方法：</p>
<ul>
<li><p>start()：加锁保证线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> </span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.checkConfig()</code>：检查配置，包括组名、消费模式、订阅信息、消息监听器等</li>
<li><code>this.copySubscription()</code>：拷贝订阅信息到 RebalanceImpl 对象<ul>
<li><code>this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData)</code>：将订阅信息加入 rbl 的 map 中</li>
<li><code>this.messageListenerInner = ...getMessageListener()</code>：将消息监听器保存到实例对象</li>
<li><code>switch (this.defaultMQPushConsumer.getMessageModel())</code>：判断消费模式，广播模式下直接返回</li>
<li><code>final String retryTopic</code>：创建当前<strong>消费者组重试的主题名</strong>，规则 <code>%RETRY%ConsumerGroup</code></li>
<li><code>SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData()</code>：创建重试主题的订阅数据对象</li>
<li><code>this.rebalanceImpl.getSubscriptionInner().put(retryTopic, subscriptionData)</code>：将创建的重试主题加入到 rbl 对象的 map 中，<strong>消息重试时会加入到该主题，消费者订阅这个主题之后，就有机会再次拿到该消息进行消费处理</strong></li>
</ul>
</li>
<li><code>this.mQClientFactory = ...getOrCreateMQClientInstance()</code>：获取客户端实例对象</li>
<li><code>this.rebalanceImpl.</code>：初始化负载均衡对象，设置<strong>队列分配策略对象</strong>到属性中</li>
<li><code>this.pullAPIWrapper = new PullAPIWrapper()</code>：创建拉消息 API 对象，内部封装了查询推荐主机算法</li>
<li><code>this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList)</code>：将过滤 Hook 列表注册到该对象内，消息拉取下来之后会执行该 Hook，<strong>再进行一次自定义的消息过滤</strong></li>
<li><code>this.offsetStore = new RemoteBrokerOffsetStore()</code>：默认集群模式下创建消息进度存储器</li>
<li><code>this.consumeMessageService = ...</code>：根据消息监听器的类型创建消费服务</li>
<li><code>this.consumeMessageService.start()</code>：启动消费服务</li>
<li><code>boolean registerOK = mQClientFactory.registerConsumer()</code>：<strong>将消费者注册到客户端实例中</strong>，客户端提供的服务：<ul>
<li>心跳服务：把订阅数据同步到订阅主题的 Broker</li>
<li>拉消息服务：内部 PullMessageService 启动线程，基于 PullRequestQueue 工作，消费者负载均衡分配到队列后会向该队列提交 PullRequest</li>
<li>队列负载服务：每 20 秒调用一次 <code>consumer.doRebalance()</code> 接口</li>
<li>消息进度持久化</li>
<li>动态调整消费者、消费服务线程池</li>
</ul>
</li>
<li><code>mQClientFactory.start()</code>：启动客户端实例</li>
<li><code> this.updateTopic</code>：从 nameserver 获取主题路由数据，生成主题集合放入 rbl 对象的 table</li>
<li><code>this.mQClientFactory.checkClientInBroker()</code>：检查服务器是否支持消息过滤模式，一般使用 tag 过滤，服务器默认支持</li>
<li><code>this.mQClientFactory.sendHeartbeatToAllBrokerWithLock()</code>：向所有已知的 Broker 节点，<strong>发送心跳数据</strong></li>
<li><code>this.mQClientFactory.rebalanceImmediately()</code>：唤醒 rbl 线程，触发负载均衡执行</li>
</ul>
</li>
</ul>
<hr>
<h4 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h4><h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><p>MQClientInstance#start 中会启动负载均衡服务 RebalanceService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 检查停止标记</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="comment">// 休眠 20 秒，防止其他线程饥饿，所以【每 20 秒负载均衡一次】</span></span><br><span class="line">        <span class="built_in">this</span>.waitForRunning(waitInterval);</span><br><span class="line">        <span class="comment">// 调用客户端实例的负载均衡方法，底层【会遍历所有消费者，调用消费者的负载均衡】</span></span><br><span class="line">        <span class="built_in">this</span>.mqClientFactory.doRebalance();</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RebalanceImpl 类成员变量：</p>
<ul>
<li><p>分配给当前消费者的处理队列：处理消息队列集合，<strong>ProcessQueue 是 MQ 队列在消费者端的快照</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ConcurrentMap&lt;MessageQueue, ProcessQueue&gt; processQueueTable;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者订阅主题的队列信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* topic */</span>, Set&lt;MessageQueue&gt;&gt; topicSubscribeInfoTable;</span><br></pre></td></tr></table></figure>
</li>
<li><p>订阅数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* topic */</span>, SubscriptionData&gt; subscriptionInner;</span><br></pre></td></tr></table></figure>
</li>
<li><p>队列分配策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AllocateMessageQueueStrategy allocateMessageQueueStrategy;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>成员方法：</p>
<ul>
<li><p>doRebalance()：负载均衡方法，以每个消费者实例为粒度进行负载均衡</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doRebalance</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> isOrder)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前消费者的订阅数据</span></span><br><span class="line">    Map&lt;String, SubscriptionData&gt; subTable = <span class="built_in">this</span>.getSubscriptionInner();</span><br><span class="line">    <span class="keyword">if</span> (subTable != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的订阅主题</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 获取订阅的主题</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="comment">// 按照主题进行负载均衡</span></span><br><span class="line">            <span class="built_in">this</span>.rebalanceByTopic(topic, isOrder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将分配到当前消费者的队列进行过滤，不属于当前消费者订阅主题的直接移除</span></span><br><span class="line">    <span class="built_in">this</span>.truncateMessageQueueNotMyTopic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集群模式下：</p>
<ul>
<li><p><code>Set&lt;MessageQueue&gt; mqSet = this.topicSubscribeInfoTable.get(topic)</code>：订阅的主题下的全部队列信息</p>
</li>
<li><p><code>cidAll = this...findConsumerIdList(topic, consumerGroup)</code>：从服务器获取消费者组下的全部消费者 ID</p>
</li>
<li><p><code>Collections.sort(mqAll)</code>：主题 MQ 队列和消费者 ID 都进行排序，<strong>保证每个消费者的视图一致性</strong></p>
</li>
<li><p><code>allocateResult = strategy.allocate()</code>： <strong>调用队列分配策略</strong>，给当前消费者进行分配 MessageQueue（下一节）</p>
</li>
<li><p><code>boolean changed = this.updateProcessQueueTableInRebalance(...)</code>：<strong>更新队列处理集合</strong>，mqSet 是 rbl 算法分配到当前消费者的 MQ 集合</p>
<ul>
<li><p><code>while (it.hasNext())</code>：遍历当前消费者的所有处理队列</p>
</li>
<li><p><code>if (mq.getTopic().equals(topic))</code>：该 MQ 是 本次 rbl 分配算法计算的主题</p>
</li>
<li><p><code>if (!mqSet.contains(mq))</code>：该 MQ 经过 rbl 计算之后，<strong>被分配到其它 Consumer 节点</strong></p>
<p><code>pq.setDropped(true)</code>：将删除状态设置为 true</p>
<p><code>if (this.removeUnnecessaryMessageQueue(mq, pq))</code>：删除不需要的 MQ 队列</p>
<ul>
<li><p><code>this...getOffsetStore().persist(mq)</code>：在 MQ 归属的 Broker 节点持久化消费进度</p>
</li>
<li><p><code>this...getOffsetStore().removeOffset(mq)</code>：删除该 MQ 在本地的消费进度</p>
</li>
<li><p><code>if (this.defaultMQPushConsumerImpl.isConsumeOrderly() &amp;&amp;)</code>：是否是<strong>顺序消费</strong>和集群模式</p>
<p><code>if (pq.getLockConsume().tryLock(1000, ..))</code>： 获取锁成功，说明顺序消费任务已经停止消费工作</p>
<p><code>return this.unlockDelay(mq, pq)</code>：<strong>释放锁 Broker 端的队列锁，向服务器发起 oneway 的解锁请求</strong></p>
<ul>
<li><code>if (pq.hasTempMessage())</code>：队列中有消息，延迟 20 秒释放队列分布式锁，确保全局范围内只有一个消费任务 运行中</li>
<li><code>else</code>：当前消费者本地该消费任务已经退出，直接释放锁</li>
</ul>
<p><code>else</code>：顺序消费任务正在消费一批消息，不可打断，增加尝试获取锁的次数</p>
</li>
</ul>
<p><code>it.remove()</code>：从 processQueueTable 移除该 MQ</p>
</li>
<li><p><code>else if (pq.isPullExpired())</code>：说明当前 MQ 还是被当前 Consumer 消费，此时判断一下是否超过 2 分钟未到服务器 拉消息，如果条件成立进行上述相同的逻辑</p>
</li>
<li><p><code>for (MessageQueue mq : mqSet)</code>：开始处理当前主题<strong>新分配到当前节点的队列</strong></p>
<p><code>if (isOrder &amp;&amp; !this.lock(mq))</code>：<strong>顺序消息为了保证有序性，需要获取队列锁</strong></p>
<p><code>ProcessQueue pq = new ProcessQueue()</code>：为每个新分配的消息队列创建快照队列</p>
<p><code>long nextOffset = this.computePullFromWhere(mq)</code>：<strong>从服务端获取新分配的 MQ 的消费进度</strong></p>
<p><code>ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq)</code>：保存到处理队列集合</p>
<p><code>PullRequest pullRequest = new PullRequest()</code>：<strong>创建拉取请求对象</strong></p>
</li>
<li><p><code>this.dispatchPullRequest(pullRequestList)</code>：放入 PullMessageService 的<strong>本地阻塞队列</strong>内，用于拉取消息工作</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>lockAll()：续约锁，对消费者的所有队列进行续约</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockAll</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>HashMap&lt;String, Set&lt;MessageQueue&gt;&gt; brokerMqs</code>：将分配给当前消费者的全部 MQ 按照 BrokerName 分组</p>
</li>
<li><p><code>while (it.hasNext())</code>：遍历所有的分组</p>
</li>
<li><p><code>final Set&lt;MessageQueue&gt; mqs</code>：获取该 Broker 上分配给当前消费者的 queue 集合</p>
</li>
<li><p><code>FindBrokerResult findBrokerResult</code>：查询 Broker 主节点信息</p>
</li>
<li><p><code>LockBatchRequestBody requestBody</code>：创建请求对象，填充属性</p>
</li>
<li><p><code>Set&lt;MessageQueue&gt; lockOKMQSet</code>：<strong>以组为单位向 Broker 发起批量续约锁的同步请求</strong>，返回成功的队列集合</p>
</li>
<li><p><code>for (MessageQueue mq : lockOKMQSet)</code>：遍历续约锁成功的 MQ</p>
<p><code>processQueue.setLocked(true)</code>：<strong>分布式锁状态设置为 true，表示允许顺序消费</strong></p>
<p><code>processQueue.setLastLockTimestamp(System.currentTimeMillis())</code>：设置上次获取锁的时间为当前时间</p>
</li>
<li><p><code>for (MessageQueue mq : mqs)</code>：遍历当前 Broker 上的所有队列集合</p>
<p><code>if (!lockOKMQSet.contains(mq))</code>：条件成立说明续约锁失败</p>
<p><code>processQueue.setLocked(false)</code>：<strong>分布式锁状态设置为 false，表示不允许顺序消费</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="队列分配"><a href="#队列分配" class="headerlink" title="队列分配"></a>队列分配</h5><p>AllocateMessageQueueStrategy 类是队列的分配策略</p>
<ul>
<li><p>平均分配：AllocateMessageQueueAveragely 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：消费者组       								参数二：当前消费者id   </span></span><br><span class="line"><span class="comment">// 参数三：主题的全部队列，包括所有 broker 上该主题的 mq  	参数四：全部消费者id集合</span></span><br><span class="line"><span class="keyword">public</span> List&lt;MessageQueue&gt; <span class="title function_">allocate</span><span class="params">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll, List&lt;String&gt; cidAll)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前消费者在全部消费者中的位置，【全部消费者是已经排序好的，排在前面的优先分配更多的队列】</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> cidAll.indexOf(currentCID);</span><br><span class="line">    <span class="comment">// 平均分配完以后，还剩余的待分配的 mq 的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> mqAll.size() % cidAll.size();</span><br><span class="line">    <span class="comment">// 首先判断整体的 mq 的数量是否小于消费者的数量，小于消费者的数量就说明不够分的，先分一个</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">averageSize</span> <span class="operator">=</span> mqAll.size() &lt;= cidAll.size() ? <span class="number">1</span> :</span><br><span class="line">    	<span class="comment">// 成立需要多分配一个队列，因为更靠前</span></span><br><span class="line">    	(mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size() + <span class="number">1</span> : mqAll.size() / cidAll.size());</span><br><span class="line">    <span class="comment">// 获取起始的分配位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod) ? index * averageSize : index * averageSize + mod;</span><br><span class="line">    <span class="comment">// 防止索引越界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> Math.min(averageSize, mqAll.size() - startIndex);</span><br><span class="line">    <span class="comment">// 开始分配，【挨着分配，是直接就把当前的 消费者分配完成】</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">        result.add(mqAll.get((startIndex + i) % mqAll.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列排序后：Q1 → Q2 → Q3，消费者排序后 C1 → C2 → C3</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E5%B9%B3%E5%9D%87%E9%98%9F%E5%88%97%E5%88%86%E9%85%8D.png"></p>
</li>
<li><p>轮流分配：AllocateMessageQueueAveragelyByCircle</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E5%B9%B3%E5%9D%87%E9%98%9F%E5%88%97%E8%BD%AE%E6%B5%81%E5%88%86%E9%85%8D.png"></p>
</li>
<li><p>指定机房平均分配：AllocateMessageQueueByMachineRoom，前提是 Broker 的命名规则为 <code>机房名@BrokerName</code></p>
</li>
</ul>
<hr>
<h4 id="拉取服务"><a href="#拉取服务" class="headerlink" title="拉取服务"></a>拉取服务</h4><h5 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h5><p>MQClientInstance#start 中会启动消息拉取服务：PullMessageService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查停止标记，【循环拉取】</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从阻塞队列中获取拉消息请求</span></span><br><span class="line">            <span class="type">PullRequest</span> <span class="variable">pullRequest</span> <span class="operator">=</span> <span class="built_in">this</span>.pullRequestQueue.take();</span><br><span class="line">            <span class="comment">// 拉取消息，获取请求对应的使用当前消费者组中的哪个消费者，调用消费者的 pullMessage 方法</span></span><br><span class="line">            <span class="built_in">this</span>.pullMessage(pullRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Pull Message Service Run Method exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultMQPushConsumerImpl#pullMessage：</p>
<ul>
<li><p><code>ProcessQueue processQueue = pullRequest.getProcessQueue()</code>：获取请求对应的快照队列，并判断是否是删除状态</p>
</li>
<li><p><code>this.executePullRequestLater()</code>：如果当前消费者不是运行状态，则拉消息任务延迟 3 秒后执行，如果是暂停状态延迟 1 秒</p>
</li>
<li><p><strong>流控的逻辑</strong>：</p>
<p><code>long cachedMessageCount = processQueue.getMsgCount().get()</code>：获取消费者本地该 queue 快照内缓存的消息数量，如果大于 1000 条，进行流控，延迟 50 毫秒</p>
<p><code>long cachedMessageSizeInMiB</code>： 消费者本地该 queue 快照内缓存的消息容量 size，超过 100m 消息未被消费进行流控</p>
<p><code>if(processQueue.getMaxSpan() &gt; 2000)</code>：消费者本地缓存消息第一条消息最后一条消息跨度超过 2000 进行流控</p>
</li>
<li><p><code>SubscriptionData subscriptionData</code>：本次拉消息请求订阅的主题数据，如果调用了 <code>unsubscribe(主题)</code> 将会获取为 null</p>
</li>
<li><p><code>PullCallback pullCallback = new PullCallback()</code>：<strong>拉消息处理回调对象</strong></p>
<ul>
<li><p><code>pullResult = ...processPullResult()</code>：预处理 PullResult 结果，将服务器端指定 MQ 的拉消息<strong>下一次的推荐节点</strong>保存到 pullFromWhichNodeTable 中，<strong>并进行消息过滤</strong></p>
</li>
<li><p><code>case FOUND</code>：正常拉取到消息</p>
<p><code>pullRequest.setNextOffset(pullResult.getNextBeginOffset())</code>：更新 pullRequest 对象下一次拉取消息的位点</p>
<p><code>if (pullResult.getMsgFoundList() == null...)</code>：消息过滤导致消息全部被过滤掉，需要立马发起下一次拉消息</p>
<p><code>boolean .. = processQueue.putMessage()</code>：将服务器拉取的消息集合<strong>加入到消费者本地</strong>的 processQueue 内</p>
<p><code>DefaultMQPushConsumerImpl...submitConsumeRequest()</code>：<strong>提交消费任务，分为顺序消费和并发消费</strong></p>
<p><code>Defaul..executePullRequestImmediately(pullRequest)</code>：将更新过 nextOffset 字段的 PullRequest 对象，再次放到 pullMessageService 的阻塞队列中，<strong>形成闭环</strong></p>
</li>
<li><p><code>case NO_NEW_MSG ||NO_MATCHED_MSG</code>：<strong>表示本次 pull 没有新的可消费的信息</strong></p>
<p><code>pullRequest.setNextOffset()</code>：更新更新 pullRequest 对象下一次拉取消息的位点</p>
<p><code>Defaul..executePullRequestImmediately(pullRequest)</code>：再次拉取请求</p>
</li>
<li><p><code>case OFFSET_ILLEGAL</code>：<strong>本次 pull 时使用的 offset 是无效的</strong>，即 offset &gt; maxOffset || offset  &lt; minOffset</p>
<p><code>pullRequest.setNextOffset()</code>：调整 pullRequest.nextOffset 为正确的 offset</p>
<p><code>pullRequest.getProcessQueue().setDropped(true)</code>：设置该 processQueue 为删除状态，如果有该 queue 的消费任务，消费任务会马上停止</p>
<p><code>DefaultMQPushConsumerImpl.this.executeTaskLater()</code>：提交异步任务，10 秒后去执行</p>
<ul>
<li><p><code>DefaultMQPushConsumerImpl...updateOffset()</code>：更新 offsetStore 该 MQ 的 offset 为正确值，内部直接替换</p>
</li>
<li><p><code>DefaultMQPushConsumerImpl...persist()</code>：持久化该 messageQueue 的 offset 到 Broker 端</p>
</li>
<li><p><code>DefaultMQPushConsumerImpl...removeProcessQueue()</code>： 删除该消费者该 messageQueue 对应的 processQueue</p>
</li>
<li><p>这里没有再次提交 pullRequest 到 pullMessageService 的队列，那该队列不再拉消息了吗？</p>
<p>负载均衡 rbl 程序会重建该队列的 processQueue，重建完之后会为该队列创建新的 PullRequest 对象</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>int sysFlag = PullSysFlag.buildSysFlag()</code>：<strong>构建标志对象</strong>，sysFlag 高 4 位未使用，低 4 位使用，从左到右 0000 0011</p>
<ul>
<li>第一位：表示是否提交消费者本地该队列的 offset，一般是 1</li>
<li>第二位：表示是否允许服务器端进行长轮询，一般是 1</li>
<li>第三位：表示是否提交消费者本地该主题的订阅数据，一般是 0</li>
<li>第四位：表示是否为类过滤，一般是 0</li>
</ul>
</li>
<li><p><code>this.pullAPIWrapper.pullKernelImpl()</code>：拉取消息的核心方法</p>
</li>
</ul>
<hr>
<h5 id="封装对象"><a href="#封装对象" class="headerlink" title="封装对象"></a>封装对象</h5><p>PullAPIWrapper 类封装了拉取消息的 API</p>
<p>成员变量：</p>
<ul>
<li><p>推荐拉消息使用的主机 ID：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ConcurrentMap&lt;MessageQueue, AtomicLong<span class="comment">/* brokerId */</span>&gt; pullFromWhichNodeTable</span><br></pre></td></tr></table></figure></li>
</ul>
<p>成员方法：</p>
<ul>
<li><p>pullKernelImpl()：拉消息</p>
<ul>
<li><p><code>FindBrokerResult findBrokerResult</code>：<strong>本地查询指定 BrokerName 的地址信息</strong>，推荐节点或者主节点</p>
</li>
<li><p><code>if (null == findBrokerResult)</code>：查询不到，就到 Namesrv 获取指定 topic 的路由数据</p>
</li>
<li><p><code>if (findBrokerResult.isSlave())</code>：成立说明 findBrokerResult 表示的主机为 slave 节点，<strong>slave 不存储 offset 信息</strong></p>
<p><code>sysFlagInner = PullSysFlag.clearCommitOffsetFlag(sysFlagInner)</code>：将 sysFlag 标记位中 CommitOffset 的位置为 0</p>
</li>
<li><p><code>PullMessageRequestHeader requestHeader</code>：创建请求头对象，封装所有的参数</p>
</li>
<li><p><code>PullResult pullResult = this.mQClientFactory.getMQClientAPIImpl().pullMessage()</code>：调用客户端实例的方法，核心逻辑就是<strong>将业务数据转化为 RemotingCommand  通过 NettyRemotingClient 的 IO 进行通信</strong></p>
<ul>
<li><p><code>RemotingCommand request</code>：创建网络层传输对象 RemotingCommand 对象，<strong>请求 ID 为 <code>PULL_MESSAGE = 11</code></strong></p>
</li>
<li><p><code>return this.pullMessageSync(...)</code>：此处是<strong>异步调用，处理结果放入 ResponseFuture 中</strong>，参考服务端小节的处理器类 <code>NettyServerHandler#processMessageReceived</code> 方法</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>RemotingCommand response = responseFuture.getResponseCommand()</code>：获取服务器端响应数据 response</p>
<ul>
<li><code>PullResult pullResult</code>：从 response 内提取出来拉消息结果对象，将响应头 PullMessageResponseHeader 对象中信息<strong>填充到 PullResult 中</strong>，列出两个重要的字段：</li>
<li><code>private Long suggestWhichBrokerId</code>：服务端建议客户端下次 Pull 时选择的 BrokerID</li>
<li><code>private Long nextBeginOffset</code>：客户端下次 Pull 时使用的 offset 信息</li>
</ul>
</li>
<li><p><code>pullCallback.onSuccess(pullResult)</code>：将 PullResult 交给拉消息结果处理回调对象，调用 onSuccess 方法</p>
</li>
</ul>
<hr>
<h4 id="拉取处理"><a href="#拉取处理" class="headerlink" title="拉取处理"></a>拉取处理</h4><h5 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h5><p>BrokerStartup#createBrokerController 方法中创建了 BrokerController 并进行初始化，调用 <code>registerProcessor()</code> 方法将处理器 PullMessageProcessor 注册到 NettyRemotingServer 中，对应的请求 ID 为 <code>PULL_MESSAGE = 11</code>，NettyServerHandler 在处理请求时通过请求 ID 会获取处理器执行 processRequest 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：服务器与客户端 netty 通道； 参数二：客户端请求； 参数三：是否允许服务器端长轮询，默认 true</span></span><br><span class="line"><span class="keyword">private</span> RemotingCommand <span class="title function_">processRequest</span><span class="params">(<span class="keyword">final</span> Channel channel, RemotingCommand request, <span class="type">boolean</span> brokerAllowSuspend)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>RemotingCommand response</code>：创建响应对象，设置为响应类型的请求，响应头是 PullMessageResponseHeader</p>
</li>
<li><p><code>final PullMessageResponseHeader responseHeader</code>：获取响应对象的 header</p>
</li>
<li><p><code>final PullMessageRequestHeader requestHeader</code>：解析出请求头 PullMessageRequestHeader</p>
</li>
<li><p><code>response.setOpaque(request.getOpaque())</code>：设置 opaque 属性，客户端<strong>根据该字段获取 ResponseFuture</strong> 进行处理</p>
</li>
<li><p>进行一些鉴权的逻辑：是否允许长轮询、提交 offset、topicConfig 是否是空、队列 ID 是否合理</p>
</li>
<li><p><code>ConsumerGroupInfo consumerGroupInfo</code>：获取消费者组信息，包含全部的消费者和订阅数据</p>
</li>
<li><p><code>subscriptionData = consumerGroupInfo.findSubscriptionData()</code>：<strong>获取指定主题的订阅数据</strong></p>
</li>
<li><p><code>if (!ExpressionType.isTagType()</code>：表达式匹配</p>
</li>
<li><p><code>MessageFilter messageFilter</code>：创建消息过滤器，一般是通过 tagCode 进行过滤</p>
</li>
<li><p><code>DefaultMessageStore.getMessage()</code>：<strong>查询消息的核心逻辑，在 Broker 端查询消息</strong>（存储端笔记详解了该源码）</p>
</li>
<li><p><code>response.setRemark()</code>：设置此次响应的状态</p>
</li>
<li><p><code>responseHeader.set..</code>：设置响应头对象的一些字段</p>
</li>
<li><p><code>switch (this.brokerController.getMessageStoreConfig().getBrokerRole())</code>：如果当前主机节点角色为 slave 并且<strong>从节点读</strong>并未开启的话，直接给客户端 一个状态 <code>PULL_RETRY_IMMEDIATELY</code>，并设置为下次从主节点读</p>
</li>
<li><p><code>if (this.brokerController.getBrokerConfig().isSlaveReadEnable())</code>：消费太慢，<strong>下次从另一台机器拉取</strong></p>
</li>
<li><p><code>switch (getMessageResult.getStatus())</code>：根据 getMessageResult 的状态设置 response 的 code</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">GetMessageStatus</span> &#123;</span><br><span class="line">    FOUND,					<span class="comment">// 查询成功</span></span><br><span class="line">    NO_MATCHED_MESSAGE,		<span class="comment">// 未查询到到消息，服务端过滤 tagCode</span></span><br><span class="line">    MESSAGE_WAS_REMOVING,	<span class="comment">// 查询时赶上 CommitLog 清理过期文件，导致查询失败，立刻尝试</span></span><br><span class="line">    OFFSET_FOUND_NULL,		<span class="comment">// 查询时赶上 ConsumerQueue 清理过期文件，导致查询失败，【进行长轮询】</span></span><br><span class="line">    OFFSET_OVERFLOW_BADLY,	<span class="comment">// pullRequest.offset 越界 maxOffset</span></span><br><span class="line">    OFFSET_OVERFLOW_ONE,	<span class="comment">// pullRequest.offset == CQ.maxOffset，【进行长轮询】</span></span><br><span class="line">    OFFSET_TOO_SMALL,		<span class="comment">// pullRequest.offset 越界 minOffset</span></span><br><span class="line">    NO_MATCHED_LOGIC_QUEUE,	<span class="comment">// 没有匹配到逻辑队列</span></span><br><span class="line">    NO_MESSAGE_IN_QUEUE,	<span class="comment">// 空队列，创建队列也是因为查询导致，【进行长轮询】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>switch (response.getCode())</code>：根据 response 状态做对应的业务处理</p>
<p><code>case ResponseCode.SUCCESS</code>：查询成功</p>
<ul>
<li><code>final byte[] r = this.readGetMessageResult()</code>：本次 pull 出来的全部消息导入 byte 数组</li>
<li><code>response.setBody(r)</code>：将消息的 byte 数组保存到 response body 字段</li>
</ul>
<p><code>case ResponseCode.PULL_NOT_FOUND</code>：产生这种情况大部分原因是 <code>pullRequest.offset  ==  queue.maxOffset</code>，说明已经没有需要获取的消息，此时如果直接返回给客户端，客户端会立刻重新请求，还是继续返回该状态，频繁拉取服务器导致服务器压力大，所以此处<strong>需要长轮询</strong></p>
<ul>
<li><code>if (brokerAllowSuspend &amp;&amp; hasSuspendFlag)</code>：brokerAllowSuspend &#x3D; true，当长轮询结束再次执行 processRequest 时该参数为 false，所以<strong>每次 Pull 请求至多在服务器端长轮询控制一次</strong></li>
<li><code>PullRequest pullRequest = new PullRequest()</code>：创建长轮询 PullRequest 对象</li>
<li><code>this.brokerController...suspendPullRequest(topic, queueId, pullRequest)</code>：将长轮询请求对象交给长轮询服务<ul>
<li><code>String key = this.buildKey(topic, queueId)</code>：构建一个 <code>topic@queueId</code> 的 key</li>
<li><code>ManyPullRequest mpr = this.pullRequestTable.get(key)</code>：从拉请求表中获取对象</li>
<li><code>mpr.addPullRequest(pullRequest)</code>：<strong>将 PullRequest 对象放入到长轮询的请求集合中</strong></li>
</ul>
</li>
<li><code>response = null</code>：响应设置为 null 内部的 callBack 就不会给客户端发送任何数据，<strong>不进行通信</strong>，否则就又开始重新请求</li>
</ul>
</li>
<li><p><code>boolean storeOffsetEnable</code>：允许长轮询、sysFlag 表示提交消费者本地该队列的offset、当前 broker 节点角色为 master 节点三个条件成立，才<strong>在 Broker 端存储消费者组内该主题的指定 queue 的消费进度</strong></p>
</li>
<li><p><code>return response</code>：返回 response，不为 null 时外层 processRequestCommand 的 callback 会将数据写给客户端</p>
</li>
</ul>
<hr>
<h5 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h5><p>PullRequestHoldService 类负责长轮询，BrokerController#start 方法中调用了 <code>this.pullRequestHoldService.start()</code> 启动该服务</p>
<p>核心方法：</p>
<ul>
<li><p>run()：核心运行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 循环运行</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">            <span class="comment">// 服务器开启长轮询开关：每次循环休眠5秒</span></span><br><span class="line">            <span class="built_in">this</span>.waitForRunning(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 服务器关闭长轮询开关：每次循环休眠1秒</span></span><br><span class="line">            <span class="built_in">this</span>.waitForRunning(...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查持有的请求</span></span><br><span class="line">        <span class="built_in">this</span>.checkHoldRequest();</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>checkHoldRequest()：检查所有的请求</p>
<ul>
<li><code>for (String key : this.pullRequestTable.keySet())</code>：<strong>处理所有的 topic@queueId 的逻辑</strong></li>
<li><code>String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR)</code>：key 按照 @ 拆分，得到 topic 和 queueId</li>
<li><code>long offset = this...getMaxOffsetInQueue(topic, queueId)</code>： 到存储模块查询该 ConsumeQueue 的<strong>最大 offset</strong></li>
<li><code>this.notifyMessageArriving(topic, queueId, offset)</code>：通知消息到达</li>
</ul>
</li>
<li><p>notifyMessageArriving()：<strong>通知消息到达</strong>的逻辑，ReputMessageService 消息分发服务也会调用该方法</p>
<ul>
<li><code>ManyPullRequest mpr = this.pullRequestTable.get(key)</code>：获取对应的的 manyPullRequest 对象</li>
<li><code>List&lt;PullRequest&gt; requestList</code>：获取该队列下的所有 PullRequest，并进行遍历</li>
<li><code>List&lt;PullRequest&gt; replayList</code>：当某个 pullRequest 不超时，并且对应的 <code>CQ.maxOffset &lt;= pullRequest.offset</code>，就将该 PullRequest 再放入该列表</li>
<li><code>long newestOffset</code>：该值为 CQ 的 maxOffset</li>
<li><code>if (newestOffset &gt; request.getPullFromThisOffset())</code>：<strong>请求对应的队列内可以 pull 消息了，结束长轮询</strong></li>
<li><code>boolean match</code>：进行过滤匹配</li>
<li><code>this.brokerController...executeRequestWhenWakeup()</code>：将满足条件的 pullRequest 再次提交到线程池内执行<ul>
<li><code>final RemotingCommand response</code>：执行 processRequest 方法，并且<strong>不会触发长轮询</strong></li>
<li><code>channel.writeAndFlush(response).addListene()</code>：<strong>将结果数据发送给客户端</strong></li>
</ul>
</li>
<li><code>if (System.currentTimeMillis() &gt;= ...)</code>：判断该 pullRequest 是否超时，超时后的也是重新提交到线程池，并且不进行长轮询</li>
<li><code>mpr.addPullRequest(replayList)</code>：将未满足条件的 PullRequest 对象再次添加到 ManyPullRequest 属性中</li>
</ul>
</li>
</ul>
<hr>
<h5 id="结果类"><a href="#结果类" class="headerlink" title="结果类"></a>结果类</h5><p>GetMessageResult 类成员信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetMessageResult</span> &#123;</span><br><span class="line">    <span class="comment">// 查询消息时，最底层都是 mappedFile 支持的查询，查询时返回给外层一个 SelectMappedBufferResult，</span></span><br><span class="line">    <span class="comment">// mappedFile 每查询一次都会 refCount++ ，通过SelectMappedBufferResult持有mappedFile，完成资源释放的句柄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SelectMappedBufferResult&gt; messageMapedList =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;SelectMappedBufferResult&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该List内存储消息，每一条消息都被转成 ByteBuffer 表示了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ByteBuffer&gt; messageBufferList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ByteBuffer&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 查询结果状态</span></span><br><span class="line">    <span class="keyword">private</span> GetMessageStatus status;</span><br><span class="line">    <span class="comment">// 客户端下次再向当前Queue拉消息时，使用的 offset</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> nextBeginOffset;</span><br><span class="line">    <span class="comment">// 当前queue最小offset</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> minOffset;</span><br><span class="line">    <span class="comment">// 当前queue最大offset</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> maxOffset;</span><br><span class="line">    <span class="comment">// 消息总byte大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">bufferTotalSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 服务器建议客户端下次到该 queue 拉消息时是否使用 【从节点】</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">suggestPullingFromSlave</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="队列快照"><a href="#队列快照" class="headerlink" title="队列快照"></a>队列快照</h4><h5 id="成员属性-10"><a href="#成员属性-10" class="headerlink" title="成员属性"></a>成员属性</h5><p>ProcessQueue 类是消费队列的快照</p>
<p>成员变量：</p>
<ul>
<li><p>属性字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">msgCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();	<span class="comment">// 队列中消息数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">msgSize</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();	<span class="comment">// 消息总大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">queueOffsetMax</span> <span class="operator">=</span> <span class="number">0L</span>;				<span class="comment">// 快照中最大 offset</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">dropped</span> <span class="operator">=</span> <span class="literal">false</span>;				<span class="comment">// 快照是否移除</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">lastPullTimestamp</span> <span class="operator">=</span> current;		<span class="comment">// 上一次拉消息的时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">lastConsumeTimestamp</span> <span class="operator">=</span> current;	<span class="comment">// 上一次消费消息的时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">lastLockTimestamp</span> <span class="operator">=</span> current;		<span class="comment">// 上一次获取锁的时间</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>消息容器</strong>：key 是消息偏移量，val 是消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Long, MessageExt&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>顺序消费临时容器</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, MessageExt&gt; consumingMsgOrderlyTreeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Long, MessageExt&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lockTreeMap;		<span class="comment">// 读写锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lockConsume;					<span class="comment">// 重入锁，【顺序消费使用】</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序消费状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="literal">false</span>;		<span class="comment">// 是否是锁定状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">consuming</span> <span class="operator">=</span> <span class="literal">false</span>;		<span class="comment">// 是否是消费中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-9"><a href="#成员方法-9" class="headerlink" title="成员方法"></a>成员方法</h5><p>核心成员方法</p>
<ul>
<li><p>putMessage()：将 Broker 拉取下来的 msgs 存储到快照队列内，返回为 true 表示提交顺序消费任务，false 表示不提交</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">putMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>this.lockTreeMap.writeLock().lockInterruptibly()</code>：获取写锁</p>
</li>
<li><p><code>for (MessageExt msg : msgs)</code>：遍历 msgs 全部加入 msgTreeMap，key 是消息的 queueOffset</p>
</li>
<li><p><code>if (!msgTreeMap.isEmpty() &amp;&amp; !this.consuming)</code>：<strong>消息容器中存在未处理的消息，并且不是消费中的状态</strong></p>
<p><code>dispatchToConsume = true</code>：代表需要提交顺序消费任务</p>
<p><code>this.consuming = true</code>：设置为顺序消费执行中的状态</p>
</li>
<li><p><code>this.lockTreeMap.writeLock().unlock()</code>：释放写锁</p>
</li>
</ul>
</li>
<li><p>removeMessage()：移除已经消费的消息，参数是已经消费的消息集合，并发消费使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">removeMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>long result = -1</code>：结果初始化为 -1 </li>
<li><code>this.lockTreeMap.writeLock().lockInterruptibly()</code>：获取写锁</li>
<li><code>this.lastConsumeTimestamp = now</code>：更新上一次消费消息的时间为现在</li>
<li><code>if (!msgTreeMap.isEmpty())</code>：判断消息容器是否是空，<strong>是空直接返回 -1</strong></li>
<li><code>result = this.queueOffsetMax + 1</code>：设置结果，<strong>删除完后消息容器为空时返回</strong></li>
<li><code>for (MessageExt msg : msgs)</code>：将已经消费的消息全部从 msgTreeMap 移除</li>
<li><code>if (!msgTreeMap.isEmpty())</code>：移除后容器内还有待消费的消息，<strong>获取第一条消息 offset 返回</strong></li>
<li><code>this.lockTreeMap.writeLock().unlock()</code>：释放写锁</li>
</ul>
</li>
<li><p>takeMessages()：获取一批消息，顺序消费使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;MessageExt&gt; <span class="title function_">takeMessages</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> batchSize)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.lockTreeMap.writeLock().lockInterruptibly()</code>：获取写锁</li>
<li><code>this.lastConsumeTimestamp = now</code>：更新上一次消费消息的时间为现在</li>
<li><code>for (int i = 0; i &lt; batchSize; i++)</code>：从头节点开始获取消息</li>
<li><code>result.add(entry.getValue())</code>：将消息放入结果集合</li>
<li><code>consumingMsgOrderlyTreeMap.put()</code>：将消息加入顺序消费容器中</li>
<li><code>if (result.isEmpty())</code>：条件成立说明顺序消费容器本地快照内的消息全部处理完了，<strong>当前顺序消费任务需要停止</strong></li>
<li><code>consuming = false</code>：消费状态置为 false</li>
<li><code>this.lockTreeMap.writeLock().unlock()</code>：释放写锁</li>
</ul>
</li>
<li><p>commit()：处理完一批消息后调用，顺序消费使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">commit</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.lockTreeMap.writeLock().lockInterruptibly()</code>：获取写锁</li>
<li><code>Long offset = this.consumingMsgOrderlyTreeMap.lastKey()</code>：获取顺序消费临时容器最后一条数据的 key</li>
<li><code>msgCount, msgSize</code>：更新顺序消费相关的字段</li>
<li><code>this.consumingMsgOrderlyTreeMap.clear()</code>：清空顺序消费容器的数据</li>
<li><code>return offset + 1</code>：<strong>消费者下一条消费的位点</strong></li>
<li><code>this.lockTreeMap.writeLock().unlock()</code>：释放写锁</li>
</ul>
</li>
<li><p>cleanExpiredMsg()：清除过期消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanExpiredMsg</span><span class="params">(DefaultMQPushConsumer pushConsumer)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>if (pushConsumer.getDefaultMQPushConsumerImpl().isConsumeOrderly()) </code>：顺序消费不执行过期清理逻辑</li>
<li><code>int loop = msgTreeMap.size() &lt; 16 ? msgTreeMap.size() : 16</code>：最多循环 16 次</li>
<li><code>if (!msgTreeMap.isEmpty() &amp;&amp;)</code>：如果容器中第一条消息的消费开始时间与当前系统时间差值 &gt; 15min，则取出该消息</li>
<li><code>else</code>：直接跳出循环，因为<strong>快照队列内的消息是有顺序的</strong>，第一条消息不过期，其他消息都不过期</li>
<li><code>pushConsumer.sendMessageBack(msg, 3)</code>：<strong>消息回退</strong>到服务器，设置该消息的延迟级别为 3</li>
<li><code>if (!msgTreeMap.isEmpty() &amp;&amp; msg.getQueueOffset() == msgTreeMap.firstKey())</code>：条件成立说明消息回退期间，该目标消息并没有被消费任务成功消费</li>
<li><code>removeMessage(Collections.singletonList(msg))</code>：从 treeMap 将该回退成功的 msg 删除</li>
</ul>
</li>
</ul>
<hr>
<h4 id="并发消费"><a href="#并发消费" class="headerlink" title="并发消费"></a>并发消费</h4><h5 id="成员属性-11"><a href="#成员属性-11" class="headerlink" title="成员属性"></a>成员属性</h5><p>ConsumeMessageConcurrentlyService 负责并发消费服务</p>
<p>成员变量：</p>
<ul>
<li><p>消息监听器：封装处理消息的逻辑，该监听器由开发者实现，并注册到 defaultMQPushConsumer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MessageListenerConcurrently messageListener;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; consumeRequestQueue;	<span class="comment">// 消费任务队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String consumerGroup;							<span class="comment">// 消费者组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor consumeExecutor;				<span class="comment">// 消费任务线程池，默认 20</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutorService;<span class="comment">// 调度线程池，延迟提交消费任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService cleanExpireMsgExecutors;	<span class="comment">// 清理过期消息任务线程池，15min 一次</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-10"><a href="#成员方法-10" class="headerlink" title="成员方法"></a>成员方法</h5><p>ConsumeMessageConcurrentlyService 并发消费核心方法</p>
<ul>
<li><p>start()：启动消费服务，DefaultMQPushConsumerImpl 启动时会调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 提交“清理过期消息任务”任务，延迟15min之后执行，之后每15min执行一次</span></span><br><span class="line">    <span class="built_in">this</span>.cleanExpireMsgExecutors.scheduleAtFixedRate(() -&gt;  cleanExpireMsg()&#125;, </span><br><span class="line">                                                     <span class="number">15</span>, <span class="number">15</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cleanExpireMsg()：清理过期消息任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cleanExpireMsg</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Iterator&lt;Map.Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it </code>：获取分配给当前消费者的队列</li>
<li><code>while (it.hasNext())</code>：遍历所有的队列</li>
<li><code>pq.cleanExpiredMsg(this.defaultMQPushConsumer)</code>：调用队列快照 ProcessQueue 清理过期消息的方法</li>
</ul>
</li>
<li><p>submitConsumeRequest()：提交消费请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：从服务器 pull 下来的这批消息</span></span><br><span class="line"><span class="comment">// 参数二：消息归属 mq 在消费者端的 processQueue，提交消费任务之前，msgs已经加入到该pq内了</span></span><br><span class="line"><span class="comment">// 参数三：消息归属队列</span></span><br><span class="line"><span class="comment">// 参数四：并发消息此参数无效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submitConsumeRequest</span><span class="params">(List&lt;MessageExt&gt; msgs, ProcessQueue processQueue, MessageQueue messageQueue, <span class="type">boolean</span> dispatchToConsume)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>final int consumeBatchSize</code>：<strong>一个消费任务可消费的消息数量</strong>，默认为 1</p>
</li>
<li><p><code>if (msgs.size() &lt;= consumeBatchSize)</code>：判断一个消费任务是否可以提交</p>
<p><code>ConsumeRequest consumeRequest</code>：封装为消费请求</p>
<p><code>this.consumeExecutor.submit(consumeRequest)</code>：提交消费任务，异步执行消息的处理</p>
</li>
<li><p><code>else</code>：说明消息较多，需要多个消费任务</p>
<p><code>for (int total = 0; total &lt; msgs.size(); )</code>：将消息拆分成多个消费任务</p>
</li>
</ul>
</li>
<li><p>processConsumeResult()：处理消费结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：消费结果状态；  参数二：消费上下文；  参数三：当前消费任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConsumeResult</span><span class="params">(status, context, consumeRequest)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>switch (status)</code>：根据消费结果状态进行处理</p>
</li>
<li><p><code>case CONSUME_SUCCESS</code>：消费成功</p>
<p><code>if (ackIndex &gt;= consumeRequest.getMsgs().size())</code>：消费成功的话，ackIndex 设置成 <code>消费消息数 - 1</code> 的值，比如有 5 条消息，这里就设置为 4</p>
<p><code>ok, failed</code>：ok 设置为消息数量，failed 设置为 0</p>
</li>
<li><p><code>case RECONSUME_LATER</code>：消费失败</p>
<p><code>ackIndex = -1</code>：设置为 -1</p>
</li>
<li><p><code>switch (this.defaultMQPushConsumer.getMessageModel())</code>：判断消费模式，默认是<strong>集群模式</strong></p>
</li>
<li><p><code>for (int i = ackIndex + 1; i &lt; msgs.size(); i++)</code>：当消费失败时 ackIndex 为 -1，i 的起始值为 0，该消费任务内的<strong>全部消息</strong>都会尝试回退给服务器</p>
</li>
<li><p><code>MessageExt msg</code>：提取一条消息</p>
</li>
<li><p><code>boolean result = this.sendMessageBack(msg, context)</code>：<strong>发送消息回退，同步发送</strong></p>
</li>
<li><p><code>if (!result)</code>：回退失败的消息，将<strong>消息的重试属性加 1</strong>，并加入到回退失败的集合</p>
</li>
<li><p><code>if (!msgBackFailed.isEmpty())</code>：回退失败集合不为空</p>
</li>
</ul>
<p><code>consumeRequest.getMsgs().removeAll(msgBackFailed)</code>：将回退失败的消息从当前消费任务的 msgs 集合内移除</p>
<p><code>this.submitConsumeRequestLater()</code>：<strong>回退失败的消息会再次提交消费任务</strong>，延迟 5 秒钟后再次尝试消费</p>
</li>
<li><p><code>long offset = ...removeMessage(msgs)</code>：从 pq 中删除已经消费成功的消息，返回 offset</p>
</li>
<li><p><code>this...getOffsetStore().updateOffset()</code>：更新消费者本地该 mq 的<strong>消费进度</strong></p>
</li>
</ul>
<hr>
<h5 id="消费请求"><a href="#消费请求" class="headerlink" title="消费请求"></a>消费请求</h5><p>ConsumeRequest 是 ConsumeMessageConcurrentlyService 的内部类，是一个 Runnable 任务对象</p>
<p>成员变量：</p>
<ul>
<li><p>分配到该消费任务的消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;MessageExt&gt; msgs;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ProcessQueue processQueue;	<span class="comment">// 消息处理队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MessageQueue messageQueue;	<span class="comment">// 消息队列</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>核心方法：</p>
<ul>
<li><p>run()：执行任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>if (this.processQueue.isDropped())</code>：条件成立说明该 queue 经过 rbl 算法分配到其他的 consumer</li>
<li><code>MessageListenerConcurrently listener</code>：获取消息监听器</li>
<li><code>ConsumeConcurrentlyContext context</code>：创建消费上下文对象</li>
<li><code>defaultMQPushConsumerImpl.resetRetryAndNamespace()</code>：重置重试标记<ul>
<li><code>final String groupTopic</code>：获取当前消费者组的重试主题 <code>%RETRY%GroupName</code></li>
<li><code>for (MessageExt msg : msgs)</code>：遍历所有的消息</li>
<li><code>String retryTopic = msg.getProperty(...)</code>：原主题，一般消息没有该属性，只有被重复消费的消息才有</li>
<li><code>if (retryTopic != null &amp;&amp; groupTopic.equals(...))</code>：条件成立说明该消息是被重复消费的消息</li>
<li><code>msg.setTopic(retryTopic)</code>：将被<strong>重复消费的消息主题修改回原主题</strong></li>
</ul>
</li>
<li><code>if (ConsumeMessageConcurrentlyService...hasHook())</code>：前置处理</li>
<li><code>boolean hasException = false</code>：消费过程中，是否向外抛出异常</li>
<li><code>MessageAccessor.setConsumeStartTimeStamp()</code>：给每条消息设置消费开始时间</li>
<li><code>status = listener.consumeMessage(Collections.unmodifiableList(msgs), context)</code>：<strong>消费消息</strong></li>
<li><code>if (ConsumeMessageConcurrentlyService...hasHook())</code>：后置处理</li>
<li><code>...processConsumeResult(status, context, this)</code>：<strong>处理消费结果</strong></li>
</ul>
</li>
</ul>
<hr>
<h4 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h4><h5 id="成员属性-12"><a href="#成员属性-12" class="headerlink" title="成员属性"></a>成员属性</h5><p>ConsumeMessageOrderlyService 负责顺序消费服务</p>
<p>成员变量：</p>
<ul>
<li><p>消息监听器：封装处理消息的逻辑，该监听器由开发者实现，并注册到 defaultMQPushConsumer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MessageListenerOrderly messageListener;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; consumeRequestQueue;	<span class="comment">// 消费任务队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String consumerGroup;							<span class="comment">// 消费者组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stopped</span> <span class="operator">=</span> <span class="literal">false</span>;					<span class="comment">// 消费停止状态</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor consumeExecutor;				<span class="comment">// 消费任务线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutorService;<span class="comment">// 调度线程池，延迟提交消费任务</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>队列锁：消费者本地 MQ 锁，<strong>确保本地对于需要顺序消费的 MQ 同一时间只有一个任务在执行</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">MessageQueueLock</span> <span class="variable">messageQueueLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueueLock</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageQueueLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;MessageQueue, Object&gt; mqLockTable = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;MessageQueue, Object&gt;();</span><br><span class="line">    <span class="comment">// 获取本地队列锁对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">fetchLockObject</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mqLockTable.get(mq);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == objLock) &#123;</span><br><span class="line">            objLock = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">prevLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mqLockTable.putIfAbsent(mq, objLock);</span><br><span class="line">            <span class="keyword">if</span> (prevLock != <span class="literal">null</span>) &#123;</span><br><span class="line">                objLock = prevLock;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已经获取了 Broker 端该 Queue 的独占锁，为什么还要获取本地队列锁对象？（这里我也没太懂，先记录下来，本地多线程？）</p>
<ul>
<li>Broker queue 占用锁的角度是 Client 占用，Client 从 Broker 的某个占用了锁的 queue 拉取下来消息以后，将消息存储到消费者本地的 ProcessQueue 中，快照对象的 consuming 属性置为 true，表示本地的队列正在消费处理中</li>
<li>ProcessQueue  调用 takeMessages 方法时会获取下一批待处理的消息，获取不到会修改 <code>consuming = false</code>，本消费任务马上停止。</li>
<li>如果此时 Pull 再次拉取一批当前 ProcessQueue  的 msg，会再次向顺序消费服务提交消费任务，此时需要本地队列锁对象同步本地线程</li>
</ul>
</li>
</ul>
<hr>
<h5 id="成员方法-11"><a href="#成员方法-11" class="headerlink" title="成员方法"></a>成员方法</h5><ul>
<li><p>start()：启动消费服务，DefaultMQPushConsumerImpl 启动时会调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.scheduledExecutorService.scheduleAtFixedRate()</code>：提交锁续约任务，延迟 1 秒执行，周期为 20 秒钟</li>
<li><code>ConsumeMessageOrderlyService.this.lockMQPeriodically()</code>：<strong>锁续约任务</strong><ul>
<li><code>this.defaultMQPushConsumerImpl.getRebalanceImpl().lockAll()</code>：对消费者的所有队列进行续约</li>
</ul>
</li>
</ul>
</li>
<li><p>submitConsumeRequest()：<strong>提交消费任务请求</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：true 表示创建消费任务并提交，false不创建消费任务，说明消费者本地已经有消费任务在执行了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submitConsumeRequest</span><span class="params">(...., <span class="keyword">final</span> <span class="type">boolean</span> dispathToConsume)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dispathToConsume) &#123;</span><br><span class="line">        <span class="comment">// 当前进程内不存在 顺序消费任务，创建新的消费任务，【提交到消费任务线程池】</span></span><br><span class="line">        <span class="type">ConsumeRequest</span> <span class="variable">consumeRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumeRequest</span>(processQueue, messageQueue);</span><br><span class="line">        <span class="built_in">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>processConsumeResult()：消费结果处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1：msgs 本轮循环消费的消息集合    					参数2：status  消费状态</span></span><br><span class="line"><span class="comment">// 参数3：context 消费上下文 							参数4：消费任务</span></span><br><span class="line"><span class="comment">// 返回值：boolean 决定是否继续循环处理pq内的消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processConsumeResult</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs, <span class="keyword">final</span> ConsumeOrderlyStatus status, <span class="keyword">final</span> ConsumeOrderlyContext context, <span class="keyword">final</span> ConsumeRequest consumeRequest)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>if (context.isAutoCommit()) </code>：默认自动提交</p>
</li>
<li><p><code>switch (status)</code>：根据消费状态进行不同的处理</p>
</li>
<li><p><code>case SUCCESS</code>：消费成功</p>
<p><code>commitOffset = ...commit()</code>：调用 pq 提交方法，会将本次循环处理的消息从顺序消费 map 删除，并且返回消息进度</p>
</li>
<li><p><code>case SUSPEND_CURRENT_QUEUE_A_MOMENT</code>：挂起当前队列</p>
<p><code>consumeRequest.getProcessQueue().makeMessageToConsumeAgain(msgs)</code>：<strong>回滚消息</strong></p>
<ul>
<li><code>for (MessageExt msg : msgs)</code>：遍历所有的消息</li>
<li><code>this.consumingMsgOrderlyTreeMap.remove(msg.getQueueOffset())</code>：从顺序消费临时容器中移除</li>
<li><code>this.msgTreeMap.put(msg.getQueueOffset(), msg)</code>：添加到消息容器</li>
</ul>
</li>
<li><p><code>this.submitConsumeRequestLater()</code>：再次提交消费任务，1 秒后执行</p>
</li>
<li><p><code>continueConsume = false</code>：设置为 false，<strong>外层会退出本次的消费任务</strong></p>
</li>
<li><p><code>this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(...)</code>：更新本地消费进度</p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="消费请求-1"><a href="#消费请求-1" class="headerlink" title="消费请求"></a>消费请求</h5><p>ConsumeRequest 是 ConsumeMessageOrderlyService 的内部类，是一个 Runnable 任务对象</p>
<p>核心方法：</p>
<ul>
<li><p>run()：执行任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>final Object objLock</code>：获取本地锁对象</p>
</li>
<li><p><code>synchronized (objLock)</code>：本地队列锁，确保每个 MQ 的消费任务只有一个在执行，<strong>确保顺序消费</strong></p>
</li>
<li><p><code>if(.. || (this.processQueue.isLocked() &amp;&amp; !this.processQueue.isLockExpired())))</code>：当前队列持有分布式锁，并且锁未过期，持锁时间超过 30 秒算过期</p>
</li>
<li><p><code>final long beginTime</code>：消费开始时间</p>
</li>
<li><p><code>for (boolean continueConsume = true; continueConsume; )</code>：根据是否继续消费的标记判断是否继续</p>
</li>
<li><p><code>final int consumeBatchSize</code>：获取每次循环处理的消息数量，一般是 1</p>
</li>
<li><p><code>List&lt;MessageExt&gt; msgs = this...takeMessages(consumeBatchSize)</code>：到<strong>处理队列获取一批消息</strong></p>
</li>
<li><p><code>if (!msgs.isEmpty())</code>：获取到了待消费的消息</p>
<p><code>final ConsumeOrderlyContext context</code>：创建消费上下文对象</p>
<p><code>this.processQueue.getLockConsume().lock()</code>：<strong>获取 lockConsume 锁</strong>，与 RBL 线程同步使用</p>
<p><code>status = messageListener.consumeMessage(...)</code>：监听器处理消息 </p>
<p><code>this.processQueue.getLockConsume().unlock()</code>：<strong>释放 lockConsume 锁</strong></p>
<p><code>if (null == status)</code>：处理消息状态返回 null，设置状态为挂起当前队列</p>
<p><code>continueConsume = ...processConsumeResult()</code>：消费结果处理</p>
</li>
<li><p><code>else</code>：获取到的消息是空</p>
<p><code>continueConsume = false</code>：结束任务循环</p>
</li>
<li><p><code>else</code>：当前队列未持有分布式锁，或者锁过期</p>
<p><code>ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume()</code>：重新提交任务，根据是否获取到队列锁，选择延迟 10 毫秒或者 300 毫秒</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="生产消费-1"><a href="#生产消费-1" class="headerlink" title="生产消费"></a>生产消费</h3><p>生产流程：</p>
<ul>
<li>首先获取当前消息主题的发布信息，获取不到去 Namesrv 获取（默认有 TBW102），并将获取的到的路由数据转化为发布数据，<strong>创建 MQ 队列</strong>，客户端实例同样更新订阅数据，创建 MQ 队列，放入负载均衡服务 topicSubscribeInfoTable 中</li>
<li>然后从发布数据中选择一个 MQ 队列发送消息</li>
<li>Broker 端通过 SendMessageProcessor 对发送的消息进行持久化处理，存储到 CommitLog。将重试次数过多的消息加入<strong>死信队列</strong>，将延迟消息的主题和队列修改为调度主题和调度队列 ID</li>
<li>Broker 启动 ScheduleMessageService 服务会为每个延迟级别创建一个延迟任务，让延迟消息得到有效的处理，将到达交付时间的消息修改为原始主题的原始 ID 存入 CommitLog，消费者就可以进行消费了</li>
</ul>
<p>消费流程：</p>
<ul>
<li>首先通过负载均衡服务，将分配到当前消费者实例的 MQ 创建 PullRequest，并放入 PullMessageService 的本地阻塞队列内</li>
<li>PullMessageService 循环从阻塞队列获取请求对象，发起拉消息请求，并创建 PullCallback 回调对象，将正常拉取的消息<strong>提交到消费任务线程池</strong>，并设置请求的下一次拉取位点，重新放入阻塞队列，形成闭环</li>
<li>消费任务服务对消费失败的消息进行回退，回退失败的消息会再次提交消费任务重新消费</li>
<li>Broker 端对拉取消息的请求进行处理（processRequestCommand），查询成功将消息放入响应体，通过 Netty 写回客户端，当 <code>pullRequest.offset == queue.maxOffset</code> 说明该队列已经没有需要获取的消息，将请求放入长轮询集合等待有新消息</li>
<li>PullRequestHoldService 负责长轮询，每 5 秒遍历一次长轮询集合，将满足条件的 PullRequest 再次提交到线程池内处理</li>
</ul>
<hr>
<h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><h2 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="框架特征"><a href="#框架特征" class="headerlink" title="框架特征"></a>框架特征</h3><p>Zookeeper 是 Apache Hadoop 项目子项目，为分布式框架提供协调服务，是一个树形目录服务</p>
<p>Zookeeper 是基于观察者模式设计的分布式服务管理框架，负责存储和管理共享数据，接受观察者的注册监控，一旦这些数据的状态发生变化，Zookeeper 会通知观察者</p>
<ul>
<li>Zookeeper 是一个领导者（Leader），多个跟随者（Follower）组成的集群</li>
<li>集群中只要有半数以上节点存活就能正常服务，所以 Zookeeper 适合部署奇数台服务器</li>
<li><strong>全局数据一致</strong>，每个 Server 保存一份相同的数据副本，Client 无论连接到哪个 Server，数据都是一致</li>
<li>更新的请求顺序执行，来自同一个 Client 的请求按其发送顺序依次执行</li>
<li><strong>数据更新原子性</strong>，一次数据更新要么成功，要么失败</li>
<li>实时性，在一定的时间范围内，Client 能读到最新数据</li>
<li>心跳检测，会定时向各个服务提供者发送一个请求（实际上建立的是一个 Socket 长连接）</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84.png"></p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1to4y1C7gw">https://www.bilibili.com/video/BV1to4y1C7gw</a></p>
<hr>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>Zookeeper 提供的主要功能包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡、分布式锁等</p>
<ul>
<li><p>在分布式环境中，经常对应用&#x2F;服务进行统一命名，便于识别，例如域名相对于 IP 地址更容易被接收</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/service/www.baidu.com 		<span class="comment"># 节点路径</span></span><br><span class="line">192.168.1.1  192.168.1.2	<span class="comment"># 节点值</span></span><br></pre></td></tr></table></figure>

<p>如果在节点中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求，可以实现负载均衡</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">192.168.1.1  10	<span class="comment"># 次数</span></span><br><span class="line">192.168.1.1  15</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件同步可以通过 Zookeeper 实现，将配置信息写入某个 ZNode，其他客户端监视该节点，当节点数据被修改，通知各个客户端服务器</p>
</li>
<li><p>集群环境中，需要实时掌握每个集群节点的状态，可以将这些信息放入 ZNode，通过监控通知的机制实现</p>
</li>
<li><p>实现客户端实时观察服务器上下线的变化，通过心跳检测实现</p>
</li>
</ul>
<hr>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="安装搭建"><a href="#安装搭建" class="headerlink" title="安装搭建"></a>安装搭建</h3><p>安装步骤：</p>
<ul>
<li><p>安装 JDK</p>
</li>
<li><p>拷贝 apache-zookeeper-3.5.7-bin.tar.gz 安装包到 Linux 系统下，并解压到指定目录</p>
</li>
<li><p>conf 目录下的配置文件重命名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim zoo.cfg</span><br><span class="line"><span class="comment"># 修改内容</span></span><br><span class="line">dataDir=/home/seazean/SoftWare/zookeeper-3.5.7/zkData </span><br></pre></td></tr></table></figure>
</li>
<li><p>在对应目录创建 zkData 文件夹：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> zkData</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Zookeeper 中的配置文件 zoo.cfg 中参数含义解读： </p>
<ul>
<li>tickTime &#x3D; 2000：通信心跳时间，<strong>Zookeeper 服务器与客户端心跳</strong>时间，单位毫秒</li>
<li>initLimit &#x3D; 10：Leader 与 Follower 初始通信时限，初始连接时能容忍的最多心跳次数</li>
<li>syncLimit &#x3D; 5：Leader 与 Follower 同步通信时限，LF 通信时间超过 <code>syncLimit * tickTime</code>，Leader 认为 Follwer 下线</li>
<li>dataDir：保存 Zookeeper 中的数据目录，默认是 tmp目录，容易被 Linux 系统定期删除，所以建议修改</li>
<li>clientPort &#x3D; 2181：客户端连接端口，通常不做修改</li>
</ul>
<hr>
<h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>Linux 命令：</p>
<ul>
<li><p>启动 ZooKeeper 服务：<code>./zkServer.sh start</code></p>
</li>
<li><p>查看 ZooKeeper 服务：<code>./zkServer.sh status</code></p>
</li>
<li><p>停止 ZooKeeper 服务：<code>./zkServer.sh stop</code></p>
</li>
<li><p>重启 ZooKeeper 服务：<code>./zkServer.sh restart </code></p>
</li>
<li><p>查看进程是否启动：<code>jps</code></p>
</li>
</ul>
<hr>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>Linux 命令：</p>
<ul>
<li><p>连接 ZooKeeper 服务端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./zkCli.sh					<span class="comment"># 直接启动</span></span><br><span class="line">./zkCli.sh –server ip:port	<span class="comment"># 指定 host 启动</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>客户端命令：</p>
<ul>
<li><p>基础操作：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">quit						<span class="comment"># 停止连接</span></span><br><span class="line"><span class="built_in">help</span>						<span class="comment"># 查看命令帮助</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建命令：**<code>/</code> 代表根目录**</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">create /path value			<span class="comment"># 创建节点，value 可选</span></span><br><span class="line">create -e /path value		<span class="comment"># 创建临时节点</span></span><br><span class="line">create -s /path value		<span class="comment"># 创建顺序节点</span></span><br><span class="line">create -es /path value  	<span class="comment"># 创建临时顺序节点，比如node10000012 删除12后也会继续从13开始，只会增加</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查询命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /path					<span class="comment"># 显示指定目录下子节点</span></span><br><span class="line"><span class="built_in">ls</span> –s /path					<span class="comment"># 查询节点详细信息</span></span><br><span class="line"><span class="built_in">ls</span> –w /path					<span class="comment"># 监听子节点数量的变化</span></span><br><span class="line"><span class="built_in">stat</span> /path					<span class="comment"># 查看节点状态</span></span><br><span class="line">get –s /path				<span class="comment"># 查询节点详细信息</span></span><br><span class="line">get –w /path				<span class="comment"># 监听节点数据的变化</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 属性，分为当前节点的属性和子节点属性</span></span><br><span class="line">czxid: 节点被创建的事务ID, 是ZooKeeper中所有修改总的次序，每次修改都有唯一的 zxid，谁小谁先发生</span><br><span class="line">ctime: 被创建的时间戳</span><br><span class="line">mzxid: 最后一次被更新的事务ID </span><br><span class="line">mtime: 最后修改的时间戳</span><br><span class="line">pzxid: 子节点列表最后一次被更新的事务ID</span><br><span class="line">cversion: 子节点的变化号，修改次数</span><br><span class="line">dataversion: 节点的数据变化号，数据的变化次数</span><br><span class="line">aclversion: 节点的访问控制列表变化号</span><br><span class="line">ephemeralOwner: 用于临时节点，代表节点拥有者的 session <span class="built_in">id</span>，如果为持久节点则为0 </span><br><span class="line">dataLength: 节点存储的数据的长度 </span><br><span class="line">numChildren: 当前节点的子节点数量</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">delete /path				<span class="comment"># 删除节点</span></span><br><span class="line">deleteall /path				<span class="comment"># 递归删除节点</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>ZooKeeper 是一个树形目录服务，类似 Unix 的文件系统，每一个节点都被称为 ZNode，每个 ZNode 默认存储 1MB 的数据，节点上会保存数据和节点信息，每个 ZNode 都可以通过其路径唯一标识</p>
<p>节点可以分为四大类：</p>
<ul>
<li>PERSISTENT：持久化节点 </li>
<li>EPHEMERAL：临时节点，客户端和服务器端<strong>断开连接</strong>后，创建的节点删除</li>
<li>PERSISTENT_SEQUENTIAL：持久化顺序节点，创建 znode 时设置顺序标识，节点名称后会附加一个值，<strong>顺序号是一个单调递增的计数器</strong>，由父节点维护</li>
<li>EPHEMERAL_SEQUENTIAL：临时顺序节点</li>
</ul>
<p>注意：在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-%E8%8A%82%E7%82%B9%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.png"></p>
<hr>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><p>添加 Maven 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数一：连接地址</span></span><br><span class="line">    <span class="comment">// 参数二：会话超时时间</span></span><br><span class="line">    <span class="comment">// 参数三：监听器</span></span><br><span class="line">    <span class="type">ZooKeeper</span> <span class="variable">zkClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">&quot;192.168.3.128:2181&quot;</span>, <span class="number">20000</span>, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;监听处理函数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="集群介绍"><a href="#集群介绍" class="headerlink" title="集群介绍"></a>集群介绍</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>Zookeepe 集群三个角色：</p>
<ul>
<li><p>Leader 领导者：处理客户端<strong>事务请求</strong>，负责集群内部各服务器的调度</p>
</li>
<li><p>Follower 跟随者：处理客户端非事务请求，转发事务请求给 Leader 服务器，参与 Leader 选举投票</p>
</li>
<li><p>Observer 观察者：观察集群的最新状态的变化，并将这些状态进行同步；处理非事务性请求，事务性请求会转发给 Leader 服务器进行处理；不会参与任何形式的投票。只提供非事务性的服务，通常用于在不影响集群事务处理能力的前提下，提升集群的非事务处理能力（提高集群读的能力，但是也降低了集群选主的复杂程度）</p>
</li>
</ul>
<p>相关属性：</p>
<ul>
<li><p>SID：服务器 ID，用来唯一标识一台集群中的机器，和 myid 一致</p>
</li>
<li><p>ZXID：事务 ID，用来标识一次服务器状态的变更，在某一时刻集群中每台机器的 ZXID 值不一定完全一致，这和 ZooKeeper 服务器对于客户端更新请求的处理逻辑有关</p>
</li>
<li><p>Epoch：每个 Leader 任期的代号，同一轮选举投票过程中的该值是相同的，投完一次票就增加</p>
</li>
</ul>
<p>选举机制：半数机制，超过半数的投票就通过</p>
<ul>
<li><p>第一次启动选举规则：投票过半数时，服务器 ID 大的胜出</p>
</li>
<li><p>第二次启动选举规则：</p>
<ul>
<li>EPOCH 大的直接胜出</li>
<li>EPOCH 相同，事务 ID 大的胜出（事务 ID 越大，数据越新）</li>
<li>事务 ID 相同，服务器 ID 大的胜出</li>
</ul>
</li>
</ul>
<hr>
<h3 id="初次选举"><a href="#初次选举" class="headerlink" title="初次选举"></a>初次选举</h3><p>选举过程：</p>
<ul>
<li>服务器 1 启动，发起一次选举，服务器 1 投自己一票，票数不超过半数，选举无法完成，服务器 1 状态保持为 LOOKING</li>
<li>服务器 2 启动，再发起一次选举，服务器 1 和 2 分别投自己一票并<strong>交换选票信息</strong>，此时服务器 1 会发现服务器 2 的 SID 比自己投票推举的（服务器 1）大，更改选票为推举服务器 2。投票结果为服务器 1 票数 0 票，服务器 2 票数 2 票，票数不超过半数，选举无法完成，服务器 1、2 状态保持 LOOKING</li>
<li>服务器 3 启动，发起一次选举，此时服务器 1 和 2 都会更改选票为服务器 3，投票结果为服务器 3 票数 3 票，此时服务器 3 的票数已经超过半数，服务器 3 当选 Leader，服务器 1、2 更改状态为 FOLLOWING，服务器 3 更改状态为 LEADING</li>
<li>服务器 4 启动，发起一次选举，此时服务器 1、2、3 已经不是 LOOKING 状态，不会更改选票信息，交换选票信息结果后服务器 3 为 3 票，服务器 4 为 1 票，此时服务器 4 更改选票信息为服务器 3，并更改状态为 FOLLOWING</li>
<li>服务器 5 启动，同 4 一样</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-%E5%88%9D%E6%AC%A1%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6.png"></p>
<hr>
<h3 id="再次选举"><a href="#再次选举" class="headerlink" title="再次选举"></a>再次选举</h3><p>ZooKeeper 集群中的一台服务器出现以下情况之一时，就会开始进入 Leader 选举：</p>
<ul>
<li>服务器初始化启动</li>
<li>服务器运行期间无法和 Leader 保持连接</li>
</ul>
<p>当一台服务器进入 Leader 选举流程时，当前集群可能会处于以下两种状态：</p>
<ul>
<li><p>集群中本来就已经存在一个 Leader，服务器试图去选举 Leader 时会被告知当前服务器的 Leader 信息，对于该服务器来说，只需要和 Leader 服务器建立连接，并进行状态同步即可</p>
</li>
<li><p>集群中确实不存在 Leader，假设服务器 3 和 5 出现故障，开始进行 Leader 选举，SID 为 1、2、4 的机器投票情况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(EPOCH，ZXID，SID): (1, 8, 1), (1, 8, 2), (1, 7, 4)</span><br></pre></td></tr></table></figure>

<p>根据选举规则，服务器 2 胜出</p>
</li>
</ul>
<hr>
<h3 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h3><p>写操作就是事务请求，写入请求直接发送给 Leader 节点：Leader 会先将数据写入自身，同时通知其他 Follower 写入，<strong>当集群中有半数以上节点写入完成</strong>，Leader 节点就会响应客户端数据写入完成</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-写入请求Leader.png" style="zoom: 50%;">

<p>写入请求直接发送给 Follower 节点：Follower 没有写入权限，会将写请求转发给 Leader，Leader 将数据写入自身，通知其他 Follower 写入，当集群中有半数以上节点写入完成，Leader 会通知 Follower 写入完成，<strong>由 Follower 响应客户端数据写入完成</strong></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-写入请求Follower.png" style="zoom:50%;">





<hr>
<h2 id="底层协议"><a href="#底层协议" class="headerlink" title="底层协议"></a>底层协议</h2><h3 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h3><p>Paxos 算法：基于消息传递且具有高度容错特性的一致性算法</p>
<p>优点：快速正确的在一个分布式系统中对某个数据值达成一致，并且保证不论发生任何异常，都不会破坏整个系统的一致性</p>
<p>缺陷：在网络复杂的情况下，可能很久无法收敛，甚至陷入活锁的情况</p>
<hr>
<h3 id="ZAB"><a href="#ZAB" class="headerlink" title="ZAB"></a>ZAB</h3><h4 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h4><p>ZAB 协议借鉴了 Paxos 算法，是为 Zookeeper 设计的支持崩溃恢复的原子广播协议，基于该协议 Zookeeper 设计为只有一台客户端（Leader）负责处理外部的写事务请求，然后 Leader 将数据同步到其他 Follower 节点</p>
<p>Zab 协议包括两种基本的模式：消息广播、崩溃恢复</p>
<hr>
<h4 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h4><p>ZAB 协议针对事务请求的处理过程类似于一个<strong>两阶段提交</strong>过程：广播事务阶段、广播提交操作</p>
<ul>
<li>客户端发起写操作请求，Leader 服务器将请求转化为事务 Proposal 提案，同时为 Proposal 分配一个全局的 ID，即 ZXID</li>
<li>Leader 服务器为每个 Follower 分配一个单独的队列，将广播的 Proposal <strong>依次放到队列</strong>中去，根据 FIFO 策略进行消息发送</li>
<li>Follower 接收到 Proposal 后，将其以事务日志的方式写入本地磁盘中，写入成功后向 Leader 反馈一个 ACK 响应消息</li>
<li>Leader 接收到超过半数以上 Follower 的 ACK 响应消息后，即认为消息发送成功，可以发送 Commit 消息</li>
<li>Leader 向所有 Follower 广播 commit 消息，同时自身也会完成事务提交，Follower 接收到 Commit 后，将上一条事务提交</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-消息广播.png" style="zoom:67%;">

<p>两阶段提交模型可能因为 Leader 宕机带来数据不一致：</p>
<ul>
<li>Leader 发起一个事务 Proposal 后就宕机，Follower 都没有 Proposal</li>
<li>Leader 收到半数 ACK 宕机，没来得及向 Follower 发送 Commit</li>
</ul>
<hr>
<h4 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h4><p>Leader 服务器出现崩溃或者由于网络原因导致 Leader 服务器失去了与<strong>过半 Follower的联系</strong>，那么就会进入崩溃恢复模式，崩溃恢复主要包括两部分：Leader 选举和数据恢复</p>
<p>Zab 协议崩溃恢复要求满足以下两个要求：</p>
<ul>
<li>已经被 Leader 提交的提案 Proposal，必须最终被所有的 Follower 服务器正确提交</li>
<li>丢弃已经被 Leader 提出的，但是没有被提交的 Proposal</li>
</ul>
<p>Zab 协议需要保证选举出来的 Leader 需要满足以下条件：</p>
<ul>
<li>新选举的 Leader 不能包含未提交的 Proposal，即新 Leader 必须都是已经提交了 Proposal 的 Follower 节点</li>
<li>新选举的 Leader 节点含有<strong>最大的 ZXID</strong>，可以避免 Leader 服务器检查 Proposal 的提交和丢弃工作</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-Leader选举.png" style="zoom: 67%;">

<p>数据恢复阶段：</p>
<ul>
<li>完成 Leader 选举后，在正式开始工作之前（接收事务请求提出新的 Proposal），Leader 服务器会首先确认事务日志中的所有 Proposal 是否已经被集群中过半的服务器 Commit</li>
<li>Leader 服务器需要确保所有的 Follower 服务器能够接收到每一条事务的 Proposal，并且能将所有已经提交的事务 Proposal 应用到内存数据中，所以只有当 Follower 将所有尚未同步的事务 Proposal 都<strong>从 Leader 服务器上同步</strong>，并且应用到内存数据后，Leader 才会把该 Follower 加入到真正可用的 Follower 列表中</li>
</ul>
<hr>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>Zab 的事务编号 zxid 设计：</p>
<ul>
<li>zxid 是一个 64 位的数字，低 32 位是一个简单的单增计数器，针对客户端每一个事务请求，Leader 在产生新的 Proposal 事务时，都会对该计数器加 1，而高 32 位则代表了 Leader 周期的 epoch 编号</li>
<li>epoch 为当前集群所处的代或者周期，每次 Leader 变更后都会在 epoch 的基础上加 1，Follower 只服从 epoch 最高的 Leader 命令，所以旧的 Leader 崩溃恢复之后，其他 Follower 就不会继续追随</li>
<li>每次选举产生一个新的 Leader，就会从新 Leader 服务器上取出本地事务日志中最大编号 Proposal 的 zxid，从 zxid 中解析得到对应的 epoch 编号，然后再对其加 1 后作为新的 epoch 值，并将低 32 位数字归零，由 0 开始重新生成 zxid</li>
</ul>
<p>Zab 协议通过 epoch 编号来区分 Leader 变化周期，能够有效避免不同的 Leader 错误的使用了相同的 zxid 编号提出了不一样的 Proposal 的异常情况</p>
<p>Zab 数据同步过程：<strong>数据同步阶段要以 Leader 服务器为准</strong></p>
<ul>
<li>一个包含了上个 Leader 周期中尚未提交过的事务 Proposal 的服务器启动时，这台机器加入集群中会以 Follower 角色连上 Leader</li>
<li>Leader 会根据自己服务器上最后提交的 Proposal 和 Follower 服务器的 Proposal 进行比对，让 Follower 进行一个<strong>回退或者前进操作</strong>，到一个已经被集群中过半机器 Commit 的最新 Proposal（源码解析部分详解）</li>
</ul>
<hr>
<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p>CAP 理论指的是在一个分布式系统中，Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性）不能同时成立，ZooKeeper 保证的是 CP</p>
<ul>
<li>ZooKeeper 不能保证每次服务请求的可用性，在极端环境下可能会丢弃一些请求，消费者程序需要重新请求才能获得结果</li>
<li>进行 Leader 选举时<strong>集群都是不可用</strong></li>
</ul>
<p>CAP 三个基本需求，因为 P 是必须的，因此分布式系统选择就在 CP 或者 AP 中：</p>
<ul>
<li>一致性：指数据在多个副本之间是否能够保持数据一致的特性，当一个系统在数据一致的状态下执行更新操作后，也能保证系统的数据仍然处于一致的状态</li>
<li>可用性：指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果</li>
<li>分区容错性：分布式系统在遇到任何网络分区故障时，仍然能够保证对外提供服务，不会宕机，除非是整个网络环境都发生了故障</li>
</ul>
<hr>
<h2 id="监听机制"><a href="#监听机制" class="headerlink" title="监听机制"></a>监听机制</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>ZooKeeper 中引入了 Watcher 机制来实现了发布&#x2F;订阅功能，客户端注册监听目录节点，在特定事件触发时，ZooKeeper 会通知所有关注该事件的客户端，保证 ZooKeeper 保存的任何的数据的任何改变都能快速的响应到监听应用程序</p>
<p>监听命令：<strong>只能生效一次</strong>，接收一次通知，再次监听需要重新注册</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> –w /path					<span class="comment"># 监听【子节点数量】的变化</span></span><br><span class="line">get –w /path				<span class="comment"># 监听【节点数据】的变化</span></span><br></pre></td></tr></table></figure>

<p>工作流程：</p>
<ul>
<li>在主线程中创建 Zookeeper 客户端，这时就会创建<strong>两个线程</strong>，一个负责网络连接通信（connet），一个负责监听（listener）</li>
<li>通过 connect 线程将注册的监听事件发送给 Zookeeper</li>
<li>在 Zookeeper 的注册监听器列表中将注册的<strong>监听事件添加到列表</strong>中</li>
<li>Zookeeper 监听到有数据或路径变化，将消息发送给 listener 线程</li>
<li>listener 线程内部调用 process() 方法</li>
</ul>
<p>Curator 框架引入了 Cache 来实现对 ZooKeeper 服务端事件的监听，三种 Watcher：</p>
<ul>
<li>NodeCache：只是监听某一个特定的节点</li>
<li>PathChildrenCache：监控一个 ZNode 的子节点</li>
<li>TreeCache：可以监控整个树上的所有节点，类似于 PathChildrenCache 和 NodeCache 的组合</li>
</ul>
<hr>
<h3 id="监听案例"><a href="#监听案例" class="headerlink" title="监听案例"></a>监听案例</h3><h4 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h4><p>客户端实时监听服务器动态上下线</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-监听服务器状态.png" style="zoom:50%;">



<hr>
<h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><p>客户端：先启动客户端进行监听</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributeClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">connectString</span> <span class="operator">=</span> <span class="string">&quot;192.168.3.128:2181&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sessionTimeout</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DistributeClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DistributeClient</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1 获取zk连接</span></span><br><span class="line">        client.getConnect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 监听/servers下面子节点的增加和删除</span></span><br><span class="line">        client.getServerList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 业务逻辑</span></span><br><span class="line">        client.business();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">business</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getServerList</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line">        ArrayList&lt;String&gt; servers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取所有子节点，true 代表触发监听操作</span></span><br><span class="line">        List&lt;String&gt; children = zk.getChildren(<span class="string">&quot;/servers&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">            <span class="comment">// 获取子节点的数据</span></span><br><span class="line">            <span class="type">byte</span>[] data = zk.getData(<span class="string">&quot;/servers/&quot;</span> + child, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            servers.add(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(servers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        zk = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(connectString, sessionTimeout, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">                getServerList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端：启动时需要 Program arguments</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributeServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">connectString</span> <span class="operator">=</span> <span class="string">&quot;192.168.3.128:2181&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sessionTimeout</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DistributeServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DistributeServer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取 zookeeper 连接</span></span><br><span class="line">        server.getConnect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2  注册服务器到 zk 集群，注意参数</span></span><br><span class="line">        server.register(args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 启动业务逻辑</span></span><br><span class="line">        server.business();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">business</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// OPEN_ACL_UNSAFE: ACL 开放</span></span><br><span class="line">        <span class="comment">// EPHEMERAL_SEQUENTIAL: 临时顺序节点</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">create</span> <span class="operator">=</span> zk.create(<span class="string">&quot;/servers/&quot;</span> + hostname, hostname.getBytes(),</span><br><span class="line">                                  ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        System.out.println(hostname + <span class="string">&quot; is online&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        zk = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(connectString, sessionTimeout, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>分布式锁可以实现在分布式系统中多个进程有序的访问该临界资源，多个进程之间不会相互干扰</p>
<p>核心思想：当客户端要获取锁，则创建节点，使用完锁，则删除该节点</p>
<ol>
<li><p>客户端获取锁时，在 &#x2F;locks 节点下创建<strong>临时顺序</strong>节点</p>
<ul>
<li>使用临时节点是为了防止当服务器或客户端宕机以后节点无法删除（持久节点），导致锁无法释放</li>
<li>使用顺序节点是为了系统自动编号排序，找最小的节点，防止客户端饥饿现象，保证公平</li>
</ul>
</li>
<li><p>获取 &#x2F;locks 目录的所有子节点，判断自己的<strong>子节点序号是否最小</strong>，成立则客户端获取到锁，使用完锁后将该节点删除</p>
</li>
<li><p>反之客户端需要找到比自己小的节点，<strong>对其注册事件监听器，监听删除事件</strong></p>
</li>
<li><p>客户端的 Watcher 收到删除事件通知，就会重新判断当前节点是否是子节点中序号最小，如果是则获取到了锁， 如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听</p>
</li>
</ol>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86.png"></p>
<hr>
<h3 id="Curator"><a href="#Curator" class="headerlink" title="Curator"></a>Curator</h3><p>Curator 实现分布式锁 API，在 Curator 中有五种锁方案：</p>
<ul>
<li><p>InterProcessSemaphoreMutex：分布式排它锁（非可重入锁）</p>
</li>
<li><p>InterProcessMutex：分布式可重入排它锁</p>
</li>
<li><p>InterProcessReadWriteLock：分布式读写锁</p>
</li>
<li><p>InterProcessMultiLock：将多个锁作为单个实体管理的容器</p>
</li>
<li><p>InterProcessSemaphoreV2：共享信号量</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuratorLock</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CuratorFramework <span class="title function_">getCuratorFramework</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 重试策略对象</span></span><br><span class="line">        <span class="type">ExponentialBackoffRetry</span> <span class="variable">policy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">3000</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 构建客户端</span></span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(<span class="string">&quot;192.168.3.128:2181&quot;</span>)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">2000</span>)	<span class="comment">// 连接超时时间</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">20000</span>)	<span class="comment">// 会话超时时间 单位ms</span></span><br><span class="line">                .retryPolicy(policy)		<span class="comment">// 重试策略</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动客户端</span></span><br><span class="line">        client.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;zookeeper 启动成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建分布式锁1</span></span><br><span class="line">        <span class="type">InterProcessMutex</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(getCuratorFramework(), <span class="string">&quot;/locks&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建分布式锁2</span></span><br><span class="line">        <span class="type">InterProcessMutex</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(getCuratorFramework(), <span class="string">&quot;/locks&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                lock1.acquire();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1 获取到锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                lock1.release();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1 释放锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                lock2.acquire();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2 获取到锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                lock2.release();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2 释放锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><p>服务端程序的入口 QuorumPeerMain</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">QuorumPeerMain</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QuorumPeerMain</span>();</span><br><span class="line">    main.initializeAndRun(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initializeAndRun 的工作：</p>
<ul>
<li><p>解析启动参数</p>
</li>
<li><p>提交周期任务，定时删除过期的快照</p>
</li>
<li><p>初始化通信模型，默认是 NIO 通信</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// QuorumPeerMain#runFromConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runFromConfig</span><span class="params">(QuorumPeerConfig config)</span> &#123;</span><br><span class="line">    <span class="comment">// 通信信组件初始化，默认是 NIO 通信</span></span><br><span class="line">    <span class="type">ServerCnxnFactory</span> <span class="variable">cnxnFactory</span> <span class="operator">=</span> ServerCnxnFactory.createFactory();</span><br><span class="line">    <span class="comment">// 初始化NIO 服务端socket，绑定2181 端口，可以接收客户端请求</span></span><br><span class="line">    cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 启动 zk</span></span><br><span class="line">    quorumPeer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 zookeeper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// QuorumPeer#start</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!getView().containsKey(myid)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;My id &quot;</span> + myid + <span class="string">&quot; not in the peer list&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 冷启动数据恢复，将快照中数据恢复到 DataTree</span></span><br><span class="line">    loadDataBase();</span><br><span class="line">    <span class="comment">// 启动通信工厂实例对象</span></span><br><span class="line">    startServerCnxnFactory();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        adminServer.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AdminServerException e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Problem starting AdminServer&quot;</span>, e);</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 准备选举环境</span></span><br><span class="line">    startLeaderElection();</span><br><span class="line">    <span class="comment">// 执行选举</span></span><br><span class="line">    <span class="built_in">super</span>.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h3><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>QuorumPeer#startLeaderElection 初始化选举环境：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startLeaderElection</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Looking 状态，需要选举</span></span><br><span class="line">        <span class="keyword">if</span> (getPeerState() == ServerState.LOOKING) &#123;</span><br><span class="line">            <span class="comment">// 选票组件: myid (serverid), zxid, epoch</span></span><br><span class="line">            <span class="comment">// 开始选票时，serverid 是自己，【先投自己】</span></span><br><span class="line">            currentVote = <span class="keyword">new</span> <span class="title class_">Vote</span>(myid, getLastLoggedZxid(), getCurrentEpoch());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (electionType == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            udpSocket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(getQuorumAddress().getPort());</span><br><span class="line">            <span class="comment">// 响应投票结果线程</span></span><br><span class="line">            responder = <span class="keyword">new</span> <span class="title class_">ResponderThread</span>();</span><br><span class="line">            responder.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建选举算法实例</span></span><br><span class="line">    <span class="built_in">this</span>.electionAlg = createElectionAlgorithm(electionType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// zk总的发送和接收队列准备好</span></span><br><span class="line"><span class="keyword">protected</span> Election <span class="title function_">createElectionAlgorithm</span><span class="params">(<span class="type">int</span> electionAlgorithm)</span>&#123;</span><br><span class="line">    <span class="comment">// 负责选举过程中的所有网络通信，创建各种队列和集合</span></span><br><span class="line">    <span class="type">QuorumCnxManager</span> <span class="variable">qcm</span> <span class="operator">=</span> createCnxnManager();</span><br><span class="line">    QuorumCnxManager.<span class="type">Listener</span> <span class="variable">listener</span> <span class="operator">=</span> qcm.listener;</span><br><span class="line">    <span class="keyword">if</span>(listener != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 启动监听线程, 调用 client = ss.accept()阻塞，等待处理请求</span></span><br><span class="line">        listener.start();</span><br><span class="line">        <span class="comment">// 准备好发送和接收队列准备</span></span><br><span class="line">        <span class="type">FastLeaderElection</span> <span class="variable">fle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastLeaderElection</span>(<span class="built_in">this</span>, qcm);</span><br><span class="line">        <span class="comment">// 启动选举线程，【WorkerSender 和 WorkerReceiver】</span></span><br><span class="line">        fle.start();</span><br><span class="line">        le = fle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="选举源码"><a href="#选举源码" class="headerlink" title="选举源码"></a>选举源码</h4><p>当 Zookeeper 启动后，首先都是 Looking 状态，通过选举让其中一台服务器成为 Leader</p>
<p>执行 <code>super.start()</code> 相当于执行 <code>QuorumPeer#run()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> LOOKING:</span><br><span class="line">        <span class="comment">// 进行选举，选举结束返回最终成为 Leader 胜选的那张选票</span></span><br><span class="line">        setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FastLeaderElection 类：</p>
<ul>
<li><p>lookForLeader：选举</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Vote <span class="title function_">lookForLeader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 正常启动中其他服务器都会向我发送一个投票，保存每个服务器的最新合法有效的投票</span></span><br><span class="line">    HashMap&lt;Long, Vote&gt; recvset = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Long, Vote&gt;();</span><br><span class="line">	<span class="comment">// 存储合法选举之外的投票结果</span></span><br><span class="line">    HashMap&lt;Long, Vote&gt; outofelection = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Long, Vote&gt;();</span><br><span class="line">	<span class="comment">// 一次选举的最大等待时间，默认值是0.2s</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">notTimeout</span> <span class="operator">=</span> finalizeWait;</span><br><span class="line">	<span class="comment">// 每发起一轮选举，logicalclock++,在没有合法的epoch 数据之前，都使用逻辑时钟代替</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">        <span class="comment">// 更新逻辑时钟，每进行一次选举，都需要更新逻辑时钟</span></span><br><span class="line">        logicalclock.incrementAndGet();</span><br><span class="line">        <span class="comment">// 更新选票(serverid， zxid, epoch）</span></span><br><span class="line">        updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 广播选票，把自己的选票发给其他服务器</span></span><br><span class="line">    sendNotifications();</span><br><span class="line">    <span class="comment">// 一轮一轮的选举直到选举成功</span></span><br><span class="line">    <span class="keyword">while</span> ((self.getPeerState() == ServerState.LOOKING) &amp;&amp; (!stop))&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sendNotifications：广播选票</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendNotifications</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历投票参与者，给每台服务器发送选票</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> sid : self.getCurrentAndNextConfigVoters()) &#123;</span><br><span class="line">		<span class="comment">// 创建发送选票</span></span><br><span class="line">        <span class="type">ToSend</span> <span class="variable">notmsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToSend</span>(...);</span><br><span class="line">        <span class="comment">// 把发送选票放入发送队列</span></span><br><span class="line">        sendqueue.offer(notmsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>FastLeaderElection 中有 WorkerSender 线程：</p>
<ul>
<li><p><code>ToSend m = sendqueue.poll(3000, TimeUnit.MILLISECONDS)</code>：<strong>阻塞获取要发送的选票</strong></p>
</li>
<li><p><code>process(m)</code>：处理要发送的选票</p>
<p><code>manager.toSend(m.sid, requestBuffer)</code>：发送选票</p>
<ul>
<li><p><code>if (this.mySid == sid)</code>：如果<strong>消息的接收者 sid 是自己</strong>，直接进入自己的 RecvQueue（自己投自己）</p>
</li>
<li><p><code>else</code>：如果接收者是其他服务器，创建对应的发送队列或者复用已经存在的发送队列，把消息放入该队列</p>
</li>
<li><p><code>connectOne(sid)</code>：建立连接</p>
<ul>
<li><p><code>sock.connect(electionAddr, cnxTO)</code>：建立与 sid 服务器的连接</p>
</li>
<li><p><code>initiateConnection(sock, sid)</code>：初始化连接</p>
<p><code>startConnection(sock, sid)</code>：创建并启动发送器线程和接收器线程</p>
<ul>
<li><code>dout = new DataOutputStream(buf)</code>：<strong>获取 Socket 输出流</strong>，向服务器发送数据</li>
<li><code>din = new DataInputStream(new BIS(sock.getInputStream())))</code>：通过输入流读取对方发送过来的选票</li>
<li><code>if (sid &gt; self.getId())</code>：接收者 sid 比我的大，没有资格给对方发送连接请求的，直接关闭自己的客户端</li>
<li><code>SendWorker sw</code>：初始化发送器，并启动发送器线程，线程 run 方法<ul>
<li><code>while (running &amp;&amp; !shutdown &amp;&amp; sock != null)</code>：连接没有断开就一直运行</li>
<li><code>ByteBuffer b = pollSendQueue()</code>：从发送队列 SendQueue 中获取发送消息</li>
<li><code>lastMessageSent.put(sid, b)</code>：更新对于 sid 这台服务器的最近一条消息</li>
<li><code>send(b)</code>：<strong>执行发送</strong></li>
</ul>
</li>
<li><code>RecvWorker rw</code>：初始化接收器，并启动接收器线程<ul>
<li><code>din.readFully(msgArray, 0, length)</code>：输入流接收消息</li>
<li><code>addToRecvQueue(new Message(messagg, sid))</code>：将消息放入接收消息 recvQueue 队列</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FastLeaderElection 中有 WorkerReceiver 线程</p>
<ul>
<li><code>response = manager.pollRecvQueue()</code>：从 RecvQueue 中<strong>阻塞获取出选举投票消息</strong>（其他服务器发送过来的）</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-选举源码.png" style="zoom: 50%;">





<hr>
<h4 id="状态同步"><a href="#状态同步" class="headerlink" title="状态同步"></a>状态同步</h4><p>选举结束后，每个节点都需要根据角色更新自己的状态，Leader 更新状态为 Leader，其他节点更新状态为 Follower，整体流程：</p>
<ul>
<li>Follower 需要让 Leader 知道自己的状态 (sid, epoch, zxid)</li>
<li>Leader 接收到信息，<strong>根据信息构建新的 epoch</strong>，要返回对应的信息给 Follower，Follower 更新自己的 epoch</li>
<li>Leader 需要根据 Follower 的状态，确定何种方式的数据同步 DIFF、TRUNC、SNAP，就是要<strong>以 Leader 服务器数据为准</strong><ul>
<li>DIFF：Leader 提交的 zxid 比 Follower 的 zxid 大，发送 Proposal 给 Follower 提交执行</li>
<li>TRUNC：Follower 的 zxid 比leader 的 zxid 大，Follower 要进行回滚</li>
<li>SNAP：Follower 没有任何数据，直接全量同步</li>
</ul>
</li>
<li>执行数据同步，当 Leader 接收到超过半数 Follower 的 Ack 之后，进入正常工作状态，集群启动完成</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-同步源码.png" style="zoom:50%;">

<p>核心函数解析：</p>
<ul>
<li>Leader 更新状态入口：<code>Leader.lead()</code><ul>
<li><code>zk.loadData()</code>：恢复数据到内存</li>
<li><code>cnxAcceptor = new LearnerCnxAcceptor()</code>：启动通信组件<ul>
<li><code>s = ss.accept()</code>：等待其他 Follower 节点向 Leader 节点发送同步状态</li>
<li><code>LearnerHandler fh </code>：接收到 Follower 的请求，就创建 LearnerHandler 对象</li>
<li><code>fh.start()</code>：启动线程，通过 switch-case 语法判断接收的命令，执行相应的操作</li>
</ul>
</li>
</ul>
</li>
<li>Follower 更新状态入口：<code>Follower.followerLeader()</code><ul>
<li><code>QuorumServer leaderServer = findLeader()</code>：查找 Leader</li>
<li><code>connectToLeader(addr, hostname) </code>：与 Leader 建立连接</li>
<li><code>long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO)</code>：向 Leader 注册</li>
</ul>
</li>
</ul>
<hr>
<h4 id="主从工作"><a href="#主从工作" class="headerlink" title="主从工作"></a>主从工作</h4><p>Leader：主服务的工作流程</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-Leader%E5%90%AF%E5%8A%A8.png"></p>
<p>Follower：从服务的工作流程，核心函数为 <code>Follower#followLeader()</code></p>
<ul>
<li><p><code>readPacket(qp)</code>：读取信息</p>
</li>
<li><p><code>processPacket(qp)</code>：处理信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processPacket</span><span class="params">(QuorumPacket qp)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="keyword">switch</span> (qp.getType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> Leader.PING:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Leader.PROPOSAL:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Leader.COMMIT:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Leader.COMMITANDACTIVATE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Leader.UPTODATE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Leader.REVALIDATE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Leader.SYNC:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96.png"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/08/02/Web/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: View</span><br><span class="line">date: 2022-01-01 00:00:00</span><br><span class="line">tags: View</span><br><span class="line">categories: View</span><br><span class="line">comment</span><br></pre></td></tr></table></figure>



<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="HTML入门"><a href="#HTML入门" class="headerlink" title="HTML入门"></a>HTML入门</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>HTML（超文本标记语言—HyperText Markup Language）是构成 Web 世界的基础，是一种用来告知浏览器如何组织页面的标记语言</p>
<ul>
<li><p>超文本 Hypertext，是指连接单个或者多个网站间的网页的链接。通过链接，就能访问互联网中的内容</p>
</li>
<li><p>标记 Markup ，是用来注明文本，图片等内容，以便于在浏览器中显示，例如 <code>&lt;head&gt;</code>，<code>&lt;body&gt;</code> 等</p>
</li>
</ul>
<p><strong>网页的构成</strong></p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">HTML</a>：通常用来定义网页内容的含义和基本结构</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS</a>：通常用来描述网页的表现与展示效果</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">JavaScript</a>：通常用来执行网页的功能与行为</li>
</ul>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1Qf4y1T7Hx">https://www.bilibili.com/video/BV1Qf4y1T7Hx</a></p>
<hr>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>HTML 页面由一系列的<strong>元素（elements）</strong> 组成，而元素是使用<strong>标签</strong>创建的</p>
<p>一对标签（tags）可以设置一段文字样式，添加一张图片或者添加超链接等等</p>
<p>在 HTML 中，<code>&lt;h1&gt;</code> 标签表示<strong>标题</strong>，我们可以使用<strong>开始标签</strong>和<strong>结束标签</strong>包围文本内容，这样其中的内容就以标题的形式显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>开始学习JavaWeb<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>HTML 标签可以拥有属性</p>
<ul>
<li>属性是属于标签的，修饰标签，让标签有更多的效果</li>
<li>属性一般定义在起始标签里面</li>
<li>属性一般以<strong>属性&#x3D;属性值</strong>的形式出现</li>
<li>属性值一般用 <code>&#39;&#39;</code> 或者 <code>&quot;&quot;</code> 括起来。 不加引号也是可以的(不建议使用)。比如：name&#x3D;’value’</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>开始学习JavaWeb<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 HTML 标签中，<code>align</code>  属性表示<strong>水平对齐方式</strong>，我们可以赋值为 <code>center</code>  表示 <strong>居中</strong> 。</p>
<hr>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML%E7%BB%93%E6%9E%84.png" alt="HTML结构"></p>
<p>文档结构介绍：</p>
<ul>
<li>文档声明：用于声明当前 HTML 的版本，这里的<code>&lt;!DOCTYPE html&gt;</code>是 HTML5 的声明</li>
<li>html 根标签：除文档声明以外，其它内容全部要放在根标签 html 内部</li>
<li>文档头部配置：head 标签，是当前页面的配置信息，外部引入文件, 例如网页标签、字符集等<ul>
<li><code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>：这个标签是页面的元数据信息，设置文档使用 utf-8 字符集编码</li>
<li><code>&lt;title&gt;</code>：这个标签定义文档标题，位置出现在浏览器标签。在收藏页面时，它可用来描述页面</li>
</ul>
</li>
<li>文档显示内容：body 标签，里边的内容会显示到浏览器页面上</li>
</ul>
<hr>
<h2 id="HTML语法"><a href="#HTML语法" class="headerlink" title="HTML语法"></a>HTML语法</h2><h3 id="注释方式"><a href="#注释方式" class="headerlink" title="注释方式"></a>注释方式</h3><p>将一段 HTML 中的内容置为注释，你需要将其用特殊的记号 <!----> 包括起来</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我在注释外！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;p&gt;我在注释内！&lt;/p&gt; --&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h3><h4 id="空元素"><a href="#空元素" class="headerlink" title="空元素"></a>空元素</h4><p>一些元素只有一个标签，叫做空元素。它是在开始标签中进行关闭的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">第一行文档<span class="tag">&lt;<span class="name">br</span>/&gt;</span> </span><br><span class="line">第二行文档<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="嵌套元素"><a href="#嵌套元素" class="headerlink" title="嵌套元素"></a>嵌套元素</h4><p>把元素放到其它元素之中——这被称作嵌套。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">u</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">u</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h4><p>在HTML中有两种重要元素类别，块级元素和内联元素</p>
<ul>
<li><p>块级元素：</p>
<p><strong>独占一行</strong>。块级元素（block）在页面中以块的形式展现。相对于其前面的内容它会出现在新的一行，其后的内容也会被挤到下一行展现。比如<code>&lt;p&gt;</code> ，<code>&lt;hr&gt;</code>，<code>&lt;li&gt;</code> ，<code>&lt;div&gt;</code>等。</p>
</li>
<li><p>行内元素</p>
<p><strong>行内显示</strong>。行内元素不会导致换行。通常出现在块级元素中并环绕文档内容的一小部分，而不是一整个段落或者一组内容。比如<code>&lt;b&gt;</code>，<code>&lt;a&gt;</code>，<code>&lt;i&gt;</code>，<code>&lt;span&gt;</code> 等。</p>
</li>
</ul>
<p>注意：一个块级元素不会被嵌套进行内元素中，但可以嵌套在其它块级元素中。</p>
<p>常用的两个标签：（<strong>重要</strong>）</p>
<ul>
<li><code>&lt;div&gt;</code> 是一个通用的内容容器，并没有任何特殊语义。它可以被用来对其它元素进行分组，一般用于样式化相关的需求。它是一个<strong>块级元素</strong>。</li>
<li>属性：id、style、class</li>
<li><code> &lt;span&gt;</code> 是短语内容的通用行内容器，并没有任何特殊语义。它可以被用来编组元素以达到某种样式。它是一个<strong>行内元素</strong></li>
</ul>
<hr>
<h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><p>标签属性，主要用于拓展标签。属性包含元素的额外信息，这些信息不会出现在实际的内容中。但是可以改变标签的一些行为或者提供数据，属性总是以<code>name = value&quot;</code>的格式展现。</p>
<ul>
<li><p>属性名：同一个标签中，属性名不得重复。</p>
</li>
<li><p>大小写：属性和属性值对大小写不敏感。不过W3C标准中，推荐使用小写的属性&#x2F;属性值。</p>
</li>
<li><p>引号：双引号是最常用的，不过使用单引号也没有问题。</p>
</li>
<li><p>常用属性：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>定义元素类名，用来选择和访问特定的元素</td>
</tr>
<tr>
<td>id</td>
<td>定义元素<strong>唯一</strong>标识符，在整个文档中必须是唯一的</td>
</tr>
<tr>
<td>name</td>
<td>定义元素名称，可以用于提交服务器的表单字段</td>
</tr>
<tr>
<td>value</td>
<td>定义在元素内显示的默认值</td>
</tr>
<tr>
<td>style</td>
<td>定义CSS样式，这些样式会覆盖之前设置的样式</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>在HTML中，字符 <code>&lt;</code>, <code>&gt;</code>,<code>&quot;</code>,<code>&#39;</code> 和 <code>&amp;</code> 是特殊字符</p>
<table>
<thead>
<tr>
<th>原义字符</th>
<th>等价字符引用</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;</td>
<td><code>&amp;lt;</code></td>
</tr>
<tr>
<td>&gt;</td>
<td><code>&amp;gt;</code></td>
</tr>
<tr>
<td>“</td>
<td><code>&amp;quot;</code></td>
</tr>
<tr>
<td>‘</td>
<td><code>&amp;apos;</code></td>
</tr>
<tr>
<td>&amp;</td>
<td><code>&amp;amp;</code></td>
</tr>
<tr>
<td>空格</td>
<td><code>&amp;nbsp;</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h3><p>使用文本内容标签设置文字基本样式</p>
<table>
<thead>
<tr>
<th>标签名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>p</td>
<td>表示文本的一个段落</td>
</tr>
<tr>
<td>h</td>
<td>表示文档标题，<code>&lt;h1&gt;–&lt;h6&gt;</code> ，呈现了六个不同的级别的标题，<code>&lt;h1&gt;</code> 级别最高，而 <code>&lt;h6&gt;</code> 级别最低</td>
</tr>
<tr>
<td>hr</td>
<td>表示段落级元素之间的主题转换，一般显示为水平线</td>
</tr>
<tr>
<td>li</td>
<td>表示列表里的条目。（常用在ul ol 中）</td>
</tr>
<tr>
<td>ul</td>
<td>表示一个无序列表，可含多个元素，无编号显示。</td>
</tr>
<tr>
<td>ol</td>
<td>表示一个有序列表，通常渲染为有带编号的列表</td>
</tr>
<tr>
<td>em</td>
<td>表示文本着重，一般用斜体显示</td>
</tr>
<tr>
<td>strong</td>
<td>表示文本重要，一般用粗体显示</td>
</tr>
<tr>
<td>font</td>
<td>表示字体，可以设置样式（已过时）</td>
</tr>
<tr>
<td>i</td>
<td>表示斜体</td>
</tr>
<tr>
<td>b</td>
<td>表示加粗文本</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>文本标签演示<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--段落标签：&lt;p&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这些年<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>支付宝的诞生就是为了解决淘宝网的客户们的买卖问题<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 标题标签：&lt;h1&gt; ~ &lt;h6&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--水平线标签：&lt;hr/&gt;</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">            size-大小</span></span><br><span class="line"><span class="comment">            color-颜色</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> <span class="attr">size</span>=<span class="string">&quot;4&quot;</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        无序列表：&lt;ul&gt;</span></span><br><span class="line"><span class="comment">        属性：type-列表样式(disc实心圆、circle空心圆、square实心方块)</span></span><br><span class="line"><span class="comment">        列表项：&lt;li&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">&quot;circle&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>javaEE<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        有序列表：&lt;ol&gt;</span></span><br><span class="line"><span class="comment">        属性：type-列表样式(1数字、A或a字母、I或i罗马字符)   start-起始位置</span></span><br><span class="line"><span class="comment">        列表项：&lt;li&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;1&quot;</span> <span class="attr">start</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>传智播客<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>黑马程序员<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        斜体标签：&lt;i&gt;    &lt;em&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span>&gt;</span>我倾斜了<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">em</span>&gt;</span>我倾斜了<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        加粗标签：&lt;strong&gt;  &lt;b&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>加粗文本<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>加粗文本<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        文字标签：&lt;font&gt;</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">            size-大小</span></span><br><span class="line"><span class="comment">            color-颜色</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">&quot;5&quot;</span> <span class="attr">color</span>=<span class="string">&quot;yellow&quot;</span>&gt;</span>这是一段文字<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>效果如下</strong>：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE%E6%95%88%E6%9E%9C%E5%9B%BE.png"></p>
<hr>
<h3 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h3><p>img标签中的img其实是英文image的缩写, img标签的作用, 就是告诉浏览器我们需要显示一张图片</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../img/b.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200px&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>src</strong></td>
<td>图片路径</td>
</tr>
<tr>
<td><strong>title</strong></td>
<td>鼠标悬停（hover）时显示文本。</td>
</tr>
<tr>
<td><strong>alt</strong></td>
<td>图片描述，图形不显示时的替换文本。</td>
</tr>
<tr>
<td><strong>height</strong></td>
<td>图像的高度。</td>
</tr>
<tr>
<td><strong>width</strong></td>
<td>图像的宽度。</td>
</tr>
</tbody></table>
<hr>
<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>超链接标签的作用: 就是用于控制页面与页面(服务器资源)之间跳转的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;指定需要跳转的目标路径&quot;</span> <span class="attr">target</span>=<span class="string">&quot;打开的方式&quot;</span>&gt;</span>需要展现给用户的内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">target属性取值: </span><br><span class="line">	_blank：新起页面</span><br><span class="line">	_self：当前页面（默认）</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>超链接标签演示<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*去掉超链接的下划线*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*超链接的颜色*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: black;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/*鼠标悬浮的样式控制*/</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        超链接标签：&lt;a&gt;</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">            href-跳转的地址</span></span><br><span class="line"><span class="comment">            target-跳转的方式(_self当前页面、_blank新标签页)</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;01案例二：样式演示.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>点我跳转到样式演示<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.itcast.cn&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>传智播客<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.itheima.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span>&gt;</span>黑马程序员<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.itheima.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../img/itheima.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;150px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50px&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML超链接效果图.png" style="zoom: 67%;">

<hr>
<h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p><strong>form</strong>  表示表单，是用来<strong>收集用户输入信息并向 Web 服务器提交</strong>的一个容器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> &gt;</span></span><br><span class="line">    //表单元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>action</td>
<td>处理此表单信息的Web服务器的URL地址</td>
</tr>
<tr>
<td>method</td>
<td>提交此表单信息到Web服务器的方式，可能的值有get和post，默认为get</td>
</tr>
<tr>
<td>autocomplete</td>
<td>自动补全，指示表单元素是否能够拥有一个默认值，配合input标签使用</td>
</tr>
</tbody></table>
<p>get与post区别：</p>
<ul>
<li><p>post：指的是 HTTP <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5">POST 方法</a>；表单数据会包含在表单体内然后发送给服务器。</p>
</li>
<li><p>get：指的是 HTTP <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.3">GET 方法</a>；表单数据会附加在 <code>action</code> 属性的URI中，并以 ‘?’ 作为分隔符，然后这样得到的 URI 再发送给服务器。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>地址栏可见</th>
<th>数据安全</th>
<th>数据大小</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>可见</td>
<td>不安全</td>
<td>有限制（取决于浏览器）</td>
</tr>
<tr>
<td>POST</td>
<td>不可见</td>
<td>相对安全</td>
<td>无限制</td>
</tr>
</tbody></table>
<h4 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h4><table>
<thead>
<tr>
<th>标签名</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>label</td>
<td>表单元素的说明，配合表单元素使用</td>
<td>for属性值为相关表单元素id属性值</td>
</tr>
<tr>
<td>input</td>
<td>表单中输入控件，多种输入类型，用于接受来自用户数据</td>
<td>type属性值决定输入类型</td>
</tr>
<tr>
<td>button</td>
<td>页面中可点击的按钮，可以配合表单进行提交</td>
<td>type属性值决定按钮类型</td>
</tr>
<tr>
<td>select</td>
<td>表单的控件，下拉选项菜单</td>
<td>与option配合实用</td>
</tr>
<tr>
<td>optgroup</td>
<td>option的分组标签</td>
<td>与option配合实用</td>
</tr>
<tr>
<td>option</td>
<td>select的子标签，表示一个选项</td>
<td></td>
</tr>
<tr>
<td>textarea</td>
<td>表示多行纯文本编辑控件</td>
<td></td>
</tr>
<tr>
<td>fieldset</td>
<td>用来对表单中的控制元素进行分组(也包括 label 元素)</td>
<td></td>
</tr>
<tr>
<td>legend</td>
<td>用于表示它的fieldset内容的标题。</td>
<td>fieldset 的子元素</td>
</tr>
</tbody></table>
<h4 id="按键控件"><a href="#按键控件" class="headerlink" title="按键控件"></a>按键控件</h4><p>button标签：表示按钮</p>
<ul>
<li>type属性：表示按钮类型，submit值为提交按钮。</li>
</ul>
<table>
<thead>
<tr>
<th>属性值</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>button</td>
<td>无行为按钮，用于结合JavaScript实现自定义动态效果</td>
<td>同 <code>&lt;input type=&quot;submit&quot;/&gt; </code></td>
</tr>
<tr>
<td>submit</td>
<td>提交按钮，用于提交表单数据到服务器。</td>
<td>同 <code>&lt;input type=&quot;submit&quot;/&gt; </code></td>
</tr>
<tr>
<td>reset</td>
<td>重置按钮，用于将表单中内容恢复为默认值。</td>
<td>同<code>&lt;input type=&quot;reset&quot;</code>&#x2F;&gt;</td>
</tr>
</tbody></table>
<hr>
<h4 id="输入控件"><a href="#输入控件" class="headerlink" title="输入控件"></a>输入控件</h4><h5 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul>
<li><p>label标签：表单的说明。</p>
<ul>
<li>for属性值：匹配input标签的id属性值</li>
</ul>
</li>
<li><p>input标签：输入控件。</p>
<p>属性：</p>
<ul>
<li>type：表示输入类型，text值为普通文本框</li>
<li>id：表示标签唯一标识</li>
<li>name：表示标签名称，提交服务器的标识</li>
<li>value：表示标签的默认数据值</li>
<li>placeholder：默认的提示信息，仅适用于当type 属性为text, search, tel, url or email时; </li>
<li>required：是否必须为该元素填充值，当type属性是hidden,image或者button类型时不可使用</li>
<li>readonly：是否只读,可以让用户不修改这个输入框的值,就使用value属性设置默认值</li>
<li>disabled：是否可用,如果某个输入框有disabled那么它的数据不能提交到服务器通常是使用在有的页面中，让一些按钮不能点击</li>
<li>autocomplete：自动补全，规定表单或输入字段是否应该自动完成。当自动完成开启，浏览器会基于用户之前的输入值自动填写值。可以设置指定的字段为off，关闭自动补全</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot; 请在此处输入用户名&quot;</span> <span class="attr">required</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果图：<br><!DOCTYPE html></p>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>表单项标签</title>
</head>
<body>
    <form action="#" method="get" autocomplete="off">
        <label for="username">用户名：</label>
        <input type="text" id="username" name="username" value placeholder=" 请在此处输入用户名" required>
        <button type="submit">提交</button>
        <button type="reset">重置</button>
        <button type="button">按钮</button>
    </form>
</body>
</html>



<h5 id="n-v属性"><a href="#n-v属性" class="headerlink" title="n-v属性"></a>n-v属性</h5><table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>name</strong></td>
<td><code>&lt;input&gt;</code>的名字，在提交整个表单数据时，可以用于区分属于不同<code>&lt;input&gt;</code>的值</td>
</tr>
<tr>
<td><strong>value</strong></td>
<td>这个<code>&lt;input&gt;</code>元素当前的值，允许用户通过页面输入</td>
</tr>
</tbody></table>
<p>使用方式：以name属性值作为键，value属性值作为值，构成键值对提交到服务器，多个键值对浏览器使用<code>&amp;</code>进行分隔。</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML%E6%A0%87%E7%AD%BEinput%E5%B1%9E%E6%80%A7-name-value.png"></p>
<h5 id="type属性"><a href="#type属性" class="headerlink" title="type属性"></a>type属性</h5><table>
<thead>
<tr>
<th>属性值</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>单行文本字段</td>
<td></td>
</tr>
<tr>
<td>password</td>
<td>单行文本字段，值被遮盖</td>
<td></td>
</tr>
<tr>
<td>email</td>
<td>用于编辑 e-mail 的字段，可以对e-mail地址进行简单校验</td>
<td></td>
</tr>
<tr>
<td>radio</td>
<td>单选按钮。 1. 在同一个”单选按钮组“中，所有单选按钮的 name 属性使用同一个值；一个单选按钮组中是，同一时间只有一个单选按钮可以被选择。 2. 必须使用 value 属性定义此控件被提交时的值。 3. 使用checked 必须指示控件是否缺省被选择。</td>
<td></td>
</tr>
<tr>
<td>checkbox</td>
<td>复选框。 1. 必须使用 value 属性定义此控件被提交时的值。 2. 使用 checked 属性指示控件是否被选择。 3. 选中多个值时，所有的值会构成一个数组而提交到Web服务器</td>
<td></td>
</tr>
<tr>
<td>date</td>
<td>HTML5 用于输入日期的控件</td>
<td>年，月，日，不包括时间</td>
</tr>
<tr>
<td>time</td>
<td>HTML5 用于输入时间的控件</td>
<td>不含时区</td>
</tr>
<tr>
<td>datetime-local</td>
<td>HTML5 用于输入日期时间的控件</td>
<td>不包含时区</td>
</tr>
<tr>
<td>number</td>
<td>HTML5 用于输入浮点数的控件</td>
<td></td>
</tr>
<tr>
<td>range</td>
<td>HTML5 用于输入不精确值控件</td>
<td>max-规定最大值min-规定最小值 step-规定步进值 value-规定默认值</td>
</tr>
<tr>
<td>search</td>
<td>HTML5 用于输入搜索字符串的单行文本字段</td>
<td>可以点击<code>x</code>清除内容</td>
</tr>
<tr>
<td>tel</td>
<td>HTML5 用于输入电话号码的控件</td>
<td></td>
</tr>
<tr>
<td>url</td>
<td>HTML5 用于编辑URL的字段</td>
<td>可以校验URL地址格式</td>
</tr>
<tr>
<td>file</td>
<td>此控件可以让用户选择文件，用于文件上传。</td>
<td>使用 accept 属性可以定义控件可以选择的文件类型。</td>
</tr>
<tr>
<td>hidden</td>
<td>此控件用户在页面上不可见，但它的值会被提交到服务器，用于传递隐藏值</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>type属性演示<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span>  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>邮箱：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;gender&quot;</span>&gt;</span>性别：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;men&quot;</span>/&gt;</span>男</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;women&quot;</span>/&gt;</span>女</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;other&quot;</span>/&gt;</span>其他<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span>爱好：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;music&quot;</span> <span class="attr">checked</span>/&gt;</span>音乐</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;game&quot;</span>/&gt;</span>游戏 <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span>生日：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">id</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;time&quot;</span>&gt;</span>当前时间：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;time&quot;</span> <span class="attr">id</span>=<span class="string">&quot;time&quot;</span> <span class="attr">name</span>=<span class="string">&quot;time&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;insert&quot;</span>&gt;</span>注册时间：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;datetime-local&quot;</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">name</span>=<span class="string">&quot;insert&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;age&quot;</span>&gt;</span>年龄：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">id</span>=<span class="string">&quot;age&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;range&quot;</span>&gt;</span>心情值(1~10)：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">id</span>=<span class="string">&quot;range&quot;</span> <span class="attr">name</span>=<span class="string">&quot;range&quot;</span> <span class="attr">min</span>=<span class="string">&quot;1&quot;</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> <span class="attr">step</span>=<span class="string">&quot;1&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;search&quot;</span>&gt;</span>可全部清除文本：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span> <span class="attr">id</span>=<span class="string">&quot;search&quot;</span> <span class="attr">name</span>=<span class="string">&quot;search&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;tel&quot;</span>&gt;</span>电话：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tel&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;url&quot;</span>&gt;</span>个人网站：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;url&quot;</span> <span class="attr">id</span>=<span class="string">&quot;url&quot;</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;file&quot;</span>&gt;</span>文件上传：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;hidden&quot;</span>&gt;</span>隐藏信息：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">id</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;itheima&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML%E6%A0%87%E7%AD%BEinput%E5%B1%9E%E6%80%A7-type.png"></p>
<hr>
<h4 id="选择控件"><a href="#选择控件" class="headerlink" title="选择控件"></a>选择控件</h4><p>下拉列表标签<select>：</select></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>显示的内容<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>option：选择菜单的选项</p>
</li>
<li><p>optgroup：列表项分组标签<br>属性：label设置分组名称</p>
</li>
</ul>
<h4 id="文本域控件"><a href="#文本域控件" class="headerlink" title="文本域控件"></a>文本域控件</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;textarea&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;50&quot;</span>&gt;</span>Write something here<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>属性：</p>
<ul>
<li><p>name-标签名称</p>
</li>
<li><p>rows-行数</p>
</li>
<li><p>cols-列数</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br><span class="line">        所在城市：<span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>---请选择城市---<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">&quot;直辖市&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">&quot;省会市&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>杭州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>武汉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        个人介绍：<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;desc&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;5&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML%E6%A0%87%E7%AD%BEselect%E5%92%8C%E6%96%87%E6%9C%AC%E5%9F%9F%E5%B1%9E%E6%80%A7.png"></p>
<hr>
<h4 id="分组控件"><a href="#分组控件" class="headerlink" title="分组控件"></a>分组控件</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">legend</span>&gt;</span>是否同意<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;radio_y&quot;</span> <span class="attr">name</span>=<span class="string">&quot;agree&quot;</span> <span class="attr">value</span>=<span class="string">&quot;y&quot;</span>&gt;</span> </span><br><span class="line">      	<span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;radio_y&quot;</span>&gt;</span>同意<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;radio_n&quot;</span> <span class="attr">name</span>=<span class="string">&quot;agree&quot;</span> <span class="attr">value</span>=<span class="string">&quot;n&quot;</span>&gt;</span> </span><br><span class="line">      	<span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;radio_n&quot;</span>&gt;</span>不同意<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<form action="#" method="post">
  <fieldset>
        <legend>是否同意</legend>
        <input type="radio" id="radio_y" name="agree" value="y"> 
          <label for="radio_y">同意</label>
        <input type="radio" id="radio_n" name="agree" value="n"> 
          <label for="radio_n">不同意</label>
  </fieldset>
</form>



<hr>
<h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><h4 id="基本属性-1"><a href="#基本属性-1" class="headerlink" title="基本属性"></a>基本属性</h4><p><code>&lt;table&gt;</code> , 表示表格标签，表格是数据单元的行和列的两维表</p>
<ul>
<li>tr：table row，表示表中单元的行    </li>
<li>td：table data，表示表中一个单元格    </li>
<li>th：table header，表格单元格的表头，通常字体样式加粗居中</li>
<li><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE.png"></li>
</ul>
<p>代码展示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>First name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Last name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>John<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>Doe<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>Jane<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>Doe<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<table>
      <tr>
        <th>First name</th>
        <th>Last name</th>
      </tr>
      <tr>
        <td>John</td>
        <td>Doe</td>
      </tr>
      <tr>
        <td>Jane</td>
        <td>Doe</td>
      </tr>
</table>


<hr>
<h4 id="跨行跨列"><a href="#跨行跨列" class="headerlink" title="跨行跨列"></a>跨行跨列</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;400px&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1px&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>数学<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>语文<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>23<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>90<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;td&gt;90&lt;/td&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;td&gt;男&lt;/td&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>24<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>95<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>98<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;4&quot;</span>&gt;</span>总分数：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>373<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE%E8%B7%A8%E8%A1%8C%E8%B7%A8%E5%88%97%E6%95%88%E6%9E%9C%E5%9B%BE.png"></p>
<hr>
<h4 id="表格结构"><a href="#表格结构" class="headerlink" title="表格结构"></a>表格结构</h4><table>
<thead>
<tr>
<th>标签名</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>thead</td>
<td>定义表格的列头的行</td>
<td>一个表格中仅有一个</td>
</tr>
<tr>
<td>tbody</td>
<td>定义表格的主体</td>
<td>用来封装一组表行（tr元素）</td>
</tr>
<tr>
<td>tfoot</td>
<td>定义表格的各列汇总行</td>
<td>一个表格中仅有一个</td>
</tr>
</tbody></table>
<hr>
<h3 id="样式布局"><a href="#样式布局" class="headerlink" title="样式布局"></a>样式布局</h3><h4 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h4><p>在head标签中，通过style标签加入样式。</p>
<p>基本格式：可以含有多个属性，一个属性名也可以含有多个值，同时设置多样式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    标签名&#123;</span></span><br><span class="line"><span class="language-css">        属性名<span class="number">1</span>:属性值<span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">        属性名<span class="number">2</span>:属性值<span class="number">2</span>;</span></span><br><span class="line"><span class="language-css">        属性名:属性值<span class="number">1</span> 属性值<span class="number">2</span> 属性值<span class="number">3</span>; </span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="背景格式"><a href="#背景格式" class="headerlink" title="背景格式"></a>背景格式</h4><p>background属性用来设置背景相关的样式。</p>
<ul>
<li><p>背景色<br>[<code>background-color</code>]属性定义任何元素的背景色</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#567895</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>背景图<br>该[<code>background-image</code>]属性允许在元素的背景中显示图像。使用url函数指定图片路径</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>背景图片<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*添加背景图片*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;../img/bg.png&quot;</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML%E8%83%8C%E6%99%AF%E5%9B%BE.png"></p>
</li>
<li><p>背景重复</p>
<p>[<code>background-repeat</code>]属性用于控制图像的平铺行为。可用值：</p>
<ul>
<li><code>no-repeat</code> -停止完全重复背景</li>
<li><code>repeat-x</code> —水平重复</li>
<li><code>repeat-y</code> —竖直重复</li>
<li><code>repeat</code>—默认值；双向重复</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">star.png</span>);</span><br><span class="line">  <span class="attribute">background-repeat</span>: repeat-x;<span class="comment">/*水平重复*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML%E8%83%8C%E6%99%AF%E8%AE%BE%E8%AE%A1.png"></p>
</li>
</ul>
<hr>
<h4 id="div布局"><a href="#div布局" class="headerlink" title="div布局"></a>div布局</h4><ul>
<li><p>div简单布局：</p>
<ul>
<li>broader：边界</li>
<li>solid：实线</li>
<li>blue：颜色</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">     <span class="selector-tag">div</span>&#123; <span class="attribute">border</span>: <span class="number">1px</span> solid blue;&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> &gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> &gt;</span>center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML-div%E7%AE%80%E5%8D%95%E5%B8%83%E5%B1%80.png"></p>
</li>
<li><p>class值<br>可以设置宽度，浮动，背景</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.class值&#123;</span><br><span class="line">    属性名:属性值;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;标签名 class=&quot;class值&quot;&gt;  </span><br><span class="line"> 提示: class是自定义的值</span><br></pre></td></tr></table></figure>

<ul>
<li><p>属性</p>
<ul>
<li><p>background：背景颜色</p>
</li>
<li><p>width：宽度 (npx 或者 n%)</p>
</li>
<li><p>height：长度</p>
</li>
<li><p>text-align：文本对齐方式</p>
</li>
<li><p>background-image: url(“..&#x2F;img&#x2F;bg.png”)：背景图</p>
</li>
<li><p>float：浮动</p>
<p>指定一个元素应沿其容器的左侧或右侧放置，允许文本或者内联元素环绕它，该元素从网页的正常流动中移除，其他部分保持正常文档流顺序。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加入浮动 --&gt;</span></span><br><span class="line">float：none；不浮动</span><br><span class="line">float：left；左浮动</span><br><span class="line">float：right；右浮动</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 清除浮动 --&gt;</span></span><br><span class="line">clear：both；清除两侧浮动，此元素不再收浮动元素布局影响。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>div基本布局</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>样式演示<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/*给div标签添加边框*/</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/*左侧图片的div样式*/</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">20%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/*中间正文的div样式*/</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.center</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">59%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/*右侧广告图片的div样式*/</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">20%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/*底部超链接的div样式*/</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.footer</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*清除浮动效果*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*文本对齐方式*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/*背景颜色*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: blue;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--顶部登陆注册--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>top<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--导航条--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>navibar<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--左侧图片--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--中间正文--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--右侧广告图片--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--底部页脚超链接--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML-div%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80.png"></p>
</li>
</ul>
<hr>
<h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><p>为了更好的组织文档，HTML5规范中设计了几个语义元素，可以将特殊含义传达给浏览器。</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>名称</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>header</strong></td>
<td>标头元素</td>
<td>表示内容的介绍</td>
<td>块元素，文档中可以定义多个</td>
</tr>
<tr>
<td><strong>nav</strong></td>
<td>导航元素</td>
<td>表示导航链接</td>
<td>常见于网站的菜单，目录和索引等，可以嵌套在header中</td>
</tr>
<tr>
<td><strong>article</strong></td>
<td>文章元素</td>
<td>表示独立内容区域</td>
<td>标签定义的内容本身必须是有意义且必须独立于文档的其他部分</td>
</tr>
<tr>
<td><strong>footer</strong></td>
<td>页脚元素</td>
<td>表示页面的底部</td>
<td>块元素，文档中可以定义多个</td>
</tr>
</tbody></table>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%E7%BB%93%E6%9E%84%E5%9B%BE.jpg"></p>
<hr>
<h2 id="HTML拓展"><a href="#HTML拓展" class="headerlink" title="HTML拓展"></a>HTML拓展</h2><h3 id="音频标签"><a href="#音频标签" class="headerlink" title="音频标签"></a>音频标签</h3><p><code>&lt;audio&gt;</code>：用于播放声音，比如音乐或其他音频流，是 HTML 5 的新标签。</p>
<p>常用属性：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>取值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>src</td>
<td>URL</td>
<td>音频资源的路径</td>
</tr>
<tr>
<td>autoplay</td>
<td>autoplay</td>
<td>音频准备就绪后自动播放</td>
</tr>
<tr>
<td>controls</td>
<td>controls</td>
<td>显示控件，比如播放按钮。</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>表示循环播放</td>
</tr>
<tr>
<td>preload</td>
<td>preload</td>
<td>音频在页面加载时进行预加载。<br>如果使用 “autoplay”，则忽略该属性。</td>
</tr>
</tbody></table>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>HTML5媒体标签-音频audio</title>
</head>
<body>
    <audio src="media/horse.ogg" controls>
        你的浏览器不支持 audio 标签。
    </audio>
</body>
</html>


<hr>
<h3 id="视频标签"><a href="#视频标签" class="headerlink" title="视频标签"></a>视频标签</h3><p><code>&lt;video&gt;</code> 标签用于播放视频，比如电影片段或其他视频流，是 HTML 5 的新标签。</p>
<p>常用属性：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>取值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>src</td>
<td><em>URL</em></td>
<td>要播放的视频的 URL。</td>
</tr>
<tr>
<td>width</td>
<td></td>
<td>设置视频播放器的宽度。</td>
</tr>
<tr>
<td>height</td>
<td></td>
<td>设置视频播放器的高度。</td>
</tr>
<tr>
<td>autoplay</td>
<td>autoplay</td>
<td>视频在就绪后自动播放。</td>
</tr>
<tr>
<td>control</td>
<td>controls</td>
<td>显示控件，比如播放按钮。</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>如果出现该属性，则当媒介文件完成播放后再次开始播放。</td>
</tr>
<tr>
<td>preload</td>
<td>preload</td>
<td>视频在页面加载时进行加载。<br>如果使用 “autoplay”，则忽略该属性。</td>
</tr>
<tr>
<td>mute</td>
<td>muted</td>
<td>规定视频的音频输出应该被静音。</td>
</tr>
<tr>
<td>poste</td>
<td><em>URL</em></td>
<td>视频下载时显示的图像，或者视频播放前显示的图像。</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML5媒体标签-视频video<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;media/movie.ogg&quot;</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">        你的浏览器不支持 video 标签</span><br><span class="line">    <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML%E6%A0%87%E7%AD%BEvideo.png"></p>
<hr>
<h3 id="回到顶部"><a href="#回到顶部" class="headerlink" title="回到顶部"></a>回到顶部</h3><p>在html里面锚点的作用: 通过a标签跳转到指定的位置.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#aId&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<!DOCTYPE html>
<html lang="en">
    <a href="#aId">回到顶部</a>



<h3 id="详情概要"><a href="#详情概要" class="headerlink" title="详情概要"></a>详情概要</h3><p>summary标签来描述概要信息, 利用details标签来描述详情信息. 默认情况下是折叠展示, 想看见详情必须点击</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">summary</span>&gt;</span>概要信息<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">        详情信息</span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure>

<details>
    <summary>概要信息</summary>
    详情信息
</details>





<hr>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="CSS入门"><a href="#CSS入门" class="headerlink" title="CSS入门"></a>CSS入门</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>CSS (层叠样式表——Cascading Style Sheets，缩写为 <strong>CSS</strong>），简单的说，它是用于设置和布局网页的计算机语言。会告知浏览器如何渲染页面元素。例如，调整内容的字体，颜色，大小等样式，设置边框的样式，调整模块的间距等。</p>
<p>层叠：是指样式表允许以多种方式规定样式信息。可以规定在单个元素中，可以在页面头元素中，也可以在另一个CSS文件中，规定的方式会有次序的差别。</p>
<p>样式：是指丰富的样式外观。拿边框距离来说，允许任何设置边框，允许设置边框与框内元素的距离，允许设置边框与边框的距离等等。</p>
<hr>
<h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><p>CSS是一门基于规则的语言—你能定义用于你的网页中<strong>特定元素</strong>的一组<strong>样式规则</strong>。这里面提到了两个概念，一是特定元素，二是样式规则。对应CSS的语法，也就是<strong>选择器（<em>selects</em>）</strong>和<strong>声明（<em>eclarations</em>）</strong>。</p>
<ul>
<li>选择器：指定要添加样式的 HTML元素的方式。可以使用标签名，class值，id值等多种方式。</li>
<li>声明：形式为**属性(property):值(value)**，用于设置特定元素的属性信息。<ul>
<li>属性：指示文体特征，例如<code>font-size</code>，<code>width</code>，<code>background-color</code>。</li>
<li>值：每个指定的属性都有一个值，该值指示您如何更改这些样式。</li>
</ul>
</li>
</ul>
<p>格式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">    属性名:属性值;</span><br><span class="line">    属性名:属性值;</span><br><span class="line">    属性名:属性值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/CSS%E7%9A%84%E7%BB%84%E6%88%90.png"></p>
<hr>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>页面标题</title>
    <style>
        h1{
            font-size:40px; /* 设置字体大小为100像素*/
        }
    </style>
  </head>
  <body>
      <h1>今天开始学CSS</h1>
  </body>
</html>





<hr>
<h2 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h2><h3 id="注释方式-1"><a href="#注释方式-1" class="headerlink" title="注释方式"></a>注释方式</h3><p>CSS中的注释以<code>/*</code>和开头<code>*/</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置h1的样式 */</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h3><h4 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h4><p>内联样式是CSS声明在元素的<code>style</code>属性中，仅影响一个元素：</p>
<ul>
<li><p>格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;标签 style=&quot;属性名:属性值; 属性名:属性值;&quot;&gt;内容&lt;/标签&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;color: blue;background-color: yellow;border: 1px solid black;&quot;</span>&gt;</span></span><br><span class="line">    Hello World!</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>效果：</p>
<h1 style="color: blue;background-color: yellow;border: 1px solid black;">
    Hello World!
</h1>
</li>
<li><p>特点：格式简单，但是样式作用无法复用到多个元素上，不利于维护</p>
</li>
</ul>
<h4 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h4><p>内部样式表是将CSS样式放在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/style">style</a>标签中，通常style标签编写在HTML 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/head">head</a>标签内部。</p>
<ul>
<li><p>格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        选择器 &#123;</span></span><br><span class="line"><span class="language-css">            属性名: 属性值;</span></span><br><span class="line"><span class="language-css">            属性名: 属性值;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">     <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="language-css">       <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">       <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">       <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span><br><span class="line"><span class="language-css">     &#125;</span></span><br><span class="line"><span class="language-css">   </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>特点：内部样式只能作用在当前页面上，如果是多个页面，就无法复用了</p>
</li>
</ul>
<h4 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h4><p>外部样式表是CSS附加到文档中的最常见和最有用的方法，因为您可以将CSS文件链接到多个页面，从而允许您使用相同的样式表设置所有页面的样式。</p>
<p>外部样式表是指将CSS编写在扩展名为<code>.css</code> 的单独文件中，并从HTML<code>&lt;link&gt;</code> 元素引用它，通常link标签&#96;编写在HTML 的[head]标签内部。</p>
<ul>
<li><p>格式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css文件&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>rel：表示“关系 (relationship) ”，属性值指链接方式与包含它的文档之间的关系，引入css文件固定值为stylesheet。</li>
<li>href：属性需要引用某文件系统中的一个文件。</li>
</ul>
</li>
<li><p>举例</p>
<ul>
<li><p>创建styles.css文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">h1 &#123;</span><br><span class="line">  color: blue;</span><br><span class="line">  background-color: yellow;</span><br><span class="line">  border: 1px solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>link标签引入文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果同上</p>
</li>
</ul>
</li>
<li><p>为了CSS文件的管理，在项目中创建一个<code>css文件夹</code>，专门保存样式文件，并调整指定的路径以匹配</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../css/styles.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--..代表上一级 相对路径--&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>规则层叠于一个样式表中，其中数字 4 拥有最高的优先权：</p>
<ol>
<li>浏览器缺省设置</li>
<li>外部样式表</li>
<li>内部样式表（位于 <head> 标签内部）</head></li>
<li>内联样式（在 HTML 元素内部）</li>
</ol>
<hr>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="介绍选择器"><a href="#介绍选择器" class="headerlink" title="介绍选择器"></a>介绍选择器</h4><p>为了样式化某些元素，我们会通过选择器来选中HTML文档中的这些元素，每个CSS规则都以一个选择器或一组选择器为开始，去告诉浏览器这些规则应该应用到哪些元素上。</p>
<p>选择器的分类：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>名称</th>
<th>符号</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>基本选择器</td>
<td>元素选择器</td>
<td>标签名</td>
<td>基于标签名匹配元素</td>
<td>div{ }</td>
</tr>
<tr>
<td></td>
<td>类选择器</td>
<td><code>.</code></td>
<td>基于class属性值匹配元素</td>
<td>.center{ }</td>
</tr>
<tr>
<td></td>
<td>ID选择器</td>
<td><code>#</code></td>
<td>基于id属性值匹配元素</td>
<td>#username{ }</td>
</tr>
<tr>
<td></td>
<td>通用选择器</td>
<td><code>*</code></td>
<td>匹配文档中的所有内容</td>
<td>*{ }</td>
</tr>
<tr>
<td>属性选择器</td>
<td>属性选择器</td>
<td><code>[]</code></td>
<td>基于某属性匹配元素</td>
<td>[type]{ }</td>
</tr>
<tr>
<td>伪类选择器</td>
<td>伪类选择器</td>
<td><code>:</code></td>
<td>用于向某些选择器添加特殊的效果</td>
<td>a:hover{ }</td>
</tr>
<tr>
<td>组合选择器</td>
<td>分组选择器</td>
<td>,</td>
<td>使用 , 号结合两个选择器，匹配两个选择器的元素</td>
<td>span,p{}</td>
</tr>
<tr>
<td></td>
<td>后代选择器</td>
<td>空格</td>
<td>使用空格符号结合两个选择器，基于<br>第一个选择器，匹配第二个选择器的所有后代元素</td>
<td>.top li{ }</td>
</tr>
</tbody></table>
<h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h4><ul>
<li><p>页面元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>div3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d1&quot;</span>&gt;</span>div4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d2&quot;</span>&gt;</span>div5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>元素选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*选择所有div标签,字体为蓝色*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	 <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*选择class为cls的,字体为蓝色*/</span></span><br><span class="line"><span class="selector-class">.cls</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ID选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*id选择器*/</span></span><br><span class="line"><span class="selector-id">#d1</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: green;<span class="comment">/*id为d1的字体变成绿色*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#d2</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: pink;<span class="comment">/*id为d2的字体变成粉色*/</span></span><br><span class="line">&#125;/</span><br></pre></td></tr></table></figure>
</li>
<li><p>通用选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*所有标签 */</span></span><br><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: aqua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><ul>
<li><p>页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>选择器：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*输入框中输入的字符是红色*/</span></span><br><span class="line"><span class="selector-attr">[type]</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输入框中输入的字符是蓝色*/</span></span><br><span class="line"><span class="selector-attr">[type=password]</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><ul>
<li><p>页面元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>伪类选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*未访问的状态*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*已访问的状态*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*鼠标悬浮的状态*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*已选中的状态*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：伪类顺序 link ，visited，hover，active，否则有可能失效。</p>
</li>
</ul>
<hr>
<h4 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h4><ul>
<li><p>页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;top&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>aa<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>bb<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>cc<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>dd<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分组选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*span p两个标签下的字体为蓝色*/</span></span><br><span class="line"><span class="selector-tag">span</span>,<span class="selector-tag">p</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后代选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*class为top下的所有li标签字体颜色为红色*/</span></span><br><span class="line"><span class="selector-class">.top</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="优先级-1"><a href="#优先级-1" class="headerlink" title="优先级"></a>优先级</h4><p>选择器优先级</p>
<ul>
<li>ID选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通用选择器</li>
<li>如果优先级相同，那么就满足就近原则</li>
</ul>
<hr>
<h3 id="边框样式"><a href="#边框样式" class="headerlink" title="边框样式"></a>边框样式</h3><h4 id="单个边框"><a href="#单个边框" class="headerlink" title="单个边框"></a>单个边框</h4><ul>
<li><p>单个边框<br>border：边框<br>border-top: 上边框<br>border-left: 左边框<br>border-bottom: 底边框<br>border-right:  右边框</p>
</li>
<li><p>无边框，当border值为none时，可以让边框不显示</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>圆角</p>
<p>通过使用[<code>border-radius</code>]属性设置盒子的圆角，虽然能分别设置四个角，但是通常我们使用一个值，来设置整体效果</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#d1</span>&#123;</span><br><span class="line">    <span class="comment">/*设置所有边框*/</span></span><br><span class="line">    <span class="comment">/*border: 5px solid black;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置上边框*/</span></span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">5px</span> solid black;</span><br><span class="line">    <span class="comment">/*设置左边框*/</span></span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">5px</span> double red;</span><br><span class="line">    <span class="comment">/*设置右边框*/</span></span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">5px</span> dotted blue;</span><br><span class="line">    <span class="comment">/*设置下边框*/</span></span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">5px</span> dashed pink;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#d2</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid red;</span><br><span class="line">    <span class="comment">/*设置边框的弧度*/</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/CSS-边框样式效果图.png" style="zoom:80%;">



<hr>
<h4 id="边框轮廓"><a href="#边框轮廓" class="headerlink" title="边框轮廓"></a>边框轮廓</h4><p>轮廓<strong>outline</strong>：是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用</p>
<ul>
<li>属性值：double：双实线   dotted：圆点   dashed：虚线   none：无</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>样式演示<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">input</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">outline</span>: dotted;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/CSS%E8%BE%B9%E6%A1%86%E8%BD%AE%E5%BB%93%E6%95%88%E6%9E%9C%E5%9B%BE.png"></p>
<hr>
<h4 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h4><h5 id="模型介绍"><a href="#模型介绍" class="headerlink" title="模型介绍"></a>模型介绍</h5><p>盒子模型是通过设置<strong>元素框</strong>与<strong>元素内容</strong>和<strong>外部元素</strong>的边距，而进行布局的方式。</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.png"></p>
<ul>
<li>element : 元素。</li>
<li>padding : 内边距，也有资料将其翻译为填充。</li>
<li>border : 边框。</li>
<li>margin : 外边距，也有资料将其翻译为空白或空白边。</li>
</ul>
<h5 id="边距"><a href="#边距" class="headerlink" title="边距"></a>边距</h5><p>内边距、边框和外边距都是可选的，默认值是零。在 CSS 中，width 和 height 指的是内容区域的宽度和高度。</p>
<ul>
<li><p>外边距<br>单独设置边框的外边距，设置上、右、下、左方向：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin-top</span></span><br><span class="line"><span class="attribute">margin-right</span></span><br><span class="line"><span class="attribute">margin-bottom</span></span><br><span class="line"><span class="attribute">margin-left</span></span><br></pre></td></tr></table></figure>

<ul>
<li><pre><code class="css">margin:  auto /*浏览器自动计算外边距，具有居中效果。*/
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 一个值</span><br><span class="line"></span><br><span class="line">  ```css</span><br><span class="line">  /*  所有 4 个外边距都是 10px */</span><br><span class="line">  margin:10px;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>两个值</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin</span>:<span class="number">10px</span> <span class="number">5px</span>;<span class="comment">/* 上外边距和下外边距是 10px*/</span></span><br><span class="line"><span class="attribute">margin</span>:<span class="number">10px</span> auto;<span class="comment">/*右外边距和左外边距是 5px */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>三个值</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 上外边距是 10px，右外边距和左外边距是 5px，下外边距是 15px*/</span></span><br><span class="line"><span class="attribute">margin</span>:<span class="number">10px</span> <span class="number">5px</span> <span class="number">15px</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>四个值</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*上外边距是 10px，右外边距是 5px，下外边距是 15px，左外边距是 20px*/</span></span><br><span class="line"><span class="comment">/*上右下外*/</span></span><br><span class="line"><span class="attribute">margin</span>:<span class="number">10px</span> <span class="number">5px</span> <span class="number">15px</span> <span class="number">20px</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>内边距<br>与外边距类似，单独设置边框的内边距，设置上、右、下、左方向：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">padding-top</span></span><br><span class="line"><span class="attribute">padding-right</span></span><br><span class="line"><span class="attribute">padding-bottom</span></span><br><span class="line"><span class="attribute">padding-left</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h5><ul>
<li><p>基本布局</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">       <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">border</span>: <span class="number">2px</span> solid blue;</span></span><br><span class="line"><span class="language-css">       &#125;</span></span><br><span class="line"><span class="language-css">       <span class="selector-class">.big</span>&#123;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">       &#125;</span></span><br><span class="line"><span class="language-css">       <span class="selector-class">.small</span>&#123;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">           <span class="attribute">margin</span>: <span class="number">30px</span>;<span class="comment">/*  外边距 */</span></span></span><br><span class="line"><span class="language-css">       &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;big&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;small&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&lt;/div</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%BC%8F-%E6%95%88%E6%9E%9C%E5%9B%BE1.png"></p>
</li>
<li><p>增加内边距会增加元素框的总尺寸</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> &lt;style&gt;</span><br><span class="line">	<span class="selector-tag">div</span>&#123;</span><br><span class="line">    	<span class="attribute">border</span>: <span class="number">2px</span> solid blue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="selector-class">.big</span>&#123;</span><br><span class="line">    	<span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    	<span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    	<span class="attribute">padding</span>: <span class="number">30px</span>;<span class="comment">/*内边距 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="selector-class">.small</span>&#123;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    	<span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%BC%8F-%E6%95%88%E6%9E%9C%E5%9B%BE2.png"></p>
</li>
</ul>
<hr>
<h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><h4 id="基本属性-2"><a href="#基本属性-2" class="headerlink" title="基本属性"></a>基本属性</h4><table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
<th>属性取值</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>宽度</td>
<td></td>
</tr>
<tr>
<td>height</td>
<td>高度</td>
<td></td>
</tr>
<tr>
<td>color</td>
<td>颜色</td>
<td></td>
</tr>
<tr>
<td>font-family</td>
<td>字体样式</td>
<td>宋体、楷体</td>
</tr>
<tr>
<td>font-size</td>
<td>字体大小</td>
<td>px : 像素，文本高度像素绝对数值。<br>em : 1em等于当前元素的父元素设置的字体大小，是相对数值</td>
</tr>
<tr>
<td>text-decoration</td>
<td>下划线</td>
<td>underline : 下划线  <br>overline : 上划线 <br>line-through : 删除线 <br>none : 不要线条</td>
</tr>
<tr>
<td>text-align</td>
<td>文本水平对齐</td>
<td>lef : 左对齐文本<br>right : 右对齐文本<br>center : 使文本居中 <br>justify : 使文本散布，改变单词间的间距，使文本所有行具有相同宽度。</td>
</tr>
<tr>
<td>line-height</td>
<td>行高，行间距</td>
<td></td>
</tr>
<tr>
<td>vertical-align</td>
<td>文本垂直对齐</td>
<td>top：居上   bottom：居下  middle：居中   或者百分比</td>
</tr>
<tr>
<td>display</td>
<td>元素如何显示</td>
<td>可以设置块级和行内元素的切换，也可以设置元素隐藏<br>inline：内联元素(无换行、无长宽)   <br>block：块级元素(有换行)  <br>inline-block：内联元素(有长宽)  <br>none：隐藏元素</td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="comment">/*red*/</span> <span class="number">#ff0000</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="comment">/*宋体*/</span> 微软雅黑;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;/</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="comment">/*文字垂直对齐  top：居上   bottom：居下  middle：居中   百分比*/</span></span><br><span class="line">    <span class="attribute">vertical-align</span>: <span class="number">50%</span>;     <span class="comment">/*居中对齐*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    我是文字</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    我是文字</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../img/wx.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;38px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;38px&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>微信<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/CSS-%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F%E6%95%88%E6%9E%9C%E5%9B%BE.png"></p>
<hr>
<h4 id="文本显示"><a href="#文本显示" class="headerlink" title="文本显示"></a>文本显示</h4><ul>
<li><p>元素显示</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*   把列表项显示为内联元素，无长宽*/</span></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:inline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*   把span元素作为块元素，有换行*/</span></span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*   行内块元素，结合的行内和块级的优点，既可以行内显示，又可以设置长宽，*/</span></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*所有div在一行显示*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>元素隐藏</p>
<p>当设置为none时，可以隐藏元素。</p>
</li>
</ul>
<hr>
<h2 id="CSS案例"><a href="#CSS案例" class="headerlink" title="CSS案例"></a>CSS案例</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*背景图片*/</span></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;../img/bg.png&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中间表单样式*/</span></span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: white;      <span class="comment">/*背景色*/</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">40%</span>;             <span class="comment">/*宽度*/</span></span><br><span class="line">    <span class="attribute">margin</span>: auto;           <span class="comment">/*水平居中外边距*/</span></span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">100px</span>;      <span class="comment">/*上外边距*/</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">15px</span>;    <span class="comment">/*边框弧度*/</span></span><br><span class="line">    <span class="attribute">text-align</span>: center;     <span class="comment">/*文本水平居中*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*表头样式*/</span></span><br><span class="line"><span class="selector-tag">thead</span> <span class="selector-tag">th</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;    <span class="comment">/*字体大小*/</span></span><br><span class="line">    <span class="attribute">color</span>: orangered;   <span class="comment">/*字体颜色*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*表体提示信息样式*/</span></span><br><span class="line"><span class="selector-tag">tbody</span> <span class="selector-tag">label</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;    <span class="comment">/*字体大小*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*表体输入框样式*/</span></span><br><span class="line"><span class="selector-tag">tbody</span> <span class="selector-tag">input</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid gray; <span class="comment">/*边框*/</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;     <span class="comment">/*边框弧度*/</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">90%</span>;             <span class="comment">/*输入框的宽度*/</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;           <span class="comment">/*输入框的高度*/</span></span><br><span class="line">    <span class="attribute">outline</span>: none;          <span class="comment">/*取消轮廓的样式*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*表底确定按钮样式*/</span></span><br><span class="line"><span class="selector-tag">tfoot</span> <span class="selector-tag">button</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid crimson;  <span class="comment">/*边框*/</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;         <span class="comment">/*边框弧度*/</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">95%</span>;                 <span class="comment">/*宽度*/</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;               <span class="comment">/*高度*/</span></span><br><span class="line">    <span class="attribute">background</span>: crimson;        <span class="comment">/*背景色*/</span></span><br><span class="line">    <span class="attribute">color</span>: white;               <span class="comment">/*文字的颜色*/</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;            <span class="comment">/*字体大小*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*表行高度*/</span></span><br><span class="line"><span class="selector-tag">tr</span>&#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">60px</span>;  <span class="comment">/*行高*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*底部页脚样式*/</span></span><br><span class="line"><span class="selector-class">.footer</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">35%</span>; <span class="comment">/*宽度*/</span></span><br><span class="line">    <span class="attribute">margin</span>: auto;   <span class="comment">/*水平居中外边距*/</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;    <span class="comment">/*字体大小*/</span></span><br><span class="line">    <span class="attribute">color</span>: gray;    <span class="comment">/*字体颜色*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*超链接样式*/</span></span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;  <span class="comment">/*去除超链接的下划线*/</span></span><br><span class="line">    <span class="attribute">color</span>: blue;            <span class="comment">/*超链接颜色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../css/login.css&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--顶部公司图标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../img/logo.png&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--中间表单--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>账<span class="symbol">&amp;nbsp;</span>密<span class="symbol">&amp;nbsp;</span>登<span class="symbol">&amp;nbsp;</span>录<span class="tag">&lt;<span class="name">hr</span>/&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>账号<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot; 请输入账号&quot;</span> <span class="attr">required</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot; 请输入密码&quot;</span> <span class="attr">required</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>确<span class="symbol">&amp;nbsp;</span>定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--底部页脚--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        登录/注册即表示您同意<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>用户协议<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span></span><br><span class="line">        和<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>隐私条款<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>忘记密码?<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/CSS%E6%A1%88%E4%BE%8B%E7%99%BB%E9%99%86%E9%A1%B5%E9%9D%A2.png"></p>
<hr>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>HTTP：Hyper Text Transfer Protocol，意为超文本传输协议，是建立在 <strong>TCP&#x2F;IP 协议</strong>基础上，指的是服务器和客户端之间交互必须遵循的一问一答的规则，形容这个规则：问答机制、握手机制</p>
<p>HTTP 协议是<strong>一个无状态的面向连接的协议</strong>，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。所以打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系</p>
<p>注意：无状态并不是代表 HTTP 就是 UDP，面向连接也不是代表 HTTP 就是TCP</p>
<p>HTTP 作用：用于定义 WEB 浏览器与 WEB 服务器之间交换数据的过程和数据本身的内容</p>
<p>浏览器和服务器交互过程：浏览器请求，服务请求响应</p>
<ul>
<li>请求（请求行、请求头、请求体）</li>
<li>响应（响应行、响应头、响应体）</li>
</ul>
<p>URL 和 URI</p>
<ul>
<li><p>URL：统一资源定位符</p>
<ul>
<li>格式：<a href="http://127.0.0.1:8080/request/servletDemo01">http://127.0.0.1:8080/request/servletDemo01</a></li>
<li>详解：http：协议；127.0.0.1：域名；8080：端口；request&#x2F;servletDemo01：请求资源路径</li>
</ul>
</li>
<li><p>URI：统一资源标志符</p>
<ul>
<li>格式：&#x2F;request&#x2F;servletDemo01</li>
</ul>
</li>
<li><p>区别：<code>URL - HOST = URI</code>，URI 是抽象的定义，URL 用地址定位，URI 用名称定位。<strong>只要能唯一标识资源的是 URI，在 URI 的基础上给出其资源的访问方式的是 URL</strong></p>
</li>
</ul>
<p><strong>从浏览器地址栏输入 URL 到请求返回发生了什么？</strong></p>
<ul>
<li><p>进行 URL 解析，进行编码</p>
</li>
<li><p>DNS 解析，顺序是先查 hosts 文件是否有记录，有的话就会把相对应映射的 IP 返回，然后去本地 DNS 缓存中寻找，然后依次向本地域名服务器、根域名服务器、顶级域名服务器、权限域名服务器发起查询请求，最终返回 IP 地址给本地域名服务器</p>
<p>本地域名服务器将得到的 IP 地址返回给操作系统，同时将 IP 地址缓存起来；操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</p>
</li>
<li><p>查找到 IP 之后，进行 TCP 协议的三次握手建立连接</p>
</li>
<li><p>发出 HTTP 请求，取文件指令</p>
</li>
<li><p>服务器处理请求，返回响应</p>
</li>
<li><p>释放 TCP 连接</p>
</li>
<li><p>浏览器解析渲染页面</p>
</li>
</ul>
<p>推荐阅读：<a href="https://xiaolincoding.com/network/">https://xiaolincoding.com/network/</a></p>
<hr>
<h2 id="版本区别"><a href="#版本区别" class="headerlink" title="版本区别"></a>版本区别</h2><p>版本介绍：</p>
<ul>
<li>HTTP&#x2F;0.9 仅支持 GET 请求，不支持请求头</li>
<li>HTTP&#x2F;1.0 默认短连接（一次请求建议一次 TCP 连接，请求完就断开），支持 GET、POST、 HEAD 请求</li>
<li>HTTP&#x2F;1.1 默认长连接（一次 TCP 连接可以多次请求）；支持 PUT、DELETE、PATCH 等六种请求；增加 HOST 头，支持虚拟主机；支持<strong>断点续传</strong>功能</li>
<li>HTTP&#x2F;2.0 多路复用，降低开销（一次 TCP 连接可以处理多个请求）；服务器主动推送（相关资源一个请求全部推送）；解析基于二进制，解析错误少，更高效（HTTP&#x2F;1.X 解析基于文本）；报头压缩，降低开销</li>
<li>HTTP&#x2F;3.0 QUIC (Quick UDP Internet Connections)，快速 UDP 互联网连接，基于 UDP 协议</li>
</ul>
<p>HTTP 1.0 和 HTTP 1.1 的主要区别：</p>
<ul>
<li><p>长短连接：</p>
<p><strong>在HTTP&#x2F;1.0中，默认使用的是短连接</strong>，每次请求都要重新建立一次连接，比如获取 HTML 和 CSS 文件，需要两次请求。HTTP 基于 TCP&#x2F;IP 协议的，每一次建立或者断开连接都需要三次握手四次挥手，开销会比较大</p>
<p><strong>HTTP 1.1起，默认使用长连接</strong> ，默认开启 <code>Connection: keep-alive</code>，Keep-Alive 有一个保持时间，不会永久保持连接。持续连接有非流水线方式和流水线方式 ，流水线方式是客户端在收到 HTTP 的响应报文之前就能接着发送新的请求报文，非流水线方式是客户端在收到前一个响应后才能发送下一个请求</p>
<p>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接</p>
</li>
<li><p>错误状态响应码：在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突，410（Gone）表示服务器上的某个资源被永久性的删除</p>
</li>
<li><p>缓存处理：在 HTTP1.0 中主要使用 header 里的 If-Modified-Since，Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略，例如 Entity tag，If-Unmodified-Since，If-Match，If-None-Match等</p>
</li>
<li><p>带宽优化及网络连接的使用：HTTP1.0 存在一些浪费带宽的现象，例如客户端只需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持<strong>断点续传</strong>功能，HTTP1.1 则在请求头引入了 range 头域，允许只<strong>请求资源的某个部分</strong>，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接</p>
</li>
<li><p>HOST 头处理：在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此请求消息中的 URL 并没有传递主机名。HTTP1.1 时代虚拟主机技术发展迅速，在一台物理服务器上可以存在多个虚拟主机，并且共享一个 IP 地址，故 HTTP1.1 增加了 HOST 信息</p>
</li>
</ul>
<p>HTTP 1.1 和 HTTP 2.0 的主要区别：</p>
<ul>
<li>新的二进制格式：HTTP1.1 基于文本格式传输数据，HTTP2.0 采用二进制格式传输数据，解析更高效</li>
<li><strong>多路复用</strong>：在一个连接里，允许同时发送多个请求或响应，并且这些请求或响应能够并行的传输而不被阻塞，避免 HTTP1.1 出现的队头堵塞问题</li>
<li>头部压缩，HTTP1.1 的 header 带有大量信息，而且每次都要重复发送；HTTP2.0 把 header 从数据中分离，并封装成头帧和数据帧，使用特定算法压缩头帧。并且 HTTP2.0 在客户端和服务器端记录了之前发送的键值对，对于相同的数据不会重复发送。比如请求 A 发送了所有的头信息字段，请求 B 则只需要发送差异数据，这样可以减少冗余数据，降低开销</li>
<li><strong>服务端推送</strong>：HTTP2.0 允许服务器向客户端推送资源，无需客户端发送请求到服务器获取</li>
</ul>
<hr>
<h2 id="安全请求"><a href="#安全请求" class="headerlink" title="安全请求"></a>安全请求</h2><p>HTTP 和 HTTPS 的区别：</p>
<ul>
<li>端口 ：HTTP 默认使用端口 80，HTTPS 默认使用端口 443</li>
<li>安全性：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份；HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上，所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密</li>
<li>资源消耗：HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源</li>
</ul>
<p><strong>对称加密和非对称加密</strong></p>
<ul>
<li><p>对称加密：加密和解密使用同一个秘钥，把密钥转发给需要发送数据的客户机，中途会被拦截（类似于把带锁的箱子和钥匙给别人，对方打开箱子放入数据，上锁后发送），私钥用来解密数据，典型的对称加密算法有 DES、AES 等</p>
<ul>
<li>优点：运算速度快</li>
<li>缺点：无法安全的将密钥传输给通信方</li>
</ul>
</li>
<li><p>非对称加密：加密和解密使用不同的秘钥，一把作为公开的公钥，另一把作为私钥，<strong>公钥公开给任何人</strong>（类似于把锁和箱子给别人，对方打开箱子放入数据，上锁后发送），典型的非对称加密算法有 RSA、DSA 等</p>
<ul>
<li>公钥加密，私钥解密：为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容</li>
<li>私钥加密，公钥解密：为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的</li>
<li>可以更安全地将公开密钥传输给通信发送方，但是运算速度慢</li>
</ul>
</li>
<li><p><strong>使用对称加密和非对称加密的方式传送数据</strong></p>
<ul>
<li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性</li>
<li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率</li>
</ul>
<p>思想：锁上加锁</p>
</li>
</ul>
<p>名词解释：</p>
<ul>
<li><p>哈希算法：通过哈希函数计算出内容的哈希值，传输到对端后会重新计算内容的哈希，进行哈希比对来校验内容的完整性</p>
</li>
<li><p>数字签名：附加在报文上的特殊加密校验码，可以防止报文被篡改。一般是通过私钥对内容的哈希值进行加密，公钥正常解密并对比哈希值后，可以确保该内容就是对端发出的，防止出现中间人替换的问题</p>
</li>
<li><p>数字证书：由权威机构给某网站颁发的一种认可凭证</p>
</li>
</ul>
<p>HTTPS 工作流程：服务器端的公钥和私钥，用来进行非对称加密，客户端生成的随机密钥，用来进行对称加密</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTTP-HTTPS%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B.png"></p>
<ol>
<li>客户端向服务器发起 HTTPS 请求，连接到服务器的 443 端口，请求携带了浏览器支持的加密算法和哈希算法，协商加密算法</li>
<li>服务器端会向数字证书认证机构注册公开密钥，认证机构<strong>用 CA 私钥</strong>对公开密钥做数字签名后绑定在数字证书（又叫公钥证书，内容有公钥，网站地址，证书颁发机构，失效日期等）</li>
<li>服务器将数字证书发送给客户端，私钥由服务器持有</li>
<li>客户端收到服务器端的数字证书后<strong>通过 CA 公钥</strong>（事先置入浏览器或操作系统）对证书进行检查，验证其合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，将该密钥称之为 client key（客户端密钥、会话密钥）。用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文，HTTPS 中的第一次 HTTP 请求结束</li>
<li>客户端会发起 HTTPS 中的第二个 HTTP 请求，将加密之后的客户端密钥发送给服务器</li>
<li>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文</li>
<li>服务器将加密后的密文发送给客户端</li>
<li>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据，这样 HTTPS 中的第二个 HTTP 请求结束，整个 HTTPS 传输完成</li>
</ol>
<p>参考文章：<a href="https://www.cnblogs.com/linianhui/p/security-https-workflow.html">https://www.cnblogs.com/linianhui/p/security-https-workflow.html</a></p>
<p>参考文章：<a href="https://www.jianshu.com/p/14cd2c9d2cd2">https://www.jianshu.com/p/14cd2c9d2cd2</a></p>
<hr>
<h2 id="请求部分"><a href="#请求部分" class="headerlink" title="请求部分"></a>请求部分</h2><p>请求行： 永远位于请求的第一行</p>
<p>请求头： 从第二行开始，到第一个空行结束</p>
<p>请求体： 从第一个空行后开始，到正文的结束（GET 没有）</p>
<ul>
<li><p>请求方式</p>
<ul>
<li>POST</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTTP%E8%AF%B7%E6%B1%82%E9%83%A8%E5%88%86.png"></p>
<ul>
<li><p>GET</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">【请求行】</span><br><span class="line">GET /myApp/success.html?username=zs&amp;password=123456 HTTP/1.1</span><br><span class="line"></span><br><span class="line">【请求头】</span><br><span class="line">Accept: text/html, application/xhtml+xml, */*; X-HttpWatch-RID: 41723-10011</span><br><span class="line">Referer: http://localhost:8080/myApp/login.html</span><br><span class="line">Accept-Language: zh-Hans-CN,zh-Hans;q=0.5</span><br><span class="line">User-Agent: Mozilla/5.0 (MSIE 9.0; qdesk 2.4.1266.203; Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Cookie: Idea-b77ddca6=4bc282fe-febf-4fd1-b6c9-72e9e0f381e8</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>GET 和 POST 比较</strong></p>
<p>作用：GET 用于获取资源，而 POST 用于传输实体主体</p>
<p>参数：GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中（GET 也有请求体，POST 也可以通过 URL 传输参数）。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看</p>
<p>安全：安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。GET 方法是安全的，而 POST 不是，因为 POST 的目的是传送实体主体内容</p>
<ul>
<li>安全的方法除了 GET 之外还有：HEAD、OPTIONS</li>
<li>不安全的方法除了 POST 之外还有 PUT、DELETE</li>
</ul>
<p>幂等性：同样的请求<strong>被执行一次与连续执行多次的效果是一样的</strong>，服务器的状态也是一样的，所有的安全方法也都是幂等的。在正确实现条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，POST 方法不是</p>
<p>可缓存：如果要对响应进行缓存，需要满足以下条件</p>
<ul>
<li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存</li>
<li>响应报文的状态码是可缓存的，包括：200、203、204、206、300、301、404、405、410、414 and 501</li>
<li>响应报文的 Cache-Control 首部字段没有指定不进行缓存</li>
</ul>
</li>
<li><p>PUT 和 POST 的区别</p>
<p>PUT 请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉（幂等），所以 PUT 用来修改资源</p>
<p>POST 请求：后一个请求不会把第一个请求覆盖掉（非幂等），所以 POST 用来创建资源</p>
<p>PATCH 方法 是新引入的，是对 PUT 方法的补充，用来对已知资源进行<strong>局部更新</strong></p>
</li>
</ul>
</li>
<li><p>请求行详解</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">GET  /myApp/success.html?username=zs&amp;password=123456 HTTP/1.1	</span><br><span class="line">POST /myApp/success.html HTTP/1.1</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GET&#x2F;POST</td>
<td>请求的方式。</td>
</tr>
<tr>
<td>&#x2F;myApp&#x2F;success.html</td>
<td>请求的资源。</td>
</tr>
<tr>
<td>HTTP&#x2F;1.1</td>
<td>使用的协议，及协议的版本。</td>
</tr>
</tbody></table>
</li>
<li><p>请求头详解</p>
<p>从第 2 行到空行处，都叫请求头，以键值对的形式存在，但存在一个 key 对应多个值的请求头</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>告知服务器，客户浏览器支持的 MIME 类型</td>
</tr>
<tr>
<td>User-Agent</td>
<td>浏览器相关信息</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>告诉服务器，客户浏览器支持哪种字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>告知服务器，客户浏览器支持的压缩编码格式，常用 gzip 压缩</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>告知服务器，客户浏览器支持的语言，zh_CN 或 en_US 等</td>
</tr>
<tr>
<td>Host</td>
<td>初始 URL 中的主机和端口</td>
</tr>
<tr>
<td>Referer</td>
<td>告知服务器，当前请求的来源。只有当前请求有来源，才有这个消息头。<br>作用：1 投放广告  2 防盗链</td>
</tr>
<tr>
<td>Content-Type</td>
<td>告知服务器，请求正文的 MIME 类型，文件传输的类型，<br>application&#x2F;x-www-form-urlencoded</td>
</tr>
<tr>
<td>Content-Length</td>
<td>告知服务器，请求正文的长度。</td>
</tr>
<tr>
<td>Connection</td>
<td>表示是否需要持久连接，一般是 <code>Keep -Alive</code>（HTTP 1.1 默认进行持久连接 )</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>告知服务器，客户浏览器缓存文件的最后修改时间</td>
</tr>
<tr>
<td>Cookie</td>
<td>会话管理相关（非常的重要）</td>
</tr>
</tbody></table>
</li>
<li><p>请求体详解</p>
<ul>
<li><p>只有 POST 请求方式，才有请求的正文，GET 方式的正文是在地址栏中的</p>
</li>
<li><p>表单的输入域有 name 属性的才会被提交，不分 GET 和 POST 的请求方式</p>
</li>
<li><p>表单的 enctype 属性取值决定了请求正文的体现形式</p>
<table>
<thead>
<tr>
<th>enctype取值</th>
<th>请求正文体现形式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>application&#x2F;x-www-form-urlencoded</td>
<td>key&#x3D;value&amp;key&#x3D;value</td>
<td>username&#x3D;test&amp;password&#x3D;1234</td>
</tr>
<tr>
<td>multipart&#x2F;form-data</td>
<td>此时变成了多部分表单数据。多部分是靠分隔符分隔的。</td>
<td>—————————–7df23a16c0210<br>Content-Disposition: form-data; name&#x3D;”username”<br>test<br>—————————–7df23a16c0210<br>Content-Disposition: form-data; name&#x3D;”password”<br>1234<br>——————————-7df23a16c0210</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="响应部分"><a href="#响应部分" class="headerlink" title="响应部分"></a>响应部分</h2><p>响应部分图：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTTP%E5%93%8D%E5%BA%94%E9%83%A8%E5%88%86.png"></p>
<ul>
<li><p>响应行</p>
<p>HTTP&#x2F;1.1：使用协议的版本</p>
<p>200：响应状态码</p>
<p>OK：状态码描述</p>
<ul>
<li><p>响应状态码：<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTTP%E7%8A%B6%E6%80%81%E5%93%8D%E5%BA%94%E7%A0%81.png"></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>一切都 OK，与服务器连接成功，发送请求成功</td>
</tr>
<tr>
<td>302&#x2F;307</td>
<td>请求重定向（客户端行为，两次请求，地址栏发生改变）</td>
</tr>
<tr>
<td>304</td>
<td>请求资源未改变，使用缓存</td>
</tr>
<tr>
<td>400</td>
<td>客户端错误，请求错误，最常见的就是请求参数有问题</td>
</tr>
<tr>
<td>403</td>
<td>客户端错误，但 forbidden 权限不够，拒绝处理</td>
</tr>
<tr>
<td>404</td>
<td>客户端错误，请求资源未找到</td>
</tr>
<tr>
<td>500</td>
<td>服务器错误，服务器运行内部错误</td>
</tr>
</tbody></table>
</li>
</ul>
<p>转移：</p>
<ul>
<li>301 redirect：301 代表永久性转移 (Permanently Moved)</li>
<li>302 redirect：302 代表暂时性转移 (Temporarily Moved )</li>
</ul>
</li>
<li><p>响应头：以 key:vaue 存在，可能多个 value 情况</p>
<table>
<thead>
<tr>
<th>消息头</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Location</td>
<td>请求重定向的地址，常与 302，307 配合使用。</td>
</tr>
<tr>
<td>Server</td>
<td>服务器相关信息</td>
</tr>
<tr>
<td>Content-Type</td>
<td>告知客户浏览器，响应正文的MIME类型</td>
</tr>
<tr>
<td>Content-Length</td>
<td>告知客户浏览器，响应正文的长度</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>告知客户浏览器，响应正文使用的压缩编码格式，常用的 gzip 压缩</td>
</tr>
<tr>
<td>Content-Language</td>
<td>告知客户浏览器，响应正文的语言，zh_CN 或 en_US 等</td>
</tr>
<tr>
<td>Content-Disposition</td>
<td>告知客户浏览器，以下载的方式打开响应正文</td>
</tr>
<tr>
<td>Refresh</td>
<td>客户端的刷新频率，单位是秒</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>服务器资源的最后修改时间</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>服务器端发送的 Cookie，会话管理相关</td>
</tr>
<tr>
<td>Expires:-1</td>
<td>服务器资源到客户浏览器后的缓存时间</td>
</tr>
<tr>
<td>Catch-Control: no-catch</td>
<td>不要缓存，&#x2F;&#x2F;针对http协议1.1版本</td>
</tr>
<tr>
<td>Pragma:no-catch</td>
<td>不要缓存，&#x2F;&#x2F;针对http协议1.0版本</td>
</tr>
</tbody></table>
</li>
<li><p>响应体：页面展示内容, 类似网页的源码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css.css&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;demo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1.jpg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="JavaEE"><a href="#JavaEE" class="headerlink" title="JavaEE"></a>JavaEE</h2><h3 id="JavaEE规范"><a href="#JavaEE规范" class="headerlink" title="JavaEE规范"></a>JavaEE规范</h3><p><code>JavaEE</code> 规范是 <code>J2EE</code> 规范的新名称，早期被称为 <code>J2EE</code> 规范，其全称是 <code>Java 2 Platform Enterprise Edition</code>，它是由 SUN 公司领导、各厂家共同制定并得到广泛认可的工业标准（<code>JCP</code>组织成员）。之所以改名为<code>JavaEE</code>，目的还是让大家清楚 <code>J2EE</code> 只是 <code>Java</code> 企业应用。在 2004 年底中国软件技术大会 <code>Ioc</code> 微容器（也就是 <code>Jdon</code> 框架的实现原理）演讲中指出：我们需要一个跨 <code>J2SE/WEB/EJB</code> 的微容器，保护我们的业务核心组件，以延续它的生命力，而不是依赖 <code>J2SE/J2EE</code> 版本。此次 <code>J2EE</code> 改名为 <code>Java EE</code>，实际也反映出业界这种共同心声</p>
<p><code>JavaEE</code> 规范是很多 Java 开发技术的总称。这些技术规范都是沿用自 <code>J2EE</code> 的。一共包括了 13 个技术规范，例如：<code>jsp/servlet</code>，<code>jndi</code>，<code>jaxp</code>，<code>jdbc</code>，<code>jni</code>，<code>jaxb</code>，<code>jmf</code>，<code>jta</code>，<code>jpa</code>，<code>EJB</code>等。</p>
<p>其中，<code>JCP</code> 组织的全称是 Java Community Process，是一个开放的国际组织，主要由 Java 开发者以及被授权者组成，职能是发展和更新。成立于 1998 年。官网是：<a href="https://jcp.org/en/home/index">JCP</a></p>
<p><code>JavaEE</code> 的版本是延续了 <code>J2EE</code> 的版本，但是没有继续采用其命名规则。<code>J2EE</code> 的版本从 1.0 开始到 1.4 结束，而 <code>JavaEE</code> 版本是从 <code>JavaEE 5</code> 版本开始，目前最新的的版本是 <code>JavaEE 8</code></p>
<p>详情请参考：<a href="https://www.oracle.com/technetwork/cn/java/javaee/overview/index.html">JavaEE8 规范概览</a></p>
<hr>
<h3 id="Web-概述"><a href="#Web-概述" class="headerlink" title="Web 概述"></a>Web 概述</h3><p>Web，在计算机领域指网络。像我们接触的 <code>WWW</code>，它是由 3 个单词组成的，即：<code>World Wide Web </code>，中文含义是<b>万维网</b>。而我们前面学的 HTML 的参考文档《W3School 全套教程》中的 <code>W3C</code> 就是万维网联盟，他们的出现都是为了让我们在网络的世界中获取资源，这些资源的存放之处，我们称之为网站。我们通过输入网站的地址（网址），就可以访问网站中提供的资源。在网上我们能访问到的内容全是资源（不区分局域网还是广域网），只不过不同类型的资源展示的效果不一样</p>
<p>资源分为静态资源和动态资源</p>
<ul>
<li><p>静态资源指的是，网站中提供给人们展示的资源是一成不变的，也就是说不同人或者在不同时间，看到的内容都是一样的。例如：我们看到的新闻，网站的使用手册，网站功能说明文档等等。而作为开发者，我们编写的 <code>html</code>、<code>css</code>、<code>js</code> 图片，多媒体等等都可以称为静态资源</p>
</li>
<li><p>动态资源它指的是，网站中提供给人们展示的资源是由程序产生的，在不同的时间或者用不同的人员由于身份的不同，所看到的内容是不一样的。例如：我们在CSDN上下载资料，只有登录成功后，且积分足够时才能下载。否则就不能下载，这就是访客身份和会员身份的区别。作为开发人员，我们编写的 <code>JSP</code>，<code>servlet</code>，<code>php</code>，<code>ASP</code> 等都是动态资源。</p>
</li>
</ul>
<p>关于广域网和局域网的划分</p>
<ul>
<li>广域网指的就是万维网，也就是我们说的互联网。</li>
<li>局域网是指的是在一定范围之内可以访问的网络，出了这个范围，就不能再使用的网络。</li>
</ul>
<hr>
<h3 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h3><p>基础结构划分：C&#x2F;S结构，B&#x2F;S结构两类。</p>
<p>技术选型划分：Model1模型，Model2模型，MVC模型和三层架构+MVC模型。</p>
<p>部署方式划分：一体化架构，垂直拆分架构，分布式架构，流动计算架构，微服务架构。</p>
<ul>
<li><p>C&#x2F;S结构：客户端—服务器的方式。其中C代表Client，S代表服务器。C&#x2F;S结构的系统设计图如下：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/JavaEE-CS结构图.jpg" style="zoom:67%;">
</li>
<li><p>B&#x2F;S结构是浏览器—服务器的方式。B代表Browser，S代表服务器。B&#x2F;S结构的系统设计图如下：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/JavaEE-BS结构图.jpg" style="zoom:67%;">


</li>
<li><p>两种结构的区别及优劣</p>
<ul>
<li><p>区别：</p>
<ul>
<li>第一：硬件环境不同，C&#x2F;S通常是建立在专用的网络或小范围的网络环境上（即局域网），且必须要安装客户端。而B&#x2F;S是建立在广域网上的，适应范围强，通常有操作系统和浏览器就行。</li>
<li>第二：C&#x2F;S结构比B&#x2F;S结构更安全，因为用户群相对固定，对信息的保护更强。</li>
<li>第三：B&#x2F;S结构维护升级比较简单，而C&#x2F;S结构维护升级相对困难。</li>
</ul>
</li>
<li><p>优劣</p>
<ul>
<li>C&#x2F;S：能充分发挥客户端PC的处理能力，很多工作可以在客户端处理后再提交给服务器。对应的优点就是客户端响应速度快。</li>
<li>B&#x2F;S：总体拥有成本低、维护方便、 分布性强、开发简单，可以不用安装任何专门的软件就能实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能使用。</li>
</ul>
</li>
</ul>
</li>
<li><p>我们的课程中涉及的系统结构都是是基于B&#x2F;S结构</p>
</li>
</ul>
<hr>
<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>服务器的概念非常的广泛，它可以指代一台特殊的计算机（相比普通计算机运行更快、负载更高、价格更贵），也可以指代用于部署网站的应用。我们这里说的服务器，其实是web服务器，或者应用服务器。它本质就是一个软件，一个应用。作用就是发布我们的应用（工程），让用户可以通过浏览器访问我们的应用。</p>
<p>常见的应用服务器，请看下表：</p>
<table>
<thead>
<tr>
<th>服务器名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>weblogic</td>
<td>实现了 JavaEE 规范，重量级服务器，又称为 JavaEE 容器</td>
</tr>
<tr>
<td>websphereAS</td>
<td>实现了 JavaEE 规范，重量级服务器。</td>
</tr>
<tr>
<td>JBOSSAS</td>
<td>实现了 JavaEE 规范，重量级服务器，免费</td>
</tr>
<tr>
<td>Tomcat</td>
<td>实现了 jsp&#x2F;servlet 规范，是一个轻量级服务器，开源免费</td>
</tr>
</tbody></table>
<hr>
<h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><h4 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h4><p>下载地址：<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p>
<p>目录结构详解：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Tomcat%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3.png"></p>
<hr>
<h4 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h4><p>解压apache-tomcat-8.5.32.tar.gz。</p>
<p>防火墙设置</p>
<ul>
<li><p>方式1：service iptables stop  关闭防火墙(不建议); 用到哪一个端口号就放行哪一个(80,8080,3306…)</p>
</li>
<li><p>方式2：放行8080 端口</p>
<ul>
<li>修改配置文件<code>cd /etc/sysconfig</code>–&gt;<code>vi iptables</code><br><code>-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT</code></li>
<li>重启加载防火墙或者重启防火墙<br><code>service iptables reload</code> 或者<code>service iptables restart</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="启动停止"><a href="#启动停止" class="headerlink" title="启动停止"></a>启动停止</h4><p>Tomcat服务器的启动文件在二进制文件目录bin中：startup.bat，startup.sh</p>
<p>Tomcat服务器的停止文件也在二进制文件目录bin中：shutdown.bat，shutdown.sh  （推荐直接关闭控制台）</p>
<p>其中<code>.bat</code>文件是针对windows系统的运行程序，<code>.sh</code>文件是针对linux系统的运行程序。</p>
<hr>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ul>
<li><p>启动一闪而过</p>
<p>没有配置环境变量，配置上 JAVA_HOME 环境变量。</p>
</li>
<li><p>Tomcat 启动后控制台输出乱码</p>
<p>打开 <code>/conf/logging.properties</code>，设置 gbk <code>java.util.logging.ConsoleHandler.encoding = gbk</code></p>
</li>
<li><p>Address already in use : JVM_Bind：端口被占用，找到占用该端口的应用</p>
<ul>
<li><p>进程不重要：使用cmd命令：netstat -a -o 查看 pid  在任务管理器中结束占用端口的进程</p>
</li>
<li><p>进程很重要：修改自己的端口号。修改的是 Tomcat 目录下<code>\conf\server.xml</code>中的配置。</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Tomcat-server.xml%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE.png"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="IDEA集成"><a href="#IDEA集成" class="headerlink" title="IDEA集成"></a>IDEA集成</h4><p>Run -&gt; Edit Configurations -&gt; Templates -&gt; Tomcat Server -&gt; Local</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Tomcat-IDEA%E9%85%8D%E7%BD%AETomcat.png"></p>
<hr>
<h3 id="发布应用"><a href="#发布应用" class="headerlink" title="发布应用"></a>发布应用</h3><h4 id="虚拟目录"><a href="#虚拟目录" class="headerlink" title="虚拟目录"></a>虚拟目录</h4><p>在 <code>server.xml</code> 的 <code>&lt;Host&gt;</code> 元素中加一个 <code>&lt;Context path=&quot;&quot; docBase=&quot;&quot;/&gt;</code> 元素</p>
<ul>
<li><code>path</code>：访问资源URI，URI名称可以随便起，但是必须在前面加上一个&#x2F;</li>
<li><code>docBase</code>：资源所在的磁盘物理地址</li>
</ul>
<hr>
<h4 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h4><p>在<code>&lt;Engine&gt;</code>元素中添加一个<code>&lt;Host name=&quot;&quot; appBase=&quot;&quot; unparkWARs=&quot;&quot; autoDeploy=&quot;&quot; /&gt;</code>，其中：</p>
<ul>
<li><code>name</code>：指定主机的名称</li>
<li><code>appBase</code>：当前主机的应用发布目录</li>
<li><code>unparkWARs</code>：启动时是否自动解压war包</li>
<li><code>autoDeploy</code>：是否自动发布</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;www.itcast.cn&quot;</span> <span class="attr">appBase</span>=<span class="string">&quot;D:\itcastapps&quot;</span> <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;www.itheima.com&quot;</span> <span class="attr">appBase</span>=<span class="string">&quot;D:\itheimaapps&quot;</span> <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="IDEA部署"><a href="#IDEA部署" class="headerlink" title="IDEA部署"></a>IDEA部署</h4><ul>
<li><p>新建工程</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Tomcat-IEDA新建工程.png" style="zoom:67%;">
</li>
<li><p>发布工程<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Tomcat-IDEA%E5%8F%91%E5%B8%83%E5%B7%A5%E7%A8%8B.png"></p>
</li>
<li><p>Run</p>
</li>
</ul>
<hr>
<h4 id="IDEA发布"><a href="#IDEA发布" class="headerlink" title="IDEA发布"></a>IDEA发布</h4><p>把资源移动到 Tomcat 工程下 web 目录中，两种访问方式</p>
<ul>
<li><p>直接访问：<a href="http://localhost:8080/Tomcat/login/login.html">http://localhost:8080/Tomcat/login/login.html</a></p>
</li>
<li><p>在 web.xml 中配置默认主页</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>/默认主页<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h3><h4 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h4><p>Tomcat 核心组件架构图如下所示：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Tomcat-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%9B%BE.png"></p>
<p>组件介绍：</p>
<ul>
<li>GlobalNamingResources：实现 JNDI，指定一些资源的配置信息</li>
<li>Server：Tomcat 是一个 Servlet 容器，一个 Tomcat 对应一个 Server，一个 Server 可以包含多个 Service</li>
<li>Service：核心服务是 Catalina，用来对请求进行处理，一个 Service 包含多个 Connector 和一个 Container</li>
<li>Connector：连接器，负责处理客户端请求，解析不同协议及 I&#x2F;O 方式</li>
<li>Executor：线程池</li>
<li>Container：容易包含 Engine，Host，Context，Wrapper 等组件</li>
<li>Engine：服务交给引擎处理请求，Container 容器中顶层的容器对象，一个 Engine 可以包含多个 Host 主机</li>
<li>Host：Engine 容器的子容器，一个 Host 对应一个网络域名，一个 Host 包含多个 Context</li>
<li>Context：Host 容器的子容器，表示一个 Web 应用</li>
<li>Wrapper：Tomcat 中的最小容器单元，表示 Web 应用中的 Servlet</li>
</ul>
<p>核心类库：</p>
<ul>
<li>Coyote：Tomcat 连接器的名称，封装了底层的网络通信，为 Catalina 容器提供了统一的接口，使容器与具体的协议以及 I&#x2F;O 解耦</li>
<li>EndPoint：Coyote 通信端点，即通信监听的接口，是 Socket 接收和发送处理器，是对传输层的抽象，用来实现 TCP&#x2F;IP 协议</li>
<li>Processor ： Coyote 协议处理接口，用来实现 HTTP 协议，Processor 接收来自 EndPoint 的 Socket，读取字节流解析成 Tomcat 的 Request 和 Response 对象，并通过 Adapter 将其提交到容器处理，Processor 是对应用层协议的抽象</li>
<li>CoyoteAdapter：适配器，连接器调用 CoyoteAdapter 的 sevice 方法，传入的是 TomcatRequest 对象，CoyoteAdapter 负责将TomcatRequest 转成 ServletRequest，再调用容器的 service 方法</li>
</ul>
<p>参考文章：<a href="https://www.jianshu.com/p/7c9401b85704">https://www.jianshu.com/p/7c9401b85704</a></p>
<p>参考文章：<a href="https://www.yuque.com/yinhuidong/yu877c/ktq82e">https://www.yuque.com/yinhuidong/yu877c/ktq82e</a></p>
<hr>
<h4 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h4><p>Tomcat 的启动入口是 Bootstrap#main 函数，首先通过调用 <code>bootstrap.init()</code> 初始化相关组件：</p>
<ul>
<li><code>initClassLoaders()</code>：初始化三个类加载器，commonLoader 的父类加载器是启动类加载器</li>
<li><code>Thread.currentThread().setContextClassLoader(catalinaLoader)</code>：自定义类加载器加载 Catalina 类，<strong>打破双亲委派</strong></li>
<li><code>Object startupInstance = startupClass.getConstructor().newInstance()</code>：反射创建 Catalina 对象</li>
<li><code>method.invoke(startupInstance, paramValues)</code>：反射调用方法，设置父类加载器是 sharedLoader</li>
<li><code>catalinaDaemon = startupInstance</code>：引用 Catalina 对象</li>
</ul>
<p><code>daemon.load(args)</code> 方法反射调用 Catalina 对象的 load 方法，对<strong>服务器的组件进行初始化</strong>，并绑定了 ServerSocket 的端口：</p>
<ul>
<li><p><code>parseServerXml(true)</code>：解析 XML 配置文件</p>
</li>
<li><p><code>getServer().init()</code>：服务器执行初始化，采用责任链的执行方式</p>
<ul>
<li><p><code>LifecycleBase.init()</code>：生命周期接口的初始化方法，开始链式调用</p>
</li>
<li><p><code>StandardServer.initInternal()</code>：Server 的初始化，遍历所有的 Service 进行初始化</p>
</li>
<li><p><code>StandardService.initInternal()</code>：Service 的初始化，对 Engine、Executor、listener、Connector 进行初始化</p>
</li>
<li><p><code>StandardEngine.initInternal()</code>：Engine 的初始化</p>
<ul>
<li><code>getRealm()</code>：创建一个 Realm 对象</li>
<li><code>ContainerBase.initInternal()</code>：容器的初始化，设置处理容器内组件的启动和停止事件的线程池</li>
</ul>
</li>
<li><p><code>Connector.initInternal()</code>：Connector 的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Connector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="string">&quot;HTTP/1.1&quot;</span>); <span class="comment">//默认无参构造方法，会创建出 Http11NioProtocol 的协议处理器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>adapter = new CoyoteAdapter(this)</code>：实例化 CoyoteAdapter 对象</p>
</li>
<li><p><code>protocolHandler.setAdapter(adapter)</code>：设置到 ProtocolHandler 协议处理器中</p>
</li>
<li><p><code>ProtocolHandler.init()</code>：协议处理器的初始化，底层调用 <code>AbstractProtocol#init</code> 方法</p>
<p><code>endpoint.init()</code>：端口的初始化，底层调用 <code>AbstractEndpoint#init</code> 方法</p>
<p><code>NioEndpoint.bind()</code>：绑定方法</p>
<ul>
<li><code>initServerSocket()</code>：<strong>初始化 ServerSocket</strong>，以 NIO 的方式监听端口<ul>
<li><code>serverSock = ServerSocketChannel.open()</code>：<strong>NIO 的方式打开通道</strong></li>
<li><code>serverSock.bind(addr, getAcceptCount())</code>：通道绑定连接端口</li>
<li><code>serverSock.configureBlocking(true)</code>：切换为阻塞模式（没懂，为什么阻塞）</li>
</ul>
</li>
<li><code>initialiseSsl()</code>：初始化 SSL 连接</li>
<li><code>selectorPool.open(getName())</code>：打开选择器，类似 NIO 的多路复用器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>初始化完所有的组件，调用 <code>daemon.start()</code> 进行<strong>组件的启动</strong>，底层反射调用 Catalina 对象的 start 方法：</p>
<ul>
<li><p><code>getServer().start()</code>：启动组件，也是责任链的模式</p>
<ul>
<li><p><code>LifecycleBase.start()</code>：生命周期接口的初始化方法，开始链式调用</p>
</li>
<li><p><code>StandardServer.startInternal()</code>：Server 服务的启动</p>
<ul>
<li><code>globalNamingResources.start()</code>：启动 JNDI 服务</li>
<li><code>for (Service service : services)</code>：遍历所有的 Service 进行启动</li>
</ul>
</li>
<li><p><code>StandardService.startInternal()</code>：Service 的启动，对所有 Executor、listener、Connector 进行启</p>
</li>
<li><p><code>StandardEngine.startInternal()</code>：启动引擎，部署项目</p>
<ul>
<li><code>ContainerBase.startInternal()</code>：容器的启动<ul>
<li>启动集群、Realm 组件，并且创建子容器，提交给线程池</li>
<li><code>((Lifecycle) pipeline).start()</code>：遍历所有的管道进行启动<ul>
<li><code>Valve current = first</code>：获取第一个阀门</li>
<li><code>((Lifecycle) current).start()</code>：启动阀门，底层 <code>ValveBase#startInternal</code> 中设置启动的状态</li>
<li><code>current = current.getNext()</code>：获取下一个阀门</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Connector.startInternal()</code>：Connector 的初始化</p>
<ul>
<li><p><code>protocolHandler.start()</code>：协议处理器的启动</p>
<p><code>endpoint.start()</code>：端点启动</p>
<p><code>NioEndpoint.startInternal()</code>：启动 NIO 的端点</p>
<ul>
<li><code>createExecutor()</code>：创建 Worker 线程组，10 个线程，用来进行任务处理</li>
<li><code>initializeConnectionLatch()</code>：用来进行连接限流，<strong>最大 8*1024 条连接</strong></li>
<li><code>poller = new Poller()</code>：<strong>创建 Poller 对象</strong>，开启了一个多路复用器 Selector</li>
<li><code>Thread pollerThread = new Thread(poller, getName() + &quot;-ClientPoller&quot;)</code>：创建并启动 Poller 线程，Poller 实现了 Runnable 接口，是一个任务对象，<strong>线程 start 后进入 Poller#run 方法</strong></li>
<li><code>pollerThread.setDaemon(true)</code>：设置为守护线程</li>
<li><code>startAcceptorThread()</code>：启动接收者线程<ul>
<li><code>acceptor = new Acceptor&lt;&gt;(this)</code>：<strong>创建 Acceptor 对象</strong></li>
<li><code>Thread t = new Thread(acceptor, threadName)</code>：创建并启动 Acceptor 接受者线程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h4><ol>
<li>Acceptor 监听客户端套接字，每 50ms 调用一次 **<code>serverSocket.accept</code>**，获取 Socket 后把封装成 NioSocketWrapper（是 SocketWrapperBase 的子类），并设置为非阻塞模式，把 NioSocketWrapper 封装成 PollerEvent 放入同步队列中</li>
<li>Poller 循环判断同步队列中是否有就绪的事件，如果有则通过 <code>selector.selectedKeys()</code> 获取就绪事件，获取 SocketChannel 中携带的 attachment（NioSocketWrapper），在 processKey 方法中根据事件类型进行 processSocket，将 Wrapper 对象封装成 SocketProcessor 对象，该对象是一个任务对象，提交到 Worker 线程池进行执行</li>
<li><code>SocketProcessorBase.run()</code> 加锁调用 <code>SocketProcessor#doRun</code>，保证线程安全，从协议处理器 ProtocolHandler 中获取 AbstractProtocol，然后<strong>创建 Http11Processor 对象处理请求</strong></li>
<li><code>Http11Processor#service</code> 中调用 <code>CoyoteAdapter#service</code> ，把生成的 Tomcat 下的 Request 和 Response 对象通过方法 postParseRequest 匹配到对应的 Servlet 的请求响应，将请求传递到对应的 Engine 容器中调用 Pipeline，管道中包含若干个 Valve，执行完所有的 Valve 最后执行 StandardEngineValve，继续调用 Host 容器的 Pipeline，执行 Host 的 Valve，再传递给 Context 的 Pipeline，最后传递到 Wrapper 容器</li>
<li><code>StandardWrapperValve#invoke</code> 中创建了 Servlet 对象并执行初始化，并为当前请求准备一个 FilterChain 过滤器链执行 doFilter 方法，<code>ApplicationFilterChain#doFilter</code> 是一个<strong>责任链的驱动方法</strong>，通过调用 internalDoFilter 来获取过滤器链的下一个过滤器执行 doFilter，执行完所有的过滤器后执行 <code>servlet.service</code> 的方法</li>
<li>最后调用 HttpServlet#service()，根据请求的方法来调用 doGet、doPost 等，执行到自定义的业务方法</li>
</ol>
<hr>
<h2 id="Servlet-1"><a href="#Servlet-1" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket 是使用 TCP&#x2F;IP 或者 UDP 协议在服务器与客户端之间进行传输的技术，是网络编程的基础</p>
<ul>
<li><strong>Servlet 是使用 HTTP 协议在服务器与客户端之间通信的技术，是 Socket 的一种应用</strong></li>
<li><strong>HTTP 协议：是在 TCP&#x2F;IP 协议之上进一步封装的一层协议，关注数据传输的格式是否规范，底层的数据传输还是运用了 Socket 和 TCP&#x2F;IP</strong></li>
</ul>
<p>Tomcat 和 Servlet 的关系：Servlet 的运行环境叫做 Web 容器或 Servlet 服务器，<strong>Tomcat 是 Web 应用服务器，是一个 Servlet&#x2F;JSP 容器</strong>。Tomcat 作为 Servlet 容器，负责处理客户请求，把请求传送给 Servlet，并将 Servlet 的响应传送回给客户。而 Servlet 是一种运行在支持 Java 语言的服务器上的组件，Servlet 用来扩展 Java Web 服务器功能，提供非常安全的、可移植的、易于使用的 CGI 替代品<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Tomcat%E4%B8%8EServlet%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p>
<hr>
<h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><h4 id="Servlet类"><a href="#Servlet类" class="headerlink" title="Servlet类"></a>Servlet类</h4><p>Servlet是SUN公司提供的一套规范，名称就叫Servlet规范，它也是JavaEE规范之一。通过API来使用Servlet。</p>
<ol>
<li><p>Servlet是一个运行在web服务端的java小程序，用于接收和响应客户端的请求。一个服务器包含多个Servlet</p>
</li>
<li><p>通过实现Servlet接口，继承GenericServlet或者HttpServlet，实现Servlet功能</p>
</li>
<li><p>每次请求都会执行service方法，在service方法中还有参数ServletRequest和ServletResponse</p>
</li>
<li><p>支持配置相关功能</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Servlet%E7%B1%BB%E5%85%B3%E7%B3%BB%E6%80%BB%E8%A7%86%E5%9B%BE.png"></p>
</li>
</ol>
<hr>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>创建 Web 工程 → 编写普通类继承 Servlet 相关类 → 重写方法</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Servlet%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B%E6%89%A7%E8%A1%8C.png"></p>
<p>Servlet执行过程分析：</p>
<p>通过浏览器发送请求，请求首先到达Tomcat服务器，由服务器解析请求URL，然后在部署的应用列表中找到应用。然后找到web.xml配置文件，在web.xml中找到FirstServlet的配置（<url-pattern>&#x2F;<url-pattern>），找到后执行service方法，最后由FirstServlet响应客户浏览器。整个过程如下图所示：</url-pattern></url-pattern></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Servlet%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%9B%BE.jpg"></p>
<hr>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>实现 Servlet 功能时，可以选择以下三种方式：</p>
<ul>
<li><p>第一种：实现 Servlet 接口，接口中的方法必须全部实现。<br>使用此种方式，表示接口中的所有方法在需求方面都有重写的必要。此种方式支持最大程度的自定义。</p>
</li>
<li><p>第二种：继承 GenericServlet，service 方法必须重写，其他方可根据需求，选择性重写。<br>使用此种方式，表示只在接收和响应客户端请求这方面有重写的需求，而其他方法可根据实际需求选择性重写，使我们的开发Servlet变得简单。但是，此种方式是和 HTTP 协议无关的。</p>
</li>
<li><p>第三种：继承 HttpServlet，它是 javax.servlet.http 包下的一个抽象类，是 GenericServlet 的子类。选择继承 HttpServlet 时，<strong>需要重写 doGet 和 doPost 方法</strong>，来接收 get 方式和 post 方式的请求，不要覆盖 service 方法。使用此种方式，表示我们的请求和响应需要和 HTTP 协议相关，我们是通过 HTTP 协议来访问。每次请求和响应都符合 HTTP 协议的规范。请求的方式就是 HTTP 协议所支持的方式（GET POST PUT DELETE TRACE OPTIONS HEAD )。</p>
</li>
</ul>
<hr>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><h4 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h4><p>Servlet 3.0 中的异步处理指的是允许Servlet重新发起一条新线程去调用 耗时业务方法，这样就可以避免等待</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Servlet3.0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86.png"></p>
<hr>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>servlet从创建到销毁的过程：</p>
<ul>
<li><p>出生：（初始化）请求第一次到达 Servlet 时，创建对象，并且初始化成功。Only one time</p>
</li>
<li><p>活着：（服务）服务器提供服务的整个过程中，该对象一直存在，每次只是执行 service 方法</p>
</li>
<li><p>死亡：（销毁）当服务停止时，或者服务器宕机时，对象删除，</p>
</li>
</ul>
<p>serrvlet生命周期方法:<br><code>init(ServletConfig config)</code> → <code>service(ServletRequest req, ServletResponse res)</code> → <code>destroy()</code></p>
<p>默认情况下, 有了第一次请求, 会调用 init() 方法进行初始化【调用一次】，任何一次请求，都会调用 service() 方法处理这个请求，服务器正常关闭或者项目从服务器移除, 调用 destory() 方法进行销毁【调用一次】</p>
<p><strong>扩展</strong>：servlet 是单例多线程的，尽量不要在 servlet 里面使用全局(成员)变量，可能会导致线程不安全</p>
<ul>
<li>单例：Servlet 对象只会创建一次，销毁一次，Servlet 对象只有一个实例。</li>
<li>多线程：服务器会针对每次请求, 开启一个线程调用 service() 方法处理这个请求</li>
</ul>
<hr>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>Servlet运用了单例模式，整个应用中只有一个实例对象，所以需要分析这个唯一的实例中的类成员是否线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="comment">//1.定义用户名成员变量</span></span><br><span class="line">    <span class="comment">//private String username = null;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//synchronized (this) &#123;</span></span><br><span class="line">            <span class="comment">//2.获取用户名</span></span><br><span class="line">            username = req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.获取输出流对象</span></span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">            <span class="comment">//4.响应给客户端浏览器</span></span><br><span class="line">            pw.print(<span class="string">&quot;Welcome:&quot;</span> + username);</span><br><span class="line">            <span class="comment">//5.关流</span></span><br><span class="line">            pw.close();</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动两个浏览器，输入不同的参数(<a href="http://localhost:8080/ServletDemo/username=aaa">http://localhost:8080/ServletDemo/username=aaa</a> 或者bbb)，访问之后发现输出的结果都是一样，所以出现线程安全问题。</p>
<p>在Servlet中定义了类成员之后，多个浏览器都会共享类成员的数据，其中任何一个线程修改了数据，都会影响其他线程。因此，我们可以认为Servlet它不是线程安全的。因为Servlet是单例，单例对象的类成员只会随类实例化时初始化一次，之后的操作都是改变，而不会重新初始化。</p>
<p>解决办法：如果类成员是共用的，只在初始化时赋值，其余时间都是获取。或者加锁synchronized</p>
<hr>
<h4 id="映射方式"><a href="#映射方式" class="headerlink" title="映射方式"></a>映射方式</h4><p>Servlet支持三种映射方式，三种映射方式的优先级为：第一种&gt;第二种&gt;第三种。</p>
<ol>
<li><p>具体名称方式<br>这种方式，只有和映射配置一模一样时，Servlet才会接收和响应来自客户端的请求。<br>访问URL：<a href="http://localhost:8080/servlet/servletDemo">http://localhost:8080/servlet/servletDemo</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletDemo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.itheima.servlet.ServletDemo<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletDemo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletDemo<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>&#x2F;开头+通配符的方式<br>这种方式，只要符合目录结构即可，不用考虑结尾是什么<br>访问URL：<a href="http://localhost:8080/servlet/">http://localhost:8080/servlet/</a> + 任何字符</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletDemo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.itheima.servlet.ServletDemo<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletDemo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>通配符+固定格式结尾<br>这种方式，只要符合固定结尾格式即可，其前面的访问URI无须关心（注意协议，主机和端口必须正确）<br>访问URL：<a href="http://localhost:8080/%E4%BB%BB%E4%BD%95%E5%AD%97%E7%AC%A6%E4%BB%BB%E4%BD%95%E7%9B%AE%E5%BD%95">http://localhost:8080/任何字符任何目录</a> + .do (<a href="http://localhost:8080/seazean/i.do">http://localhost:8080/seazean/i.do</a>)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletDemo05<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.itheima.servlet.ServletDemo05<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletDemo05<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="多路径映射"><a href="#多路径映射" class="headerlink" title="多路径映射"></a>多路径映射</h4><p>一个Servlet的多种路径配置的支持。给一个Servlet配置多个访问映射，从而根据不同请求的URL实现不同的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*多路映射*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo06</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//获取访问的资源路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getRequestURI();</span><br><span class="line">        name = name.substring(name.lastIndexOf(<span class="string">&quot;/&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;/vip&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="comment">//如果访问资源路径是/vip 商品价格为9折</span></span><br><span class="line">            System.out.println(<span class="string">&quot;商品原价为：&quot;</span> + money + <span class="string">&quot;。优惠后是：&quot;</span> + (money*<span class="number">0.9</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;/svip&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="comment">//如果访问资源路径是/svip 商品价格为5折</span></span><br><span class="line">            System.out.println(<span class="string">&quot;商品原价为：&quot;</span> + money + <span class="string">&quot;。优惠后是：&quot;</span> + (money*<span class="number">0.5</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果访问资源路径是其他  商品价格原样显示</span></span><br><span class="line">            System.out.println(<span class="string">&quot;商品价格为：&quot;</span> + money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--演示Servlet多路径映射--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>vip<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.itheima.servlet.ServletDemo06<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>vip<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/vip<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>svip<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.itheima.servlet.ServletDemo06<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>svip<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/svip<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>other<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.itheima.servlet.ServletDemo06<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>other<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/other<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样就可以根据不同的网页显示不同的数据。</p>
<hr>
<h4 id="启动时创建"><a href="#启动时创建" class="headerlink" title="启动时创建"></a>启动时创建</h4><ul>
<li>第一种：应用加载时创建Servlet，它的优势是在服务器启动时，就把需要的对象都创建完成了，从而在使用的时候减少了创建对象的时间，提高了首次执行的效率。它的弊端是在应用加载时就创建了Servlet对象，因此，导致内存中充斥着大量用不上的Servlet对象，造成了内存的浪费。</li>
<li>第二种：请求第一次访问是创建Servlet，它的优势就是减少了对服务器内存的浪费，因为一直没有被访问过的Servlet对象都没有创建，因此也提高了服务器的启动时间。而它的弊端就是要在应用加载时就做的初始化操作，它都没法完成，从而要考虑其他技术实现。</li>
</ul>
<p>在web.xml中是支持对Servlet的创建时机进行配置的，配置的方式如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置ServletDemo3--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletDemo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.itheima.web.servlet.ServletDemo<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置Servlet的创建顺序，当配置此标签时，Servlet就会改为应用加载时创建</span></span><br><span class="line"><span class="comment">        配置项的取值只能是正整数（包括0），数值越小，表明创建的优先级越高--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletDemo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletDemo<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="默认Servlet"><a href="#默认Servlet" class="headerlink" title="默认Servlet"></a>默认Servlet</h4><p>默认 Servlet 是由服务器提供的一个 Servlet，它配置在 Tomcat 的 conf 目录下的 web.xml 中。</p>
<p>它的映射路径是<code>&lt;url-pattern&gt;/&lt;url-pattern&gt;</code>，我们在发送请求时，首先会在我们应用中的 web.xml 中查找映射配置。但是当找不到对应的 Servlet 路径时，就去找默认的 Servlet，由默认 Servlet 处理。</p>
<hr>
<h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><p>ServletConfig 是 Servlet 的配置参数对象。在 Servlet 规范中，允许为每个 Servlet 都提供一些初始化配置，每个 Servlet 都有自己的ServletConfig，作用是<strong>在 Servlet 初始化期间，把一些配置信息传递给 Servlet</strong></p>
<p>生命周期：在初始化阶段读取了 web.xml 中为 Servlet 准备的初始化配置，并把配置信息传递给 Servlet，所以生命周期与 Servlet 相同。如果 Servlet 配置了 <code>&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</code>，ServletConfig 也会在应用加载时创建。</p>
<p>获取 ServletConfig：在 init 方法中为 ServletConfig 赋值</p>
<p>常用API：</p>
<ul>
<li><code>String getInitParameter(String name)</code>：根据初始化参数的名称获取参数的值，根据<param-name>，获取<param-value></param-value></param-name></li>
<li><code>Enumeration&lt;String&gt; getInitParameterNames()</code> : 获取所有初始化参数名称的枚举(遍历方式看例子)</li>
<li><code>ServletContext getServletContext()</code> : 获取<strong>ServletContext</strong>对象</li>
<li><code>String getServletName()</code> : 获取Servlet名称</li>
</ul>
<p>代码实现：</p>
<ul>
<li><p>web.xml 配置：<br>初始化参数使用 <code>&lt;servlet&gt;</code> 标签中的 <code>&lt;init-param&gt; </code>标签来配置，并且每个 Servlet 都支持有多个初始化参数，并且初始化参数都是以键值对的形式存在的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置ServletDemo8--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletDemo8<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.itheima.web.servlet.ServletDemo8<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置初始化参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用于获取初始化参数的key--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--初始化参数的值--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--每个初始化参数都需要用到init-param标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>servletInfo<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>This is Demo8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletDemo8<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletDemo8<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//演示Servlet的初始化参数对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo8</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">	<span class="comment">//定义Servlet配置对象ServletConfig</span></span><br><span class="line">    <span class="keyword">private</span> ServletConfig servletConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在初始化时为ServletConfig赋值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="built_in">this</span>.servletConfig = config;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * doGet方法输出一句话</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.输出ServletConfig</span></span><br><span class="line">        System.out.println(servletConfig);</span><br><span class="line">        <span class="comment">//2.获取Servlet的名称</span></span><br><span class="line">        String servletName= servletConfig.getServletName();</span><br><span class="line">        System.out.println(servletName);</span><br><span class="line">        <span class="comment">//3.获取字符集编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encoding</span> <span class="operator">=</span> servletConfig.getInitParameter(<span class="string">&quot;encoding&quot;</span>);</span><br><span class="line">        System.out.println(encoding);</span><br><span class="line">        <span class="comment">//4.获取所有初始化参数名称的枚举</span></span><br><span class="line">        Enumeration&lt;String&gt; names = servletConfig.getInitParameterNames();</span><br><span class="line">        <span class="comment">//遍历names</span></span><br><span class="line">        <span class="keyword">while</span>(names.hasMoreElements())&#123;</span><br><span class="line">            <span class="comment">//取出每个name</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> names.nextElement();</span><br><span class="line">            <span class="comment">//根据key获取value</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> servletConfig.getInitParameter(name);</span><br><span class="line">            System.out.println(<span class="string">&quot;name:&quot;</span>+name+<span class="string">&quot;,value:&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.获取ServletContext对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> servletConfig.getServletContext();</span><br><span class="line">        System.out.println(servletContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用doGet方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/ServletConfig%E6%BC%94%E7%A4%BA.png"></p>
</li>
</ul>
<hr>
<h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>ServletContext 对象是应用上下文对象。服务器为每一个应用都创建了一个 ServletContext 对象，ServletContext 属于整个应用，不局限于某个 Servlet，可以实现让应用中所有 Servlet 间的数据共享。 </p>
<p>上下文代表了程序当下所运行的环境，联系整个应用的生命周期与资源调用，是程序可以访问到的所有资源的总和，资源可以是一个变量，也可以是一个对象的引用</p>
<p>生命周期：</p>
<ul>
<li>出生：应用一加载，该对象就被创建出来。一个应用只有一个实例对象（Servlet 和 ServletContext 都是单例的）</li>
<li>活着：只要应用一直提供服务，该对象就一直存在。</li>
<li>死亡：应用被卸载（或者服务器停止），该对象消亡。</li>
</ul>
<p>域对象：指的是对象有作用域，即有作用范围，可以<strong>实现数据共享</strong>，不同作用范围的域对象，共享数据的能力不一样。</p>
<p>Servlet 规范中，共有4个域对象，ServletContext 是其中一个，web 应用中最大的作用域，叫 application 域，可以实现整个应用间的数据共享功能。</p>
<p>数据共享：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/ServletContext共享数据.png" style="zoom:50%;">

<p>获取ServletContext：</p>
<ul>
<li><p>Java 项目继承 HttpServlet，HttpServlet 继承 GenericServlet，GenericServlet 中有一个方法可以直接使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ServletContext <span class="title function_">getServletContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getServletConfig().getServletContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>ServletRequest 类方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServletContext <span class="title function_">getServletContext</span><span class="params">()</span><span class="comment">//获取ServletContext对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>常用API：</p>
<ul>
<li><code>String getInitParameter(String name)</code> : 根据名称获取全局配置的参数</li>
<li><code>String getContextPath</code> : 获取当前应用访问的虚拟目录</li>
<li><code>String getRealPath(String path)</code> : 根据虚拟目录获取应用部署的磁盘绝对路径</li>
<li><code>void setAttribute(String name, Object object)</code> : 向应用域对象中存储数据</li>
<li><code>Object getAttribute(String name)</code> : 根据名称获取域对象中的数据，没有则返回null</li>
<li><code>void removeAttribute(String name)</code> : 根据名称移除应用域对象中的数据</li>
</ul>
<p>代码实现：</p>
<ul>
<li><p>web.xml配置：<br>配置的方式，需要在<code>&lt;web-app&gt;</code>标签中使用<code>&lt;context-param&gt;</code>来配置初始化参数，它的配置是针对整个应用的配置，被称为应用的初始化参数配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置应用初始化参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用于获取初始化参数的key--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>servletContextInfo<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--初始化参数的值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>This is application scope<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--每个应用初始化参数都需要用到context-param标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>globalEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContextDemo</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取ServletContext对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取全局配置的globalEncoding</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> context.getInitParameter(<span class="string">&quot;globalEncoding&quot;</span>);</span><br><span class="line">        System.out.println(value);<span class="comment">//UTF-8</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取应用的访问虚拟目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> context.getContextPath();</span><br><span class="line">        System.out.println(contextPath);<span class="comment">//servlet</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据虚拟目录获取应用部署的磁盘绝对路径</span></span><br><span class="line">        <span class="comment">//获取b.txt文件的绝对路径 web目录下</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> context.getRealPath(<span class="string">&quot;/b.txt&quot;</span>);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取c.txt文件的绝对路径  /WEB-INF目录下</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> context.getRealPath(<span class="string">&quot;/WEB-INF/c.txt&quot;</span>);</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取a.txt文件的绝对路径 //src目录下</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> context.getRealPath(<span class="string">&quot;/WEB-INF/classes/a.txt&quot;</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向域对象中存储数据</span></span><br><span class="line">        context.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除域对象中username的数据</span></span><br><span class="line">        <span class="comment">//context.removeAttribute(&quot;username&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//E:\Database\Java\Project\JavaEE\out\artifacts\Servlet_war_exploded\b.txt</span></span><br><span class="line"><span class="comment">//E:\Database\Java\Project\JavaEE\out\artifacts\Servlet_war_exploded\WEB-INF\c.txt</span></span><br><span class="line"><span class="comment">//E:\Database\Java\Project\JavaEE\out\artifacts\Servlet_war_exploded\WEB-INF\classes\a.txt</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h3><p>Servlet3.0 版本！不需要配置 web.xml</p>
<ul>
<li><p>注解案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doPost(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Servlet Demo1 Annotation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>WebServlet注解（@since Servlet 3.0 (Section 8.1.1)）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WebServlet &#123;</span><br><span class="line">    <span class="comment">//指定Servlet的名称。相当于xml配置中&lt;servlet&gt;标签下的&lt;servlet-name&gt;</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于映射Servlet访问的url映射，相当于xml配置时的&lt;url-pattern&gt;</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相当于xml配置时的&lt;url-pattern&gt;</span></span><br><span class="line">    String[] urlPatterns() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用于配置Servlet的启动时机，相当于xml配置的&lt;load-on-startup&gt;</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">loadOnStartup</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于配置Servlet的初始化参数，相当于xml配置的&lt;init-param&gt;</span></span><br><span class="line">    WebInitParam[] initParams() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于配置Servlet是否支持异步，相当于xml配置的&lt;async-supported&gt;</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">asyncSupported</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于指定Servlet的小图标</span></span><br><span class="line">    String <span class="title function_">smallIcon</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于指定Servlet的大图标</span></span><br><span class="line">    String <span class="title function_">largeIcon</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于指定Servlet的描述信息</span></span><br><span class="line">    String <span class="title function_">description</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于指定Servlet的显示名称</span></span><br><span class="line">    String <span class="title function_">displayName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动创建容器：（了解）</p>
</li>
</ul>
<hr>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="请求响应"><a href="#请求响应" class="headerlink" title="请求响应"></a>请求响应</h3><p>Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象。</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Servlet%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E5%9B%BE.png"></p>
<hr>
<h3 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h3><p>请求：客户机希望从服务器端索取一些资源，向服务器发出询问</p>
<p>请求对象：在 JavaEE 工程中，用于发送请求的对象，常用的对象是 ServletRequest 和 HttpServletRequest ，它们的区是是否与 HTTP 协议有关</p>
<p>Request 作用：</p>
<ul>
<li>操作请求三部分(行,头,体)</li>
<li>请求转发</li>
<li>作为域对象存数据</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Request%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E8%A7%86%E5%9B%BE.png"></p>
<hr>
<h3 id="请求路径"><a href="#请求路径" class="headerlink" title="请求路径"></a>请求路径</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>String  getLocalAddr()</td>
<td>获取本机（服务器）地址</td>
</tr>
<tr>
<td>String getLocalName()</td>
<td>获取本机（服务器）名称</td>
</tr>
<tr>
<td>int getLocalPort()</td>
<td>获取本机（服务器）端口</td>
</tr>
<tr>
<td>String getRemoteAddr()</td>
<td>获取访问者IP</td>
</tr>
<tr>
<td>String getRemoteHost</td>
<td>获取访问者主机</td>
</tr>
<tr>
<td>int getRemotePort()</td>
<td>获取访问者端口</td>
</tr>
<tr>
<td>String getMethod();</td>
<td>获得请求方式</td>
</tr>
<tr>
<td>String getRequestURI()</td>
<td>获取统一资源标识符（&#x2F;request&#x2F;servletDemo01）</td>
</tr>
<tr>
<td>String getRequestURL()</td>
<td>获取统一资源定位符（<a href="http://localhost:8080/request/servletDemo01%EF%BC%89">http://localhost:8080/request/servletDemo01）</a></td>
</tr>
<tr>
<td>String getQueryString()</td>
<td>获取请求消息的数据<br>（GET方式 URL中带参字符串：username&#x3D;aaa&amp;password&#x3D;123）</td>
</tr>
<tr>
<td>String getContextPath()</td>
<td>获取虚拟目录名称（&#x2F;request）</td>
</tr>
<tr>
<td>String getServletPath</td>
<td>获取Servlet映射路径<br>（<url-pattern>或@WebServlet值: &#x2F;servletDemo01）</url-pattern></td>
</tr>
<tr>
<td>String getRealPath(String path)</td>
<td>根据虚拟目录获取应用部署的磁盘绝对路径</td>
</tr>
</tbody></table>
<p>URL &#x3D; URI + HOST</p>
<p>URL &#x3D; HOST + ContextPath + ServletPath</p>
<hr>
<h3 id="获取请求头"><a href="#获取请求头" class="headerlink" title="获取请求头"></a>获取请求头</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>String  getHeader(String name)</td>
<td>获得指定请求头的值。<br>如果没有该请求头返回null，有多个值返回第一个</td>
</tr>
<tr>
<td>Enumeration<String> getHeaders(String name)</String></td>
<td>获取指定请求头的多个值</td>
</tr>
<tr>
<td>Enumeration<String> getHeaderNames()</String></td>
<td>获取所有请求头名称的枚举</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo02&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo02</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.根据请求头名称获取一个值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">connection</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;connection&quot;</span>);</span><br><span class="line">        System.out.println(connection);<span class="comment">//keep-alive</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.根据请求头名称获取多个值</span></span><br><span class="line">        Enumeration&lt;String&gt; values = req.getHeaders(<span class="string">&quot;accept-encoding&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(values.hasMoreElements()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> values.nextElement();</span><br><span class="line">            System.out.println(value);<span class="comment">//gzip, deflate, br</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><h4 id="请求参数-1"><a href="#请求参数-1" class="headerlink" title="请求参数"></a>请求参数</h4><p>请求参数是正文部分<input>标签内容，<form>标签属性action&#x3D;”&#x2F;request&#x2F;servletDemo08”，服务器URI</form></p>
<table>
<thead>
<tr>
<th>法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>String getParameter(String name)</td>
<td>获得指定参数名的值<br>如果没有该参数则返回null，如果有多个获得第一个</td>
</tr>
<tr>
<td>String[] getParameterValues(String name)</td>
<td>获得指定参数名所有的值。此方法为复选框提供的</td>
</tr>
<tr>
<td>Enumeration<String> getParameterNames()</String></td>
<td>获得所有参数名</td>
</tr>
<tr>
<td>Map&lt;String,String[]&gt; getParameterMap()</td>
<td>获得所有的请求参数键值对（key&#x3D;value）</td>
</tr>
</tbody></table>
<hr>
<h4 id="封装参数"><a href="#封装参数" class="headerlink" title="封装参数"></a>封装参数</h4><p>封装请求参数到类对象：</p>
<ul>
<li><p>直接封装：有参构造或者set方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo04&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo04</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.获取所有的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        String[] hobbies = req.getParameterValues(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.封装学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(username,password,hobbies);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.输出对象</span></span><br><span class="line">        System.out.println(stu);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String[] hobby;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--register.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>注册页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/request/servletDemo05&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br><span class="line">        姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        爱好：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;study&quot;</span>&gt;</span>学习</span><br><span class="line">              <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;game&quot;</span>&gt;</span>游戏 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>反射方式：</p>
<p>表单<code>&lt;input&gt;</code>标签的name属性取值，必须和实体类中定义的属性名称一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//1.获取请求正文的映射关系</span></span><br><span class="line">    Map&lt;String, String[]&gt; map = req.getParameterMap();</span><br><span class="line">    <span class="comment">//2.封装学生对象</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    <span class="comment">//2.1遍历集合</span></span><br><span class="line">    <span class="keyword">for</span>(String name : map.keySet()) &#123;</span><br><span class="line">        String[] value = map.get(name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.2获取Student对象的属性描述器</span></span><br><span class="line">            <span class="comment">//参数一：指定获取xxx属性的描述器</span></span><br><span class="line">            <span class="comment">//参数二：指定字节码文件</span></span><br><span class="line">            <span class="type">PropertyDescriptor</span> <span class="variable">pd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyDescriptor</span>(name,stu.getClass());</span><br><span class="line">            <span class="comment">//2.3获取对应的setXxx方法</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">writeMethod</span> <span class="operator">=</span> pd.getWriteMethod();</span><br><span class="line">            <span class="comment">//2.4执行方法</span></span><br><span class="line">            <span class="keyword">if</span>(value.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                writeMethod.invoke(stu,(Object)value);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                writeMethod.invoke(stu,value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.输出对象</span></span><br><span class="line">    System.out.println(stu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>commons-beanutils封装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.获取所有的数据</span></span><br><span class="line">        Map&lt;String, String[]&gt; map = req.getParameterMap();</span><br><span class="line">        <span class="comment">//2.封装学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BeanUtils.populate(stu,map);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.输出对象</span></span><br><span class="line">        System.out.println(stu);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="流获取数据"><a href="#流获取数据" class="headerlink" title="流获取数据"></a>流获取数据</h4><p><code>ServletInputStream getInputStream()</code> : 获取请求字节输入流对象<br><code>BufferedReader getReader()  </code> : 获取请求缓冲字符输入流对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo07&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo07</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//字符流(必须是post方式)</span></span><br><span class="line">        <span class="comment">/*BufferedReader br = req.getReader();</span></span><br><span class="line"><span class="comment">        String line;</span></span><br><span class="line"><span class="comment">        while((line = br.readLine()) != null) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(line);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">//br.close();</span></span><br><span class="line">        <span class="comment">//字节流</span></span><br><span class="line">        <span class="type">ServletInputStream</span> <span class="variable">is</span> <span class="operator">=</span> req.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(arr,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//is.close();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/request/servletDemo07&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="请求域"><a href="#请求域" class="headerlink" title="请求域"></a>请求域</h3><h4 id="请求域-1"><a href="#请求域-1" class="headerlink" title="请求域"></a>请求域</h4><p>request 域：可以在一次请求范围内进行共享数据</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void setAttribute(String name, Object value)</td>
<td>向请求域对象中存储数据</td>
</tr>
<tr>
<td>Object getAttribute(String name)</td>
<td>通过名称获取请求域对象的数据</td>
</tr>
<tr>
<td>void removeAttribute(String name)</td>
<td>通过名称移除请求域对象的数据</td>
</tr>
</tbody></table>
<hr>
<h4 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h4><p>请求转发：客户端的一次请求到达后，需要借助其他 Servlet 来实现功能，进行请求转发。特点：</p>
<ul>
<li>浏览器地址栏不变</li>
<li>域对象中的数据不丢失</li>
<li>负责转发的 Servlet 转发前后响应正文会丢失</li>
<li>由转发目的地来响应客户端</li>
</ul>
<p>HttpServletRequest 类方法：</p>
<ul>
<li><code>RequestDispatcher getRequestDispatcher(String path) </code> : 获取任务调度对象</li>
</ul>
<p>RequestDispatcher 类方法：</p>
<ul>
<li><code>void forward(ServletRequest request, ServletResponse response)</code> : 实现转发，将请求从 Servlet 转发到服务器上的另一个资源（Servlet，JSP 文件或 HTML 文件）</li>
</ul>
<p>过程：浏览器访问 <a href="http://localhost:8080/request/servletDemo09%EF%BC%8C/servletDemo10%E4%B9%9F%E4%BC%9A%E6%89%A7%E8%A1%8C">http://localhost:8080/request/servletDemo09，/servletDemo10也会执行</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo09&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo09</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置共享数据</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;encoding&quot;</span>,<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        <span class="comment">//获取请求调度对象</span></span><br><span class="line">        <span class="type">RequestDispatcher</span> <span class="variable">rd</span> <span class="operator">=</span> req.getRequestDispatcher(<span class="string">&quot;/servletDemo10&quot;</span>);</span><br><span class="line">        <span class="comment">//实现转发功能</span></span><br><span class="line">        rd.forward(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo10&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo10</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取共享数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">encoding</span> <span class="operator">=</span> req.getAttribute(<span class="string">&quot;encoding&quot;</span>);</span><br><span class="line">        System.out.println(encoding);<span class="comment">//gbk</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;servletDemo10执行了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="请求包含"><a href="#请求包含" class="headerlink" title="请求包含"></a>请求包含</h4><p>请求包含：合并其他的 Servlet 中的功能一起响应给客户端。特点：</p>
<ul>
<li>浏览器地址栏不变</li>
<li>域对象中的数据不丢失</li>
<li>被包含的 Servlet 响应头会丢失</li>
</ul>
<p>请求转发的注意事项：负责转发的 Servlet，转发前后的响应正文丢失，由转发目的地来响应浏览器</p>
<p>请求包含的注意事项：被包含者的响应消息头丢失，因为它被包含者包含起来了</p>
<p>HttpServletRequest 类方法：</p>
<ul>
<li><code>RequestDispatcher getRequestDispatcher(String path) </code> : 获取任务调度对象</li>
</ul>
<p>RequestDispatcher 类方法：</p>
<ul>
<li><code>void include(ServletRequest request, ServletResponse response) </code> : 实现包含。包括响应中资源的内容（servlet，JSP页面，HTML文件）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo11&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo11</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servletDemo11执行了...&quot;</span>);<span class="comment">//执行了</span></span><br><span class="line">        <span class="comment">//获取请求调度对象</span></span><br><span class="line">        <span class="type">RequestDispatcher</span> <span class="variable">rd</span> <span class="operator">=</span> req.getRequestDispatcher(<span class="string">&quot;/servletDemo12&quot;</span>);</span><br><span class="line">        <span class="comment">//实现包含功能</span></span><br><span class="line">        rd.include(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">**********************************************************************************</span><br><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo12&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo12</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servletDemo12执行了...&quot;</span>);<span class="comment">//输出了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h3><p>请求体</p>
<ul>
<li><p>POST：<code>void setCharacterEncoding(String env)</code>：设置请求体的编码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo08&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo08</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置编码格式</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>GET：Tomcat8.5 版本及以后，Tomcat 服务器已经帮我们解决</p>
</li>
</ul>
<hr>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><h3 id="响应对象"><a href="#响应对象" class="headerlink" title="响应对象"></a>响应对象</h3><p>响应，服务器把请求的处理结果告知客户端</p>
<p>响应对象：在 JavaEE 工程中，用于发送响应的对象</p>
<ul>
<li>协议无关的对象标准是：ServletResponse 接口</li>
<li>协议相关的对象标准是：HttpServletResponse 接口</li>
</ul>
<p>Response 的作用：</p>
<ul>
<li>操作响应的三部分(行, 头, 体)</li>
</ul>
<ul>
<li>请求重定向</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Response%E5%93%8D%E5%BA%94%E7%B1%BB%E8%A7%86%E5%9B%BE.png"></p>
<hr>
<h3 id="操作响应行"><a href="#操作响应行" class="headerlink" title="操作响应行"></a>操作响应行</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int getStatus()</td>
<td>Gets the current status code of this response</td>
</tr>
<tr>
<td>void setStatus(int sc)</td>
<td>Sets the status code for this response</td>
</tr>
</tbody></table>
<p>状态码：（HTTP–&gt;相应部分）</p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1xx</td>
<td align="center">消息</td>
</tr>
<tr>
<td align="center">2xx</td>
<td align="center">成功</td>
</tr>
<tr>
<td align="center">3xx</td>
<td align="center">重定向</td>
</tr>
<tr>
<td align="center">4xx</td>
<td align="center">客户端错误</td>
</tr>
<tr>
<td align="center">5xx</td>
<td align="center">服务器错误</td>
</tr>
</tbody></table>
<hr>
<h3 id="操作响应体"><a href="#操作响应体" class="headerlink" title="操作响应体"></a>操作响应体</h3><h4 id="字节流响应"><a href="#字节流响应" class="headerlink" title="字节流响应"></a>字节流响应</h4><p>响应体对应<strong>乱码问题</strong></p>
<p>项目中常用的编码格式是UTF-8，而浏览器默认使用的编码是gbk。导致乱码！</p>
<p>解决方式：<br>    一：修改浏览器的编码格式(不推荐，不能让用户做修改的动作)<br>    二：通过输出流写出一个标签：&lt;meta http-equiv&#x3D;’content-type’content&#x3D;’text&#x2F;html;charset&#x3D;UTF-8’&gt;<br>    三：指定响应头信息：response.setHeader(“Content-Type”,”text&#x2F;html;charset&#x3D;UTF-8”)<br>    四：response.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”)</p>
<p>常用API：<br>    <code>ServletOutputStream getOutputStream()</code> : 获取响应字节输出流对象<br>    <code>void setContenType(&quot;text/html;charset=UTF-8&quot;)</code> : 设置响应内容类型，解决中文乱码问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo01</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.设置响应内容类型</span></span><br><span class="line">		resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//2.通过响应对象获取字节输出流对象</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">sos</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line">        <span class="comment">//3.定义消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">        <span class="comment">//4.通过字节流输出对象</span></span><br><span class="line">        sos.write(str.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="字符流响应"><a href="#字符流响应" class="headerlink" title="字符流响应"></a>字符流响应</h4><p>response得到的字符流和字节流互斥，只能选其一，response获取的流不用关闭，由服务器关闭即可。</p>
<p>常用API：<br>    <code>PrintWriter getWriter()</code> : 获取响应字节输出流对象，可以发送标签<br>    <code>void setContenType(&quot;text/html;charset=UTF-8&quot;)</code> : 设置响应内容类型，解决中文乱码问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">    <span class="comment">//解决中文乱码</span></span><br><span class="line">    resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">//获取字符流对象</span></span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">    pw.write(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="响应图片"><a href="#响应图片" class="headerlink" title="响应图片"></a>响应图片</h4><p>响应图片到浏览器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo03&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo03</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.通过文件的相对路径来获取文件的绝对路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> getServletContext().getRealPath(<span class="string">&quot;/img/hm.png&quot;</span>);</span><br><span class="line">        <span class="comment">//E:\Project\JavaEE\out\artifacts\Response_war_exploded\img\hm.png</span></span><br><span class="line">        System.out.println(realPath);</span><br><span class="line">        <span class="comment">//2.创建字节输入流对象，关联图片路径</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过响应对象获取字节输出流对象</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">sos</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.循环读写</span></span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sos.write(arr,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="操作响应头"><a href="#操作响应头" class="headerlink" title="操作响应头"></a>操作响应头</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>响应头: 是服务器指示浏览器去做什么</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String getHeader(String name)</td>
<td>获取指定响应头的内容</td>
</tr>
<tr>
<td>Collection<String> getHeaders(String name)</String></td>
<td>获取指定响应头的多个值</td>
</tr>
<tr>
<td>Collection<String> getHeaderNames()</String></td>
<td>获取所有响应头名称的枚举</td>
</tr>
<tr>
<td>void setHeader(String name, String value)</td>
<td>设置响应头</td>
</tr>
<tr>
<td>void setDateHeader(String name, long date)</td>
<td>设置具有给定名称和日期值的响应消息头</td>
</tr>
<tr>
<td>void sendRedirect(String location)</td>
<td>设置重定向</td>
</tr>
</tbody></table>
<p>setHeader常用响应头：</p>
<ul>
<li>Expires：设置缓存时间</li>
<li>Refresh：定时跳转</li>
<li>Location：重定向地址</li>
<li>Content-Disposition: 告诉浏览器下载</li>
<li>Content-Type：设置响应内容的MIME类型(服务器告诉浏览器内容的类型)</li>
</ul>
<hr>
<h4 id="控制缓存"><a href="#控制缓存" class="headerlink" title="控制缓存"></a>控制缓存</h4><p>缓存：对于不经常变化的数据，我们可以设置合理的缓存时间，防止浏览器频繁的请求服务器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo04&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo04</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">news</span> <span class="operator">=</span> <span class="string">&quot;设置缓存时间&quot;</span>;</span><br><span class="line">        <span class="comment">//设置缓存时间，缓存一小时</span></span><br><span class="line">        resp.setDateHeader(<span class="string">&quot;Expires&quot;</span>,System.currentTimeMillis()+<span class="number">1</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">//设置编码格式</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//写出数据</span></span><br><span class="line">        resp.getWriter().write(news);</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);<span class="comment">//只输出一次，不能刷新，必须从网址直接进入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Response%E8%AE%BE%E7%BD%AE%E7%BC%93%E5%AD%98%E6%97%B6%E9%97%B4.png"></p>
<hr>
<h4 id="定时刷新"><a href="#定时刷新" class="headerlink" title="定时刷新"></a>定时刷新</h4><p>定时刷新：过了指定时间后，页面进行自动跳转</p>
<p>格式：<code>setHeader(&quot;Refresh&quot;, &quot;3;URL=https://www.baidu.com&quot;&quot;);</code><br>            Refresh设置的时间单位是秒，如果刷新到其他地址，需要在时间后面拼接上地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo05&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo05</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">news</span> <span class="operator">=</span> <span class="string">&quot;您的用户名或密码错误，3秒后自动跳转到登录页面...&quot;</span>;</span><br><span class="line">        <span class="comment">//设置编码格式</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//写出数据</span></span><br><span class="line">        resp.getWriter().write(news);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置响应消息头定时刷新</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Refresh&quot;</span>,<span class="string">&quot;3;URL=/response/login.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo06&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo06</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建字节输入流对象，关联读取的文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> getServletContext().getRealPath(<span class="string">&quot;/img/hm.png&quot;</span>);<span class="comment">//绝对路径</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.设置响应头支持的类型  应用支持的类型为字节流</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Content-Type 消息头名称   支持的类型</span></span><br><span class="line"><span class="comment">            application/octet-stream   消息头参数  应用类型为字节流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;application/octet-stream&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.设置响应头以下载方式打开  以附件形式处理内容</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Content-Disposition  消息头名称  处理的形式</span></span><br><span class="line"><span class="comment">            attachment;filename=  消息头参数  附件形式进行处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment;filename=&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取字节输出流对象</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">sos</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.循环读写文件</span></span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sos.write(arr,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.释放资源</span></span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><h5 id="实现重定向"><a href="#实现重定向" class="headerlink" title="实现重定向"></a>实现重定向</h5><p>请求重定向：客户端的一次请求到达后，需要借助其他 Servlet 来实现功能。特点：</p>
<ol>
<li>重定向两次请求</li>
<li>重定向的地址栏路径改变</li>
<li><strong>重定向的路径写绝对路径</strong>（带域名 &#x2F;ip 地址，如果是同一个项目，可以省略域名 &#x2F;ip 地址）</li>
<li>重定向的路径可以是项目内部的,也可以是项目以外的（百度）</li>
<li>重定向不能重定向到 WEB-INF 下的资源</li>
<li>把数据存到 request 域里面，重定向不可用</li>
</ol>
<p>实现方式：</p>
<ul>
<li><p>方式一：</p>
<ol>
<li>设置响应状态码：<code>resp.setStatus(302)</code></li>
<li>设置重定向的路径（响应到哪里，通过响应头 location 来指定）<ul>
<li><code>response.setHeader(&quot;Location&quot;,&quot;http://www.baidu.com&quot;);</code></li>
<li><code>response.setHeader(&quot;Location&quot;,&quot;/response/servletDemo08);</code></li>
</ul>
</li>
</ol>
</li>
<li><p>方式二：</p>
<ul>
<li><code> resp.sendRedirect(&quot;重定向的路径&quot;);</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo07&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo07</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置请求域数据</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置重定向</span></span><br><span class="line">        resp.sendRedirect(req.getContextPath() + <span class="string">&quot;/servletDemo07&quot;</span>);</span><br><span class="line">		<span class="comment">// resp.sendRedirect(&quot;https://www.baidu.com&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo08&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo08</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servletDemo08执行了...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">username</span> <span class="operator">=</span> req.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="重定向和转发"><a href="#重定向和转发" class="headerlink" title="重定向和转发"></a>重定向和转发</h5><p>请求重定向跳转的特点：</p>
<ol>
<li>重定向是由<strong>浏览器发起</strong>的，在这个过程中浏览器会发起<strong>两次请求</strong></li>
<li>重定向可以跳转到任意服务器的资源，但是<strong>无法跳转到WEB-INF中的资源</strong></li>
<li>重定向不能和请求域对象共享数据，数据会丢失</li>
<li>重定向浏览器的地址栏中的地址会变成跳转到的路径</li>
</ol>
<p>请求转发跳转的特点：</p>
<ol>
<li>请求转发是由<strong>服务器发起</strong>的，在这个过程中浏览器只会发起<strong>一次请求</strong></li>
<li>请求转发只能跳转到本项目的资源，但是<strong>可以跳转到WEB-INF中的资源</strong></li>
<li>请求转发可以和请求域对象共享数据，数据不会丢失</li>
<li>请求转发浏览器地址栏不变</li>
</ol>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%AF%B9%E6%AF%94%E5%9B%BE.jpg"></p>
<hr>
<h3 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h3><p><strong>完整URL地址：</strong></p>
<ol>
<li>协议：http:&#x2F;&#x2F;</li>
<li>服务器主机地址：127.0.0.1  or localhost</li>
<li>服务器端口号：8080</li>
<li>项目的虚拟路径(部署路径)：&#x2F;response</li>
<li>具体的项目上资源路径   &#x2F;login.html      or     Demo 的Servlet映射路径</li>
</ol>
<p> <strong>相对路径：</strong></p>
<p>不以”&#x2F;“开头的路径写法，它是以目标路径相对当前文件的路径，其中”..”表示上一级目录。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world....<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        目标资源的url: http://localhost:8080/response/demo05</span></span><br><span class="line"><span class="comment">        当前资源的url: http://localhost:8080/response/pages/demo.html</span></span><br><span class="line"><span class="comment">        相对路径的优劣:</span></span><br><span class="line"><span class="comment">            1. 优势: 无论部署的项目名怎么改变，我的路径都不需要改变</span></span><br><span class="line"><span class="comment">            2. 劣势: 如果当前资源的位置发生改变，那么相对路径就必定要发生改变--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;../demo05&quot;</span>&gt;</span>访问ServletDemo05<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>绝对路径：</strong></p>
<p>绝对路径就是以”&#x2F;“开头的路径写法，项目部署的路径</p>
<hr>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h3><p><strong>会话</strong>：浏览器和服务器之间的多次请求和响应</p>
<p>浏览器和服务器可能产生多次的请求和响应，从浏览器访问服务器开始，到访问服务器结束（关闭浏览器、到了过期时间），这期间产生的多次请求和响应加在一起称为浏览器和服务器之间的一次对话</p>
<p>作用：保存用户各自的数据（以浏览器为单位），在多次请求间实现数据共享</p>
<p><strong>常用的会话管理技术</strong>：</p>
<ul>
<li><p>Cookie：客户端会话管理技术，用户浏览的信息以键值对（key&#x3D;value）的形式保存在浏览器上。如果没有关闭浏览器，再次访问服务器，会把 cookie 带到服务端，服务端就可以做相应的处理</p>
</li>
<li><p>Session：服务端会话管理技术。当客户端第一次请求 session 对象时，服务器为每一个浏览器开辟一块内存空间，并将通过特殊算法算出一个 session 的 ID，用来标识该 session 对象。由于内存空间是每一个浏览器独享的，所有用户在访问的时候，可以把信息保存在 session 对象中，同时服务器会把 sessionId 写到 cookie 中，再次访问的时候，浏览器会把 cookie(sessionId) 带过来，找到对应的 session 对象即可</p>
<p>tomcat 生成的 sessionID 叫做 jsessionID</p>
</li>
</ul>
<p>两者区别：</p>
<ul>
<li><p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie，应该将 Cookie 信息加密然后使用到的时候再去服务器端解密</p>
</li>
<li><p>Cookie 一般用来保存用户信息，在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候就不需要重新登录，因为用户登录的时候可以存放一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可（为了安全考虑，重新登录一般要将 Token 重写），所以登录一次网站后访问网站其他页面不需要重新登录</p>
</li>
<li><p>Session 通过服务端记录用户的状态，服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户</p>
</li>
<li><p>Cookie 只能存储 ASCII 码，而 Session 可以存储任何类型的数据</p>
</li>
</ul>
<p>参考文章：<a href="https://blog.csdn.net/weixin_43625577/article/details/92393581">https://blog.csdn.net/weixin_43625577/article/details/92393581</a></p>
<hr>
<h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Cookie：客户端会话管理技术，把要共享的数据保存到了客户端（也就是浏览器端）。每次请求时，把会话信息带到服务器，从而实现多次请求的数据共享。</p>
<p>作用：保存客户浏览器访问网站的相关内容（需要客户端不禁用 Cookie），从而在每次访问同一个内容时，先从本地缓存获取，使资源共享，提高效率。</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Cookie%E7%B1%BB%E8%AE%B2%E8%A7%A3.png"></p>
<hr>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><ul>
<li><p><strong>Cookie属性：</strong></p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>属性作用</th>
<th>是否重要</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>cookie的名称</td>
<td>必要属性</td>
</tr>
<tr>
<td>value</td>
<td>cookie的值（不能是中文）</td>
<td>必要属性</td>
</tr>
<tr>
<td>path</td>
<td>cookie的路径</td>
<td>重要</td>
</tr>
<tr>
<td>domain</td>
<td>cookie的域名</td>
<td>重要</td>
</tr>
<tr>
<td>maxAge</td>
<td>cookie的生存时间</td>
<td>重要</td>
</tr>
<tr>
<td>version</td>
<td>cookie的版本号</td>
<td>不重要</td>
</tr>
<tr>
<td>comment</td>
<td>cookie的说明</td>
<td>不重要</td>
</tr>
</tbody></table>
<p>注意：Cookie 有大小，个数限制。每个网站最多只能存20个 Cookie，且大小不能超过 4kb。同时所有网站的 Cookie 总数不超过300个。</p>
</li>
<li><p><strong>Cookie类API：</strong></p>
<ul>
<li><p><code>Cookie(String name, String value)</code> : 构造方法创建 Cookie 对象</p>
</li>
<li><p>Cookie 属性对应的 set 和 get 方法，name 属性被 final 修饰，没有 set 方法</p>
</li>
</ul>
</li>
<li><p>HttpServletResponse 类 API：</p>
<ul>
<li><code>void addCookie(Cookie cookie)</code>：向客户端添加 Cookie，Adds cookie to the response</li>
</ul>
</li>
<li><p>HttpServletRequest类API：</p>
<ul>
<li><code>Cookie[] getCookies()</code>：获取所有的 Cookie 对象，client sent with this request</li>
</ul>
</li>
</ul>
<hr>
<h4 id="有效期"><a href="#有效期" class="headerlink" title="有效期"></a>有效期</h4><p>如果不设置过期时间，表示这个 Cookie 生命周期为浏览器会话期间，只要关闭浏览器窗口 Cookie 就消失，这种生命期为浏览会话期的 Cookie 被称为会话 Cookie，会话 Cookie 一般不保存在硬盘上而是保存在内存里。</p>
<p>如果设置过期时间，浏览器就会把 Cookie 保存到硬盘上，关闭后再次打开浏览器，这些 Cookie 依然有效直到超过设定的过期时间。存储在硬盘上的 Cookie 可以在<strong>不同的浏览器进程间共享</strong>，比如两个 IE 窗口，而对于保存在内存的 Cookie，不同的浏览器有不同的处理方式</p>
<p>设置 Cookie 存活时间 API：<code>void setMaxAge(int expiry)</code> </p>
<ul>
<li>-1：默认，代表 Cookie 数据存到浏览器关闭（保存在浏览器文件中）</li>
<li>0：代表删除 Cookie，如果要删除 Cookie 要确保<strong>路径一致</strong></li>
<li>正整数：以秒为单位保存数据有有效时间（把缓存数据保存到磁盘中）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo01</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.通过响应对象写出提示信息</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        pw.write(<span class="string">&quot;欢迎访问本网站，您的最后访问时间为：&lt;br&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建Cookie对象，用于记录最后访问时间</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;time&quot;</span>,System.currentTimeMillis()+<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.设置最大存活时间</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">3600</span>);</span><br><span class="line">        <span class="comment">//cookie.setMaxAge(0);    // 立即清除</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.将cookie对象添加到客户端</span></span><br><span class="line">        resp.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.获取cookie</span></span><br><span class="line">        Cookie[] cookies = req.getCookies();</span><br><span class="line">        <span class="keyword">for</span>(Cookie c : cookies) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;time&quot;</span>.equals(c.getName())) &#123;</span><br><span class="line">                <span class="comment">//6.获取cookie对象中的value，进行写出</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> c.getValue();</span><br><span class="line">                <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">                pw.write(sdf.format(Long.parseLong(value)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="有效路径"><a href="#有效路径" class="headerlink" title="有效路径"></a>有效路径</h4><p><code>setPath(String url)</code> : Cookie 设置有效路径</p>
<p>有效路径作用 :</p>
<ol>
<li>保证不会携带别的网站&#x2F;项目里面的 Cookie 到我们自己的项目</li>
<li>路径不一样，Cookie 的 key 可以相同</li>
<li>保证自己的项目可以合理的利用自己项目的 Cookie</li>
</ol>
<p>判断路径是否携带 Cookie：请求资源 URI.startWith(cookie的path)，返回 true 就带</p>
<table>
<thead>
<tr>
<th>访问URL</th>
<th>URI部分</th>
<th>Cookie的Path</th>
<th>是否携带Cookie</th>
<th>能否取到Cookie</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://localhost:8080/servlet/servletDemo02">servletDemo02</a></td>
<td>&#x2F;servlet&#x2F;servletDemo02</td>
<td>&#x2F;servlet&#x2F;</td>
<td>带</td>
<td>能取到</td>
</tr>
<tr>
<td><a href="http://localhost:8080/servlet/servletDemo03">servletDemo03</a></td>
<td>&#x2F;servlet&#x2F;servletDemo03</td>
<td>&#x2F;servlet&#x2F;</td>
<td>带</td>
<td>能取到</td>
</tr>
<tr>
<td><a href="http://localhost:8080/servlet/aaa/servletDemo03">servletDemo04</a></td>
<td>&#x2F;servlet&#x2F;aaa&#x2F;servletDemo04</td>
<td>&#x2F;servlet&#x2F;</td>
<td>带</td>
<td>能取到</td>
</tr>
<tr>
<td><a href="http://localhost:8080/bbb/servletDemo03">servletDemo05</a></td>
<td>&#x2F;bbb&#x2F;servletDemo04</td>
<td>&#x2F;servlet&#x2F;</td>
<td>不带</td>
<td>不能取到</td>
</tr>
</tbody></table>
<p>只有当访问资源的 url 包含此 cookie 的有效 path 的时候，才会携带这个 cookie</p>
<p>想要当前项目下的 Servlet 可以使用该 cookie，一般设置：<code>cookie.setPath(request.getContextPath())</code></p>
<hr>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>如果 Cookie 中设置了 HttpOnly 属性，通过 js 脚本将无法读取到 cookie 信息，这样能有效的防止 XSS 攻击，窃取 cookie 内容，这样就增加了安全性，即便是这样，也不要将重要信息存入cookie。</p>
<p>XSS 全称 Cross SiteScript，跨站脚本攻击，是Web程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有 XSS 漏洞的网站中输入(传入)恶意的 HTML 代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如盗取用户 Cookie、破坏页面结构、重定向到其它网站等。</p>
<hr>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Session：服务器端会话管理技术，本质也是采用客户端会话管理技术，不过在客户端保存的是一个特殊标识，共享的数据保存到了服务器的内存对象中。每次请求时，会将特殊标识带到服务器端，根据标识来找到对应的内存空间，从而实现数据共享。简单说它就是一个服务端会话对象，用于存储用户的会话数据</p>
<p>Session 域（会话域）对象是 Servlet 规范中四大域对象之一，并且它也是用于实现数据共享的</p>
<table>
<thead>
<tr>
<th>域对象</th>
<th>功能</th>
<th>创建</th>
<th>销毁</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>ServletContext</td>
<td>应用域</td>
<td>服务器启动</td>
<td>服务器关闭</td>
<td>在整个应用之间实现数据共享<br>（记录网站访问次数，聊天室）</td>
</tr>
<tr>
<td>ServletRequest</td>
<td>请求域</td>
<td>请求到来</td>
<td>响应了这个请求</td>
<td>在当前请求或者请求转发之间实现数据共享</td>
</tr>
<tr>
<td>HttpSession</td>
<td>会话域</td>
<td>getSession()</td>
<td>session过期，调用invalidate()，服务器关闭</td>
<td>在当前会话范围中实现数据共享，可以在多次请求中实现数据共享。<br>（验证码校验, 保存用户登录状态等）</td>
</tr>
</tbody></table>
<hr>
<h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="获取会话"><a href="#获取会话" class="headerlink" title="获取会话"></a>获取会话</h4><p>HttpServletRequest类获取Session：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>HttpSession getSession()</td>
<td>获取HttpSession对象</td>
</tr>
<tr>
<td>HttpSession getSession(boolean creat)</td>
<td>获取HttpSession对象，未获取到是否自动创建</td>
</tr>
</tbody></table>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Session获取的两个方法.png" style="zoom: 80%;">



<hr>
<h4 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void setAttribute(String name, Object value)</td>
<td>设置会话域中的数据</td>
</tr>
<tr>
<td>Object getAttribute(String name)</td>
<td>获取指定名称的会话域数据</td>
</tr>
<tr>
<td>Enumeration<String> getAttributeNames()</String></td>
<td>获取所有会话域所有属性的名称</td>
</tr>
<tr>
<td>void removeAttribute(String name)</td>
<td>移除会话域中指定名称的数据</td>
</tr>
<tr>
<td>String getId()</td>
<td>获取唯一标识名称，Jsessionid的值</td>
</tr>
<tr>
<td>void invalidate()</td>
<td>立即失效session</td>
</tr>
</tbody></table>
<hr>
<h4 id="实现会话"><a href="#实现会话" class="headerlink" title="实现会话"></a>实现会话</h4><p>通过第一个Servlet设置共享的数据用户名，并在第二个Servlet获取到</p>
<p>项目执行完以后，去浏览器抓包，Request Headers 中的 Cookie JSESSIONID的值是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo01</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.获取请求的用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取HttpSession的对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        System.out.println(session);</span><br><span class="line">        System.out.println(session.getId());</span><br><span class="line">        <span class="comment">//3.将用户名信息添加到共享数据中</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo02&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo02</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.获取HttpSession对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        <span class="comment">//2.获取共享数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">username</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="comment">//3.将数据响应给浏览器</span></span><br><span class="line">        resp.getWriter().write(username+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h4><p>Session 的创建：一个常见的错误是以为 Session 在有客户端访问时就被创建，事实是直到某 server 端程序（如 Servlet）调用 <code>HttpServletRequest.getSession(true)</code> 这样的语句时才会被创建</p>
<p>Session 在以下情况会被删除：</p>
<ul>
<li>程序调用 HttpSession.invalidate()</li>
<li>距离上一次收到客户端发送的 session id 时间间隔超过了 session 的最大有效时间</li>
<li>服务器进程被停止</li>
</ul>
<p>注意事项：</p>
<ul>
<li>客户端只保存 sessionID 到 cookie 中，而不会保存 session</li>
<li>关闭浏览器只会使存储在客户端浏览器内存中的 cookie 失效，不会使服务器端的 session 对象失效，同样也不会使已经保存到硬盘上的持久化cookie消失</li>
</ul>
<p>打开两个浏览器窗口访问应用程序会使用的是不同的session，通常 session cookie 是不能跨窗口使用，当新开了一个浏览器窗口进入相同页面时，系统会赋予一个新的 session id，实现跨窗口信息共享：</p>
<ul>
<li>先把 session id 保存在 persistent cookie 中（通过设置session的最大有效时间）</li>
<li>在新窗口中读出来，就可以得到上一个窗口的 session id，这样通过 session cookie 和 persistent cookie 的结合就可以实现跨窗口的会话跟踪</li>
</ul>
<hr>
<h3 id="会话问题"><a href="#会话问题" class="headerlink" title="会话问题"></a>会话问题</h3><h4 id="禁用Cookie"><a href="#禁用Cookie" class="headerlink" title="禁用Cookie"></a>禁用Cookie</h4><p>浏览器禁用Cookie解决办法：</p>
<ul>
<li><p>方式一：通过提示信息告知用户</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo03&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo03</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.获取HttpSession对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession(<span class="literal">false</span>);</span><br><span class="line">        System.out.println(session);</span><br><span class="line">        <span class="keyword">if</span>(session == <span class="literal">null</span>) &#123;</span><br><span class="line">            resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;为了不影响正常的使用，请不要禁用浏览器的Cookie~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：访问时拼接 jsessionid 标识，通过 encodeURL() 方法<strong>重写地址</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">    <span class="comment">//实现url重写  相当于在地址栏后面拼接了一个jsessionid</span></span><br><span class="line">    resp.getWriter().write(<span class="string">&quot;&lt;a href=&#x27;&quot;</span>+ resp.encodeURL</span><br><span class="line">                           (<span class="string">&quot;http://localhost:8080/session/servletDemo03&quot;</span>) +</span><br><span class="line">                           <span class="string">&quot;&#x27;&gt;go servletDemo03&lt;/a&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="钝化活化"><a href="#钝化活化" class="headerlink" title="钝化活化"></a>钝化活化</h4><p>Session 存放在服务器端的内存中，可以做持久化管理。</p>
<p>钝化：序列化，持久态。把长时间不用，但还不到过期时间的 HttpSession 进行序列化写到磁盘上。</p>
<p>活化：相反的状态</p>
<p>何时钝化：</p>
<ul>
<li>当访问量很大时，服务器会根据getLastAccessTime来进行排序，对长时间不用，但是还没到过期时间的HttpSession进行序列化（持久化）</li>
<li>当服务器进行重启的时候，为了保持客户HttpSession中的数据，也要对HttpSession进行序列化（持久化）</li>
</ul>
<p>注意：</p>
<ul>
<li>HttpSession的持久化由服务器来负责管理，我们不用关心</li>
<li>只有实现了序列化接口的类才能被序列化</li>
</ul>
<hr>
<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><h3 id="JSP概述"><a href="#JSP概述" class="headerlink" title="JSP概述"></a>JSP概述</h3><p>JSP(Java Server Page)：是一种动态网页技术标准。（页面技术）</p>
<p>JSP是基于Java语言的，它的本质就是Servlet，一个特殊的Servlet。</p>
<p>JSP部署在服务器上，可以处理客户端发送的请求，并根据请求内容动态的生成HTML、XML或其他格式文档的Web网页，然后响应给客户端。</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>HTML</td>
<td>开发静态资源，不能包含java代码，无法添加动态数据。</td>
</tr>
<tr>
<td>CSS</td>
<td>美化页面</td>
</tr>
<tr>
<td>JavaScript</td>
<td>给网页添加动态效果</td>
</tr>
<tr>
<td>Servlet</td>
<td>编写java代码，实现后台功能处理，但是很不方便，开发效率低。</td>
</tr>
<tr>
<td>JSP</td>
<td>包括了显示页面技术，同时具备Servlet输出动态资源的能力。但是不适合作为控制器来用。</td>
</tr>
</tbody></table>
<h3 id="执行原理-1"><a href="#执行原理-1" class="headerlink" title="执行原理"></a>执行原理</h3><ul>
<li><p>新建JavaEE工程，编写index.jsp文件</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;JSP的入门&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">      这是第一个JSP页面</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><p>执行过程：</p>
<p>客户端提交请求——Tomcat服务器解析请求地址——找到JSP页面——Tomcat将JSP页面翻译成Servlet的java文件——将翻译好的.java文件编译成.class文件——返回到客户浏览器上</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/JSP%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png"></p>
</li>
<li><p>溯源，打开JSP翻译后的Java文件</p>
<p><code>public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase</code>，<code>public abstract class HttpJspBase extends HttpServlet implements HttpJspPage</code>，HttpJspBase是个抽象类继承HttpServlet，所以JSP本质上继承HttpServlet</p>
<p>在文件中找到了输出页面的代码，本质都是用out.write()输出的JSP语句</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Jsp%E7%9A%84%E6%9C%AC%E8%B4%A8%E8%AF%B4%E6%98%8E.png"></p>
</li>
<li><p>总结：<br>JSP它是一个特殊的Servlet，主要是用于展示动态数据。它展示的方式是用流把数据输出出来，而我们在使用JSP时，涉及HTML的部分，都与HTML的用法一致，这部分称为jsp中的模板元素，决定了页面的外观。</p>
</li>
</ul>
<hr>
<h3 id="JSP语法"><a href="#JSP语法" class="headerlink" title="JSP语法"></a>JSP语法</h3><ul>
<li><p>JSP注释：</p>
<table>
<thead>
<tr>
<th>注释类型</th>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>JSP注释</td>
<td>&lt;%–注释内容–%&gt;</td>
<td>被jsp注释的部分不会被翻译成.java文件，不会在浏览器上显示</td>
</tr>
<tr>
<td>HTML注释</td>
<td><!--HTML注释--></td>
<td>在Jsp中可以使用html的注释，但是只能注释html元素<br>被html注释部分会参与翻译，并且会在浏览器上显示</td>
</tr>
<tr>
<td>Java注释</td>
<td>&#x2F;&#x2F;; &#x2F;* *&#x2F;</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>Java代码块</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;% 此处写java代码 %&gt;</span><br><span class="line">&lt;%--由tomcat负责翻译，翻译之后是service方法的成员变量--%&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSP表达式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%=表达式%&gt;</span><br><span class="line">&lt;%--翻译成Service()方法里面的内容,相当于调用out.print()--%&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSP声明</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%! 声明的变量或方法 %&gt;</span><br><span class="line">&lt;%--翻译成Servlet类里面的内容--%&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><p>语法示例：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;jsp语法&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%--<span class="number">1.</span> 这是注释--%&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%--</span><br><span class="line">        <span class="number">2.</span>java代码块</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello JSP&quot;</span>); 普通输出语句，输出在控制台!!</span><br><span class="line">        out.println(<span class="string">&quot;Hello JSP&quot;</span>);out是JspWriter对象，输出在页面上</span><br><span class="line">    --%&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello JSP&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;Hello JSP&lt;br&gt;&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&lt;br&gt;&quot;</span>;</span><br><span class="line">        out.println(str);</span><br><span class="line">    %&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%--</span><br><span class="line">        <span class="number">3.</span>jsp表达式,相当于 out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    --%&gt;</span><br><span class="line">    &lt;%=<span class="string">&quot;Hello&lt;br&gt;&quot;</span>%&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%--</span><br><span class="line">        <span class="number">4.</span>jsp中的声明(变量或方法)</span><br><span class="line">        如果加!  代表的是声明的是成员变量</span><br><span class="line">        如果不加!  代表的是声明的是局部变量,页面显示abc</span><br><span class="line">    --%&gt;</span><br><span class="line">    &lt;%! <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;%&gt;</span><br><span class="line">    &lt;% <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;def&quot;</span>;%&gt;</span><br><span class="line">    &lt;%=s%&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;%! <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">()</span>&#123;&#125;%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">控制台输出：Hello JSP</span><br><span class="line">页面输出：</span><br><span class="line">	Hello JSP</span><br><span class="line">	hello</span><br><span class="line">	Hello</span><br><span class="line">	def</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="JSP指令"><a href="#JSP指令" class="headerlink" title="JSP指令"></a>JSP指令</h3><ul>
<li><p><strong>page指令：</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;%@ page  属性名=属性值 属性名=属性值... %&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>contentType</td>
<td>设置响应正文支持的MIME类型和编码格式：contentType&#x3D;”text&#x2F;html;charset&#x3D;UTF-8”</td>
</tr>
<tr>
<td>language</td>
<td>告知引擎，脚本使用的语言，默认为Java</td>
</tr>
<tr>
<td>errorPage</td>
<td>当前页面出现异常后跳转的页面</td>
</tr>
<tr>
<td>isErrorPage</td>
<td>是否抓住异常。值为true页面中就能使用exception对象，打印异常信息。默认值false</td>
</tr>
<tr>
<td>import</td>
<td>导入哪些包（类）&lt;%@ page import&#x3D;”java.util.ArrayList” %&gt;</td>
</tr>
<tr>
<td>session</td>
<td>是否创建HttpSession对象，默认是true</td>
</tr>
<tr>
<td>buffer</td>
<td>设定JspWriter用s输出jsp内容的缓存大小。默认8kb</td>
</tr>
<tr>
<td>pageEncoding</td>
<td>翻译jsp时所用的编码格式，pageEncoding&#x3D;”UTF-8”相当于用UTF-8读取JSP</td>
</tr>
<tr>
<td>isELIgnored</td>
<td>是否忽略EL表达式，默认值是false</td>
</tr>
</tbody></table>
<p>Note：当使用全局错误页面，就无须配置errorPage实现跳转错误页面，而是由服务器负责跳转到错误页面</p>
<ul>
<li><p>配置全局错误页面：web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.Exception<span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span>    			</span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span> </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>include指令：</strong>包含其他页面</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;%@include file=&quot;被包含的页面&quot; %&gt;</span><br></pre></td></tr></table></figure>

<p>属性：file，以&#x2F;开头，就代表当前应用</p>
</li>
<li><p><strong>taglib指令：</strong>引入外部标签库</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;%taglib uri=&quot;标签库的地址&quot; prefix=&quot;前缀名称&quot;%&gt;</span><br></pre></td></tr></table></figure>

<p>html标签和jsp标签不用引入</p>
</li>
</ul>
<hr>
<h3 id="隐式对象"><a href="#隐式对象" class="headerlink" title="隐式对象"></a>隐式对象</h3><h4 id="九大隐式对象"><a href="#九大隐式对象" class="headerlink" title="九大隐式对象"></a>九大隐式对象</h4><p>隐式对象：在jsp中可以不声明就直接使用的对象。它只存在于jsp中，因为java类中的变量必须要先声明再使用。<br>jsp中的隐式对象也并不是未声明，它是在翻译成.java文件时声明的，所以我们在jsp中可以直接使用。</p>
<table>
<thead>
<tr>
<th>隐式对象名称</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>request</td>
<td>javax.servlet.http.HttpServletRequest</td>
<td></td>
</tr>
<tr>
<td>response</td>
<td>javax.servlet.http.HttpServletResponse</td>
<td></td>
</tr>
<tr>
<td>session</td>
<td>javax.servlet.http.HttpSession</td>
<td>Page指令可以控制开关</td>
</tr>
<tr>
<td>application</td>
<td>javax.servlet.ServletContext</td>
<td></td>
</tr>
<tr>
<td>page</td>
<td>Java.lang.Object</td>
<td>当前jsp对应的servlet引用实例</td>
</tr>
<tr>
<td>config</td>
<td>javax.servlet.ServletConfig</td>
<td></td>
</tr>
<tr>
<td>exception</td>
<td>java.lang.Throwable</td>
<td>page指令有开关</td>
</tr>
<tr>
<td>out</td>
<td>javax.servlet.jsp.JspWriter</td>
<td>字符输出流，相当于printwriter</td>
</tr>
<tr>
<td>pageContext</td>
<td>javax.servlet.jsp.PageContext</td>
<td>很重要，页面域</td>
</tr>
</tbody></table>
<h4 id="PageContext"><a href="#PageContext" class="headerlink" title="PageContext"></a>PageContext</h4><ul>
<li><p>PageContext对象特点：</p>
<ul>
<li>PageContextd对象是JSP独有的对象，Servlet中没有</li>
<li>PageContextd对象是一个<strong>页面域（作用范围）对象</strong>，还可以操作其他三个域对象中的属性</li>
<li>PageContextd对象<strong>可以获取其他八个隐式对象</strong></li>
<li>PageContextd对象是一个局部变量，它的生命周期随着JSP的创建而诞生，随着JSP的结束而消失。每个JSP页面都有一个独立的PageContext</li>
</ul>
</li>
<li><p>PageContext方法如下，页面域操作的方法定义在了PageContext的父类JspContext中</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/PageContext%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3.png"></p>
</li>
</ul>
<hr>
<h3 id="四大域对象"><a href="#四大域对象" class="headerlink" title="四大域对象"></a>四大域对象</h3><table>
<thead>
<tr>
<th>域对象名称</th>
<th>范围</th>
<th>级别</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>PageContext</td>
<td>页面范围</td>
<td>最小，只能在当前页面用</td>
<td>因范围太小，开发中用的很少</td>
</tr>
<tr>
<td>ServletRequest</td>
<td>请求范围</td>
<td>一次请求或当期请求转发用</td>
<td>当请求转发之后，再次转发时请求域丢失</td>
</tr>
<tr>
<td>HttpSession</td>
<td>会话范围</td>
<td>多次请求数据共享时使用</td>
<td>多次请求共享数据，但不同的客户端不能共享</td>
</tr>
<tr>
<td>ServletContext</td>
<td>应用范围</td>
<td>最大，整个应用都可以使用</td>
<td>尽量少用，如果对数据有修改需要做同步处理</td>
</tr>
</tbody></table>
<hr>
<h3 id="MVC模型"><a href="#MVC模型" class="headerlink" title="MVC模型"></a>MVC模型</h3><p>M : model， 通常用于封装数据，封装的是数据模型<br>V :  view，通常用于展示数据。动态展示用jsp页面，静态数据展示用html<br>C :  controller，通常用于处理请求和响应，一般指的是Servlet</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/MVC%E6%A8%A1%E5%9E%8B.png"></p>
<hr>
<h2 id="EL"><a href="#EL" class="headerlink" title="EL"></a>EL</h2><h3 id="EL概述"><a href="#EL概述" class="headerlink" title="EL概述"></a>EL概述</h3><p>EL表达式：Expression Language，意为表达式语言。它是Servlet规范中的一部分，是JSP2.0规范加入的内容。</p>
<p>EL表达式作用：在JSP页面中获取数据，让JSP脱离java代码块和JSP表达式</p>
<p>EL表达式格式： <code>$&#123;表达式内容&#125;</code></p>
<p>EL表达式特点：</p>
<ul>
<li>有明确的<strong>返回值</strong></li>
<li>把内容输出到<strong>页面</strong>上</li>
<li><strong>只能在四大域对象中获取数据</strong>，不在四大域对象中的数据取不到。</li>
</ul>
<hr>
<h3 id="EL用法"><a href="#EL用法" class="headerlink" title="EL用法"></a>EL用法</h3><h4 id="多种类型"><a href="#多种类型" class="headerlink" title="多种类型"></a>多种类型</h4><p>EL表达式可以获取不同类型数据，前提是数据放入四大域对象。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;bean.Student&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.ArrayList&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.HashMap&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;EL表达式获取不同类型数据&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%--<span class="number">1.</span>获取基本数据类型--%&gt;</span><br><span class="line">    &lt;% pageContext.setAttribute(<span class="string">&quot;num&quot;</span>,<span class="number">10</span>); %&gt;</span><br><span class="line">    基本数据类型：$&#123;num&#125; &lt;br&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%--<span class="number">2.</span>获取自定义对象类型--%&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        pageContext.setAttribute(<span class="string">&quot;stu&quot;</span>,stu);</span><br><span class="line">    %&gt;</span><br><span class="line">    自定义对象：$&#123;stu&#125; &lt;br&gt;</span><br><span class="line">    &lt;%--stu.name 实现原理 getName()--%&gt;</span><br><span class="line">    学生姓名：$&#123;stu.name&#125; &lt;br&gt;</span><br><span class="line">    学生年龄：$&#123;stu.age&#125; &lt;br&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%--<span class="number">3.</span>获取数组类型--%&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">        pageContext.setAttribute(<span class="string">&quot;arr&quot;</span>,arr);</span><br><span class="line">    %&gt;</span><br><span class="line">    数组：$&#123;arr&#125;  &lt;br&gt;</span><br><span class="line">    <span class="number">0</span>索引元素：$&#123;arr[<span class="number">0</span>]&#125; &lt;br&gt;</span><br><span class="line">    <span class="number">1</span>索引元素：$&#123;arr[<span class="number">1</span>]&#125; &lt;br&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%--<span class="number">4.</span>获取List集合--%&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        pageContext.setAttribute(<span class="string">&quot;list&quot;</span>,list);</span><br><span class="line">    %&gt;</span><br><span class="line">    List集合：$&#123;list&#125; &lt;br&gt;</span><br><span class="line">    <span class="number">0</span>索引元素：$&#123;list[<span class="number">0</span>]&#125; &lt;br&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%--<span class="number">5.</span>获取Map集合--%&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        HashMap&lt;String,Student&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;hm01&quot;</span>,<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        map.put(<span class="string">&quot;hm02&quot;</span>,<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">24</span>));</span><br><span class="line">        pageContext.setAttribute(<span class="string">&quot;map&quot;</span>,map);</span><br><span class="line">    %&gt;</span><br><span class="line">    Map集合：$&#123;map&#125;  &lt;br&gt;</span><br><span class="line">    第一个学生对象：$&#123;map.hm01&#125;  &lt;br&gt;</span><br><span class="line">    第一个学生对象的姓名：$&#123;map.hm01.name&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;--页面输出效果</span><br><span class="line">基本数据类型：<span class="number">10</span></span><br><span class="line">自定义对象：bean.Student@5f8da92c   (地址)</span><br><span class="line">学生姓名：张三</span><br><span class="line">学生年龄：<span class="number">23</span></span><br><span class="line">数组：[Ljava.lang.String;@4b3bd520</span><br><span class="line"><span class="number">0</span>索引元素：hello</span><br><span class="line"><span class="number">1</span>索引元素：world</span><br><span class="line">List集合：[aaa, bbb]</span><br><span class="line"><span class="number">0</span>索引元素：aaa</span><br><span class="line">Map集合：&#123;hm01=bean.Student@4768d250, hm02=bean.Student@67f237d9&#125;</span><br><span class="line">第一个学生对象：bean.Student@4768d250</span><br><span class="line">第一个学生对象的姓名：张三</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="异常问题"><a href="#异常问题" class="headerlink" title="异常问题"></a>异常问题</h4><p>EL表达式的注意事项：</p>
<ol>
<li>EL表达式没有空指针异常</li>
<li>EL表达式没有数组下标越界</li>
<li>EL表达式没有字符串拼接</li>
</ol>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;EL表达式的注意事项&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    第一个：没有空指针异常&lt;br/&gt;</span><br><span class="line">    &lt;% <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;testNull&quot;</span>,str);</span><br><span class="line">    %&gt;</span><br><span class="line">    str：$&#123;testNull&#125;</span><br><span class="line">    &lt;hr/&gt;</span><br><span class="line">    第二个：没有数组下标越界&lt;br/&gt;</span><br><span class="line">    &lt;% String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;strs&quot;</span>,strs);</span><br><span class="line">    %&gt;</span><br><span class="line">    取第一个元素：$&#123;strs[<span class="number">0</span>]&#125;&lt;br/&gt;</span><br><span class="line">    取第六个元素：$&#123;strs[<span class="number">5</span>]&#125;&lt;br/&gt;</span><br><span class="line">    &lt;hr/&gt;</span><br><span class="line">    第三个：没有字符串拼接&lt;br/&gt;</span><br><span class="line">    &lt;%--$&#123;strs[<span class="number">0</span>]+strs[<span class="number">1</span>]&#125;--%&gt;</span><br><span class="line">    拼接：$&#123;strs[<span class="number">0</span>]&#125;+$&#123;strs[<span class="number">1</span>]&#125; &lt;%--注意拼接--%&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;--页面输出效果</span><br><span class="line">第一个：没有空指针异常</span><br><span class="line">str：</span><br><span class="line">第二个：没有数组下标越界</span><br><span class="line">取第一个元素：a</span><br><span class="line">取第六个元素：</span><br><span class="line">第三个：没有字符串拼接</span><br><span class="line">拼接：a+b</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>EL表达式中运算符：</p>
<ul>
<li><p>关系运算符：<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6.png"></p>
</li>
<li><p>逻辑运算符：</p>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp; 或 and</td>
<td>交集</td>
</tr>
<tr>
<td>|| 或 or</td>
<td>并集</td>
</tr>
<tr>
<td>! 或 not</td>
<td>非</td>
</tr>
</tbody></table>
<p>​	  </p>
</li>
<li><p>其他运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>empty</td>
<td>1. 判断对象是否为null<br>2. 判断字符串是否为空字符串<br>3. 判断容器元素是否为0</td>
</tr>
<tr>
<td>条件 ? 表达式1 : 表达式2</td>
<td>三元运算符，条件?真:假</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;EL表达式运算符&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%--empty--%&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;&#125;;</span><br><span class="line">    %&gt;</span><br><span class="line">    $&#123;empty str1&#125; &lt;br&gt;</span><br><span class="line">    $&#123;empty str2&#125; &lt;br&gt;</span><br><span class="line">    $&#123;empty arr&#125; &lt;br&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%--三元运算符。获取性别的数据，在对应的按钮上进行勾选--%&gt;</span><br><span class="line">    &lt;% pageContext.setAttribute(<span class="string">&quot;gender&quot;</span>,<span class="string">&quot;women&quot;</span>); %&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;gender&quot;</span> value=<span class="string">&quot;men&quot;</span> $&#123;gender==<span class="string">&quot;men&quot;</span>?<span class="string">&quot;checked&quot;</span>:<span class="string">&quot;&quot;</span>&#125;&gt;男</span><br><span class="line">    &lt;input type=<span class="string">&quot;radio&quot;</span> name=<span class="string">&quot;gender&quot;</span> value=<span class="string">&quot;women&quot;</span> $&#123;gender==<span class="string">&quot;women&quot;</span>?<span class="string">&quot;checked&quot;</span>:<span class="string">&quot;&quot;</span>&#125;&gt;女</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E6%95%88%E6%9E%9C%E5%9B%BE.png"></p>
<hr>
<h4 id="四大域数据"><a href="#四大域数据" class="headerlink" title="四大域数据"></a>四大域数据</h4><p>EL表达式只能从从四大域中获取数据，调用的就是<code>findAttribute(name,value);</code>方法，根据名称由小到大在域对象中查找，找到就返回，找不到就什么都不显示。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;EL表达式使用细节&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%--获取四大域对象中的数据--%&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        <span class="comment">//pageContext.setAttribute(&quot;username&quot;,&quot;zhangsan&quot;);</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">//session.setAttribute(&quot;username&quot;,&quot;zhangsan&quot;);</span></span><br><span class="line">        <span class="comment">//application.setAttribute(&quot;username&quot;,&quot;zhangsan&quot;);</span></span><br><span class="line">    %&gt;</span><br><span class="line">    $&#123;username&#125; &lt;br&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%--获取JSP中其他八个隐式对象  获取虚拟目录名称--%&gt;</span><br><span class="line">    &lt;%= request.getContextPath()%&gt;</span><br><span class="line">    $&#123;pageContext.request.contextPath&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="EL隐式对象"><a href="#EL隐式对象" class="headerlink" title="EL隐式对象"></a>EL隐式对象</h3><h4 id="EL表达式隐式对象"><a href="#EL表达式隐式对象" class="headerlink" title="EL表达式隐式对象"></a>EL表达式隐式对象</h4><p>EL表达式也为我们提供隐式对象，可以让我们不声明直接来使用，需要注意的是，它和JSP的隐式对象不是同一种事物。</p>
<table>
<thead>
<tr>
<th>EL中的隐式对象</th>
<th>类型</th>
<th>对应JSP隐式对象</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>PageContext</td>
<td>Javax.serlvet.jsp.PageContext</td>
<td>PageContext</td>
<td>完全一样</td>
</tr>
<tr>
<td>ApplicationScope</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>应用层范围</td>
</tr>
<tr>
<td>SessionScope</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>会话范围</td>
</tr>
<tr>
<td>RequestScope</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>请求范围</td>
</tr>
<tr>
<td>PageScope</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>页面层范围</td>
</tr>
<tr>
<td>Header</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>请求消息头key，值是value（一个）</td>
</tr>
<tr>
<td>HeaderValues</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>请求消息头key，值是数组（一个头多个值）</td>
</tr>
<tr>
<td>Param</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>请求参数key，值是value（一个）</td>
</tr>
<tr>
<td>ParamValues</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>请求参数key，值是数组（一个名称多个值）</td>
</tr>
<tr>
<td>InitParam</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>全局参数，key是参数名称，value是参数值</td>
</tr>
<tr>
<td>Cookie</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>Key是cookie的名称，value是cookie对象</td>
</tr>
</tbody></table>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;EL表达式<span class="number">11</span>个隐式对象&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%--pageContext对象 可以获取其他三个域对象和JSP中八个隐式对象--%&gt;</span><br><span class="line">    $&#123;pageContext.request.contextPath&#125; &lt;br&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%--applicationScope sessionScope requestScope pageScope 操作四大域对象中的数据--%&gt;</span><br><span class="line">    &lt;% request.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>); %&gt;</span><br><span class="line">    $&#123;username&#125; &lt;br&gt;</span><br><span class="line">    $&#123;requestScope.username&#125; &lt;br&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%--header headerValues  获取请求头数据--%&gt;</span><br><span class="line">    $&#123;header[<span class="string">&quot;connection&quot;</span>]&#125; &lt;br&gt;</span><br><span class="line">    $&#123;headerValues[<span class="string">&quot;connection&quot;</span>][<span class="number">0</span>]&#125; &lt;br&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%--param paramValues 获取请求参数数据--%&gt;</span><br><span class="line">    $&#123;param.username&#125; &lt;br&gt;</span><br><span class="line">    $&#123;paramValues.hobby[<span class="number">0</span>]&#125; &lt;br&gt;</span><br><span class="line">    $&#123;paramValues.hobby[<span class="number">1</span>]&#125; &lt;br&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%--initParam 获取全局配置参数--%&gt;</span><br><span class="line">    $&#123;initParam[<span class="string">&quot;pname&quot;</span>]&#125;  &lt;br&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%--cookie 获取cookie信息--%&gt;</span><br><span class="line">    $&#123;cookie&#125;  &lt;br&gt; &lt;%--获取Map集合--%&gt;</span><br><span class="line">    $&#123;cookie.JSESSIONID&#125;  &lt;br&gt; &lt;%--获取map集合中第二个元素--%&gt;</span><br><span class="line">    $&#123;cookie.JSESSIONID.name&#125;  &lt;br&gt; &lt;%--获取cookie对象的名称--%&gt;</span><br><span class="line">    $&#123;cookie.JSESSIONID.value&#125; &lt;%--获取cookie对象的值--%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;--页面显示</span><br><span class="line">/el</span><br><span class="line">zhangsan</span><br><span class="line">zhangsan</span><br><span class="line">keep-alive</span><br><span class="line">keep-alive</span><br><span class="line"></span><br><span class="line">bbb</span><br><span class="line">&#123;JSESSIONID=javax.servlet.http.Cookie@435c8431, Idea-5a5d203e=javax.servlet.http.Cookie@46be0b58, Idea-be3279e7=javax.servlet.http.Cookie@4ef6e8e8&#125;</span><br><span class="line">javax.servlet.http.Cookie@435c8431</span><br><span class="line">JSESSIONID</span><br><span class="line">E481B2A845A448AD88A71FD43611FF02    </span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>

<p>在web.xml配置全局参数</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> ******&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置全局参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>pname<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="获取JSP隐式对象"><a href="#获取JSP隐式对象" class="headerlink" title="获取JSP隐式对象"></a>获取JSP隐式对象</h4><p>通过获取页面域对象，获取其他JSP八个隐式对象</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;EL表达式使用细节&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%--获取虚拟目录名称--%&gt;</span><br><span class="line">    &lt;%= request.getContextPath()%&gt;</span><br><span class="line">    $&#123;pageContext.request.contextPath&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;--页面显示</span><br><span class="line">/el /el</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h3><p>JSTL：Java Server Pages Standarded Tag Library，JSP中标准标签库。</p>
<p>作用：提供给开发人员一个标准的标签库，开发人员可以利用这些标签取代JSP页面上的Java代码，从而提高程序的可读性，降低程序的维护难度。</p>
<table>
<thead>
<tr>
<th>组成</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Core</td>
<td>核心标签库</td>
<td>通用逻辑处理</td>
</tr>
<tr>
<td>Fmt</td>
<td>国际化有关</td>
<td>需要不同地域显示不同语言时使用</td>
</tr>
<tr>
<td>Functions</td>
<td>EL函数</td>
<td>EL表达式可以使用的方法</td>
</tr>
<tr>
<td>SQL</td>
<td>操作数据库</td>
<td></td>
</tr>
<tr>
<td>XML</td>
<td>操作XML</td>
<td></td>
</tr>
</tbody></table>
<p>使用：添加jar包，通过taglib导入，prefix属性表示程序调用标签使用的引用名</p>
<table>
<thead>
<tr>
<th>标签名称</th>
<th>功能分类</th>
<th>分类</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>&#96;&lt;c:if test&#x3D;”${A&#x3D;&#x3D;B</td>
<td></td>
<td>C&#x3D;&#x3D;D}”&gt;&#96;</td>
<td>流程控制</td>
</tr>
<tr>
<td><code>&lt;c:choose&gt; ,&lt;c:when&gt;,&lt;c:otherwise&gt;</code></td>
<td>流程控制</td>
<td>核心标签库</td>
<td>用于多个条件判断</td>
</tr>
<tr>
<td><code>&lt;c:foreache&gt;</code></td>
<td>迭代操作</td>
<td>核心标签库</td>
<td>用于循环遍历</td>
</tr>
</tbody></table>
<ul>
<li><p>流程控制</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> prefix=<span class="string">&quot;c&quot;</span>%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;流程控制&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%--向域对象中添加成绩数据--%&gt;</span><br><span class="line">    $&#123;pageContext.setAttribute(<span class="string">&quot;score&quot;</span>,<span class="string">&quot;T&quot;</span>)&#125;</span><br><span class="line"></span><br><span class="line">    &lt;%--对成绩进行判断--%&gt;</span><br><span class="line">    &lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;score eq &#x27;A&#x27;&#125;&quot;</span>&gt;</span><br><span class="line">        优秀</span><br><span class="line">    &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%--对成绩进行多条件判断--%&gt;</span><br><span class="line">    &lt;c:choose&gt;</span><br><span class="line">        &lt;c:when test=<span class="string">&quot;$&#123;score eq &#x27;A&#x27;&#125;&quot;</span>&gt;优秀&lt;/c:when&gt;</span><br><span class="line">        &lt;c:when test=<span class="string">&quot;$&#123;score eq &#x27;B&#x27;&#125;&quot;</span>&gt;良好&lt;/c:when&gt;</span><br><span class="line">        &lt;c:when test=<span class="string">&quot;$&#123;score eq &#x27;C&#x27;&#125;&quot;</span>&gt;及格&lt;/c:when&gt;</span><br><span class="line">        &lt;c:when test=<span class="string">&quot;$&#123;score eq &#x27;D&#x27;&#125;&quot;</span>&gt;较差&lt;/c:when&gt;</span><br><span class="line">        &lt;c:otherwise&gt;成绩非法&lt;/c:otherwise&gt;</span><br><span class="line">    &lt;/c:choose&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代操作<br>c:forEach：用来遍历集合，属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>items</td>
<td>指定要遍历的集合，它可以是用EL表达式取出来的元素</td>
</tr>
<tr>
<td>var</td>
<td>把当前遍历的元素放入指定的page域中。var的值是key，遍历的元素是value<br>注意：var不支持EL表达式，只能是字符串常量</td>
</tr>
<tr>
<td>begin</td>
<td>开始遍历的索引</td>
</tr>
<tr>
<td>end</td>
<td>结束遍历的索引</td>
</tr>
<tr>
<td>step</td>
<td>步长，i+&#x3D;step</td>
</tr>
<tr>
<td>varStatus</td>
<td>它是一个计数器对象，有两个属性，一个是用于记录索引，一个是用于计数。索引是从0开始，计数是从1开始</td>
</tr>
</tbody></table>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.ArrayList&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> prefix=<span class="string">&quot;c&quot;</span>%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;循环&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%--向域对象中添加集合--%&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;dd&quot;</span>);</span><br><span class="line">        pageContext.setAttribute(<span class="string">&quot;list&quot;</span>,list);</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;%--遍历集合--%&gt;</span><br><span class="line">    &lt;c:forEach items=<span class="string">&quot;$&#123;list&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;str&quot;</span>&gt;</span><br><span class="line">        $&#123;str&#125; &lt;br&gt;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Filter：过滤器，是 JavaWeb 三大组件之一，另外两个是 Servlet 和 Listener</p>
<p>工作流程：在程序访问服务器资源时，当一个请求到来，服务器首先判断是否有过滤器与去请求资源相关联，如果有过滤器可以将请求拦截下来，完成一些特定的功能，再由过滤器决定是否交给请求资源，如果没有就直接请求资源，响应同理</p>
<p>作用：过滤器一般用于完成通用的操作，例如：登录验证、统一编码处理、敏感字符过滤等</p>
<hr>
<h3 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h3><h4 id="Filter-1"><a href="#Filter-1" class="headerlink" title="Filter"></a>Filter</h4><p>Filter是一个接口，如果想实现过滤器的功能，必须实现该接口</p>
<ul>
<li><p>核心方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void init(FilterConfig filterConfig)</td>
<td>初始化，开启过滤器</td>
</tr>
<tr>
<td>void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</td>
<td>对请求资源和响应资源过滤</td>
</tr>
<tr>
<td>void destroy()</td>
<td>销毁过滤器</td>
</tr>
</tbody></table>
</li>
<li><p>配置方式</p>
<p>注解方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line">()内填拦截路径，<span class="comment">/*代表全部路径</span></span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.FilterDemo01<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="FilterChain"><a href="#FilterChain" class="headerlink" title="FilterChain"></a>FilterChain</h4><ul>
<li><p>FilterChain 是一个接口，代表过滤器对象。由Servlet容器提供实现类对象，直接使用即可。</p>
</li>
<li><p>过滤器可以定义多个，就会组成过滤器链</p>
</li>
<li><p>核心方法：<code>void doFilter(ServletRequest request, ServletResponse response)</code> 用来放行方法</p>
<p>如果有多个过滤器，在第一个过滤器中调用下一个过滤器，以此类推，直到到达最终访问资源。<br>如果只有一个过滤器，放行时就会直接到达最终访问资源。</p>
</li>
</ul>
<h4 id="FilterConfig"><a href="#FilterConfig" class="headerlink" title="FilterConfig"></a>FilterConfig</h4><p>FilterConfig 是一个接口，代表过滤器的配置对象，可以加载一些初始化参数</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>String getFilterName()</td>
<td>获取过滤器对象名称</td>
</tr>
<tr>
<td>String getInitParameter(String name)</td>
<td>获取指定名称的初始化参数的值，不存在返回null</td>
</tr>
<tr>
<td>Enumeration<String> getInitParameterNames()</String></td>
<td>获取所有参数的名称</td>
</tr>
<tr>
<td>ServletContext getServletContext()</td>
<td>获取应用上下文对象</td>
</tr>
</tbody></table>
<hr>
<h3 id="Filter使用"><a href="#Filter使用" class="headerlink" title="Filter使用"></a>Filter使用</h3><h4 id="设置页面编码"><a href="#设置页面编码" class="headerlink" title="设置页面编码"></a>设置页面编码</h4><p>请求先被过滤器拦截进行相关操作</p>
<p>过滤器放行之后执行完目标资源，仍会回到过滤器中</p>
<ul>
<li><p>Filter 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo01</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filterDemo01拦截到请求...&quot;</span>);</span><br><span class="line">        <span class="comment">//处理乱码</span></span><br><span class="line">        servletResponse.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//过滤器放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        System.out.println(<span class="string">&quot;filterDemo1放行之后，又回到了doFilter方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Servlet 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo01</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servletDemo01执行了...&quot;</span>);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;servletDemo01执行了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filterDemo01拦截到请求...</span><br><span class="line">servletDemo01执行了...</span><br><span class="line">filterDemo1放行之后，又回到了doFilter方法  </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="多过滤器顺序"><a href="#多过滤器顺序" class="headerlink" title="多过滤器顺序"></a>多过滤器顺序</h4><p>多个过滤器使用的顺序，取决于过滤器映射的顺序。</p>
<ul>
<li><p>两个 Filter 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo01</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filterDemo01执行了...&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo02</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filterDemo02执行了...&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Servlet代码：<code>System.out.println(&quot;servletDemo02执行了...&quot;);</code></p>
</li>
<li><p>web.xml配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.FilterDemo01<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.FilterDemo02<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filterDemo01执行了</span><br><span class="line">filterDemo02执行了</span><br><span class="line">servletDemo02执行了...</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在过滤器的配置中，有过滤器的声明和过滤器的映射两部分，到底是声明决定顺序，还是映射决定顺序呢？</p>
<p>答案是：<code>&lt;filter-mapping&gt;</code>的配置前后顺序决定过滤器的调用顺序，也就是由映射配置顺序决定。</p>
<hr>
<h4 id="Filter生命周期"><a href="#Filter生命周期" class="headerlink" title="Filter生命周期"></a>Filter生命周期</h4><p><strong>创建：</strong>当应用加载时实例化对象并执行init()初始化方法</p>
<p><strong>服务：</strong>对象提供服务的过程，执行doFilter()方法</p>
<p><strong>销毁</strong>：当应用卸载时或服务器停止时对象销毁，执行destroy()方法</p>
<ul>
<li><p>Filter代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo03</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        初始化方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象初始化成功了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        提供服务方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filterDemo03执行了...&quot;</span>);</span><br><span class="line">        <span class="comment">//过滤器放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        对象销毁方法，关闭Tomcat服务器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象销毁了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>Servlet 代码：<code>System.out.println(&quot;servletDemo03执行了...&quot;);</code></p>
</li>
<li><p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对象初始化成功了...</span><br><span class="line">filterDemo03执行了...</span><br><span class="line">servletDemo03执行了...</span><br><span class="line">对象销毁了</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="FilterConfig使用"><a href="#FilterConfig使用" class="headerlink" title="FilterConfig使用"></a>FilterConfig使用</h4><p>Filter初始化函数init的参数是FilterConfig 对象</p>
<ul>
<li><p>Filter代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo04</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象初始化成功了...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取过滤器名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filterName</span> <span class="operator">=</span> filterConfig.getFilterName();</span><br><span class="line">        System.out.println(filterName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据name获取value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> filterConfig.getInitParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filterDemo04执行了...&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>web.xml配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo04<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.FilterDemo04<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo04<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对象初始化成功了...</span><br><span class="line">filterDemo04</span><br><span class="line">zhangsan</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="Filter案例"><a href="#Filter案例" class="headerlink" title="Filter案例"></a>Filter案例</h3><p>在访问html，js，image时，不需要每次都重新发送请求读取资源，就可以通过设置响应消息头的方式，设置缓存时间。但是如果每个Servlet都编写相同的代码，显然不符合我们统一调用和维护的理念。</p>
<p>静态资源设置缓存时间：html设置为1小时，js设置为2小时，css设置为3小时</p>
<ul>
<li><p>配置过滤器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>StaticResourceNeedCacheFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.StaticResourceNeedCacheFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>html<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>js<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>4<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>css<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>5<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>StaticResourceNeedCacheFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>StaticResourceNeedCacheFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.js<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>StaticResourceNeedCacheFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.css<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写过滤器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticResourceNeedCacheFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> FilterConfig filterConfig;<span class="comment">//获取初始化参数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="built_in">this</span>.filterConfig = filterConfig;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res,</span></span><br><span class="line"><span class="params">                         FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//1.把doFilter的请求和响应对象转换成跟http协议有关的对象</span></span><br><span class="line">        HttpServletRequest  request;</span><br><span class="line">        HttpServletResponse response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request = (HttpServletRequest) req;</span><br><span class="line">            response = (HttpServletResponse) res;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;non-HTTP request or response&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.获取请求资源URI</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        <span class="comment">//3.得到请求资源到底是什么类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">extend</span> <span class="operator">=</span> uri.substring(uri.lastIndexOf(<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>);<span class="comment">//我们只需要判断它是不是html,css,js。其他的不管</span></span><br><span class="line">        <span class="comment">//4.判断到底是什么类型的资源</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> <span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;html&quot;</span>.equals(extend))&#123;</span><br><span class="line">            <span class="comment">//html 缓存1小时</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> filterConfig.getInitParameter(<span class="string">&quot;html&quot;</span>);</span><br><span class="line">            time = time*Long.parseLong(html);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;js&quot;</span>.equals(extend))&#123;</span><br><span class="line">            <span class="comment">//js 缓存2小时</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">js</span> <span class="operator">=</span> filterConfig.getInitParameter(<span class="string">&quot;js&quot;</span>);</span><br><span class="line">            time = time*Long.parseLong(js);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;css&quot;</span>.equals(extend))&#123;</span><br><span class="line">            <span class="comment">//css 缓存3小时</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">css</span> <span class="operator">=</span> filterConfig.getInitParameter(<span class="string">&quot;css&quot;</span>);</span><br><span class="line">            time = time*Long.parseLong(css);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.设置响应消息头</span></span><br><span class="line">        response.setDateHeader(<span class="string">&quot;Expires&quot;</span>, System.currentTimeMillis()+time);</span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="拦截行为"><a href="#拦截行为" class="headerlink" title="拦截行为"></a>拦截行为</h3><p>Filter过滤器默认拦截的是请求，但是在实际开发中，我们还有请求转发和请求包含，以及由服务器触发调用的全局错误页面。默认情况下过滤器是不参与过滤的，需要配置web.xml</p>
<p>开启功能后，当访问页面发生相关行为后，会执行过滤器的操作</p>
<p>五种拦截行为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterDemo5<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.FilterDemo5<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置开启异步支持，当dispatcher配置ASYNC时，需要配置此行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterDemo5<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;url-pattern&gt;/index.jsp&lt;/url-pattern&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--过滤请求：默认值。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--过滤全局错误页面：开启后，当由服务器调用全局错误页面时，过滤器工作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--过滤请求转发：开启后，当请求转发时，过滤器工作。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>FORWARD<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--过滤请求包含：当请求包含时，过滤器工作。它只能过滤动态包含，jsp的include指令是静态包含--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>INCLUDE<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--过滤异步类型，它要求我们在filter标签中配置开启异步支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>ASYNC<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>web.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterDemo5<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.FilterDemo5<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置开启异步支持，当dispatcher配置ASYNC时，需要配置此行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterDemo5<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span>    </span><br></pre></td></tr></table></figure>
</li>
<li><p>ServletDemo03：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servletDemo03执行了...&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/ <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>FilterDemo05：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo05</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filterDemo05执行了...&quot;</span>);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问URL：<a href="http://localhost:8080/filter/servletDemo03">http://localhost:8080/filter/servletDemo03</a></p>
</li>
<li><p>控制台输出（注意输出顺序）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">servletDemo03执行了...</span><br><span class="line">filterDemo05执行了...</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="对比Servlet"><a href="#对比Servlet" class="headerlink" title="对比Servlet"></a>对比Servlet</h3><table>
<thead>
<tr>
<th>方法&#x2F;类型</th>
<th>Servlet</th>
<th>Filter</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>初始化                                        方法</td>
<td>void   init(ServletConfig);</td>
<td>void init(FilterConfig);</td>
<td>几乎一样，都是在web.xml中配置参数，用该对象的方法可以获取到。</td>
</tr>
<tr>
<td>提供服务方法</td>
<td>void   service(request,response);</td>
<td>void   dofilter(request,response,FilterChain)</td>
<td>Filter比Servlet多了一个FilterChain，它不仅能完成Servlet的功能，而且还可以决定程序是否能继续执行。所以过滤器比Servlet更为强大。   在Struts2中，核心控制器就是一个过滤器。</td>
</tr>
<tr>
<td>销毁方法</td>
<td>void destroy();</td>
<td>void destroy();</td>
<td>方法&#x2F;类型</td>
</tr>
</tbody></table>
<hr>
<h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><h3 id="观察者设计者"><a href="#观察者设计者" class="headerlink" title="观察者设计者"></a>观察者设计者</h3><p>所有的监听器都是基于观察者设计模式的。</p>
<p>观察者模式通常由以下三部分组成：</p>
<ul>
<li><p>事件源：触发事件的对象。</p>
</li>
<li><p>事件：触发的动作，里面封装了事件源。</p>
</li>
<li><p>监听器：当事件源触发事件后，可以完成的功能。一般是一个接口，由使用者来实现。（此处的思想还涉及了一个策略模式）</p>
</li>
</ul>
<hr>
<h3 id="监听器分类"><a href="#监听器分类" class="headerlink" title="监听器分类"></a>监听器分类</h3><p>在程序当中，我们可以对：对象的创建销毁、域对象中属性的变化、会话相关内容进行监听。</p>
<p>Servlet规范中共计8个监听器，<strong>监听器都是以接口形式提供</strong>，具体功能需要我们自己完成</p>
<h4 id="监听对象"><a href="#监听对象" class="headerlink" title="监听对象"></a>监听对象</h4><ul>
<li><p>ServletContextListener：用于监听ServletContext对象的创建和销毁</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void contextInitialized(ServletContextEvent sce)</td>
<td>对象创建时执行该方法</td>
</tr>
<tr>
<td>void contextDestroyed(ServletContextEvent sce)</td>
<td>对象销毁时执行该方法</td>
</tr>
</tbody></table>
<p>参数ServletContextEvent 代表事件对象，事件对象中封装了事件源ServletContext，真正的事件指的是创建或者销毁ServletContext对象的操作</p>
</li>
<li><p>HttpSessionListener：用于监听HttpSession对象的创建和销毁</p>
<table>
<thead>
<tr>
<th>方法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td>void sessionCreated(HttpSessionEvent se)</td>
<td align="left">对象创建时执行该方法</td>
</tr>
<tr>
<td>void sessionDestroyed(HttpSessionEvent se)</td>
<td align="left">对象销毁时执行该方法</td>
</tr>
</tbody></table>
<p>参数HttpSessionEvent 代表事件对象，事件对象中封装了事件源HttpSession，真正的事件指的是创建或者销毁HttpSession对象的操作</p>
</li>
<li><p>ServletRequestListener：用于监听ServletRequest对象的创建和销毁</p>
<table>
<thead>
<tr>
<th>方法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td>void requestInitialized(ServletRequestEvent sre)</td>
<td align="left">对象创建时执行该方法</td>
</tr>
<tr>
<td>void requestDestroyed(ServletRequestEvent sre)</td>
<td align="left">对象销毁时执行该方法</td>
</tr>
</tbody></table>
<p>参数ServletRequestEvent 代表事件对象，事件对象中封装了事件源ServletRequest，真正的事件指的是创建或者销毁ServletRequest对象的操作</p>
</li>
</ul>
<hr>
<h4 id="监听域对象属性"><a href="#监听域对象属性" class="headerlink" title="监听域对象属性"></a>监听域对象属性</h4><ul>
<li><p>ServletContextAttributeListener：用于监听ServletContext应用域中属性的变化</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void attributeAdded(ServletContextAttributeEvent event)</td>
<td>域中添加属性时执行该方法</td>
</tr>
<tr>
<td>void attributeRemoved(ServletContextAttributeEvent event)</td>
<td>域中移除属性时执行该方法</td>
</tr>
<tr>
<td>void attributeReplaced(ServletContextAttributeEvent event)</td>
<td>域中替换属性时执行该方法</td>
</tr>
</tbody></table>
<p>参数ServletContextAttributeEvent 代表事件对象，事件对象中封装了事件源ServletContext，真正的事件指的是添加、移除、替换应用域中属性的操作</p>
</li>
<li><p>HttpSessionAttributeListener：用于监听HttpSession会话域中属性的变化</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void attributeAdded(HttpSessionBindingEvent event)</td>
<td>域中添加属性时执行该方法</td>
</tr>
<tr>
<td>void attributeRemoved(HttpSessionBindingEvent event)</td>
<td>域中移除属性时执行该方法</td>
</tr>
<tr>
<td>void attributeReplaced(HttpSessionBindingEvent event)</td>
<td>域中替换属性时执行该方法</td>
</tr>
</tbody></table>
<p>参数HttpSessionBindingEvent 代表事件对象，事件对象中封装了事件源HttpSession，真正的事件指的是添加、移除、替换应用域中属性的操作</p>
</li>
<li><p>ServletRequestAttributeListener：用于监听ServletRequest请求域中属性的变化</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void attributeAdded(ServletRequestAttributeEvent srae)</td>
<td>域中添加属性时执行该方法</td>
</tr>
<tr>
<td>void attributeRemoved(ServletRequestAttributeEvent srae)</td>
<td>域中移除属性时执行该方法</td>
</tr>
<tr>
<td>void attributeReplaced(ServletRequestAttributeEvent srae)</td>
<td>域中替换属性时执行该方法</td>
</tr>
</tbody></table>
<p>参数ServletRequestAttributeEvent 代表事件对象，事件对象中封装了事件源ServletRequest，真正的事件指的是添加、移除、替换应用域中属性的操作</p>
</li>
<li><p>页面域对象没有监听器</p>
</li>
</ul>
<hr>
<h4 id="感知型监听器"><a href="#感知型监听器" class="headerlink" title="感知型监听器"></a>感知型监听器</h4><p>监听会话相关的感知型监听器，和会话域相关的两个感知型监听器是无需配置（注解）的，可以直接编写代码</p>
<ul>
<li><p>HttpSessionBindingListener：用于感知对象和会话域绑定的监听器</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void valueBound(HttpSessionBindingEvent event)</td>
<td>数据添加到会话域中(绑定)时执行该方法</td>
</tr>
<tr>
<td>void valueUnbound(HttpSessionBindingEvent event)</td>
<td>数据从会话域中移除(解绑)时执行该方法</td>
</tr>
</tbody></table>
<p>参数HttpSessionBindingEvent 代表事件对象，事件对象中封装了事件源HttpSession，真正的事件指的是添加、移除、替换应用域中属性的操作</p>
</li>
<li><p>HttpSessionActivationListener：用于感知会话域中对象和钝化和活化的监听器</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void sessionWillPassivate(HttpSessionEvent se)</td>
<td>会话域中数据钝化时执行该方法</td>
</tr>
<tr>
<td>void sessionDidActivate(HttpSessionEvent se)</td>
<td>会话域中数据活化时执行该方法</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h3 id="监听器使用"><a href="#监听器使用" class="headerlink" title="监听器使用"></a>监听器使用</h3><h4 id="ServletContextListener"><a href="#ServletContextListener" class="headerlink" title="ServletContextListener"></a>ServletContextListener</h4><p>ServletContext对象的创建和销毁的监听器</p>
<p>注解方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContextListenerDemo</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line">    <span class="comment">//创建时执行此方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听到对象的创建....&quot;</span>);<span class="comment">//启动服务器就创建</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line">        System.out.println(servletContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁时执行的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听到对象的销毁...&quot;</span>);<span class="comment">//关闭服务器就销毁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置监听器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>listener.ServletContextAttributeListenerDemo<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="ServletContextAttributeListener"><a href="#ServletContextAttributeListener" class="headerlink" title="ServletContextAttributeListener"></a>ServletContextAttributeListener</h4><p>应用域对象中的属性变化的监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContextAttributeListenerDemo</span> <span class="keyword">implements</span> <span class="title class_">ServletContextAttributeListener</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        向应用域对象中添加属性时执行此方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeAdded</span><span class="params">(ServletContextAttributeEvent scae)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听到了属性的添加...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取应用域对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> scae.getServletContext();</span><br><span class="line">        <span class="comment">//获取属性</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> servletContext.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(value);<span class="comment">//zhangsan </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        向应用域对象中替换属性时执行此方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeReplaced</span><span class="params">(ServletContextAttributeEvent scae)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听到了属性的替换...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取应用域对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> scae.getServletContext();</span><br><span class="line">        <span class="comment">//获取属性</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> servletContext.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(value);<span class="comment">//lisi</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        向应用域对象中移除属性时执行此方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeRemoved</span><span class="params">(ServletContextAttributeEvent scae)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听到了属性的移除...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取应用域对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> scae.getServletContext();</span><br><span class="line">        <span class="comment">//获取属性</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> servletContext.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(value);<span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContextListenerDemo</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span>&#123;</span><br><span class="line">    <span class="comment">//ServletContext对象创建的时候执行此方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听到了对象的创建...&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加属性</span></span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//替换属性</span></span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除属性</span></span><br><span class="line">        servletContext.removeAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ServletContext对象销毁的时候执行此方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听到了对象的销毁...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">监听到了对象的创建...</span><br><span class="line">监听到了属性的添加...</span><br><span class="line">zhangsan</span><br><span class="line">监听到了属性的替换</span><br><span class="line">lisi</span><br><span class="line">监听到属性的移除</span><br><span class="line">null</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>JavaScript 是一种客户端脚本语言。运行在客户端浏览器中，每一个浏览器都具备解析 JavaScript 的引擎。</p>
<p>脚本语言：不需要编译，就可以被浏览器直接解析执行了。</p>
<p>作用：增强用户和 HTML 页面的交互过程，让页面产生动态效果，增强用户的体验。</p>
<p>组成部分：ECMAScript、DOM、BOM</p>
<p>开发环境搭建：安装Node.js，是JavaScript运行环境</p>
<hr>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>引入HTML文件</p>
<ul>
<li><p>内部方式：<script>标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS快速入门<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--html语句--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// JS语句</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>外部方式</p>
<ul>
<li><p>创建js文件：my.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;Hello&quot;</span>);<span class="comment">//js语句</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在html中引用外部js文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--html语句--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/my.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li><p>单行注释</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注释的内容</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多行注释</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注释的内容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><ul>
<li><p>输入框：prompt(“提示内容”);</p>
</li>
<li><p>弹出警告框：alert(“提示内容”); </p>
</li>
<li><p>控制台输出：console.log(“显示内容”); </p>
</li>
<li><p>页面内容输出：document.write(“显示内容”);</p>
<p>注：<code>document.write(&quot;&lt;br/&gt;&quot;)</code>换行，通常输出数据后跟br标签</p>
</li>
</ul>
<hr>
<h3 id="变量常量"><a href="#变量常量" class="headerlink" title="变量常量"></a>变量常量</h3><p>JavaScript 属于弱类型的语言，定义变量时不区分具体的数据类型</p>
<ul>
<li><p>定义局部变量：let 变量名 = 值; </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">23</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(name + <span class="string">&quot;,&quot;</span> + age +<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义全局变量：变量名 = 值; </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    l2 = <span class="string">&quot;bb&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(l2 + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义常量：const 常量名 = 值;<br>常量不能被重新赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="comment">//PI = 3.15;  </span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="variable constant_">PI</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>布尔类型，true或false</td>
</tr>
<tr>
<td>null</td>
<td>声明null值的特殊关键字</td>
</tr>
<tr>
<td>undefined</td>
<td>代表变量未定义</td>
</tr>
<tr>
<td>number</td>
<td>整数或浮点数</td>
</tr>
<tr>
<td>string</td>
<td>字符串</td>
</tr>
<tr>
<td>bigint</td>
<td>大整数，例如：let num = 10n;</td>
</tr>
</tbody></table>
<p><strong>typeof 用于判断变量的数据类型</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>; </span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="title function_">typeof</span>(age)); <span class="comment">// number</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li><p>算术运算符</p>
<table>
<thead>
<tr>
<th>算术运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法运算</td>
</tr>
<tr>
<td>-</td>
<td>减法运算</td>
</tr>
<tr>
<td>*</td>
<td>乘法运算</td>
</tr>
<tr>
<td>/</td>
<td>除法运算</td>
</tr>
<tr>
<td>%</td>
<td>取余数</td>
</tr>
<tr>
<td>++</td>
<td>自增</td>
</tr>
<tr>
<td>--</td>
<td>自减</td>
</tr>
</tbody></table>
</li>
<li><p>赋值运算符</p>
<table>
<thead>
<tr>
<th>赋值运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>加法运算</td>
</tr>
<tr>
<td>+=</td>
<td>减法运算</td>
</tr>
<tr>
<td>-=</td>
<td>乘法运算</td>
</tr>
<tr>
<td>*=</td>
<td>除法运算</td>
</tr>
<tr>
<td>/=</td>
<td>取余数</td>
</tr>
<tr>
<td>%=</td>
<td>自增</td>
</tr>
</tbody></table>
</li>
<li><p>比较运算符</p>
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>判断值是否相等</td>
</tr>
<tr>
<td>===</td>
<td>判断数据类型和值是否相等</td>
</tr>
<tr>
<td>></td>
<td>大于</td>
</tr>
<tr>
<td>>=</td>
<td>大于等于</td>
</tr>
<tr>
<td><</td>
<td>小于</td>
</tr>
<tr>
<td><=</td>
<td>小于等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
</tbody></table>
</li>
<li><p>逻辑运算符</p>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&&</td>
<td>逻辑与，并且的功能</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或，或者的功能</td>
</tr>
<tr>
<td>!</td>
<td>取反</td>
</tr>
</tbody></table>
</li>
<li><p><strong>三元运算符</strong></p>
<ul>
<li>三元运算符格式：(比较表达式) ? 表达式1 : 表达式2; </li>
<li>格式说明：<br>如果比较表达式为true，则取表达式1<br>如果比较表达式为false，则取表达式2</li>
</ul>
</li>
</ul>
<hr>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><ul>
<li><p><strong>if语句</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> month = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(month &gt;= <span class="number">3</span> &amp;&amp; month &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;春季&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(month &gt;= <span class="number">6</span> &amp;&amp; month &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;夏季&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(month == <span class="number">12</span> || month == <span class="number">1</span> || month == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;冬季&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;月份有误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>switch语句</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(sex)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;男性&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;女性&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;性别有误&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>for循环</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(i + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>while循环</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">while</span>(n &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(n + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">    n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组的使用和 java 中的数组基本一致，在JavaScript 中的数组更加灵活，数据类型和长度都没有限制</p>
<ul>
<li><p>定义格式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> 数组名 = [元素<span class="number">1</span>,元素<span class="number">2</span>,…];</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引范围：从 0 开始，最大到数组长度-1</p>
</li>
<li><p>数组长度：数组名.length</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]; </span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(arr+<span class="string">&quot;&lt;br&gt;&quot;</span>)<span class="comment">// 直接输出：10,20,30</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(arr[i] + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组高级运算符：...</p>
<ul>
<li><p>数组赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = [...arr];</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>];</span><br><span class="line"><span class="keyword">let</span> arr4 = [...arr2 , ...arr3];</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串转数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr5 = [...<span class="string">&quot;JavaScript&quot;</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数类似于 java 中的方法，可以将一些代码进行抽取，达到复用的效果</p>
<ul>
<li><p>定义格式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 方法名(参数列表) &#123;</span><br><span class="line">    方法体; </span><br><span class="line">    <span class="keyword">return</span> 返回值; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> 变量 = 方法名();</span><br><span class="line">方法名();</span><br></pre></td></tr></table></figure>
</li>
<li><p>可变参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 方法名(... 参数名) &#123;</span><br><span class="line">    方法体; </span><br><span class="line">    <span class="keyword">return</span> 返回值; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">参数列表</span>) &#123;</span><br><span class="line">    方法体; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="DOM介绍"><a href="#DOM介绍" class="headerlink" title="DOM介绍"></a>DOM介绍</h3><p>DOM(Document Object Model)：文档对象模型。</p>
<p>将 HTML 文档的各个组成部分，封装为对象。借助这些对象，可以对 HTML 文档进行增删改查的动态操作。</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/DOM%E4%BB%8B%E7%BB%8D.png"></p>
<hr>
<h3 id="元素获取"><a href="#元素获取" class="headerlink" title="元素获取"></a>元素获取</h3><p>Element元素的获取操作：document接口方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getElementById(id属性值)</td>
<td>根据id属性值获取元素对象</td>
</tr>
<tr>
<td>getElementsByTagName(标签名称)</td>
<td>根据标签名称获取元素对象，返回数组</td>
</tr>
<tr>
<td>getElementsByClassName(class属性值)</td>
<td>根据class属性值获取元素对象，返回数组</td>
</tr>
<tr>
<td>getElementsByName(name属性值)</td>
<td>根据name属性值获取元素对象，返回数组</td>
</tr>
<tr>
<td>子元素对象.parentElement属性</td>
<td>获取当前元素的父元素</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span>div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div2&quot;</span>&gt;</span>div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>div3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>div4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> div1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>);<span class="comment">//根据id属性值获取元素对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//alert(div1);//[object HTMLDivElement]</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> body = div1.<span class="property">parentElement</span>;<span class="comment">//获取当前元素的父元素</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(body);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="元素增删改"><a href="#元素增删改" class="headerlink" title="元素增删改"></a>元素增删改</h3><p>Element元素的增删改操作：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>createElement(标签名)</td>
<td>创建一个新的标签元素</td>
</tr>
<tr>
<td>appendChild(子元素)</td>
<td>将指定子元素添加到父元素中</td>
</tr>
<tr>
<td>removeChild(子元素)</td>
<td>用父元素删除指定子元素</td>
</tr>
<tr>
<td>replaceChild(新元素, 旧元素)</td>
<td>用新元素替换子元素</td>
</tr>
<tr>
<td>createTextNode(数据)</td>
<td>创建文本元素</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;s&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>---请选择---<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> option = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;option&quot;</span>);<span class="comment">//创建新的元素</span></span></span><br><span class="line"><span class="language-javascript">    option.<span class="property">innerText</span> = <span class="string">&quot;深圳&quot;</span>;<span class="comment">//为option添加文本内容</span></span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> select = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;s&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    select.<span class="title function_">appendChild</span>(option);<span class="comment">//将子元素添加到父元素中</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> option2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;option&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    option2.<span class="property">innerText</span> = <span class="string">&quot;杭州&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    select.<span class="title function_">replaceChild</span>(option2,option);<span class="comment">//用新元素替换老元素</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><p>Attribute属性的操作：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>setAttribute(属性名, 属性值)</td>
<td>设置属性</td>
</tr>
<tr>
<td>getAttribute(属性名)</td>
<td>根据属性名获取属性值</td>
</tr>
<tr>
<td>removeAttribute(属性名)</td>
<td>根据属性名移除指定的属性</td>
</tr>
<tr>
<td>元素名.style属性</td>
<td>为元素添加样式</td>
</tr>
<tr>
<td>元素名.className属性</td>
<td>为元素添加指定样式</td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.aColor</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;<span class="comment">/*获取写在&lt;style&gt;标签*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span>&gt;</span>点我呀<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> a = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;a&quot;</span>)[<span class="number">0</span>];<span class="comment">//因为是数组</span></span></span><br><span class="line"><span class="language-javascript">    a.<span class="title function_">setAttribute</span>(<span class="string">&quot;href&quot;</span>,<span class="string">&quot;https://www.baidu.com&quot;</span>);<span class="comment">//添加属性</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> value = a.<span class="title function_">getAttribute</span>(<span class="string">&quot;href&quot;</span>);<span class="comment">//获取属性</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//a.style.color = &quot;red&quot;;//添加样式</span></span></span><br><span class="line"><span class="language-javascript">    a.<span class="property">className</span> = <span class="string">&quot;aColor&quot;</span>;<span class="comment">//添加指定CSS样式</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h3><ul>
<li><p>Text文本的操作： </p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>innerText</td>
<td>元素的文本内容，不解析标签</td>
</tr>
<tr>
<td>innerHTML</td>
<td>元素的文本内容，解析标签</td>
</tr>
</tbody></table>
<p>类似于赋值操作，同时支持取用该值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. innerText   添加文本内容，不解析标签</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    div.<span class="property">innerText</span> = <span class="string">&quot;我是div&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2. innerHTML   添加文本内容，解析标签</span></span></span><br><span class="line"><span class="language-javascript">    div.<span class="property">innerHTML</span> = <span class="string">&quot;&lt;b&gt;我是div&lt;/b&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输入框文本：input元素.value;</p>
</li>
</ul>
<hr>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="事件介绍"><a href="#事件介绍" class="headerlink" title="事件介绍"></a>事件介绍</h3><p>事件指的就是当某些组件执行了某些操作后，会触发某些代码的执行</p>
<ul>
<li><p>常用的事件：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/JS%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6.png"></p>
</li>
<li><p>更多的事件：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/JS%E6%9B%B4%E5%A4%9A%E7%9A%84%E4%BA%8B%E4%BB%B6.png"></p>
</li>
</ul>
<hr>
<h3 id="事件操作"><a href="#事件操作" class="headerlink" title="事件操作"></a>事件操作</h3><p>绑定事件的方式</p>
<ul>
<li><p>方式一：通过标签中的事件属性进行绑定</p>
</li>
<li><p>方式二：通过 DOM 元素属性绑定</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;img/01.png&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;button id=&quot;up&quot; onclick=&quot;up()&quot;&gt;上一张&lt;/button&gt; </span></span><br><span class="line"><span class="comment">    &lt;button id=&quot;down&quot; onclick=&quot;down()&quot;&gt;下一张&lt;/button&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;up&quot;</span>&gt;</span>上一张<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="comment">&lt;!--图片 上一张 下一张  类似百度图库--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;down&quot;</span>&gt;</span>下一张<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//显示第一张图片的方法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">up</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;img&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        img.<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span>,<span class="string">&quot;img/01.png&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//显示第二张图片的方法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">down</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;img&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        img.<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span>,<span class="string">&quot;img/02.png&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//为上一张按钮绑定单击事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> upBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;up&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    upBtn.<span class="property">onclick</span> = up;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//为下一张按钮绑定单击事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> downBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;down&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    downBtn.<span class="property">onclick</span> = down;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><p>案例介绍：</p>
<p>在姓名、年龄、性别三个文本框中填写信息后，添加到“学生信息表”列表（表格），点击删除后，删除该行数据，并且不需刷新</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/%E4%BA%8B%E4%BB%B6%E6%A1%88%E4%BE%8B%E6%95%88%E6%9E%9C.png"></p>
<ul>
<li><p>添加功能分析</p>
<ol>
<li>为添加按钮绑定单击事件</li>
<li>创建 tr 元素</li>
<li>创建 4 个 td 元素</li>
<li>将 td 添加到 tr 中</li>
<li>获取文本框输入的信息</li>
<li>创建 3 个文本元素</li>
<li>将文本元素添加到对应的 td 中</li>
<li>创建 a 元素</li>
<li>将 a 元素添加到对应的 td 中</li>
<li>将 tr 添加到 table 中</li>
</ol>
</li>
<li><p>删除功能分析</p>
<ol>
<li>为每个删除超链接添加单击事件属性</li>
<li>定义删除的方法</li>
<li>获取 table 元素</li>
<li>获取 tr 元素</li>
<li>通过 table 删除 tr</li>
</ol>
</li>
<li><p>HTML</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>动态表格<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../css/table.css&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入姓名&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;age&quot;</span>  <span class="attr">placeholder</span>=<span class="string">&quot;请输入年龄&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;gender&quot;</span>  <span class="attr">placeholder</span>=<span class="string">&quot;请输入性别&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;添加&quot;</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;tb&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">caption</span>&gt;</span>学生信息表<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>23<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;JavaScript:void(0);&quot;</span><span class="attr">onclick</span>=<span class="string">&quot;drop(this)&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//一、添加功能</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.为添加按钮绑定单击事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;add&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//2.创建行元素</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> tr = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tr&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//3.创建4个单元格元素</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> nameTd = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> ageTd = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> genderTd = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> deleteTd = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;td&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//4.将td添加到tr中</span></span></span><br><span class="line"><span class="language-javascript">        tr.<span class="title function_">appendChild</span>(nameTd);</span></span><br><span class="line"><span class="language-javascript">        tr.<span class="title function_">appendChild</span>(ageTd);</span></span><br><span class="line"><span class="language-javascript">        tr.<span class="title function_">appendChild</span>(genderTd);</span></span><br><span class="line"><span class="language-javascript">        tr.<span class="title function_">appendChild</span>(deleteTd);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//5.获取输入框的文本信息</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> name = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> age = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;age&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> gender = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;gender&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//6.根据获取到的信息创建3个文本元素</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> nameText = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(name);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> ageText = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(age);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> genderText = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(gender);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//7.将3个文本元素添加到td中</span></span></span><br><span class="line"><span class="language-javascript">        nameTd.<span class="title function_">appendChild</span>(nameText);</span></span><br><span class="line"><span class="language-javascript">        ageTd.<span class="title function_">appendChild</span>(ageText);</span></span><br><span class="line"><span class="language-javascript">        genderTd.<span class="title function_">appendChild</span>(genderText);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//8.创建超链接元素和显示的文本以及添加href属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> aText = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;删除&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        a.<span class="title function_">setAttribute</span>(<span class="string">&quot;href&quot;</span>,<span class="string">&quot;JavaScript:void(0);&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        a.<span class="title function_">setAttribute</span>(<span class="string">&quot;onclick&quot;</span>,<span class="string">&quot;drop(this)&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        a.<span class="title function_">appendChild</span>(aText);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//9.将超链接元素添加到td中</span></span></span><br><span class="line"><span class="language-javascript">        deleteTd.<span class="title function_">appendChild</span>(a);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//10.获取table元素，将tr添加到table中</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> table = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tb&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        table.<span class="title function_">appendChild</span>(tr);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//二、删除的功能</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.为每个删除超链接标签添加单击事件的属性</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2.定义删除的方法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">drop</span>(<span class="params">obj</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//3.获取table元素</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> table = obj.<span class="property">parentElement</span>.<span class="property">parentElement</span>.<span class="property">parentElement</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//4.获取tr元素</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> tr = obj.<span class="property">parentElement</span>.<span class="property">parentElement</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//5.通过table删除tr</span></span></span><br><span class="line"><span class="language-javascript">        table.<span class="title function_">removeChild</span>(tr);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>CSS</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">td</span>,<span class="selector-tag">th</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul>
<li><p>定义格式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">变量列表</span>)&#123;</span><br><span class="line">        变量赋值;</span><br><span class="line">    &#125;</span><br><span class="line">    方法名(参数列表) &#123;</span><br><span class="line">        方法体;</span><br><span class="line">        <span class="keyword">return</span> 返回值;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用格式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> 对象名 = <span class="keyword">new</span> 类名(实际变量值);</span><br><span class="line">对象名.方法名();</span><br></pre></td></tr></table></figure>


</li>
<li><p>字面量类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//定义person</span></span><br><span class="line">    <span class="keyword">let</span> person = &#123;</span><br><span class="line">        name : <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">        age : <span class="number">23</span>,</span><br><span class="line">        hobby : [<span class="string">&quot;听课&quot;</span>,<span class="string">&quot;学习&quot;</span>],</span><br><span class="line"></span><br><span class="line">        eat : <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;吃饭...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用person</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(person.<span class="property">name</span> + <span class="string">&quot;,&quot;</span> + person.<span class="property">age</span> + <span class="string">&quot;,&quot;</span> + person.<span class="property">hobby</span>[<span class="number">0</span>]+<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">    person.<span class="title function_">eat</span>();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><p>继承：让类与类产生子父类的关系，子类可以使用父类有权限的成员。</p>
</li>
<li><p>继承关键字：extends</p>
</li>
<li><p>顶级父类：Object</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//定义Person类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">        <span class="comment">//构造方法</span></span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//eat方法</span></span><br><span class="line">        <span class="title function_">eat</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;吃饭...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义Worker类继承Person</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span>&#123;</span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params">name,age,salary</span>)&#123;</span><br><span class="line">            <span class="variable language_">super</span>(name,age);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">salary</span> = salary;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">show</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;,&quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&quot;,&quot;</span> + <span class="variable language_">this</span>.<span class="property">salary</span> + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用Worker</span></span><br><span class="line">    <span class="keyword">let</span> w = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>,<span class="number">10000</span>);</span><br><span class="line">    w.<span class="title function_">show</span>();</span><br><span class="line">    w.<span class="title function_">eat</span>();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>内置对象是 JavaScript 提供的带有属性和方法的特殊数据类型，常见的有普通类型、JSON和正则表达式</p>
<hr>
<h3 id="普通类型"><a href="#普通类型" class="headerlink" title="普通类型"></a>普通类型</h3><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><ul>
<li><p>Number</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>parseFloat(Sring)</td>
<td>将传入的字符串转为浮点数</td>
</tr>
<tr>
<td>parseInt()</td>
<td>将传入的字符串整数转为整数</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//1. parseFloat()  将传入的字符串浮点数转为浮点数</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="title class_">Number</span>.<span class="built_in">parseFloat</span>(<span class="string">&quot;3.14&quot;</span>) + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. parseInt()    将传入的字符串整数转为整数</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="title class_">Number</span>.<span class="built_in">parseInt</span>(<span class="string">&quot;100&quot;</span>) + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="title class_">Number</span>.<span class="built_in">parseInt</span>(<span class="string">&quot;200abc&quot;</span>) + <span class="string">&quot;&lt;br&gt;&quot;</span>);<span class="comment">//从数字开始转换，直到不是数字</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Math</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ceil(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>floor(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>round(x)</td>
<td>四舍五入为整数</td>
</tr>
<tr>
<td>random()</td>
<td>随机数，返回的是0.0-1.0之间的范围（含头不含尾）</td>
</tr>
<tr>
<td>pow(x,y)</td>
<td>幂运算，x的y次方</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>,<span class="number">3</span>) + <span class="string">&quot;&lt;br&gt;&quot;</span>); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h4><ul>
<li><p>Date构造方法</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Date()</td>
<td>根据当前时间创建对象</td>
</tr>
<tr>
<td>Date(value)</td>
<td>根据指定毫秒值创建对象</td>
</tr>
<tr>
<td>Date(year, month, [day, hours, minutes, seconds, milliseconds])</td>
<td>根据指定字段创建对象</td>
</tr>
</tbody></table>
</li>
<li><p>Date成员方法</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getFullYear()</td>
<td>获取年份</td>
</tr>
<tr>
<td>getMonth()</td>
<td>获取月份</td>
</tr>
<tr>
<td>getDate()</td>
<td>获取天数，相对于月份</td>
</tr>
<tr>
<td>getHours()</td>
<td>获取小时</td>
</tr>
<tr>
<td>getMinutes()</td>
<td>获取分钟</td>
</tr>
<tr>
<td>getSeconds()</td>
<td>获取秒数</td>
</tr>
<tr>
<td>getTime()</td>
<td>返回据1970年1月1日至今的毫秒数</td>
</tr>
<tr>
<td>toLocaleString()</td>
<td>返回本地日期格式的字符串<br />2021/2/3下午8:20:20</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>String</p>
<ul>
<li><p>构造方法</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>gengenString(vale)</td>
<td>根据指定字符串创建对象</td>
</tr>
<tr>
<td>let s = "字符串"</td>
<td>直接赋值</td>
</tr>
</tbody></table>
</li>
<li><p>成员方法</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>length</td>
<td>获取字符串长度</td>
</tr>
<tr>
<td>charAt(index)</td>
<td>获取指定索引处的字符</td>
</tr>
<tr>
<td>indexOf(value)</td>
<td>获取指定字符串出现的索引位置，找不到为-1</td>
</tr>
<tr>
<td>substring(start, end)</td>
<td>根据指定索引范围截取字符串（含头不含尾）</td>
</tr>
<tr>
<td>split(value)</td>
<td>根据指定规则切割字符串，返回数组</td>
</tr>
<tr>
<td>replace(old, new)</td>
<td>使用新字符替换老字符串</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h4 id="数组集合"><a href="#数组集合" class="headerlink" title="数组集合"></a>数组集合</h4><ul>
<li><p>Array</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>push(value)</td>
<td>添加元素到数组的末尾</td>
</tr>
<tr>
<td>pop()</td>
<td>删除数组末尾的元素</td>
</tr>
<tr>
<td>shift()</td>
<td>删除数组最前面的元素</td>
</tr>
<tr>
<td>includes(value)</td>
<td>判断数组是否包含给定的值</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转数组中的元素</td>
</tr>
<tr>
<td>sort()</td>
<td>对数组元素进行升序排序</td>
</tr>
<tr>
<td>length</td>
<td>返回数组的长度</td>
</tr>
</tbody></table>
<p><strong>降序排序：先sort，再reverse</strong></p>
</li>
<li><p>Set：JavaScript中的Set集合，元素唯一，存取顺序一致</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Set()</td>
<td>创建Set集合对象</td>
</tr>
<tr>
<td>add(value)</td>
<td>向集合中添加元素</td>
</tr>
<tr>
<td>size</td>
<td>获取集合长度</td>
</tr>
<tr>
<td>keys()</td>
<td>获取迭代器对象（遍历方法看实例）</td>
</tr>
<tr>
<td>delete(value)</td>
<td>删除指定元素</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="comment">// add(元素)   添加元素</span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="string">&quot;a&quot;</span>);s.<span class="title function_">add</span>(<span class="string">&quot;b&quot;</span>);s.<span class="title function_">add</span>(<span class="string">&quot;c&quot;</span>);s.<span class="title function_">add</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// keys()      获取迭代器对象</span></span><br><span class="line"><span class="keyword">let</span> st = s.<span class="title function_">keys</span>();</span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">size</span>; i++)&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(st.<span class="title function_">next</span>().<span class="property">value</span> + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Map：JavaScript 中的 Map 集合，key 唯一，存取顺序一致</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Map()</td>
<td>创建Map集合对象</td>
</tr>
<tr>
<td>set(key, value)</td>
<td>向集合添加元素</td>
</tr>
<tr>
<td>size</td>
<td>获取集合长度</td>
</tr>
<tr>
<td>get(key)</td>
<td>根据key获取value</td>
</tr>
<tr>
<td>entries()</td>
<td>获取迭代器对象</td>
</tr>
<tr>
<td>delete(key)</td>
<td>根据key删除键值对</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><h4 id="JSON入门"><a href="#JSON入门" class="headerlink" title="JSON入门"></a>JSON入门</h4><p>JSON(JavaScript Object Notation)：是一种轻量级的数据交换格式。</p>
<ul>
<li>基于 ECMAScript 规范的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据</li>
<li>简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言，易于人阅读和编写，同时也易于计算机解析和 生成，并有效的提升网络传输效率。</li>
</ul>
<ul>
<li><p>创建格式：<br><strong>name是字符串类型</strong><br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/JSON%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F.png"></p>
</li>
<li><p>json常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>stringify(对象)</td>
<td>将指定对象转换为json格式字符串</td>
</tr>
<tr>
<td>parse(字符串)</td>
<td>将指定json格式字符串解析成对象</td>
</tr>
</tbody></table>
</li>
<li><p>入门案例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//定义天气对象</span></span><br><span class="line"><span class="keyword">let</span> weather = &#123;</span><br><span class="line">    city : <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    date : <span class="string">&quot;2088-08-08&quot;</span>,</span><br><span class="line">    wendu : <span class="string">&quot;10° ~ 23°&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.将天气对象转换为JSON格式的字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(weather);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(str + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.将JSON格式字符串解析成JS对象</span></span><br><span class="line"><span class="keyword">let</span> weather2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;城市：&quot;</span> + weather2.<span class="property">city</span> + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="转换工具"><a href="#转换工具" class="headerlink" title="转换工具"></a>转换工具</h4><p>我们除了可以在 JavaScript 中来使用 JSON 以外，在 JAVA 中同样也可以使用 JSON。</p>
<p>JSON 的转换工具是通过 JAVA 封装好的一些 JAR 工具包，可以将 JAVA 对象或集合转换成 JSON 格式的字符串，也可以将 JSON 格式的字符串转成 JAVA 对象。</p>
<p>Jackson：开源免费的 JSON 转换工具，SpringMVC 转换默认使用 Jackson。</p>
<ul>
<li><p>常用类</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ObjectMapper</td>
<td>是Jackson工具包的核心类，提供方法来实现JSON字符串和对象之间的转换</td>
</tr>
<tr>
<td>TypeReference</td>
<td>对集合泛型的反序列化，使用TypeReference可以明确的指定反序列化的对象类型</td>
</tr>
</tbody></table>
</li>
<li><p>ObjectMapper常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String writeValueAsString(Object obj)</td>
<td>将Java对象转换成JSON字符串</td>
</tr>
<tr>
<td><T> T readValue(String json, Class<T> valueType)</td>
<td>将JSON字符串转换成Java对象</td>
</tr>
<tr>
<td><T> T readValue(String json, TypeReference valueTypeRef)</td>
<td>将JSON字符串转换成Java对象</td>
</tr>
</tbody></table>
</li>
</ul>
<p>方法练习：</p>
<ul>
<li><p>对象转 JSON，JSON 转对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//User对象转json</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">    System.out.println(<span class="string">&quot;json字符串：&quot;</span> + json<span class="comment">//json字符串 = &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23&#125;</span></span><br><span class="line">    <span class="comment">//json转User对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> mapper.readValue(json, User.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;user对象：&quot;</span> + user2);<span class="comment">//user对象 = User&#123;name=&#x27;张三&#x27;, age=23&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Map转 JSON，JSON 转 Map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//map&lt;String,String&gt;转json</span></span><br><span class="line">    HashMap&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;姓名&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;性别&quot;</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(map);</span><br><span class="line">    System.out.println(<span class="string">&quot;json字符串：&quot;</span> + json);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//json转map&lt;String,String&gt;</span></span><br><span class="line">    HashMap&lt;String,String&gt; map2 = mapper.readValue(json, HashMap.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;map对象：&quot;</span> + map2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//json字符串 = &#123;&quot;姓名&quot;:&quot;张三&quot;,&quot;性别&quot;:&quot;男&quot;&#125;</span></span><br><span class="line"><span class="comment">//map对象 = &#123;姓名=张三, 性别=男&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Map转 JSON，JSON 转 Map<自定义类></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//map&lt;String,User&gt;转json</span></span><br><span class="line">    HashMap&lt;String,User&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;sea一班&quot;</span>,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>));</span><br><span class="line">    map.put(<span class="string">&quot;sea二班&quot;</span>,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">24</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(map);</span><br><span class="line">    System.out.println(<span class="string">&quot;json字符串：&quot;</span> + json);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//json转map&lt;String,User&gt;</span></span><br><span class="line">    HashMap&lt;String,User&gt; map2=mapper.readValue(json,</span><br><span class="line">                                 <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;HashMap&lt;String,User&gt;&gt;()&#123;&#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;java对象：&quot;</span> + map2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//json字符串 = &#123;&quot;sea一班&quot;:&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23&#125;,&quot;sea二班&quot;:&#123;....&#125;</span></span><br><span class="line"><span class="comment">//map对象 = &#123;sea一班=User&#123;name=&#x27;张三&#x27;, age=23&#125;, sea二班=User&#123;name=&#x27;李四&#x27;, age=24&#125;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>List</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//List&lt;User&gt;转json</span></span><br><span class="line">    ArrayList&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">24</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(list);</span><br><span class="line">    System.out.println(<span class="string">&quot;json字符串：&quot;</span> + json);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//json转List&lt;User&gt;</span></span><br><span class="line">    ArrayList&lt;User&gt; list2 = mapper.readValue(json,</span><br><span class="line">								<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;ArrayList&lt;User&gt;&gt;()&#123;&#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;java对象：&quot;</span> + list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//json字符串 = [&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23&#125;,&#123;&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:24&#125;]</span></span><br><span class="line"><span class="comment">//list对象 = [User&#123;name=&#x27;张三&#x27;, age=23&#125;, User&#123;name=&#x27;李四&#x27;, age=24&#125;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>正则表达式：是一种对字符串进行匹配的规则</p>
<p>RegExp：</p>
<ul>
<li><p>构造方法</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>RegExp(规则)</td>
<td>根据指定规则创建对象</td>
</tr>
<tr>
<td>let reg = /^规则$/</td>
<td>直接赋值</td>
</tr>
</tbody></table>
</li>
<li><p>成员方法</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>test(匹配的字符串)</td>
<td>根据指定规则验证字符串是否符合</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="验证用户"><a href="#验证用户" class="headerlink" title="验证用户"></a>验证用户</h4><p>使用 onsubmit 表单提交事件</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;login-form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">id</span>=<span class="string">&quot;registered&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.为表单绑定提交事件  匿名函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;registered&quot;</span>).<span class="property">onsubmit</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//2.获取填写的用户名和密码</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> password = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;password&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//3.判断用户名是否符合规则  4~16位纯字母</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> reg1 = <span class="regexp">/^[a-zA-Z]&#123;4,16&#125;$/</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(!reg1.<span class="title function_">test</span>(username)) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;用户名不符合规则，请输入4到16位的纯字母！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//4.判断密码是否符合规则  6位纯数字</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> reg2 = <span class="regexp">/^[\d]&#123;6&#125;$/</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(!reg2.<span class="title function_">test</span>(password)) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;密码不符合规则，请输入6位纯数字的密码！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//5.如果所有条件都满足，则提交表单</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><h3 id="BOM介绍"><a href="#BOM介绍" class="headerlink" title="BOM介绍"></a>BOM介绍</h3><p>BOM(Browser Object Model)：浏览器对象模型。</p>
<p>将浏览器的各个组成部分封装成不同的对象，方便我们进行操作。</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/BOM%E4%BB%8B%E7%BB%8D.png"></p>
<hr>
<h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><p>Windows窗口对象：</p>
<ul>
<li><strong>定时器</strong><ul>
<li>唯一标识 setTimeout(功能，毫秒值)：设置一次性定时器。</li>
<li>clearTimeout(标识)：取消一次性定时器。</li>
<li>唯一标识 setInterval(功能，毫秒值)：设置循环定时器。</li>
<li>clearInterval(标识)：取消循环定时器。</li>
</ul>
</li>
<li>加载事件<ul>
<li>window.onload：在页面加载完毕后触发此事件的功能</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//一、定时器</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;该起床了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置一次性定时器</span></span><br><span class="line">    <span class="keyword">let</span> d1 = <span class="built_in">setTimeout</span>(<span class="string">&quot;fun()&quot;</span>,<span class="number">3000</span>);</span><br><span class="line">    <span class="comment">//取消一次性定时器</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(d1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置循环定时器，3秒弹出一次</span></span><br><span class="line">    <span class="keyword">let</span> d2 = <span class="built_in">setInterval</span>(<span class="string">&quot;fun()&quot;</span>,<span class="number">3000</span>);</span><br><span class="line">    <span class="comment">//取消循环定时器</span></span><br><span class="line">    <span class="built_in">clearInterval</span>(d2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载事件</span></span><br><span class="line">    <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    <span class="title function_">alert</span>(div);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>window窗口对象<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;该起床了！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//加载事件</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(div);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span>&gt;</span>dddd<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><p>Location地址栏对象：</p>
<ul>
<li>href 属性：浏览器的地址栏。我们可以通过为该属性设置新的URL，使浏览器读取并显示新URL的内容</li>
</ul>
<p>实现效果：秒数会自动变小，倒计时，5，4，3，2，1</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        注册成功！<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;time&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">span</span>&gt;</span>秒之后自动跳转到首页...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.定义方法。改变秒数，跳转页面</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> num = <span class="number">5</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">showTime</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        num--;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(num &lt;= <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//跳转首页</span></span></span><br><span class="line"><span class="language-javascript">            location.<span class="property">href</span> = <span class="string">&quot;index.html&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> span = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;time&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        span.<span class="property">innerText</span> = num;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2.设置循环定时器，每1秒钟执行showTime方法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setInterval</span>(<span class="string">&quot;showTime()&quot;</span>,<span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装思想：</p>
<ul>
<li><p><strong>封装：</strong>将复杂的操作进行封装隐藏，对外提供更加简单的操作。</p>
</li>
<li><p><strong>获取元素的方法</strong></p>
<ul>
<li>document.getElementById(id值)：根据 id 值获取元素 </li>
<li>document.getElementsByName(name值)：根据 name 属性值获取元素们 </li>
<li>document.getElementsByTagName(标签名)：根据标签名获取元素们</li>
</ul>
</li>
</ul>
<p>代码实现：</p>
<ul>
<li><p>my.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getById</span>(<span class="params">id</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getByName</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getByTag</span>(<span class="params">tag</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span>div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;my.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>	<span class="comment">&lt;!--引入js文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> div1 = <span class="title function_">getById</span>(<span class="string">&quot;div1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(div1);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>jQuery 是一个 JavaScript 库</p>
<ul>
<li>所谓的库，就是一个 JS 文件，里面封装了很多预定义的函数，比如获取元素，执行隐藏、移动等，目的就是在使用时直接调用，不需要再重复定义，这样就可以极大地简化了 JavaScript 编程。</li>
<li>jQuery 官网：<a href="https://www.jquery.com/">https://www.jquery.com</a></li>
</ul>
<p>引入jQ文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入 jQuery 文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-3.3.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//jQ语句</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>jQuery 的核心语法 $()</li>
</ul>
<hr>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><h4 id="对象转换"><a href="#对象转换" class="headerlink" title="对象转换"></a>对象转换</h4><p>jQuery 本质上虽然也是 JS，但二者的 API 方法不能混合使用，若想使用对方的 API，需要进行对象的转换</p>
<ul>
<li><p>JS 的 DOM 对象转换成 jQuery 对象：$(JS的DOM对象);</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JS方式，通过id属性值获取div元素</span></span><br><span class="line"><span class="keyword">let</span> jsDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="comment">// 将 JS 对象转换为jQuery对象</span></span><br><span class="line"><span class="keyword">let</span> jq = $(jsDiv);</span><br></pre></td></tr></table></figure>
</li>
<li><p>jQuery 对象转换成 JS 对象</p>
<ul>
<li>jQuery对象[索引];</li>
<li>jQuery对象.get(索引);</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jQuery方式，通过id属性值获取div元素</span></span><br><span class="line"><span class="keyword">let</span> jqDiv = $(<span class="string">&quot;#div&quot;</span>);</span><br><span class="line"><span class="comment">//将 jQuery对象转换为JS对象</span></span><br><span class="line"><span class="keyword">let</span> js = jqDiv[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="事件操作-1"><a href="#事件操作-1" class="headerlink" title="事件操作"></a>事件操作</h4><h5 id="绑定解绑"><a href="#绑定解绑" class="headerlink" title="绑定解绑"></a>绑定解绑</h5><p>在 jQuery 中将事件封装成了对应的方法。去掉了 JS 中的 .on 语法</p>
<ul>
<li><p>绑定事件：<code>jQuery对象.on(事件名称,执行的功能);</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给btn1按钮绑定单击事件</span></span><br><span class="line">$(<span class="string">&quot;#btn1&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="title function_">alert</span>(<span class="string">&quot;点我干嘛?&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>解绑事件：<code>jQuery对象.off(事件名称);</code><br>如果不指定事件名称，则会把该对象绑定的所有事件都解绑</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过btn2解绑btn1的单击事件</span></span><br><span class="line">$(<span class="string">&quot;#btn2&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	$(<span class="string">&quot;#btn1&quot;</span>).<span class="title function_">off</span>(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="事件切换"><a href="#事件切换" class="headerlink" title="事件切换"></a>事件切换</h5><p>事件切换：需要给同一个对象绑定多个事件，而且多个事件还有先后顺序关系</p>
<ul>
<li><p>方式一：单独定义</p>
<ul>
<li>$(元素).事件方法名1(要执行的功能); </li>
<li>$(元素).事件方法名2(要执行的功能);</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将鼠标移到某元素，添加css样式</span></span><br><span class="line">$(<span class="string">&quot;#div&quot;</span>).<span class="title function_">mouseover</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//背景色：红色</span></span><br><span class="line">    <span class="comment">//$(&quot;#div&quot;).css(&quot;background&quot;,&quot;red&quot;);</span></span><br><span class="line">    $(<span class="variable language_">this</span>).<span class="title function_">css</span>(<span class="string">&quot;background&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&quot;#div&quot;</span>).<span class="title function_">mouseout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//背景色：蓝色</span></span><br><span class="line">    $(<span class="variable language_">this</span>).<span class="title function_">css</span>(<span class="string">&quot;background&quot;</span>,<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：链式定义</p>
<ul>
<li>$(元素).事件方法名1(要执行的功能) .事件方法名2(要执行的功能);</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#div&quot;</span>).<span class="title function_">mouseover</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   $(<span class="variable language_">this</span>).<span class="title function_">css</span>(<span class="string">&quot;background&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">&#125;).<span class="title function_">mouseout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   $(<span class="variable language_">this</span>).<span class="title function_">css</span>(<span class="string">&quot;background&quot;</span>,<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h4><ul>
<li><p>数据准备，实现按键后遍历无序列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;遍历列表项&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>传智播客<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>黑马程序员<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>传智专修学院<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>for循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; 容器对象长度; i++)&#123;</span><br><span class="line">		执行功能;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象.each方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">容器对象.<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params">index,ele</span>)&#123;</span><br><span class="line">	执行功能;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#btn&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> lis = $(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    lis.<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params">index,ele</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(index + <span class="string">&quot;:&quot;</span> + ele.<span class="property">innerHTML</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>$.each()方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">each</span>(容器对象,<span class="keyword">function</span>(<span class="params">index,ele</span>)&#123;</span><br><span class="line">	执行功能;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#btn&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> lis = $(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    $.<span class="title function_">each</span>(lis,<span class="keyword">function</span>(<span class="params">index,ele</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(index + <span class="string">&quot;:&quot;</span> + ele.<span class="property">innerHTML</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>for of语句</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#btn&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> lis = $(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(ele <span class="keyword">of</span> lis)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(ele.<span class="property">innerHTML</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="选择器-1"><a href="#选择器-1" class="headerlink" title="选择器"></a>选择器</h3><h4 id="基本选择器-1"><a href="#基本选择器-1" class="headerlink" title="基本选择器"></a>基本选择器</h4><p>选择器：类似于 CSS 的选择器，可以帮助我们获取元素。</p>
<ul>
<li>下面所有的A B均为标签名</li>
</ul>
<table>
<thead>
<tr>
<th>选择器</th>
<th>语法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>元素选择器</td>
<td>$("元素的名称")</td>
<td>根据元素名称获取元素对象（数组）</td>
</tr>
<tr>
<td>id选择器</td>
<td>$("#id的属性值")</td>
<td>根据id属性值获取元素对象</td>
</tr>
<tr>
<td>类选择器</td>
<td>$(".class的属性值")</td>
<td>根据class属性值获取元素对象（数组）</td>
</tr>
</tbody></table>
<h4 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h4><table>
<thead>
<tr>
<th>选择器</th>
<th>语法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>后代选择器</td>
<td>$("A B")</td>
<td>A下的所有B，包括B的子级</td>
</tr>
<tr>
<td>子选择器</td>
<td>$("A > B")</td>
<td>A下的所有B，不 包括B的子级</td>
</tr>
<tr>
<td>兄弟选择器</td>
<td>$("A + B")</td>
<td>A相邻的下一个B</td>
</tr>
<tr>
<td>兄弟选择器</td>
<td>$("A ~ B")</td>
<td>A相邻的所有B</td>
</tr>
</tbody></table>
<h4 id="属性选择器-1"><a href="#属性选择器-1" class="headerlink" title="属性选择器"></a>属性选择器</h4><table>
<thead>
<tr>
<th>选择器</th>
<th>语法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>属性名选择器</td>
<td>$("A[属性名]")</td>
<td>根据指定属性名获取元素对象（数组）</td>
</tr>
<tr>
<td>属性值选择器</td>
<td>$("A[属性名=属性值]")</td>
<td>根据指定属性名和属性值获取元素对象（数组）</td>
</tr>
</tbody></table>
<hr>
<h4 id="过滤器选择器"><a href="#过滤器选择器" class="headerlink" title="过滤器选择器"></a>过滤器选择器</h4><table>
<thead>
<tr>
<th>选择器</th>
<th>语法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>首元素选择器</td>
<td>$("A:first")</td>
<td>获取选择的元素中的第一个元素</td>
</tr>
<tr>
<td>尾元素选择器</td>
<td>$("A:last")</td>
<td>获取选择的元素中的最后一个元素</td>
</tr>
<tr>
<td>非元素选择器</td>
<td>$("A:not(B)")</td>
<td>不包括指定内容的元素</td>
</tr>
<tr>
<td>偶数选择器</td>
<td>$("A:even")</td>
<td>偶数，从0开始计数</td>
</tr>
<tr>
<td>奇数选择器</td>
<td>$("A:odd")</td>
<td>奇数，从0开始计数</td>
</tr>
<tr>
<td>等于索引选择器</td>
<td>$("A:eq(index)")</td>
<td>指定索引的元素</td>
</tr>
<tr>
<td>大于索引选择器</td>
<td>$("A:gt(index)")</td>
<td>大于指定索引的元素</td>
</tr>
<tr>
<td>小于索引选择器</td>
<td>$("A:lt(index)")</td>
<td>小于指定索引的元素</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div2&quot;</span>&gt;</span>div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-3.3.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 首元素选择器	$(&quot;A:first&quot;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> div1 = $(<span class="string">&quot;div:first&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//alert(div1.html());</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 非元素选择器	$(&quot;A:not(B)&quot;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> divs1 = $(<span class="string">&quot;div:not(#div2)&quot;</span>);<span class="comment">//数组</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 偶数选择器	    $(&quot;A:even&quot;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> divs2 = $(<span class="string">&quot;div:even&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(divs2.<span class="property">length</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(divs2[<span class="number">0</span>].<span class="property">innerHTML</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(divs2[<span class="number">1</span>].<span class="property">innerHTML</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 等于索引选择器	 $(&quot;A:eq(index)&quot;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> div3 = $(<span class="string">&quot;div:eq(2)&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//alert(div3.html());</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="表单属性选择器"><a href="#表单属性选择器" class="headerlink" title="表单属性选择器"></a>表单属性选择器</h4><table>
<thead>
<tr>
<th>选择器</th>
<th>语法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>可用选择器</td>
<td>$("A:enabled")</td>
<td>获得可用元素</td>
</tr>
<tr>
<td>不可用元素选择器</td>
<td>$("A:disabled")</td>
<td>获得不可用元素</td>
</tr>
<tr>
<td>单选/复选框被选中的元素</td>
<td>$("A:checked")</td>
<td>获取单选/复选框被选中的元素</td>
</tr>
<tr>
<td>下拉框被选中的元素</td>
<td>$("A:selected")</td>
<td>获取下拉框被选中的元素</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">disabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;men&quot;</span> <span class="attr">checked</span>&gt;</span>男</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;women&quot;</span>&gt;</span>女</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;study&quot;</span> <span class="attr">checked</span>&gt;</span>学习</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sleep&quot;</span> <span class="attr">checked</span>&gt;</span>睡觉</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>---请选择---<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>本科<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>专科<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-3.3.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1.可用元素选择器  $(&quot;A:enabled&quot;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> ins1 = $(<span class="string">&quot;input:enabled&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2.不可用元素选择器  $(&quot;A:disabled&quot;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> ins2 = $(<span class="string">&quot;input:disabled&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 3.单选/复选框被选中的元素  $(&quot;A:checked&quot;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> ins3 = $(<span class="string">&quot;input:checked&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(ins3.<span class="property">length</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(ins3[<span class="number">0</span>].<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(ins3[<span class="number">1</span>].<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 4.下拉框被选中的元素   $(&quot;A:selected&quot;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> select = $(<span class="string">&quot;select option:selected&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(select.<span class="title function_">html</span>());  </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="DOM-1"><a href="#DOM-1" class="headerlink" title="DOM"></a>DOM</h3><h4 id="文本操作-1"><a href="#文本操作-1" class="headerlink" title="文本操作"></a>文本操作</h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>html()</td>
<td>获取标签的文本</td>
</tr>
<tr>
<td>html(value)</td>
<td>设置标签的文本内容，解析标签</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取div标签的文本内容</span></span><br><span class="line"><span class="keyword">let</span> value = $(<span class="string">&quot;#div&quot;</span>).<span class="title function_">html</span>();</span><br><span class="line"><span class="comment">//设置div标签的文本内容</span></span><br><span class="line">$(<span class="string">&quot;#div&quot;</span>).<span class="title function_">html</span>(<span class="string">&quot;&lt;b&gt;我是div&lt;/b&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>$("元素")</td>
<td>创建指定元素</td>
</tr>
<tr>
<td>append(element)</td>
<td>添加成最后一个子元素，由添加者对象调用</td>
</tr>
<tr>
<td>appendTo(element)</td>
<td>添加成最后一个子元素，由被添加者对象调用</td>
</tr>
<tr>
<td>prepend(element)</td>
<td>添加成第一个子元素，由添加者对象调用</td>
</tr>
<tr>
<td>prependTo(element)</td>
<td>添加成第一个子元素，由被添加者对象调用</td>
</tr>
<tr>
<td>before(element)</td>
<td>添加到当前元素的前面，两者之间是兄弟关系，由添加者对象调用</td>
</tr>
<tr>
<td>after(element)</td>
<td>添加到当前元素的后面，两者之间是兄弟关系，由添加者对象调用</td>
</tr>
<tr>
<td>remove()</td>
<td>删除指定元素（自己移除自己）</td>
</tr>
<tr>
<td>empty()</td>
<td>清空指定元素的所有子元素（自己还在）</td>
</tr>
</tbody></table>
<div id="div"></div>
<ul id="city">
    <li id="bj">北京</li>
    <li id="sh">上海</li>
</ul>
<ul id="desc">
    <li id="jy">加油</li>
</ul> 

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按钮一：添加一个span到div</span></span><br><span class="line">$(<span class="string">&quot;#btn1&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> span = $(<span class="string">&quot;&lt;span&gt;span&lt;/span&gt;&quot;</span>);</span><br><span class="line">    $(<span class="string">&quot;#div&quot;</span>).<span class="title function_">append</span>(span);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//按钮二：将加油添加到城市列表最下方</span></span><br><span class="line">$(<span class="string">&quot;#btn2&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;#city&quot;</span>).<span class="title function_">append</span>($(<span class="string">&quot;#jy&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//按钮三：将加油添加到城市列表最上方</span></span><br><span class="line">$(<span class="string">&quot;#btn3&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;#jy&quot;</span>).<span class="title function_">prependTo</span>($(<span class="string">&quot;#city&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//按钮四：将加油添加到北京下方</span></span><br><span class="line">$(<span class="string">&quot;#btn4&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;#bj&quot;</span>).<span class="title function_">after</span>($(<span class="string">&quot;#jy&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>css(name)</td>
<td>根据样式名称获取css样式</td>
</tr>
<tr>
<td>css(name,value)</td>
<td>设置css样式</td>
</tr>
<tr>
<td>addClass(value)</td>
<td>给指定的对象添加样式类名</td>
</tr>
<tr>
<td>removeClass(value)</td>
<td>给指定的对象删除样式类名</td>
</tr>
<tr>
<td>toggleClass(value)</td>
<td>没有样式类名就添加，有就删除，循环如此</td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.cls</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid red;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span>&gt;</span>我是div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.css(name)   获取css样式</span></span><br><span class="line">$(<span class="string">&quot;#btn1&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>($(<span class="string">&quot;#div&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;border&quot;</span>));  <span class="comment">//1px solid rgb(255, 0, 0)</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.css(name,value)   设置CSS样式</span></span><br><span class="line">$(<span class="string">&quot;#btn2&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;#div&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;background&quot;</span>,<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.addClass(value)   给指定的对象添加样式类名</span></span><br><span class="line">$(<span class="string">&quot;#btn3&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;#div&quot;</span>).<span class="title function_">addClass</span>(<span class="string">&quot;cls&quot;</span>);  <span class="comment">//cls是一个css样式</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.toggleClass(value)  如果没有样式类名，则添加。如果有，则删除</span></span><br><span class="line">$(<span class="string">&quot;#btn5&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="string">&quot;#div&quot;</span>).<span class="title function_">toggleClass</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="属性操作-1"><a href="#属性操作-1" class="headerlink" title="属性操作"></a>属性操作</h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>attr(name,[value])</td>
<td>获得/设置属性的值</td>
</tr>
<tr>
<td>prop(name,[value])</td>
<td>获得/设置属性的值（checked, selected）</td>
</tr>
</tbody></table>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>操作属性</title>
</head>
<body>
    <input type="text" id="username"> <br>
    <input type="button" id="btn1" value="获取输入框的id属性">  &nbsp;&nbsp;
    <input type="button" id="btn2" value="给输入框设置value属性"><br/>
    <input type="radio" id="gender1" name="gender">男
    <input type="radio" id="gender2" name="gender">女<br/>
    <input type="button" id="btn3" value="选中女"><br/><br/>
    <select>
    <option>---请选择---</option>
    <option id="bk">本科</option>
    <option id="zk">专科</option>
    </select><br/>
    <input type="button" id="btn4" value="选中本科">
</body>
</html>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-3.3.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//按钮一：获取输入框的id属性  attr(name,[value])</span></span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&quot;#btn1&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>($(<span class="string">&quot;#username&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;id&quot;</span>));</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//按钮二：给输入框设置value属性  attr(name,[value])</span></span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&quot;#btn2&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#username&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;hello...&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//按钮三：选中女   prop(name,[value]) </span></span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&quot;#btn3&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#gender2&quot;</span>).<span class="title function_">prop</span>(<span class="string">&quot;checked&quot;</span>,<span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//按钮四：选中本科  prop(name,[value]) </span></span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&quot;#btn4&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#bk&quot;</span>).<span class="title function_">prop</span>(<span class="string">&quot;selected&quot;</span>,<span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>





<hr>
<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>AJAX(Asynchronous JavaScript And XML)：异步的 JavaScript 和 XML。 </p>
</li>
<li><p>不是一种新技术，而是多个技术综合，用于快速创建动态网页的技术。</p>
</li>
<li><p>一般的网页如果需要更新内容，必需重新加载个页面。而 AJAX 通过浏览器与服务器进行少量数据交换，就可以使网页实现异步更新。也就是在不重新加载整个页 面的情况下，对网页的部分内容进行<strong>局部更新</strong>。</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/AJAX%E7%BD%91%E9%A1%B5%E5%B1%80%E9%83%A8%E6%9B%B4%E6%96%B0.png"></p>
</li>
</ul>
<hr>
<h2 id="实现AJAX"><a href="#实现AJAX" class="headerlink" title="实现AJAX"></a>实现AJAX</h2><h3 id="JS方式"><a href="#JS方式" class="headerlink" title="JS方式"></a>JS方式</h3><ul>
<li><p>核心对象：XMLHttpRequest</p>
<ul>
<li>用于在后台与服务器交换数据。可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</li>
</ul>
</li>
<li><p>打开链接：open(method,url,async)</p>
<ul>
<li>method：请求的类型 GET 或 POST</li>
<li>url：请求资源的路径</li>
</ul>
<ul>
<li>async：true(异步) 或 false(同步)。</li>
</ul>
</li>
<li><p>发送请求：send(String params) </p>
<ul>
<li>params：请求的参数(POST 专用)</li>
</ul>
</li>
<li><p>处理响应：onreadystatechange</p>
<ul>
<li>readyState：0-请求未初始化，1-服务器连接已建立，2-请求已接收，3-请求处理中，4-请求已完成，且响应已就绪。</li>
</ul>
<ul>
<li>status：200-响应已全部 OK。</li>
</ul>
</li>
<li><p>获得响应数据形式</p>
<ul>
<li><p>responseText：获得字符串形式的响应数据。</p>
</li>
<li><p>responseXML：获得 XML 形式的响应数据。</p>
</li>
</ul>
</li>
</ul>
<p>鼠标移出输入框，判断用户名是否被注册：</p>
<ul>
<li><p>Servlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/userServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置请求和响应的乱码</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="comment">//模拟服务器处理请求需要1秒钟</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.判断姓名是否已注册</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;zhangsan&quot;</span>.equals(username)) &#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;&lt;font color=&#x27;red&#x27;&gt;用户名已注册&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;&lt;font color=&#x27;green&#x27;&gt;用户名可用&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>html文件</p>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>用户注册</title>
</head>
<body>
    <form autocomplete="off">
        姓名：<input type="text" id="username">
        <span id="uSpan"></span>
        <br>
        密码：<input type="password" id="password">
        <br>
        <input type="submit" value="注册">
    </form>
</body>


<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.为姓名绑定失去焦点事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">onblur</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//2.创建XMLHttpRequest核心对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> xmlHttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//3.打开链接</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">        xmlHttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;userServlet?username=&quot;</span> + username, <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//4.发送请求</span></span></span><br><span class="line"><span class="language-javascript">        xmlHttp.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//5.处理响应</span></span></span><br><span class="line"><span class="language-javascript">        xmlHttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//判断请求和响应是否成功</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(xmlHttp.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xmlHttp.<span class="property">status</span> == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//将响应的数据显示到span标签</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;uSpan&quot;</span>).<span class="property">innerHTML</span> = xmlHttp.<span class="property">responseText</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="JQ方式"><a href="#JQ方式" class="headerlink" title="JQ方式"></a>JQ方式</h3><p><strong>核心语法：</strong><code>$.ajax(&#123;name:value,name:value,…&#125;); </code></p>
<ul>
<li>url：请求的资源路径。</li>
<li>async：是否异步请求，true-是，false-否 (默认是 true)。</li>
<li>data：发送到服务器的数据，可以是<strong>键值对或者 js 对象</strong>形式。</li>
<li>type：请求方式，POST 或 GET (默认是 GET)。</li>
<li>dataType：预期的返回数据的类型，取值可以是 xml, html, js, json, text等。 </li>
<li>success：请求成功时调用的回调函数。</li>
<li>error：请求失败时调用的回调函数。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-3.3.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.为用户名绑定失去焦点事件</span></span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&quot;#username&quot;</span>).<span class="title function_">blur</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> username = $(<span class="string">&quot;#username&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//2.jQuery的通用方式实现AJAX</span></span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//请求资源路径</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>:<span class="string">&quot;userServletxxx&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//是否异步</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">async</span>:<span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//请求参数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>:<span class="string">&quot;username=&quot;</span>+username,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//请求方式</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//数据形式</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">dataType</span>:<span class="string">&quot;text&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//请求成功后调用的回调函数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">success</span>:<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//将响应的数据显示到span标签</span></span></span><br><span class="line"><span class="language-javascript">                $(<span class="string">&quot;#uSpan&quot;</span>).<span class="title function_">html</span>(data);</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//请求失败后调用的回调函数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">error</span>:<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&quot;操作失败...&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="分页知识"><a href="#分页知识" class="headerlink" title="分页知识"></a>分页知识</h2><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/%E5%88%86%E9%A1%B5%E7%9F%A5%E8%AF%86.png" alt="分页知识"></p>
<hr>
<h1 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>Vue是一套构建用户界面的渐进式前端框架。</p>
<p>Vue只关注视图层，并且非常容易学习，还可以很方便的与其它库或已有项目整合。<br>通过尽可能简单的API来实现<strong>响应数据的绑定和组合的视图组件</strong>。</p>
<p>特点：</p>
<ul>
<li>易用：在有HTMLCSSJavaScript的基础上，快速上手。</li>
<li>灵活：简单小巧的核心，渐进式技术栈，足以应付任何规模的应用。</li>
<li>性能：20kbmin+gzip运行大小、超快虚拟DOM、最省心的优化。</li>
</ul>
<hr>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li><p>Vue 核心对象：每一个 Vue 程序都是从一个 Vue 核心对象开始的。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	选项列表;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项列表</p>
<ul>
<li>el选项：用于接收获取到页面中的元素（根据常用选择器获取）</li>
<li>data选项：用于保存当前Vue对象中的数据，在视图中声明的变量需要在此处赋值</li>
<li>methods选项：用于定义方法，方法可以直接通过对象名调用，this代表当前Vue对象</li>
</ul>
</li>
<li><p>数据绑定：在视图部分获取脚本部分的数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;遍变量名&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 视图 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>姓名：&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>班级：&#123;&#123;classRoom&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;hi()&quot;</span>&gt;</span>打招呼<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 脚本</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#div&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">classRoom</span>:<span class="string">&quot;sea程序员&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">study</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;正在&quot;</span> + <span class="variable language_">this</span>.<span class="property">classRoom</span> + <span class="string">&quot;好好学习!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义打招呼方法  按一下按钮就弹出</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">hi</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        vm.<span class="title function_">study</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="指令介绍"><a href="#指令介绍" class="headerlink" title="指令介绍"></a>指令介绍</h3><p>指令：是带有 v- 前缀的特殊属性，不同指令具有不同含义</p>
<p>使用方法：通常编写在标签的属性上，值可以使用 JS 的表达式</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Vue%E6%8C%87%E4%BB%A4%E4%BB%8B%E7%BB%8D.png"></p>
<hr>
<h3 id="文本插值"><a href="#文本插值" class="headerlink" title="文本插值"></a>文本插值</h3><p>v-html：把文本解析为 HTML 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>	<span class="comment">&lt;!--标签不解析--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!--加粗显示--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#div&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">msg</span>:<span class="string">&quot;&lt;b&gt;Hello Vue&lt;/b&gt;&quot;</span>  </span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="绑定属性"><a href="#绑定属性" class="headerlink" title="绑定属性"></a>绑定属性</h3><p>v-bind：为 HTML 标签绑定属性值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>绑定属性<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.my</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>我是div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#div&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>:<span class="string">&quot;https://www.baidu.com&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">cls</span>:<span class="string">&quot;my&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>v-if：条件性的渲染某元素，判定为真时渲染，否则不渲染<br>v-else：条件性的渲染<br>v-else-if：条件性的渲染</p>
<p>v-show：根据条件展示某元素，区别在于切换的是display属性的值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 判断num的值，对3取余  余数为0显示div1  余数为1显示div2  余数为2显示div3 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;num % 3 == 0&quot;</span>&gt;</span>div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;num % 3 == 1&quot;</span>&gt;</span>div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>=<span class="string">&quot;num % 3 == 2&quot;</span>&gt;</span>div3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;flag&quot;</span>&gt;</span>div4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#div&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">num</span>:<span class="number">1</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">flag</span>:<span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p>v-for：列表渲染，遍历容器的元素或者对象的属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;name in names&quot;</span>&gt;</span></span><br><span class="line">                &#123;&#123;name&#125;&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in student&quot;</span>&gt;</span></span><br><span class="line">                &#123;&#123;value&#125;&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#div&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">names</span>:[<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>],</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">student</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">age</span>:<span class="number">23</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>v-on：为 HTML 标签绑定事件，有简写方式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;change()&quot;</span>&gt;</span>改变div的内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change()&quot;</span>&gt;</span>改变div的内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="comment">&lt;!--把sea改成传智播客--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#div&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">name</span>:<span class="string">&quot;sea程序员&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">change</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;传智播客&quot;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="表单绑定"><a href="#表单绑定" class="headerlink" title="表单绑定"></a>表单绑定</h3><ul>
<li><p><strong>表单绑定</strong><br>v-model：在表单元素上创建双向数据绑定</p>
</li>
<li><p><strong>双向数据绑定</strong><br>更新data数据，页面中的数据也会更新；更新页面数据，data数据也会更新</p>
</li>
<li><p><strong>MVVM模型(ModelViewViewModel)：是MVC模式的改进版</strong><br>在前端页面中，JS对象表示Model，页面表示View，两者做到了最大限度的分离。<br>将Model和View关联起来的就是ViewModel，它是桥梁。<br>ViewModel负责把Model的数据同步到View显示出来，还负责把View修改的数据同步回Model。</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/MVVM%E6%A8%A1%E5%9E%8B.png"></p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br><span class="line">            姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;username&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;age&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#div&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">username</span>:<span class="string">&quot;张三&quot;</span>,  <span class="comment">//输入框内容从网页更改后，更新为修改后的值</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">age</span>:<span class="number">23</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h2><p>Element：网站快速成型工具，是饿了么公司前端开发团队提供的一套基于Vue的网站组件库，使用Element前提必须要有Vue</p>
<p>组件：组成网页的部件，例如超链接、按钮、图片、表格等等</p>
<ul>
<li>Element官网：<a href="https://element.eleme.cn/#/zh-CN">https://element.eleme.cn/#/zh-CN</a></li>
</ul>
<ul>
<li><p>开发步骤：</p>
<ol>
<li>下载 Element 核心库</li>
<li>引入 Element 样式文件</li>
<li>引入 Vue 核心 js 文件</li>
<li>引入 Element 核心 js 文件</li>
<li>编写按钮标签</li>
<li>通过 Vue 核心对象加载元素</li>
</ol>
</li>
<li><p>代码实现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>快速入门<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;element-ui/lib/theme-chalk/index.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;element-ui/lib/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>我是按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span>&gt;</span>默认按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>主要按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;success&quot;</span>&gt;</span>成功按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;info&quot;</span>&gt;</span>信息按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;warning&quot;</span>&gt;</span>警告按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span>&gt;</span>危险按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">plain</span>&gt;</span>朴素按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">plain</span>&gt;</span>主要按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;success&quot;</span> <span class="attr">plain</span>&gt;</span>成功按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;info&quot;</span> <span class="attr">plain</span>&gt;</span>信息按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;warning&quot;</span> <span class="attr">plain</span>&gt;</span>警告按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span> <span class="attr">plain</span>&gt;</span>危险按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">round</span>&gt;</span>圆角按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">round</span>&gt;</span>主要按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;success&quot;</span> <span class="attr">round</span>&gt;</span>成功按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;info&quot;</span> <span class="attr">round</span>&gt;</span>信息按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;warning&quot;</span> <span class="attr">round</span>&gt;</span>警告按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span> <span class="attr">round</span>&gt;</span>危险按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">icon</span>=<span class="string">&quot;el-icon-search&quot;</span> <span class="attr">circle</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">icon</span>=<span class="string">&quot;el-icon-edit&quot;</span> <span class="attr">circle</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;success&quot;</span> <span class="attr">icon</span>=<span class="string">&quot;el-icon-check&quot;</span> <span class="attr">circle</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;info&quot;</span> <span class="attr">icon</span>=<span class="string">&quot;el-icon-message&quot;</span> <span class="attr">circle</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;warning&quot;</span> <span class="attr">icon</span>=<span class="string">&quot;el-icon-star-off&quot;</span> <span class="attr">circle</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span> <span class="attr">icon</span>=<span class="string">&quot;el-icon-delete&quot;</span> <span class="attr">circle</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#div&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><p>对组件的封装</p>
<ul>
<li><p>定义格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.component(组件名称, &#123;</span><br><span class="line">     props:组件的属性,</span><br><span class="line">     data: 组件的数据函数,</span><br><span class="line">     template: 组件解析的标签模板</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码实现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">my-button</span>&gt;</span>我的按钮<span class="tag">&lt;/<span class="name">my-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;my-button&quot;</span>,&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">props</span>:[<span class="string">&quot;style&quot;</span>],</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 数据函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">msg</span>:<span class="string">&quot;我的按钮&quot;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//解析标签模板</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>:<span class="string">&quot;&lt;button style=&#x27;color:red&#x27;&gt;&#123;&#123;msg&#125;&#125;&lt;/button&gt;&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#div&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>效果</p>
<div id="div"><button style="color: red;">我的按钮</button></div></li>
</ul>
<hr>
<h2 id="生命周期-2"><a href="#生命周期-2" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li><p>生命周期</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p>
</li>
<li><p>生命周期八个阶段</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%85%AB%E4%B8%AA%E9%98%B6%E6%AE%B5.png"></p>
</li>
</ul>
<hr>
<h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><p>在Vue中发送异步请求，本质上还是AJAX，使用axios这个插件来简化操作</p>
<ul>
<li><p>使用步骤：<br>1.引入axios核心js文件<br>2.调用axios对象的方法来发起异步请求<br>3.调用axios对象的方法来处理响应的数据</p>
</li>
<li><p>axios常用方法： </p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>get(请求的资源路径与请求的参数)</td>
<td>发起GET方式请求</td>
</tr>
<tr>
<td>post(请求的资源路径**,** 请求的参数)</td>
<td>发起POST方式请求</td>
</tr>
<tr>
<td>then(response)</td>
<td>请求成功后的回调函数，通过response获取响应的数据</td>
</tr>
<tr>
<td>catch(error)</td>
<td>请求失败后的回调函数，通过error获取错误信息</td>
</tr>
</tbody></table>
</li>
<li><p>代码实现</p>
<p>Servlet类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/testServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span>&#123;</span><br><span class="line">        <span class="comment">//设置请求响应编码</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//响应客户端</span></span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;请求成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HTML文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;name&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;send()&quot;</span>&gt;</span>发起请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#div&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">send</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//GET方式请求</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">/*axios.get(&quot;testServlet?name=&quot; + this.name)</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                    .then(resp =&gt; &#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                        alert(resp.data);</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                    &#125;)</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                    .catch(error =&gt; &#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                        alert(error);</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">                    &#125;)*/</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//POST方式请求</span></span></span><br><span class="line"><span class="language-javascript">                axios.<span class="title function_">post</span>(<span class="string">&quot;testServlet&quot;</span>, <span class="string">&quot;name=&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>)</span></span><br><span class="line"><span class="language-javascript">                    .<span class="title function_">then</span>(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125;)</span></span><br><span class="line"><span class="language-javascript">                    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>(error);</span></span><br><span class="line"><span class="language-javascript">                    &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>Nginx 是一个高性能的 HTTP 和<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理 </a>Web 服务器，同时也提供了 IMAP/POP3/SMTP 服务</p>
<p>Nginx 两个最核心的功能：高性能的静态 Web 服务器，反向代理</p>
<ul>
<li><p>安装指令：sudo apt-get install nginx</p>
</li>
<li><p>查看版本：nginx -v</p>
</li>
<li><p>系统指令：systemctl / service  start/restart/stop/status nginx</p>
</li>
</ul>
<p>配置文件安装目录：/etc/nginx</p>
<p>日志文件：/var/log/nginx</p>
<hr>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>nginx.conf 文件时 Nginx 的主配置文件</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Nginx配置文件conf.jpg" style="zoom:80%;" />

<ul>
<li><p>main 部分</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Nginx配置文件main部分.jpg" style="zoom: 67%;" />
</li>
<li><p>events 部分</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Nginx配置文件events部分.jpg" style="zoom:67%;" />
</li>
<li><p>server 部分</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Nginx配置文件server部分.jpg" style="zoom:67%;" />

<p>root 设置的路径会拼接上 location 的路径，然后去最终路径寻找对应的文件</p>
</li>
</ul>
<hr>
<h2 id="发布项目"><a href="#发布项目" class="headerlink" title="发布项目"></a>发布项目</h2><ol>
<li><p>创建一个 toutiao 目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home</span><br><span class="line"><span class="built_in">mkdir</span> toutiao</span><br></pre></td></tr></table></figure>
</li>
<li><p>将项目上传到 toutiao 目录</p>
</li>
<li><p>解压项目 unzip web.zip</p>
</li>
<li><p>编辑 Nginx 配置文件 nginx.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	listen       80;</span><br><span class="line">	server_name  localhost;</span><br><span class="line">	location / &#123;</span><br><span class="line">		root   /home/seazean/toutiao;</span><br><span class="line">		index  index.html index.htm;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 Nginx 服务：systemctl  restart nginx</p>
</li>
<li><p>浏览器打开网址：<a href="http://127.0.0.1/">http://127.0.0.1:80</a></p>
</li>
</ol>
<hr>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><blockquote>
<p>无法访问 Google，可以配置一个代理服务器，发送请求到代理服务器，代理服务器经过转发，再将请求转发给 Google，返回结果之后，再次转发给用户，这个叫做正向代理，正向代理对于用户来说，是有感知的</p>
</blockquote>
<p><strong>正向代理（forward proxy）</strong>：是一个位于客户端和目标服务器之间的代理服务器，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端，<strong>正向代理，其实是"代理服务器"代理了当前"客户端"，去和"目标服务器"进行交互</strong></p>
<p>作用：</p>
<ul>
<li>突破访问限制：通过代理服务器，可以突破自身 IP 访问限制，访问国外网站，教育网等</li>
<li>提高访问速度：代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度</li>
<li>隐藏客户端真实 IP：隐藏自己的 IP，免受攻击</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/正向代理.png" style="zoom:50%;" />





<p><strong>反向代理（reverse proxy）</strong>：是指以代理服务器来接受 Internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器，<strong>反向代理，其实是"代理服务器"代理了"目标服务器"，去和当前"客户端"进行交互</strong></p>
<p>作用：</p>
<ul>
<li>隐藏服务器真实 IP：使用反向代理，可以对客户端隐藏服务器的 IP 地址</li>
<li>负载均衡：根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上</li>
<li>提高访问速度：反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务</li>
<li>提供安全保障：反向代理服务器可以作为应用层防火墙，为网站提供对基于 Web 的攻击行为（例如 DoS/DDoS）的防护，更容易排查恶意软件等</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/反向代理.png" style="zoom:50%;" />

<p>区别：</p>
<ul>
<li><p>正向代理其实是客户端的代理，帮助客户端访问其无法访问的服务器资源；反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等</p>
</li>
<li><p>正向代理一般是客户端架设的，比如在自己的机器上安装一个代理软件；反向代理一般是服务器架设的，比如在自己的机器集群中部署一个反向代理服务器</p>
</li>
<li><p>正向代理中，服务器不知道真正的客户端到底是谁，以为访问自己的就是真实的客户端；反向代理中，客户端不知道真正的服务器是谁，以为自己访问的就是真实的服务器</p>
</li>
<li><p>正向代理和反向代理的作用和目的不同。正向代理主要是用来解决访问限制问题；而反向代理则是提供负载均衡、安全防护等作用；二者均能提高访问速度</p>
</li>
</ul>
</script></p></li></ul></html>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/08/02/DB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 数据库</span><br><span class="line">date: 2022-01-01 00:00:00</span><br><span class="line">tags: DataSource</span><br><span class="line">categories: DataSource</span><br><span class="line">comment</span><br></pre></td></tr></table></figure>

<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>数据库：DataBase，简称 DB，存储和管理数据的仓库</p>
<p>数据库的优势：</p>
<ul>
<li>可以持久化存储数据</li>
<li>方便存储和管理数据</li>
<li>使用了统一的方式操作数据库 SQL</li>
</ul>
<p>数据库、数据表、数据的关系介绍：</p>
<ul>
<li><p>数据库</p>
<ul>
<li>用于存储和管理数据的仓库</li>
<li>一个库中可以包含多个数据表</li>
</ul>
</li>
<li><p>数据表</p>
<ul>
<li>数据库最重要的组成部分之一</li>
<li>由纵向的列和横向的行组成（类似 excel 表格）</li>
<li>可以指定列名、数据类型、约束等</li>
<li>一个表中可以存储多条数据</li>
</ul>
</li>
<li><p>数据：想要永久化存储的数据</p>
</li>
</ul>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1zJ411M7TB">https://www.bilibili.com/video/BV1zJ411M7TB</a></p>
<p>参考专栏：<a href="https://time.geekbang.org/column/intro/139">https://time.geekbang.org/column/intro/139</a></p>
<p>参考书籍：<a href="https://book.douban.com/subject/35231266/">https://book.douban.com/subject/35231266/</a></p>
<hr>
<h3 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL"></a>MySQL</h3><p>MySQL 数据库是一个最流行的关系型数据库管理系统之一，关系型数据库是将数据保存在不同的数据表中，而且表与表之间可以有关联关系，提高了灵活性</p>
<p>缺点：数据存储在磁盘中，导致读写性能差，而且数据关系复杂，扩展性差</p>
<p>MySQL 所使用的 SQL 语句是用于访问数据库最常用的标准化语言</p>
<p>MySQL 配置：</p>
<ul>
<li><p>MySQL 安装：<a href="https://www.jianshu.com/p/ba48f1e386f0">https://www.jianshu.com/p/ba48f1e386f0</a></p>
</li>
<li><p>MySQL 配置：</p>
<ul>
<li><p>修改 MySQL 默认字符集：安装 MySQL 之后第一件事就是修改字符集编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/mysql/my.cnf</span><br><span class="line"></span><br><span class="line">添加如下内容：</span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 MySQL 服务： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start/restart mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录 MySQL：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -p  敲回车，输入密码</span><br><span class="line">初始密码查看：cat /var/log/mysqld.log</span><br><span class="line">在root@localhost:   后面的就是初始密码</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看默认字符集命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;char%&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改MySQL登录密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global validate_password_policy=0;</span><br><span class="line">set global validate_password_length=1;</span><br><span class="line">  </span><br><span class="line">set password=password(&#x27;密码&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>授予远程连接权限（MySQL 内输入）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 授权</span><br><span class="line">grant all privileges on *.* to &#x27;root&#x27; @&#x27;%&#x27; identified by &#x27;密码&#x27;;</span><br><span class="line">-- 刷新</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>修改 MySQL 绑定 IP：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/mysql/mysql.conf.d</span><br><span class="line">sudo chmod 666 mysqld.cnf </span><br><span class="line">vim mysqld.cnf </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bind-address = 127.0.0.1注释该行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭 Linux 防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">放行3306端口</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>体系结构详解：</p>
<ul>
<li>第一层：网络连接层<ul>
<li>一些客户端和链接服务，包含本地 Socket 通信和大多数基于客户端&#x2F;服务端工具实现的 TCP&#x2F;IP 通信，主要完成一些类似于连接处理、授权认证、及相关的安全方案</li>
<li>在该层上引入了<strong>连接池</strong> Connection Pool 的概念，管理缓冲用户连接，线程处理等需要缓存的需求</li>
<li>在该层上实现基于 SSL 的安全链接，服务器也会为安全接入的每个客户端验证它所具有的操作权限</li>
</ul>
</li>
</ul>
<ul>
<li>第二层：核心服务层<ul>
<li>查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，所有的内置函数（日期、数学、加密函数等）<ul>
<li>Management Serveices &amp; Utilities：系统管理和控制工具，备份、安全、复制、集群等</li>
<li>SQL Interface：接受用户的 SQL 命令，并且返回用户需要查询的结果</li>
<li>Parser：SQL 语句分析器</li>
<li>Optimizer：查询优化器</li>
<li>Caches &amp; Buffers：查询缓存，服务器会查询内部的缓存，如果缓存空间足够大，可以在大量读操作的环境中提升系统性能</li>
</ul>
</li>
<li>所有<strong>跨存储引擎的功能</strong>在这一层实现，如存储过程、触发器、视图等</li>
<li>在该层服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询顺序，是否利用索引等， 最后生成相应的执行操作</li>
<li>MySQL 中服务器层不管理事务，<strong>事务是由存储引擎实现的</strong></li>
</ul>
</li>
<li>第三层：存储引擎层<ul>
<li>Pluggable Storage Engines：存储引擎接口，MySQL 区别于其他数据库的重要特点就是其存储引擎的架构模式是插件式的（存储引擎是基于表的，而不是数据库）</li>
<li>存储引擎<strong>真正的负责了 MySQL 中数据的存储和提取</strong>，服务器通过 API 和存储引擎进行通信</li>
<li>不同的存储引擎具有不同的功能，共用一个 Server 层，可以根据开发的需要，来选取合适的存储引擎</li>
</ul>
</li>
<li>第四层：系统文件层<ul>
<li>数据存储层，主要是将数据存储在文件系统之上，并完成与存储引擎的交互</li>
<li>File System：文件系统，保存配置文件、数据文件、日志文件、错误文件、二进制文件等</li>
</ul>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"></p>
<hr>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>池化技术：对于访问数据库来说，建立连接的代价是比较昂贵的，因为每个连接对应一个用来交互的线程，频繁的创建关闭连接比较耗费资源，有必要建立数据库连接池，以提高访问的性能</p>
<p>连接建立 TCP 以后需要做<strong>权限验证</strong>，验证成功后可以进行执行 SQL。如果这时管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限，只有再新建的连接才会使用新的权限设置</p>
<p>MySQL 服务器可以同时和多个客户端进行交互，所以要保证每个连接会话的隔离性（事务机制部分详解）</p>
<p>整体的执行流程：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SQL的执行流程.png" style="zoom: 33%;">



<hr>
<h4 id="权限信息"><a href="#权限信息" class="headerlink" title="权限信息"></a>权限信息</h4><p>grant 语句会同时修改数据表和内存，判断权限的时候使用的是内存数据</p>
<p>flush privileges 语句本身会用数据表（磁盘）的数据重建一份内存权限数据，所以在权限数据可能存在不一致的情况下使用，这种不一致往往是由于直接用 DML 语句操作系统权限表导致的，所以尽量不要使用这类语句</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%9D%83%E9%99%90%E8%8C%83%E5%9B%B4.png"></p>
<hr>
<h4 id="连接状态"><a href="#连接状态" class="headerlink" title="连接状态"></a>连接状态</h4><p>客户端如果长时间没有操作，连接器就会自动断开，时间是由参数 wait_timeout 控制的，默认值是 8 小时。如果在连接被断开之后，客户端<strong>再次发送请求</strong>的话，就会收到一个错误提醒：<code>Lost connection to MySQL server during query</code></p>
<p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接；短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个</p>
<p>为了减少连接的创建，推荐使用长连接，但是<strong>过多的长连接会造成 OOM</strong>，解决方案：</p>
<ul>
<li><p>定期断开长连接，使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KILL CONNECTION id</span><br></pre></td></tr></table></figure>
</li>
<li><p>MySQL 5.7 版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源，这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态</p>
</li>
</ul>
<p>SHOW PROCESSLIST：查看当前 MySQL 在进行的线程，可以实时地查看 SQL 的执行情况，其中的 Command 列显示为 Sleep 的这一行，就表示现在系统里面有一个空闲连接</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SHOW_PROCESSLIST%E5%91%BD%E4%BB%A4.png"></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ID</td>
<td>用户登录 mysql 时系统分配的 connection_id，可以使用函数 connection_id() 查看</td>
</tr>
<tr>
<td>User</td>
<td>显示当前用户，如果不是 root，这个命令就只显示用户权限范围的 sql 语句</td>
</tr>
<tr>
<td>Host</td>
<td>显示这个语句是从哪个 ip 的哪个端口上发的，可以用来跟踪出现问题语句的用户</td>
</tr>
<tr>
<td>db</td>
<td>显示这个进程目前连接的是哪个数据库</td>
</tr>
<tr>
<td>Command</td>
<td>显示当前连接的执行的命令，一般取值为休眠 Sleep、查询 Query、连接 Connect 等</td>
</tr>
<tr>
<td>Time</td>
<td>显示这个状态持续的时间，单位是秒</td>
</tr>
<tr>
<td>State</td>
<td>显示使用当前连接的 sql 语句的状态，以查询为例，需要经过 copying to tmp table、sorting result、sending data等状态才可以完成</td>
</tr>
<tr>
<td>Info</td>
<td>显示执行的 sql 语句，是判断问题语句的一个重要依据</td>
</tr>
</tbody></table>
<p><strong>Sending data 状态</strong>表示 MySQL 线程开始访问数据行并把结果返回给客户端，而不仅仅只是返回给客户端，是处于执行器过程中的任意阶段。由于在 Sending data 状态下，MySQL 线程需要做大量磁盘读取操作，所以是整个查询中耗时最长的状态</p>
<hr>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><p>当执行完全相同的 SQL 语句的时候，服务器就会直接从缓存中读取结果，当数据被修改，之前的缓存会失效，修改比较频繁的表不适合做查询缓存</p>
<p>查询过程：</p>
<ol>
<li>客户端发送一条查询给服务器</li>
<li>服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果（一般是 K-V 键值对），否则进入下一阶段</li>
<li>分析器进行 SQL 分析，再由优化器生成对应的执行计划</li>
<li>MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询</li>
<li>将结果返回给客户端</li>
</ol>
<p>大多数情况下不建议使用查询缓存，因为查询缓存往往弊大于利</p>
<ul>
<li>查询缓存的<strong>失效非常频繁</strong>，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能费力地把结果存起来，还没使用就被一个更新全清空了，对于更新压力大的数据库来说，查询缓存的命中率会非常低</li>
<li>除非业务就是有一张静态表，很长时间才会更新一次，比如一个系统配置表，那这张表上的查询才适合使用查询缓存</li>
</ul>
<hr>
<h5 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h5><ol>
<li><p>查看当前 MySQL 数据库是否支持查询缓存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;have_query_cache&#x27;;	-- YES</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前 MySQL 是否开启了查询缓存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;query_cache_type&#x27;;	-- OFF</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><p>OFF 或 0：查询缓存功能关闭</p>
</li>
<li><p>ON 或 1：查询缓存功能打开，查询结果符合缓存条件即会缓存，否则不予缓存；可以显式指定 SQL_NO_CACHE 不予缓存</p>
</li>
<li><p>DEMAND 或 2：查询缓存功能按需进行，显式指定 SQL_CACHE 的 SELECT 语句才缓存，其它不予缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT SQL_CACHE id, name FROM customer; -- SQL_CACHE:查询结果可缓存</span><br><span class="line">SELECT SQL_NO_CACHE id, name FROM customer;-- SQL_NO_CACHE:不使用查询缓存</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>查看查询缓存的占用大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;query_cache_size&#x27;;-- 单位是字节 1048576 / 1024 = 1024 = 1KB</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看查询缓存的状态变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Qcache%&#x27;;</span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-查询缓存的状态变量.png" style="zoom:67%;">

<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Qcache_free_blocks</td>
<td>查询缓存中的可用内存块数</td>
</tr>
<tr>
<td>Qcache_free_memory</td>
<td>查询缓存的可用内存量</td>
</tr>
<tr>
<td>Qcache_hits</td>
<td>查询缓存命中数</td>
</tr>
<tr>
<td>Qcache_inserts</td>
<td>添加到查询缓存的查询数</td>
</tr>
<tr>
<td>Qcache_lowmen_prunes</td>
<td>由于内存不足而从查询缓存中删除的查询数</td>
</tr>
<tr>
<td>Qcache_not_cached</td>
<td>非缓存查询的数量（由于 query_cache_type 设置而无法缓存或未缓存）</td>
</tr>
<tr>
<td>Qcache_queries_in_cache</td>
<td>查询缓存中注册的查询数</td>
</tr>
<tr>
<td>Qcache_total_blocks</td>
<td>查询缓存中的块总数</td>
</tr>
</tbody></table>
</li>
<li><p>配置 my.cnf：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 666 /etc/mysql/my.cnf</span><br><span class="line">vim my.cnf</span><br><span class="line"><span class="comment"># mysqld中配置缓存</span></span><br><span class="line">query_cache_type=1</span><br></pre></td></tr></table></figure>

<p>重启服务既可生效，执行 SQL 语句进行验证 ，执行一条比较耗时的 SQL 语句，然后再多执行几次，查看后面几次的执行时间；获取通过查看查询缓存的缓存命中数，来判定是否走查询缓存</p>
</li>
</ol>
<hr>
<h5 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h5><p>查询缓存失效的情况：</p>
<ul>
<li><p>SQL 语句不一致，要想命中查询缓存，查询的 SQL 语句必须一致，因为<strong>缓存中 key 是查询的语句</strong>，value 是查询结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) from tb_item;</span><br><span class="line">Select count(*) from tb_item;	-- 不走缓存，首字母不一致</span><br></pre></td></tr></table></figure>
</li>
<li><p>当查询语句中有一些不确定查询时，则不会缓存，比如：now()、current_date()、curdate()、curtime()、rand()、uuid()、user()、database() </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tb_item WHERE updatetime &lt; NOW() LIMIT 1;</span><br><span class="line">SELECT USER();</span><br><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure>
</li>
<li><p>不使用任何表查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT &#x27;A&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询 mysql、information_schema、performance_schema 等系统表时，不走查询缓存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.engines;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<strong>跨存储引擎</strong>的存储过程、触发器或存储函数的主体内执行的查询，缓存失效</p>
</li>
<li><p>如果表更改，则使用该表的<strong>所有高速缓存查询都将变为无效</strong>并从高速缓存中删除，包括使用 MERGE 映射到已更改表的表的查询，比如：INSERT、UPDATE、DELETE、ALTER TABLE、DROP TABLE、DROP DATABASE</p>
</li>
</ul>
<hr>
<h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>没有命中查询缓存，就开始了 SQL 的真正执行，分析器会对 SQL 语句做解析</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>解析器：处理语法和解析查询，生成一课对应的解析树</p>
<ul>
<li>先做<strong>词法分析</strong>，输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么代表什么。从输入的 select 这个关键字识别出来这是一个查询语句；把字符串 t 识别成 表名 t，把字符串 id 识别成列 id</li>
<li>然后做<strong>语法分析</strong>，根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果语句不对，就会收到 <code>You have an error in your SQL syntax</code> 的错误提醒</li>
</ul>
<p>预处理器：进一步检查解析树的合法性，比如数据表和数据列是否存在、别名是否有歧义等</p>
<hr>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><h5 id="成本分析"><a href="#成本分析" class="headerlink" title="成本分析"></a>成本分析</h5><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序</p>
<ul>
<li>根据搜索条件找出所有可能的使用的索引</li>
<li>成本分析，执行成本由 I&#x2F;O 成本和 CPU 成本组成，计算全表扫描和使用不同索引执行 SQL 的代价</li>
<li>找到一个最优的执行方案，用最小的代价去执行语句</li>
</ul>
<p>在数据库里面，扫描行数是影响执行代价的因素之一，扫描的行数越少意味着访问磁盘的次数越少，消耗的 CPU 资源越少，优化器还会结合是否使用临时表、是否排序等因素进行综合判断</p>
<hr>
<h5 id="统计数据"><a href="#统计数据" class="headerlink" title="统计数据"></a>统计数据</h5><p>MySQL 中保存着两种统计数据：</p>
<ul>
<li>innodb_table_stats 存储了表的统计数据，每一条记录对应着一个表的统计数据</li>
<li>innodb_index_stats 存储了索引的统计数据，每一条记录对应着一个索引的一个统计项的数据</li>
</ul>
<p>MySQL 在真正执行语句之前，并不能精确地知道满足条件的记录有多少条，只能根据统计信息来估算记录，统计信息就是索引的区分度,一个索引上不同的值的个数（比如性别只能是男女，就是 2 ），称之为基数（cardinality），<strong>基数越大说明区分度越好</strong></p>
<p>通过<strong>采样统计</strong>来获取基数，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数</p>
<p>在 MySQL 中，有两种存储统计数据的方式，可以通过设置参数 <code>innodb_stats_persistent</code> 的值来选择：</p>
<ul>
<li>ON：表示统计信息会持久化存储（默认），采样页数 N 默认为 20，可以通过 <code>innodb_stats_persistent_sample_pages</code> 指定，页数越多统计的数据越准确，但消耗的资源更大</li>
<li>OFF：表示统计信息只存储在内存，采样页数 N 默认为 8，也可以通过系统变量设置（不推荐，每次重新计算浪费资源）</li>
</ul>
<p>数据表是会持续更新的，两种统计信息的更新方式：</p>
<ul>
<li>设置 <code>innodb_stats_auto_recalc</code> 为 1，当发生变动的记录数量超过表大小的 10% 时，自动触发重新计算，不过是<strong>异步进行</strong></li>
<li>调用 <code>ANALYZE TABLE t</code> 手动更新统计信息，只对信息做<strong>重新统计</strong>（不是重建表），没有修改数据，这个过程中加了 MDL 读锁并且是同步进行，所以会暂时阻塞系统</li>
</ul>
<p><strong>EXPLAIN 执行计划在优化器阶段生成</strong>，如果 explain 的结果预估的 rows 值跟实际情况差距比较大，可以执行 analyze 命令重新修正信息</p>
<hr>
<h5 id="错选索引"><a href="#错选索引" class="headerlink" title="错选索引"></a>错选索引</h5><p>采样统计本身是估算数据，或者 SQL 语句中的字段选择有问题时，可能导致 MySQL 没有选择正确的执行索引</p>
<p>解决方法：</p>
<ul>
<li><p>采用 force index 强行选择一个索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> FORCE INDEX(name) <span class="keyword">WHERE</span> NAME<span class="operator">=</span><span class="string">&#x27;seazean&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以考虑修改 SQL 语句，引导 MySQL 使用期望的索引</p>
</li>
<li><p>新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引</p>
</li>
</ul>
<hr>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>开始执行的时候，要先判断一下当前连接对表有没有<strong>执行查询的权限</strong>，如果没有就会返回没有权限的错误，在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。如果有权限，就打开表继续执行，执行器就会根据表的引擎定义，去使用这个引擎提供的接口</p>
<hr>
<h4 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h4><p>Server 层和存储引擎层的交互是<strong>以记录为单位的</strong>，存储引擎会将单条记录返回给 Server 层做进一步处理，并不是直接返回所有的记录</p>
<p>工作流程：</p>
<ul>
<li>首先根据二级索引选择扫描范围，获取第一条符合二级索引条件的记录，进行回表查询，将聚簇索引的记录返回 Server 层，由 Server 判断记录是否符合要求</li>
<li>然后在二级索引上继续扫描下一个符合条件的记录</li>
</ul>
<p>推荐阅读：<a href="https://mp.weixin.qq.com/s/YZ-LckObephrP1f15mzHpA">https://mp.weixin.qq.com/s/YZ-LckObephrP1f15mzHpA</a></p>
<hr>
<h3 id="终止流程"><a href="#终止流程" class="headerlink" title="终止流程"></a>终止流程</h3><h4 id="终止语句"><a href="#终止语句" class="headerlink" title="终止语句"></a>终止语句</h4><p>终止线程中正在执行的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KILL QUERY thread_id</span><br></pre></td></tr></table></figure>

<p>KILL 不是马上终止的意思，而是告诉执行线程这条语句已经不需要继续执行，可以开始执行停止的逻辑（类似于打断）。因为对表做增删改查操作，会在表上加 MDL 读锁，如果线程被 KILL 时就直接终止，那这个 MDL 读锁就没机会被释放了</p>
<p>命令 <code>KILL QUERYthread_id_A</code> 的执行流程：</p>
<ul>
<li>把 session A 的运行状态改成 THD::KILL_QUERY（将变量 killed 赋值为 THD::KILL_QUERY）</li>
<li>给 session A 的执行线程发一个信号，让 session A 来处理这个 THD::KILL_QUERY 状态</li>
</ul>
<p>会话处于等待状态（锁阻塞），必须满足是一个可以被唤醒的等待，必须有机会去<strong>判断线程的状态</strong>，如果不满足就会造成 KILL 失败</p>
<p>典型场景：innodb_thread_concurrency 为 2，代表并发线程上限数设置为 2</p>
<ul>
<li>session A 执行事务，session B 执行事务，达到线程上限；此时 session C 执行事务会阻塞等待，session D 执行 kill query C 无效</li>
<li>C 的逻辑是每 10 毫秒判断是否可以进入 InnoDB 执行，如果不行就调用 nanosleep 函数进入 sleep 状态，没有去判断线程状态</li>
</ul>
<p>补充：执行 Ctrl+C 的时候，是 MySQL 客户端另外启动一个连接，然后发送一个 KILL QUERY 命令</p>
<hr>
<h4 id="终止连接"><a href="#终止连接" class="headerlink" title="终止连接"></a>终止连接</h4><p>断开线程的连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KILL CONNECTION id</span><br></pre></td></tr></table></figure>

<p>断开连接后执行 SHOW PROCESSLIST 命令，如果这条语句的 Command 列显示 Killed，代表线程的状态是 KILL_CONNECTION，说明这个线程有语句正在执行，当前状态是停止语句执行中，终止逻辑耗时较长</p>
<ul>
<li>超大事务执行期间被 KILL，这时回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长</li>
<li>大查询回滚，如果查询过程中生成了比较大的临时文件，删除临时文件可能需要等待 IO 资源，导致耗时较长</li>
<li>DDL 命令执行到最后阶段被 KILL，需要删除中间过程的临时文件，也可能受 IO 资源影响耗时较久</li>
</ul>
<p>总结：KILL CONNECTION 本质上只是把客户端的 SQL 连接断开，后面的终止流程还是要走 KILL QUERY</p>
<p>一个事务被 KILL 之后，持续处于回滚状态，不应该强行重启整个 MySQL 进程，应该等待事务自己执行完成，因为重启后依然继续做回滚操作的逻辑</p>
<hr>
<h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><p>mysql 不是指 mysql 服务，而是指 mysql 的客户端工具</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql [options] [database]</span><br></pre></td></tr></table></figure>

<ul>
<li>-u  –user&#x3D;name：指定用户名</li>
<li>-p  –password[&#x3D;name]：指定密码</li>
<li>-h  –host&#x3D;name：指定服务器IP或域名</li>
<li>-P  –port&#x3D;#：指定连接端口</li>
<li>-e  –execute&#x3D;name：执行SQL语句并退出，在控制台执行SQL语句，而不用连接到数据库执行</li>
</ul>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -P 3306 -u root -p</span><br><span class="line">mysql -uroot -p2143 db01 -e <span class="string">&quot;select * from tb_book&quot;</span>;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h4><p>mysqladmin 是一个执行管理操作的客户端程序，用来检查服务器的配置和当前状态、创建并删除数据库等</p>
<p>通过 <code>mysqladmin --help</code> 指令查看帮助文档</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqladmin -uroot -p2143 create <span class="string">&#x27;test01&#x27;</span>;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p>服务器生成的日志文件以二进制格式保存，如果需要检查这些文本，就要使用 mysqlbinlog 日志管理工具</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlbinlog [options]  log-files1 log-files2 ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-d  –database&#x3D;name：指定数据库名称，只列出指定的数据库相关操作</p>
</li>
<li><p>-o  –offset&#x3D;#：忽略掉日志中的前 n 行命令。</p>
</li>
<li><p>-r  –result-file&#x3D;name：将输出的文本格式日志输出到指定文件。</p>
</li>
<li><p>-s  –short-form：显示简单格式，省略掉一些信息。</p>
</li>
<li><p>–start-datatime&#x3D;date1  –stop-datetime&#x3D;date2：指定日期间隔内的所有日志</p>
</li>
<li><p>–start-position&#x3D;pos1 –stop-position&#x3D;pos2：指定位置间隔内的所有日志</p>
</li>
</ul>
<hr>
<h4 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h4><h5 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h5><p>mysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移，备份内容包含创建表，及插入表的 SQL 语句</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line">mysqldump [options] --database/-B db1 [db2 db3...]</span><br><span class="line">mysqldump [options] --all-databases/-A</span><br></pre></td></tr></table></figure>

<p>连接选项：</p>
<ul>
<li>-u  –user&#x3D;name：指定用户名</li>
<li>-p  –password[&#x3D;name]：指定密码</li>
<li>-h  –host&#x3D;name：指定服务器 IP 或域名</li>
<li>-P  –port&#x3D;#：指定连接端口</li>
</ul>
<p>输出内容选项：</p>
<ul>
<li>–add-drop-database：在每个数据库创建语句前加上 Drop database 语句</li>
<li>–add-drop-table：在每个表创建语句前加上 Drop table 语句 , 默认开启，不开启 (–skip-add-drop-table)</li>
<li>-n  –no-create-db：不包含数据库的创建语句</li>
<li>-t  –no-create-info：不包含数据表的创建语句</li>
<li>-d –no-data：不包含数据</li>
<li>-T, –tab&#x3D;name：自动生成两个文件：一个 .sql 文件，创建表结构的语句；一个 .txt 文件，数据文件，相当于 select into outfile</li>
</ul>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p2143 db01 tb_book --add-drop-database --add-drop-table &gt; a</span><br><span class="line">mysqldump -uroot -p2143 -T /tmp <span class="built_in">test</span> city</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h5><p>命令行方式：</p>
<ul>
<li>备份命令：mysqldump -u root -p 数据库名称 &gt; 文件保存路径</li>
<li>恢复<ol>
<li>登录MySQL数据库：<code>mysql -u root p</code></li>
<li>删除已经备份的数据库</li>
<li>重新创建与备份数据库名称相同的数据库</li>
<li>使用该数据库</li>
<li>导入文件执行：<code>source 备份文件全路径</code></li>
</ol>
</li>
</ul>
<p>更多方式参考：<a href="https://time.geekbang.org/column/article/81925">https://time.geekbang.org/column/article/81925</a></p>
<p>图形化界面：</p>
<ul>
<li><p>备份</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E5%A4%87%E4%BB%BD.png" alt="图形化界面备份"></p>
</li>
<li><p>恢复</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E6%81%A2%E5%A4%8D.png" alt="图形化界面恢复"></p>
</li>
</ul>
<hr>
<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>mysqlimport 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlimport [options]  db_name  textfile1  [textfile2...]</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlimport -uroot -p2143 <span class="built_in">test</span> /tmp/city.txt</span><br></pre></td></tr></table></figure>

<p>导入 sql 文件，可以使用 MySQL 中的 source 指令 : </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source 文件全路径</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="show"><a href="#show" class="headerlink" title="show"></a>show</h4><p>mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlshow [options] [db_name [table_name [col_name]]]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>–count：显示数据库及表的统计信息（数据库，表 均可以不指定）</p>
</li>
<li><p>-i：显示指定数据库或者指定表的状态信息</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询每个数据库的表的数量及表中记录的数量</span></span><br><span class="line">mysqlshow -uroot -p1234 --count</span><br><span class="line"><span class="comment">#查询test库中每个表中的字段书，及行数</span></span><br><span class="line">mysqlshow -uroot -p1234 <span class="built_in">test</span> --count</span><br><span class="line"><span class="comment">#查询test库中book表的详细情况</span></span><br><span class="line">mysqlshow -uroot -p1234 <span class="built_in">test</span> book --count</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="单表操作"><a href="#单表操作" class="headerlink" title="单表操作"></a>单表操作</h2><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul>
<li><p>SQL</p>
<ul>
<li>Structured Query Language：结构化查询语言</li>
<li>定义了操作所有关系型数据库的规则，每种数据库操作的方式可能会存在不一样的地方，称为“方言”</li>
</ul>
</li>
<li><p>SQL 通用语法</p>
<ul>
<li>SQL 语句可以单行或多行书写，以<strong>分号结尾</strong>。</li>
<li>可使用空格和缩进来增强语句的可读性。</li>
<li>MySQL 数据库的 SQL 语句不区分大小写，<strong>关键字建议使用大写</strong>。</li>
<li>数据库的注释：<ul>
<li>单行注释：– 注释内容       #注释内容（MySQL 特有）</li>
<li>多行注释：&#x2F;* 注释内容 *&#x2F;</li>
</ul>
</li>
</ul>
</li>
<li><p>SQL 分类</p>
<ul>
<li><p>DDL（Data Definition Language）数据定义语言</p>
<ul>
<li>用来定义数据库对象：数据库，表，列等。关键字：create、drop,、alter 等</li>
</ul>
</li>
<li><p>DML（Data Manipulation Language）数据操作语言</p>
<ul>
<li>用来对数据库中表的数据进行增删改。关键字：insert、delete、update 等</li>
</ul>
</li>
<li><p>DQL（Data Query Language）数据查询语言</p>
<ul>
<li>用来查询数据库中表的记录(数据)。关键字：select、where 等</li>
</ul>
</li>
<li><p>DCL（Data Control Language）数据控制语言</p>
<ul>
<li>用来定义数据库的访问权限和安全级别，及创建用户。关键字：grant， revoke等</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SQL%E5%88%86%E7%B1%BB.png"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><h4 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h4><ul>
<li><p>R(Retrieve)：查询</p>
<ul>
<li><p>查询所有数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询某个数据库的创建语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名称;  <span class="comment">-- 标准语法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE mysql;     <span class="comment">-- 查看mysql数据库的创建格式</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>C(Create)：创建</p>
<ul>
<li><p>创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名称;-- 标准语法</span><br><span class="line"></span><br><span class="line">CREATE DATABASE db1;     -- 创建db1数据库</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库（判断，如果不存在则创建）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS 数据库名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库，并指定字符集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名称 CHARACTER SET 字符集名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例如：创建db4数据库、如果不存在则创建，指定字符集为gbk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建db4数据库、如果不存在则创建，指定字符集为gbk</span><br><span class="line">CREATE DATABASE IF NOT EXISTS db4 CHARACTER SET gbk;</span><br><span class="line"></span><br><span class="line">-- 查看db4数据库的字符集</span><br><span class="line">SHOW CREATE DATABASE db4;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>U(Update)：修改</p>
<ul>
<li><p>修改数据库的字符集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE 数据库名称 CHARACTER SET 字符集名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用字符集：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--查询所有支持的字符集</span><br><span class="line">SHOW CHARSET;</span><br><span class="line">--查看所有支持的校对规则</span><br><span class="line">SHOW COLLATION;</span><br><span class="line"></span><br><span class="line">-- 字符集: utf8,latinI,GBK,,GBK是utf8的子集</span><br><span class="line">-- 校对规则: ci 大小定不敏感，cs或bin大小写敏感</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>D(Delete)：删除</p>
<ul>
<li><p>删除数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE 数据库名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据库(判断，如果存在则删除)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS 数据库名称;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用数据库：</p>
<ul>
<li><p>查询当前正在使用的数据库名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE 数据库名称； -- 标准语法</span><br><span class="line">USE db4;	   -- 使用db4数据库</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h4><ul>
<li><p>R(Retrieve)：查询</p>
<ul>
<li><p>查询数据库中所有的数据表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE mysql;-- 使用mysql数据库</span><br><span class="line"></span><br><span class="line">SHOW TABLES;-- 查询库中所有的表</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询表结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询表字符集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLE STATUS FROM 库名 LIKE &#x27;表名&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>C(Create)：创建</p>
<ul>
<li><p>创建数据表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    列名1 数据类型1,</span><br><span class="line">    列名2 数据类型2,</span><br><span class="line">    ....</span><br><span class="line">    列名n 数据类型n</span><br><span class="line">);</span><br><span class="line">-- 注意：最后一列，不需要加逗号</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 LIKE 被复制的表名;  -- 标准语法</span><br><span class="line"></span><br><span class="line">CREATE TABLE product2 LIKE product; -- 复制product表到product2表</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据类型</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>INT</td>
<td>整数类型</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>小数类型</td>
</tr>
<tr>
<td>DATE</td>
<td>日期，只包含年月日：yyyy-MM-dd</td>
</tr>
<tr>
<td>DATETIME</td>
<td>日期，包含年月日时分秒：yyyy-MM-dd HH:mm:ss</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>时间戳类型，包含年月日时分秒：yyyy-MM-dd HH:mm:ss<br>如果不给这个字段赋值或赋值为 NULL，则默认使用当前的系统时间</td>
</tr>
<tr>
<td>CHAR</td>
<td>字符串，定长类型</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>字符串，<strong>变长类型</strong><br>name varchar(20) 代表姓名最大 20 个字符：zhangsan 8 个字符，张三 2 个字符</td>
</tr>
</tbody></table>
<p><code>INT(n)</code>：n 代表位数</p>
<ul>
<li>3：int（9）显示结果为 000000010</li>
<li>3：int（3）显示结果为 010</li>
</ul>
<p><code>varchar(n)</code>：n 表示的是字符数</p>
</li>
<li><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 使用db3数据库</span><br><span class="line">USE db3;</span><br><span class="line"></span><br><span class="line">-- 创建一个product商品表</span><br><span class="line">CREATE TABLE product(</span><br><span class="line">	id INT,				-- 商品编号</span><br><span class="line">	NAME VARCHAR(30),	-- 商品名称</span><br><span class="line">	price DOUBLE,		-- 商品价格</span><br><span class="line">	stock INT,			-- 商品库存</span><br><span class="line">	insert_time DATE    -- 上架时间</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>​    </p>
<ul>
<li><p>U(Update)：修改</p>
<ul>
<li><p>修改表名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME TO 新的表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表的字符集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 CHARACTER SET 字符集名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加一列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 列名 数据类型;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改列数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 新数据类型;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改列名称和数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 列名;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>D(Delete)：删除</p>
<ul>
<li><p>删除数据表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据表(判断，如果存在则删除)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS 表名;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><h4 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h4><ul>
<li><p>新增表数据</p>
<ul>
<li><p>新增格式 1：给指定列添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名(列名1,列名2...) VALUES (值1,值2...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增格式 2：默认给全部列添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES (值1,值2,值3,...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增格式 3：批量添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 给指定列批量添加数据</span><br><span class="line">INSERT INTO 表名(列名1,列名2,...) VALUES (值1,值2,...),(值1,值2,...)...;</span><br><span class="line"></span><br><span class="line">-- 默认给所有列批量添加数据 </span><br><span class="line">INSERT INTO 表名 VALUES (值1,值2,值3,...),(值1,值2,值3,...)...;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>字符串拼接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONCAT(string1,string2,&#x27;&#x27;,...)</span><br></pre></td></tr></table></figure>


</li>
<li><p>注意事项</p>
<ul>
<li>列名和值的数量以及数据类型要对应</li>
<li>除了数字类型，其他数据类型的数据都需要加引号(单引双引都可以，推荐单引)</li>
</ul>
</li>
</ul>
<hr>
<h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><ul>
<li><p>修改表数据语法</p>
<ul>
<li><p>标准语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE 表名 SET 列名1 = 值1,列名2 = 值2,... [where 条件];</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改电视的价格为1800、库存为36</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE product SET price=1800,stock=36 WHERE NAME=&#x27;电视&#x27;;</span><br><span class="line">SELECT * FROM product;-- 查看所有商品信息</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>修改语句中必须加条件</li>
<li>如果不加条件，则将所有数据都修改</li>
</ul>
</li>
</ul>
<hr>
<h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><ul>
<li><p>删除表数据语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM 表名 [WHERE 条件];</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项</p>
<ul>
<li>删除语句中必须加条件</li>
<li>如果不加条件，则将所有数据删除</li>
</ul>
</li>
</ul>
<p>​    </p>
<hr>
<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><h4 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h4><p>数据库查询遵循条件在前的原则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT</span><br><span class="line">	&lt;select list&gt;</span><br><span class="line">FROM</span><br><span class="line">	&lt;left_table&gt; &lt;join_type&gt;</span><br><span class="line">JOIN</span><br><span class="line">	&lt;right_table&gt; ON &lt;join_condition&gt;	-- 连接查询在多表查询部分详解</span><br><span class="line">WHERE</span><br><span class="line">	&lt;where_condition&gt;</span><br><span class="line">GROUP BY</span><br><span class="line">	&lt;group_by_list&gt;</span><br><span class="line">HAVING</span><br><span class="line">	&lt;having_condition&gt;</span><br><span class="line">ORDER BY</span><br><span class="line">	&lt;order_by_condition&gt;</span><br><span class="line">LIMIT</span><br><span class="line">	&lt;limit_params&gt;</span><br></pre></td></tr></table></figure>

<p>执行顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM	&lt;left_table&gt;</span><br><span class="line"></span><br><span class="line">ON 		&lt;join_condition&gt;</span><br><span class="line"></span><br><span class="line">&lt;join_type&gt;		JOIN	&lt;right_table&gt;</span><br><span class="line"></span><br><span class="line">WHERE		&lt;where_condition&gt;</span><br><span class="line"></span><br><span class="line">GROUP BY 	&lt;group_by_list&gt;</span><br><span class="line"></span><br><span class="line">HAVING		&lt;having_condition&gt;</span><br><span class="line"></span><br><span class="line">SELECT DISTINCT		&lt;select list&gt;</span><br><span class="line"></span><br><span class="line">ORDER BY	&lt;order_by_condition&gt;</span><br><span class="line"></span><br><span class="line">LIMIT		&lt;limit_params&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="查询全部"><a href="#查询全部" class="headerlink" title="查询全部"></a>查询全部</h4><ul>
<li><p>查询全部的表数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 标准语法</span><br><span class="line">SELECT * FROM 表名;</span><br><span class="line"></span><br><span class="line">-- 查询product表所有数据(常用)</span><br><span class="line">SELECT * FROM product;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询指定字段的表数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名1,列名2,... FROM 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>去除重复查询</strong>：只有值全部重复的才可以去除，需要创建临时表辅助查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT 列名1,列名2,... FROM 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算列的值（四则运算）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名1 运算符(+ - * /) 列名2 FROM 表名;</span><br><span class="line"></span><br><span class="line">/*如果某一列值为null，可以进行替换</span><br><span class="line">	ifnull(表达式1,表达式2)</span><br><span class="line">	表达式1：想替换的列</span><br><span class="line">	表达式2：想替换的值*/</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询商品名称和库存，库存数量在原有基础上加10</span><br><span class="line">SELECT NAME,stock+10 FROM product;</span><br><span class="line"></span><br><span class="line">-- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断</span><br><span class="line">SELECT NAME,IFNULL(stock,0)+10 FROM product;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>起别名</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名1,列名2,... AS 别名 FROM 表名;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断，起别名为getSum,AS可以省略。</span><br><span class="line">SELECT NAME,IFNULL(stock,0)+10 AS getsum FROM product;</span><br><span class="line">SELECT NAME,IFNULL(stock,0)+10 getsum FROM product;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><ul>
<li><p>条件查询语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 WHERE 条件;</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件分类</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt; 或 !&#x3D;</td>
<td>不等于</td>
</tr>
<tr>
<td>BETWEEN … AND …</td>
<td>在某个范围之内(都包含)</td>
</tr>
<tr>
<td>IN(…)</td>
<td>多选一</td>
</tr>
<tr>
<td>LIKE</td>
<td><strong>模糊查询</strong>：_单个任意字符、%任意个字符、[] 匹配集合内的字符<br><code>LIKE &#39;[^AB]%&#39; </code>：不以 A 和 B 开头的任意文本</td>
</tr>
<tr>
<td>IS NULL</td>
<td>是NULL</td>
</tr>
<tr>
<td>IS NOT NULL</td>
<td>不是NULL</td>
</tr>
<tr>
<td>AND 或 &amp;&amp;</td>
<td>并且</td>
</tr>
<tr>
<td>OR 或 ||</td>
<td>或者</td>
</tr>
<tr>
<td>NOT 或 !</td>
<td>非，不是</td>
</tr>
<tr>
<td>UNION</td>
<td>对两个结果集进行<strong>并集操作并进行去重，同时进行默认规则的排序</strong></td>
</tr>
<tr>
<td>UNION ALL</td>
<td>对两个结果集进行并集操作不进行去重，不进行排序</td>
</tr>
</tbody></table>
</li>
<li><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询库存大于20的商品信息</span><br><span class="line">SELECT * FROM product WHERE stock &gt; 20;</span><br><span class="line"></span><br><span class="line">-- 查询品牌为华为的商品信息</span><br><span class="line">SELECT * FROM product WHERE brand=&#x27;华为&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询金额在4000 ~ 6000之间的商品信息</span><br><span class="line">SELECT * FROM product WHERE price &gt;= 4000 AND price &lt;= 6000;</span><br><span class="line">SELECT * FROM product WHERE price BETWEEN 4000 AND 6000;</span><br><span class="line"></span><br><span class="line">-- 查询库存为14、30、23的商品信息</span><br><span class="line">SELECT * FROM product WHERE stock=14 OR stock=30 OR stock=23;</span><br><span class="line">SELECT * FROM product WHERE stock IN(14,30,23);</span><br><span class="line"></span><br><span class="line">-- 查询库存为null的商品信息</span><br><span class="line">SELECT * FROM product WHERE stock IS NULL;</span><br><span class="line">-- 查询库存不为null的商品信息</span><br><span class="line">SELECT * FROM product WHERE stock IS NOT NULL;</span><br><span class="line"></span><br><span class="line">-- 查询名称以&#x27;小米&#x27;为开头的商品信息</span><br><span class="line">SELECT * FROM product WHERE NAME LIKE &#x27;小米%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询名称第二个字是&#x27;为&#x27;的商品信息</span><br><span class="line">SELECT * FROM product WHERE NAME LIKE &#x27;_为%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询名称为四个字符的商品信息 4个下划线</span><br><span class="line">SELECT * FROM product WHERE NAME LIKE &#x27;____&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询名称中包含电脑的商品信息</span><br><span class="line">SELECT * FROM product WHERE NAME LIKE &#x27;%电脑%&#x27;;</span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-DQL数据准备.png" style="zoom: 80%;"></li>
</ul>
<hr>
<h4 id="函数查询"><a href="#函数查询" class="headerlink" title="函数查询"></a>函数查询</h4><h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h5><p>聚合函数：将一列数据作为一个整体，进行纵向的计算</p>
<ul>
<li><p>聚合函数语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 函数名(列名) FROM 表名 [WHERE 条件]</span><br></pre></td></tr></table></figure>
</li>
<li><p>聚合函数分类</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>COUNT(列名)</td>
<td>统计数量（一般选用不为 null 的列）</td>
</tr>
<tr>
<td>MAX(列名)</td>
<td>最大值</td>
</tr>
<tr>
<td>MIN(列名)</td>
<td>最小值</td>
</tr>
<tr>
<td>SUM(列名)</td>
<td>求和</td>
</tr>
<tr>
<td>AVG(列名)</td>
<td>平均值（会忽略 null 行）</td>
</tr>
</tbody></table>
</li>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 计算product表中总记录条数 7</span><br><span class="line">SELECT COUNT(*) FROM product;</span><br><span class="line"></span><br><span class="line">-- 获取最高价格</span><br><span class="line">SELECT MAX(price) FROM product;</span><br><span class="line">-- 获取最高价格的商品名称</span><br><span class="line">SELECT NAME,price FROM product WHERE price = (SELECT MAX(price) FROM product);</span><br><span class="line"></span><br><span class="line">-- 获取最低库存</span><br><span class="line">SELECT MIN(stock) FROM product;</span><br><span class="line">-- 获取最低库存的商品名称</span><br><span class="line">SELECT NAME,stock FROM product WHERE stock = (SELECT MIN(stock) FROM product);</span><br><span class="line"></span><br><span class="line">-- 获取总库存数量</span><br><span class="line">SELECT SUM(stock) FROM product;</span><br><span class="line">-- 获取品牌为小米的平均商品价格</span><br><span class="line">SELECT AVG(price) FROM product WHERE brand=&#x27;小米&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="文本函数"><a href="#文本函数" class="headerlink" title="文本函数"></a>文本函数</h5><p>CONCAT()：用于连接两个字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="built_in">TRIM</span>(col1), <span class="string">&#x27;(&#x27;</span>, <span class="built_in">TRIM</span>(col2), <span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span> concat_col <span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="comment">-- 许多数据库会使用空格把一个值填充为列宽，连接的结果出现一些不必要的空格，使用TRIM()可以去除首尾空格</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数名称</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>LENGTH</td>
<td>计算字符串长度函数，返回字符串的字节长度</td>
</tr>
<tr>
<td>CONCAT</td>
<td>合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个</td>
</tr>
<tr>
<td>INSERT</td>
<td>替换字符串函数</td>
</tr>
<tr>
<td>LOWER</td>
<td>将字符串中的字母转换为小写</td>
</tr>
<tr>
<td>UPPER</td>
<td>将字符串中的字母转换为大写</td>
</tr>
<tr>
<td>LEFT</td>
<td>从左侧字截取符串，返回字符串左边的若干个字符</td>
</tr>
<tr>
<td>RIGHT</td>
<td>从右侧字截取符串，返回字符串右边的若干个字符</td>
</tr>
<tr>
<td>TRIM</td>
<td>删除字符串左右两侧的空格</td>
</tr>
<tr>
<td>REPLACE</td>
<td>字符串替换函数，返回替换后的新字符串</td>
</tr>
<tr>
<td>SUBSTRING</td>
<td>截取字符串，返回从指定位置开始的指定长度的字符换</td>
</tr>
<tr>
<td>REVERSE</td>
<td>字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串</td>
</tr>
</tbody></table>
<hr>
<h5 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h5><table>
<thead>
<tr>
<th>函数名称</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>ABS</td>
<td>求绝对值</td>
</tr>
<tr>
<td>SQRT</td>
<td>求二次方根</td>
</tr>
<tr>
<td>MOD</td>
<td>求余数</td>
</tr>
<tr>
<td>CEIL 和 CEILING</td>
<td>两个函数功能相同，都是返回不小于参数的最小整数，即向上取整</td>
</tr>
<tr>
<td>FLOOR</td>
<td>向下取整，返回值转化为一个BIGINT</td>
</tr>
<tr>
<td>RAND</td>
<td>生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列</td>
</tr>
<tr>
<td>ROUND</td>
<td>对所传参数进行四舍五入</td>
</tr>
<tr>
<td>SIGN</td>
<td>返回参数的符号</td>
</tr>
<tr>
<td>POW 和 POWER</td>
<td>两个函数的功能相同，都是所传参数的次方的结果值</td>
</tr>
<tr>
<td>SIN</td>
<td>求正弦值</td>
</tr>
<tr>
<td>ASIN</td>
<td>求反正弦值，与函数 SIN 互为反函数</td>
</tr>
<tr>
<td>COS</td>
<td>求余弦值</td>
</tr>
<tr>
<td>ACOS</td>
<td>求反余弦值，与函数 COS 互为反函数</td>
</tr>
<tr>
<td>TAN</td>
<td>求正切值</td>
</tr>
<tr>
<td>ATAN</td>
<td>求反正切值，与函数 TAN 互为反函数</td>
</tr>
<tr>
<td>COT</td>
<td>求余切值</td>
</tr>
</tbody></table>
<hr>
<h5 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h5><table>
<thead>
<tr>
<th>函数名称</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>CURDATE 和 CURRENT_DATE</td>
<td>两个函数作用相同，返回当前系统的日期值</td>
</tr>
<tr>
<td>CURTIME 和 CURRENT_TIME</td>
<td>两个函数作用相同，返回当前系统的时间值</td>
</tr>
<tr>
<td>NOW 和  SYSDATE</td>
<td>两个函数作用相同，返回当前系统的日期和时间值</td>
</tr>
<tr>
<td>MONTH</td>
<td>获取指定日期中的月份</td>
</tr>
<tr>
<td>MONTHNAME</td>
<td>获取指定日期中的月份英文名称</td>
</tr>
<tr>
<td>DAYNAME</td>
<td>获取指定曰期对应的星期几的英文名称</td>
</tr>
<tr>
<td>DAYOFWEEK</td>
<td>获取指定日期对应的一周的索引位置值</td>
</tr>
<tr>
<td>WEEK</td>
<td>获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53</td>
</tr>
<tr>
<td>DAYOFYEAR</td>
<td>获取指定曰期是一年中的第几天，返回值范围是1~366</td>
</tr>
<tr>
<td>DAYOFMONTH</td>
<td>获取指定日期是一个月中是第几天，返回值范围是1~31</td>
</tr>
<tr>
<td>YEAR</td>
<td>获取年份，返回值范围是 1970〜2069</td>
</tr>
<tr>
<td>TIME_TO_SEC</td>
<td>将时间参数转换为秒数</td>
</tr>
<tr>
<td>SEC_TO_TIME</td>
<td>将秒数转换为时间，与TIME_TO_SEC 互为反函数</td>
</tr>
<tr>
<td>DATE_ADD 和 ADDDATE</td>
<td>两个函数功能相同，都是向日期添加指定的时间间隔</td>
</tr>
<tr>
<td>DATE_SUB 和 SUBDATE</td>
<td>两个函数功能相同，都是向日期减去指定的时间间隔</td>
</tr>
<tr>
<td>ADDTIME</td>
<td>时间加法运算，在原始时间上添加指定的时间</td>
</tr>
<tr>
<td>SUBTIME</td>
<td>时间减法运算，在原始时间上减去指定的时间</td>
</tr>
<tr>
<td>DATEDIFF</td>
<td>获取两个日期之间间隔，返回参数 1 减去参数 2 的值</td>
</tr>
<tr>
<td>DATE_FORMAT</td>
<td>格式化指定的日期，根据参数返回指定格式的值</td>
</tr>
<tr>
<td>WEEKDAY</td>
<td>获取指定日期在一周内的对应的工作日索引</td>
</tr>
</tbody></table>
<hr>
<h4 id="正则查询"><a href="#正则查询" class="headerlink" title="正则查询"></a>正则查询</h4><p>正则表达式（Regular Expression）是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM emp WHERE name REGEXP &#x27;^T&#x27;;	-- 匹配以T开头的name值</span><br><span class="line">SELECT * FROM emp WHERE name REGEXP &#x27;2$&#x27;;	-- 匹配以2结尾的name值</span><br><span class="line">SELECT * FROM emp WHERE name REGEXP &#x27;[uvw]&#x27;;-- 匹配包含 uvw 的name值</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>在字符串开始处进行匹配</td>
</tr>
<tr>
<td>$</td>
<td>在字符串末尾处进行匹配</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意单个字符, 包括换行符</td>
</tr>
<tr>
<td>[…]</td>
<td>匹配出括号内的任意字符</td>
</tr>
<tr>
<td>[^…]</td>
<td>匹配不出括号内的任意字符</td>
</tr>
<tr>
<td>a*</td>
<td>匹配零个或者多个a(包括空串)</td>
</tr>
<tr>
<td>a+</td>
<td>匹配一个或者多个a(不包括空串)</td>
</tr>
<tr>
<td>a?</td>
<td>匹配零个或者一个a</td>
</tr>
<tr>
<td>a1|a2</td>
<td>匹配a1或a2</td>
</tr>
<tr>
<td>a(m)</td>
<td>匹配m个a</td>
</tr>
<tr>
<td>a(m,)</td>
<td>至少匹配m个a</td>
</tr>
<tr>
<td>a(m,n)</td>
<td>匹配m个a 到 n个a</td>
</tr>
<tr>
<td>a(,n)</td>
<td>匹配0到n个a</td>
</tr>
<tr>
<td>(…)</td>
<td>将模式元素组成单一元素</td>
</tr>
</tbody></table>
<hr>
<h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><ul>
<li><p>排序查询语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 [WHERE 条件] ORDER BY 列名1 排序方式1,列名2 排序方式2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>排序方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASC:升序</span><br><span class="line">DESC:降序</span><br></pre></td></tr></table></figure>

<p>注意：多个排序条件，当前边的条件值一样时，才会判断第二条件</p>
</li>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 按照库存升序排序</span><br><span class="line">SELECT * FROM product ORDER BY stock ASC;</span><br><span class="line"></span><br><span class="line">-- 查询名称中包含手机的商品信息。按照金额降序排序</span><br><span class="line">SELECT * FROM product WHERE NAME LIKE &#x27;%手机%&#x27; ORDER BY price DESC;</span><br><span class="line"></span><br><span class="line">-- 按照金额升序排序，如果金额相同，按照库存降序排列</span><br><span class="line">SELECT * FROM product ORDER BY price ASC,stock DESC;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>分组查询会进行去重</p>
<ul>
<li><p>分组查询语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式];</span><br></pre></td></tr></table></figure>

<p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤</p>
<p>分组规定：</p>
<ul>
<li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前</li>
<li>NULL 的行会单独分为一组</li>
<li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型</li>
</ul>
</li>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 按照品牌分组，获取每组商品的总金额</span><br><span class="line">SELECT brand,SUM(price) FROM product GROUP BY brand;</span><br><span class="line"></span><br><span class="line">-- 对金额大于4000元的商品，按照品牌分组,获取每组商品的总金额</span><br><span class="line">SELECT brand,SUM(price) FROM product WHERE price &gt; 4000 GROUP BY brand;</span><br><span class="line"></span><br><span class="line">-- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的</span><br><span class="line">SELECT brand,SUM(price) AS getSum FROM product WHERE price &gt; 4000 GROUP BY brand HAVING getSum &gt; 7000;</span><br><span class="line"></span><br><span class="line">-- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的、并按照总金额的降序排列</span><br><span class="line">SELECT brand,SUM(price) AS getSum FROM product WHERE price &gt; 4000 GROUP BY brand HAVING getSum &gt; 7000 ORDER BY getSum DESC;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><ul>
<li><p>分页查询语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式] LIMIT 开始索引,查询条数;</span><br></pre></td></tr></table></figure>
</li>
<li><p>公式：开始索引 &#x3D; (当前页码-1) * 每页显示的条数</p>
</li>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM product LIMIT 0,2;  -- 第一页 开始索引=(1-1) * 2</span><br><span class="line">SELECT * FROM product LIMIT 2,2;  -- 第二页 开始索引=(2-1) * 2</span><br><span class="line">SELECT * FROM product LIMIT 4,2;  -- 第三页 开始索引=(3-1) * 2</span><br><span class="line">SELECT * FROM product LIMIT 6,2;  -- 第四页 开始索引=(4-1) * 2</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-DQL%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E5%9B%BE%E8%A7%A3.png"></p>
</li>
</ul>
<hr>
<h2 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h2><h3 id="约束分类"><a href="#约束分类" class="headerlink" title="约束分类"></a>约束分类</h3><h4 id="约束介绍"><a href="#约束介绍" class="headerlink" title="约束介绍"></a>约束介绍</h4><p>约束：对表中的数据进行限定，保证数据的正确性、有效性、完整性</p>
<p>约束的分类：</p>
<table>
<thead>
<tr>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>PRIMARY KEY</td>
<td>主键约束</td>
</tr>
<tr>
<td>PRIMARY KEY AUTO_INCREMENT</td>
<td>主键、自动增长</td>
</tr>
<tr>
<td>UNIQUE</td>
<td>唯一约束</td>
</tr>
<tr>
<td>NOT NULL</td>
<td>非空约束</td>
</tr>
<tr>
<td>FOREIGN KEY</td>
<td>外键约束</td>
</tr>
<tr>
<td>FOREIGN KEY ON UPDATE CASCADE</td>
<td>外键级联更新</td>
</tr>
<tr>
<td>FOREIGN KEY ON DELETE CASCADE</td>
<td>外键级联删除</td>
</tr>
</tbody></table>
<hr>
<h4 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h4><ul>
<li><p>主键约束特点：</p>
<ul>
<li>主键约束默认包含<strong>非空和唯一</strong>两个功能</li>
<li>一张表只能有一个主键</li>
<li>主键一般用于表中数据的唯一标识</li>
</ul>
</li>
<li><p>建表时添加主键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	列名 数据类型 PRIMARY KEY,</span><br><span class="line">    列名 数据类型,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除主键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建表后单独添加主键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型 PRIMARY KEY;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建student表</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">	id INT PRIMARY KEY  -- 给id添加主键约束</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO student VALUES (1),(2);</span><br><span class="line">-- 主键默认唯一，添加重复数据，会报错</span><br><span class="line">INSERT INTO student VALUES (2);</span><br><span class="line">-- 主键默认非空，不能添加null的数据</span><br><span class="line">INSERT INTO student VALUES (NULL);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="主键自增"><a href="#主键自增" class="headerlink" title="主键自增"></a>主键自增</h4><p>主键自增约束可以为空，并自动增长。删除某条数据不影响自增的下一个数值，依然按照前一个值自增</p>
<ul>
<li><p>建表时添加主键自增约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	列名 数据类型 PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    列名 数据类型,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除主键自增约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建表后单独添加主键自增约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型 AUTO_INCREMENT;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建student2表</span><br><span class="line">CREATE TABLE student2(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT    -- 给id添加主键自增约束</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO student2 VALUES (1),(2);</span><br><span class="line">-- 添加null值，会自动增长</span><br><span class="line">INSERT INTO student2 VALUES (NULL),(NULL);-- 3，4</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h4><p>唯一约束：约束不能有重复的数据</p>
<ul>
<li><p>建表时添加唯一约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	列名 数据类型 UNIQUE,</span><br><span class="line">    列名 数据类型,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除唯一约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP INDEX 列名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建表后单独添加唯一约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型 UNIQUE;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h4><ul>
<li><p>建表时添加非空约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	列名 数据类型 NOT NULL,</span><br><span class="line">    列名 数据类型,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除非空约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建表后单独添加非空约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型 NOT NULL;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>  外键约束：让表和表之间产生关系，从而保证数据的准确性</p>
<ul>
<li><p>建表时添加外键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	列名 数据类型 约束,</span><br><span class="line">    ...</span><br><span class="line">    CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除外键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建表后单独添加外键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名);</span><br></pre></td></tr></table></figure>
</li>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建user用户表</span><br><span class="line">CREATE TABLE USER(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,    -- id</span><br><span class="line">	name VARCHAR(20) NOT NULL             -- 姓名</span><br><span class="line">);</span><br><span class="line">-- 添加用户数据</span><br><span class="line">INSERT INTO USER VALUES (NULL,&#x27;张三&#x27;),(NULL,&#x27;李四&#x27;),(NULL,&#x27;王五&#x27;);</span><br><span class="line"></span><br><span class="line">-- 创建orderlist订单表</span><br><span class="line">CREATE TABLE orderlist(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,    -- id</span><br><span class="line">	number VARCHAR(20) NOT NULL,          -- 订单编号</span><br><span class="line">	uid INT,                              -- 订单所属用户</span><br><span class="line">	CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id)   -- 添加外键约束</span><br><span class="line">);</span><br><span class="line">-- 添加订单数据</span><br><span class="line">INSERT INTO orderlist VALUES (NULL,&#x27;hm001&#x27;,1),(NULL,&#x27;hm002&#x27;,1),</span><br><span class="line">(NULL,&#x27;hm003&#x27;,2),(NULL,&#x27;hm004&#x27;,2),</span><br><span class="line">(NULL,&#x27;hm005&#x27;,3),(NULL,&#x27;hm006&#x27;,3);</span><br><span class="line"></span><br><span class="line">-- 添加一个订单，但是没有所属用户。无法添加</span><br><span class="line">INSERT INTO orderlist VALUES (NULL,&#x27;hm007&#x27;,8);</span><br><span class="line">-- 删除王五这个用户，但是订单表中王五还有很多个订单呢。无法删除</span><br><span class="line">DELETE FROM USER WHERE NAME=&#x27;王五&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="外键级联"><a href="#外键级联" class="headerlink" title="外键级联"></a>外键级联</h4><p>级联操作：当把主表中的数据进行删除或更新时，从表中有关联的数据的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION</p>
<ul>
<li><p>RESTRICT 和 NO ACTION相同， 是指限制在子表有关联记录的情况下， 父表不能更新</p>
</li>
<li><p>CASCADE 表示父表在更新或者删除时，更新或者删除子表对应的记录</p>
</li>
<li><p>SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL</p>
</li>
</ul>
<p>级联操作：</p>
<ul>
<li><p>添加级联更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名) ON UPDATE [CASCADE | RESTRICT | SET NULL];</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加级联删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名) ON DELETE CASCADE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同时添加级联更新和级联删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名) ON UPDATE CASCADE ON DELETE CASCADE;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="多表设计"><a href="#多表设计" class="headerlink" title="多表设计"></a>多表设计</h3><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>多表：有多张数据表，而表与表之间有一定的关联关系，通过外键约束实现，分为一对一、一对多、多对多三类</p>
<p>举例：人和身份证</p>
<p>实现原则：在任意一个表建立外键，去关联另外一个表的主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建person表</span><br><span class="line">CREATE TABLE person(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 主键id</span><br><span class="line">	NAME VARCHAR(20)                        -- 姓名</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO person VALUES (NULL,&#x27;张三&#x27;),(NULL,&#x27;李四&#x27;);</span><br><span class="line"></span><br><span class="line">-- 创建card表</span><br><span class="line">CREATE TABLE card(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 主键id</span><br><span class="line">	number VARCHAR(20) UNIQUE NOT NULL,	-- 身份证号</span><br><span class="line">	pid INT UNIQUE,                         -- 外键列</span><br><span class="line">	CONSTRAINT cp_fk1 FOREIGN KEY (pid) REFERENCES person(id)</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO card VALUES (NULL,&#x27;12345&#x27;,1),(NULL,&#x27;56789&#x27;,2);</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E5%A4%9A%E8%A1%A8%E8%AE%BE%E8%AE%A1%E4%B8%80%E5%AF%B9%E4%B8%80.png"></p>
<hr>
<h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>举例：用户和订单、商品分类和商品</p>
<p>实现原则：在多的一方，建立外键约束，来关联一的一方主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建user表</span><br><span class="line">CREATE TABLE USER(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 主键id</span><br><span class="line">	NAME VARCHAR(20)                        -- 姓名</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO USER VALUES (NULL,&#x27;张三&#x27;),(NULL,&#x27;李四&#x27;);</span><br><span class="line"></span><br><span class="line">-- 创建orderlist表</span><br><span class="line">CREATE TABLE orderlist(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 主键id</span><br><span class="line">	number VARCHAR(20),                     -- 订单编号</span><br><span class="line">	uid INT,				-- 外键列</span><br><span class="line">	CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id)</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO orderlist VALUES (NULL,&#x27;hm001&#x27;,1),(NULL,&#x27;hm002&#x27;,1),(NULL,&#x27;hm003&#x27;,2),(NULL,&#x27;hm004&#x27;,2);</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E5%A4%9A%E8%A1%A8%E8%AE%BE%E8%AE%A1%E4%B8%80%E5%AF%B9%E5%A4%9A.png" alt="多表设计一对多"></p>
<hr>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>举例：学生和课程。一个学生可以选择多个课程，一个课程也可以被多个学生选择</p>
<p>实现原则：借助第三张表中间表，中间表至少包含两个列，这两个列作为中间表的外键，分别关联两张表的主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建student表</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 主键id</span><br><span class="line">	NAME VARCHAR(20)			-- 学生姓名</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO student VALUES (NULL,&#x27;张三&#x27;),(NULL,&#x27;李四&#x27;);</span><br><span class="line"></span><br><span class="line">-- 创建course表</span><br><span class="line">CREATE TABLE course(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 主键id</span><br><span class="line">	NAME VARCHAR(10)			-- 课程名称</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO course VALUES (NULL,&#x27;语文&#x27;),(NULL,&#x27;数学&#x27;);</span><br><span class="line"></span><br><span class="line">-- 创建中间表</span><br><span class="line">CREATE TABLE stu_course(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 主键id</span><br><span class="line">	sid INT,  -- 用于和student表中的id进行外键关联</span><br><span class="line">	cid INT,  -- 用于和course表中的id进行外键关联</span><br><span class="line">	CONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id), -- 添加外键约束</span><br><span class="line">	CONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id)   -- 添加外键约束</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO stu_course VALUES (NULL,1,1),(NULL,1,2),(NULL,2,1),(NULL,2,2);</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E5%A4%9A%E8%A1%A8%E8%AE%BE%E8%AE%A1%E5%A4%9A%E5%AF%B9%E5%A4%9A.png"></p>
<hr>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><h4 id="内外连接"><a href="#内外连接" class="headerlink" title="内外连接"></a>内外连接</h4><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>连接查询的是两张表有交集的部分数据，两张表分为<strong>驱动表和被驱动表</strong>，如果结果集中的每条记录都是两个表相互匹配的组合，则称这样的结果集为笛卡尔积</p>
<p>内连接查询，若驱动表中的记录在被驱动表中找不到匹配的记录时，则该记录不会加到最后的结果集</p>
<ul>
<li><p>显式内连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名1 [INNER] JOIN 表名2 ON 条件;</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式内连接：内连接中 WHERE 子句和 ON 子句是等价的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名1,表名2 WHERE 条件;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>STRAIGHT_JOIN与 JOIN 类似，只不过左表始终在右表之前读取，只适用于内连接</p>
<hr>
<h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>外连接查询，若驱动表中的记录在被驱动表中找不到匹配的记录时，则该记录也会加到最后的结果集，只是对于被驱动表中<strong>不匹配过滤条件</strong>的记录，各个字段使用 NULL 填充</p>
<p>应用实例：查学生成绩，也想展示出缺考的人的成绩</p>
<ul>
<li><p>左外连接：选择左侧的表为驱动表，查询左表的全部数据，和左右两张表有交集部分的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名1 LEFT [OUTER] JOIN 表名2 ON 条件;</span><br></pre></td></tr></table></figure>
</li>
<li><p>右外连接：选择右侧的表为驱动表，查询右表的全部数据，和左右两张表有交集部分的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名1 RIGHT [OUTER] JOIN 表名2 ON 条件;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-JOIN%E6%9F%A5%E8%AF%A2%E5%9B%BE.png"></p>
<hr>
<h4 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h4><p>自关联查询：同一张表中有数据关联，可以多次查询这同一个表</p>
<ul>
<li><p>数据准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建员工表</span><br><span class="line">CREATE TABLE employee(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 员工编号</span><br><span class="line">	NAME VARCHAR(20),					-- 员工姓名</span><br><span class="line">	mgr INT,							-- 上级编号</span><br><span class="line">	salary DOUBLE						-- 员工工资</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO employee VALUES (1001,&#x27;孙悟空&#x27;,1005,9000.00),..,(1009,&#x27;宋江&#x27;,NULL,16000.00);</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E8%87%AA%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87.png"></p>
</li>
<li><p>数据查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询所有员工的姓名及其直接上级的姓名，没有上级的员工也需要查询</span><br><span class="line">/*</span><br><span class="line">分析</span><br><span class="line">	员工信息 employee表</span><br><span class="line">	条件：employee.mgr = employee.id</span><br><span class="line">	查询左表的全部数据，和左右两张表有交集部分数据，左外连接</span><br><span class="line">*/</span><br><span class="line">SELECT</span><br><span class="line">	e1.id,</span><br><span class="line">	e1.name,</span><br><span class="line">	e1.mgr,</span><br><span class="line">	e2.id,</span><br><span class="line">	e2.name</span><br><span class="line">FROM</span><br><span class="line">	employee e1</span><br><span class="line">LEFT OUTER JOIN</span><br><span class="line">	employee e2</span><br><span class="line">ON</span><br><span class="line">	e1.mgr = e2.id;	</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id		name	mgr	   id	  name</span><br><span class="line">1001	孙悟空	  1005	1005	唐僧</span><br><span class="line">1002	猪八戒	  1005	1005	唐僧</span><br><span class="line">1003	沙和尚	  1005	1005	唐僧</span><br><span class="line">1004	小白龙	  1005	1005	唐僧</span><br><span class="line">1005	唐僧	   NULL	 NULL	 NULL</span><br><span class="line">1006	武松	   1009	 1009	 宋江</span><br><span class="line">1007	李逵	   1009	 1009	 宋江</span><br><span class="line">1008	林冲	   1009	 1009	 宋江</span><br><span class="line">1009	宋江	   NULL	 NULL	 NULL</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="连接原理"><a href="#连接原理" class="headerlink" title="连接原理"></a>连接原理</h4><p>Index Nested-Loop Join 算法：查询驱动表得到<strong>数据集</strong>，然后根据数据集中的每一条记录的<strong>关联字段再分别</strong>到被驱动表中查找匹配（<strong>走索引</strong>），所以驱动表只需要访问一次，被驱动表要访问多次</p>
<p>MySQL 将查询驱动表后得到的记录成为驱动表的扇出，连接查询的成本：单次访问驱动表的成本 + 扇出值 * 单次访问被驱动表的成本，优化器会选择成本最小的表连接顺序（确定谁是驱动表，谁是被驱动表）生成执行计划，进行连接查询，优化方式：</p>
<ul>
<li>减少驱动表的扇出（让数据量小的表来做驱动表）</li>
<li>降低访问被驱动表的成本</li>
</ul>
<p>说明：STRAIGHT_JOIN 是查一条驱动表，然后根据关联字段去查被驱动表，要访问多次驱动表，所以需要优化为 INL 算法</p>
<p>Block Nested-Loop Join 算法：一种<strong>空间换时间</strong>的优化方式，基于块的循环连接，执行连接查询前申请一块固定大小的内存作为连接缓冲区 Join Buffer，先把若干条驱动表中的扇出暂存在缓冲区，每一条被驱动表中的记录一次性的与 Buffer 中多条记录进行匹配（扫描全部数据，一条一条的匹配），因为是在内存中完成，所以速度快，并且降低了 I&#x2F;O 成本</p>
<p>Join Buffer 可以通过参数 <code>join_buffer_size</code> 进行配置，默认大小是 256 KB</p>
<p>在成本分析时，对于很多张表的连接查询，连接顺序有非常多，MySQL 如果挨着进行遍历计算成本，会消耗很多资源</p>
<ul>
<li><p>提前结束某种连接顺序的成本评估：维护一个全局变量记录当前成本最小的连接方式，如果一种顺序只计算了一部分就已经超过了最小成本，可以提前结束计算</p>
</li>
<li><p>系统变量 optimizer_search_depth：如果连接表的个数小于该变量，就继续穷举分析每一种连接数量，反之只对数量与 depth 值相同的表进行分析，该值越大成本分析的越精确</p>
</li>
<li><p>系统变量 optimizer_prune_level：控制启发式规则的启用，这些规则就是根据以往经验指定的，不满足规则的连接顺序不分析成本</p>
</li>
</ul>
<hr>
<h4 id="连接优化"><a href="#连接优化" class="headerlink" title="连接优化"></a>连接优化</h4><h5 id="BKA"><a href="#BKA" class="headerlink" title="BKA"></a>BKA</h5><p>Batched Key Access 算法是对 NLJ 算法的优化，在读取被驱动表的记录时使用顺序 IO，Extra 信息中会有 Batched Key Access 信息</p>
<p>使用 BKA 的表的 JOIN 过程如下：</p>
<ul>
<li>连接驱动表将满足条件的记录放入 Join Buffer，并将两表连接的字段放入一个 DYNAMIC_ARRAY ranges 中</li>
<li>在进行表的过接过程中，会将 ranges 相关的信息传入 Buffer 中，进行被驱动表主建的查找及排序操作</li>
<li>调用步骤 2 中产生的有序主建，<strong>顺序读取被驱动表的数据</strong></li>
<li>当缓冲区的数据被读完后，会重复进行步骤 2、3，直到记录被读取完</li>
</ul>
<p>使用 BKA 优化需要设进行设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET optimizer_switch=&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;;</span><br></pre></td></tr></table></figure>

<p>说明：前两个参数的作用是启用 MRR，因为 BKA 算法的优化要依赖于 MRR（系统优化 → 内存优化 → Read 详解）</p>
<hr>
<h5 id="BNL"><a href="#BNL" class="headerlink" title="BNL"></a>BNL</h5><h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><p>BNL 即 Block Nested-Loop Join 算法，由于要访问多次被驱动表，会产生两个问题：</p>
<ul>
<li><p>Join 语句多次扫描一个冷表，并且语句执行时间小于 1 秒，就会在再次扫描冷表时，把冷表的数据页移到 LRU 链表头部，导致热数据被淘汰，影响业务的正常运行</p>
<p>这种情况冷表的数据量要小于整个 Buffer Pool 的 old 区域，能够完全放入 old 区，才会再次被读时加到 young，否则读取下一段时就已经把上一段淘汰</p>
</li>
<li><p>Join 语句在循环读磁盘和淘汰内存页，进入 old 区域的数据页很可能在 1 秒之内就被淘汰，就会导致 MySQL 实例的 Buffer Pool 在这段时间内 young 区域的数据页没有被合理地淘汰</p>
</li>
</ul>
<p>大表 Join 操作虽然对 IO 有影响，但是在语句执行结束后对 IO 的影响随之结束。但是对 Buffer Pool 的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率</p>
<h6 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h6><p>将 BNL 算法转成 BKA 算法，优化方向：</p>
<ul>
<li>在被驱动表上建索引，这样就可以根据索引进行顺序 IO</li>
<li>使用临时表，<strong>在临时表上建立索引</strong>，将被驱动表和临时表进行连接查询</li>
</ul>
<p>驱动表 t1，被驱动表 t2，使用临时表的工作流程：</p>
<ul>
<li>把表 t1 中满足条件的数据放在临时表 tmp_t 中</li>
<li>给临时表 tmp_t 的关联字段加上索引，使用 BKA 算法</li>
<li>让表 t2 和 tmp_t 做 Join 操作（临时表是被驱动表）</li>
</ul>
<p>补充：MySQL 8.0 支持 hash join，join_buffer 维护的不再是一个无序数组，而是一个哈希表，查询效率更高，执行效率比临时表更高</p>
<hr>
<h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><h4 id="查询分类"><a href="#查询分类" class="headerlink" title="查询分类"></a>查询分类</h4><p>查询语句中嵌套了查询语句，<strong>将嵌套查询称为子查询</strong>，FROM 子句后面的子查询的结果集称为派生表</p>
<p>根据结果分类：</p>
<ul>
<li><p>结果是单行单列：可以将查询的结果作为另一条语句的查询条件，使用运算符判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 WHERE 列名=(SELECT 列名/聚合函数(列名) FROM 表名 [WHERE 条件]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果是多行单列：可以作为条件，使用运算符 IN 或 NOT IN 进行判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 WHERE 列名 [NOT] IN (SELECT 列名 FROM 表名 [WHERE 条件]); </span><br></pre></td></tr></table></figure>
</li>
<li><p>结果是多行多列：查询的结果可以作为一张虚拟表参与查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 [别名],(SELECT 列名 FROM 表名 [WHERE 条件]) [别名] [WHERE 条件];</span><br><span class="line"></span><br><span class="line">-- 查询订单表orderlist中id大于4的订单信息和所属用户USER信息</span><br><span class="line">SELECT </span><br><span class="line">	* </span><br><span class="line">FROM </span><br><span class="line">	USER u,</span><br><span class="line">	(SELECT * FROM orderlist WHERE id&gt;4) o </span><br><span class="line">WHERE </span><br><span class="line">	u.id=o.uid;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>相关性分类：</p>
<ul>
<li>不相关子查询：子查询不依赖外层查询的值，可以单独运行出结果</li>
<li>相关子查询：子查询的执行需要依赖外层查询的值</li>
</ul>
<hr>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p>不相关子查询的结果集会被写入一个临时表，并且在写入时<strong>去重</strong>，该过程称为<strong>物化</strong>，存储结果集的临时表称为物化表</p>
<p>系统变量 tmp_table_size 或者 max_heap_table_size 为表的最值</p>
<ul>
<li>小于系统变量时，内存中可以保存，会为建立<strong>基于内存</strong>的 MEMORY 存储引擎的临时表，并建立哈希索引</li>
<li>大于任意一个系统变量时，物化表会使用<strong>基于磁盘</strong>的 InnoDB 存储引擎来保存结果集中的记录，索引类型为 B+ 树</li>
</ul>
<p>物化后，嵌套查询就相当于外层查询的表和物化表进行内连接查询，然后经过优化器选择成本最小的表连接顺序执行查询</p>
<p>子查询物化会产生建立临时表的成本，但是将子查询转化为连接查询可以充分发挥优化器的作用，所以引入：半连接</p>
<ul>
<li>t1 和 t2 表进行半连接，对于 t1 表中的某条记录，只需要关心在 t2 表中是否存在，而不需要关心有多少条记录与之匹配，最终结果集只保留 t1 的记录</li>
<li>半连接只是执行子查询的一种方式，MySQL 并没有提供面向用户的半连接语法</li>
</ul>
<p>参考书籍：<a href="https://book.douban.com/subject/35231266/">https://book.douban.com/subject/35231266/</a></p>
<hr>
<h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><p>UNION 是取这两个子查询结果的并集，并进行去重，同时进行默认规则的排序（union 是行加起来，join 是列加起来）</p>
<p>UNION ALL 是对两个结果集进行并集操作不进行去重，不进行排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(select 1000 as f) union (select id from t1 order by id desc limit 2); #t1表中包含id 为 1-1000 的数据</span><br></pre></td></tr></table></figure>

<p>语句的执行流程：</p>
<ul>
<li>创建一个内存临时表，这个临时表只有一个整型字段 f，并且 f 是主键字段</li>
<li>执行第一个子查询，得到 1000 这个值，并存入临时表中</li>
<li>执行第二个子查询，拿到第一行 id&#x3D;1000，试图插入临时表中，但由于 1000 这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行</li>
<li>取到第二行 id&#x3D;999，插入临时表成功</li>
<li>从临时表中按行取出数据，返回结果并删除临时表，结果中包含两行数据分别是 1000 和 999</li>
</ul>
<hr>
<h3 id="查询练习"><a href="#查询练习" class="headerlink" title="查询练习"></a>查询练习</h3><p>数据准备：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建db4数据库</span><br><span class="line">CREATE DATABASE db4;</span><br><span class="line">-- 使用db4数据库</span><br><span class="line">USE db4;</span><br><span class="line"></span><br><span class="line">-- 创建user表</span><br><span class="line">CREATE TABLE USER(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 用户id</span><br><span class="line">	NAME VARCHAR(20),					-- 用户姓名</span><br><span class="line">	age INT                             -- 用户年龄</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 订单表</span><br><span class="line">CREATE TABLE orderlist(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 订单id</span><br><span class="line">	number VARCHAR(30),					-- 订单编号</span><br><span class="line">	uid INT,   							-- 外键字段</span><br><span class="line">	CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 商品分类表</span><br><span class="line">CREATE TABLE category(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,  -- 商品分类id</span><br><span class="line">	NAME VARCHAR(10)                    -- 商品分类名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 商品表</span><br><span class="line">CREATE TABLE product(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,   -- 商品id</span><br><span class="line">	NAME VARCHAR(30),                    -- 商品名称</span><br><span class="line">	cid INT, -- 外键字段</span><br><span class="line">	CONSTRAINT cp_fk1 FOREIGN KEY (cid) REFERENCES category(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 中间表</span><br><span class="line">CREATE TABLE us_pro(</span><br><span class="line">	upid INT PRIMARY KEY AUTO_INCREMENT,  -- 中间表id</span><br><span class="line">	uid INT, 							  -- 外键字段。需要和用户表的主键产生关联</span><br><span class="line">	pid INT,							  -- 外键字段。需要和商品表的主键产生关联</span><br><span class="line">	CONSTRAINT up_fk1 FOREIGN KEY (uid) REFERENCES USER(id),</span><br><span class="line">	CONSTRAINT up_fk2 FOREIGN KEY (pid) REFERENCES product(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E5%A4%9A%E8%A1%A8%E7%BB%83%E4%B9%A0%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png" alt="多表练习架构设计"></p>
<p><strong>数据查询：</strong></p>
<ol>
<li><p>查询用户的编号、姓名、年龄、订单编号</p>
<p>数据：用户的编号、姓名、年龄在 user 表，订单编号在 orderlist 表</p>
<p>条件：user.id &#x3D; orderlist.uid</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	u.*,</span><br><span class="line">	o.number</span><br><span class="line">FROM</span><br><span class="line">	USER u,</span><br><span class="line">	orderlist o</span><br><span class="line">WHERE</span><br><span class="line">	u.id = o.uid;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询所有的用户，显示用户的编号、姓名、年龄、订单编号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	u.*,</span><br><span class="line">	o.number</span><br><span class="line">FROM</span><br><span class="line">	USER u</span><br><span class="line">LEFT OUTER JOIN</span><br><span class="line">	orderlist o</span><br><span class="line">ON</span><br><span class="line">	u.id = o.uid;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询用户年龄大于 23 岁的信息，显示用户的编号、姓名、年龄、订单编号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	u.*,</span><br><span class="line">	o.number</span><br><span class="line">FROM</span><br><span class="line">	USER u,</span><br><span class="line">	orderlist o</span><br><span class="line">WHERE</span><br><span class="line">	u.id = o.uid</span><br><span class="line">	AND</span><br><span class="line">	u.age &gt; 23;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	u.*,</span><br><span class="line">	o.number</span><br><span class="line">FROM</span><br><span class="line">	(SELECT * FROM USER WHERE age &gt; 23) u,-- 嵌套查询</span><br><span class="line">	orderlist o</span><br><span class="line">WHERE</span><br><span class="line">	u.id = o.uid;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询张三和李四用户的信息，显示用户的编号、姓名、年龄、订单编号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	u.*,</span><br><span class="line">	o.number</span><br><span class="line">FROM</span><br><span class="line">	USER u,</span><br><span class="line">	orderlist o</span><br><span class="line">WHERE</span><br><span class="line">	u.id=o.uid</span><br><span class="line">	AND</span><br><span class="line">	u.name IN (&#x27;张三&#x27;,&#x27;李四&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询所有的用户和该用户能查看的所有的商品，显示用户的编号、姓名、年龄、商品名称</p>
<p>数据：用户的编号、姓名、年龄在 user 表，商品名称在 product 表，中间表 us_pro</p>
<p>条件：us_pro.uid &#x3D; user.id AND us_pro.pid &#x3D; product.id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	u.id,</span><br><span class="line">	u.name,</span><br><span class="line">	u.age,</span><br><span class="line">	p.name</span><br><span class="line">FROM</span><br><span class="line">	USER u,</span><br><span class="line">	product p,</span><br><span class="line">	us_pro up</span><br><span class="line">WHERE</span><br><span class="line">	up.uid = u.id</span><br><span class="line">	AND</span><br><span class="line">	up.pid=p.id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询张三和李四这两个用户可以看到的商品，显示用户的编号、姓名、年龄、商品名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	u.id,</span><br><span class="line">	u.name,</span><br><span class="line">	u.age,</span><br><span class="line">	p.name</span><br><span class="line">FROM</span><br><span class="line">	USER u,</span><br><span class="line">	product p,</span><br><span class="line">	us_pro up</span><br><span class="line">WHERE</span><br><span class="line">	up.uid=u.id</span><br><span class="line">	AND</span><br><span class="line">	up.pid=p.id</span><br><span class="line">	AND</span><br><span class="line">	u.name IN (&#x27;张三&#x27;,&#x27;李四&#x27;);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="高级结构"><a href="#高级结构" class="headerlink" title="高级结构"></a>高级结构</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>视图概念：视图是一种虚拟存在的数据表，这个虚拟的表并不在数据库中实际存在</p>
<p>本质：将一条 SELECT 查询语句的结果封装到了一个虚拟表中，所以在创建视图的时候，工作重心要放在这条 SELECT 查询语句上</p>
<p>作用：将一些比较复杂的查询语句的结果，封装到一个虚拟表中，再有相同查询需求时，直接查询该虚拟表</p>
<p>优点：</p>
<ul>
<li><p>简单：使用视图的用户不需要关心表的结构、关联条件和筛选条件，因为虚拟表中已经是过滤好的结果集</p>
</li>
<li><p>安全：使用视图的用户只能访问查询的结果集，对表的权限管理并不能限制到某个行某个列</p>
</li>
<li><p>数据独立，一旦视图的结构确定，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响</p>
</li>
</ul>
<hr>
<h4 id="视图创建"><a href="#视图创建" class="headerlink" title="视图创建"></a>视图创建</h4><ul>
<li><p>创建视图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [OR REPLACE] </span><br><span class="line">VIEW 视图名称 [(列名列表)] </span><br><span class="line">AS 查询语句</span><br><span class="line">[WITH [CASCADED | LOCAL] CHECK OPTION];</span><br></pre></td></tr></table></figure>

<p><code>WITH [CASCADED | LOCAL] CHECK OPTION</code> 决定了是否允许更新数据使记录不再满足视图的条件：</p>
<ul>
<li>LOCAL：只要满足本视图的条件就可以更新</li>
<li>CASCADED：必须满足所有针对该视图的所有视图的条件才可以更新， 默认值</li>
</ul>
</li>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 数据准备 city</span><br><span class="line">id	NAME	cid</span><br><span class="line">1	深圳	 	1</span><br><span class="line">2	上海		1</span><br><span class="line">3	纽约		2</span><br><span class="line">4	莫斯科	    3</span><br><span class="line"></span><br><span class="line">-- 数据准备 country</span><br><span class="line">id	NAME</span><br><span class="line">1	中国</span><br><span class="line">2	美国</span><br><span class="line">3	俄罗斯</span><br><span class="line"></span><br><span class="line">-- 创建city_country视图，保存城市和国家的信息(使用指定列名)</span><br><span class="line">CREATE </span><br><span class="line">VIEW </span><br><span class="line">	city_country (city_id,city_name,country_name)</span><br><span class="line">AS</span><br><span class="line">    SELECT</span><br><span class="line">        c1.id,</span><br><span class="line">        c1.name,</span><br><span class="line">        c2.name</span><br><span class="line">    FROM</span><br><span class="line">        city c1,</span><br><span class="line">        country c2</span><br><span class="line">    WHERE</span><br><span class="line">        c1.cid=c2.id;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="视图查询"><a href="#视图查询" class="headerlink" title="视图查询"></a>视图查询</h4><ul>
<li><p>查询所有数据表，视图也会查询出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLES;</span><br><span class="line">SHOW TABLE STATUS [\G];</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询视图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 视图名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询某个视图创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE VIEW 视图名称;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="视图修改"><a href="#视图修改" class="headerlink" title="视图修改"></a>视图修改</h4><p>视图表数据修改，会<strong>自动修改源表中的数据</strong>，因为更新的是视图中的基表中的数据</p>
<ul>
<li><p>修改视图表中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE 视图名称 SET 列名 = 值 WHERE 条件;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改视图的结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]</span><br><span class="line">VIEW 视图名称 [(列名列表)] </span><br><span class="line">AS 查询语句</span><br><span class="line">[WITH [CASCADED | LOCAL] CHECK OPTION]</span><br><span class="line"></span><br><span class="line">-- 将视图中的country_name修改为name</span><br><span class="line">ALTER </span><br><span class="line">VIEW </span><br><span class="line">	city_country (city_id,city_name,name) </span><br><span class="line">AS</span><br><span class="line">    SELECT</span><br><span class="line">        c1.id,</span><br><span class="line">        c1.name,</span><br><span class="line">        c2.name</span><br><span class="line">    FROM</span><br><span class="line">        city c1,</span><br><span class="line">        country c2</span><br><span class="line">    WHERE</span><br><span class="line">        c1.cid=c2.id;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="视图删除"><a href="#视图删除" class="headerlink" title="视图删除"></a>视图删除</h4><ul>
<li><p>删除视图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW 视图名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果存在则删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW IF EXISTS 视图名称;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>存储过程和函数：存储过程和函数是事先经过编译并存储在数据库中的一段 SQL 语句的集合</p>
<p>存储过程和函数的好处：</p>
<ul>
<li>提高代码的复用性</li>
<li>减少数据在数据库和应用服务器之间的传输，提高传输效率</li>
<li>减少代码层面的业务处理</li>
<li><strong>一次编译永久有效</strong></li>
</ul>
<p>存储过程和函数的区别：</p>
<ul>
<li>存储函数必须有返回值</li>
<li>存储过程可以没有返回值</li>
</ul>
<hr>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>DELIMITER：</p>
<ul>
<li><p>DELIMITER 关键字用来声明 sql 语句的分隔符，告诉 MySQL 该段命令已经结束</p>
</li>
<li><p>MySQL 语句默认的分隔符是分号，但是有时需要一条功能 sql 语句中包含分号，但是并不作为结束标识，这时使用 DELIMITER 来指定分隔符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER 分隔符</span><br></pre></td></tr></table></figure></li>
</ul>
<p>存储过程的创建调用查看和删除：</p>
<ul>
<li><p>创建存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 修改分隔符为$</span><br><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">-- 标准语法</span><br><span class="line">CREATE PROCEDURE 存储过程名称(参数...)</span><br><span class="line">BEGIN</span><br><span class="line">	sql语句;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">-- 修改分隔符为分号</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL 存储过程名称(实际参数);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM mysql.proc WHERE db=&#x27;数据库名称&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE [IF EXISTS] 存储过程名称;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>练习：</p>
<ul>
<li><p>数据准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	NAME	age		gender	score</span><br><span class="line">1	张三		23		男		95</span><br><span class="line">2	李四		24		男		98</span><br><span class="line">3	王五		25		女		100</span><br><span class="line">4	赵六		26		女		90</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 stu_group() 存储过程，封装分组查询总成绩，并按照总成绩升序排序的功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE stu_group()</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT gender,SUM(score) getSum FROM student GROUP BY gender ORDER BY getSum ASC; </span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">-- 调用存储过程</span><br><span class="line">CALL stu_group();</span><br><span class="line">-- 删除存储过程</span><br><span class="line">DROP PROCEDURE IF EXISTS stu_group;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="存储语法"><a href="#存储语法" class="headerlink" title="存储语法"></a>存储语法</h4><h5 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h5><p>存储过程是可以进行编程的，意味着可以使用变量、表达式、条件控制语句等，来完成比较复杂的功能</p>
<ul>
<li><p>定义变量：DECLARE 定义的是局部变量，只能用在 BEGIN END 范围之内</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 变量名 数据类型 [DEFAULT 默认值];</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量的赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET 变量名 = 变量值;</span><br><span class="line">SELECT 列名 INTO 变量名 FROM 表名 [WHERE 条件];</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据准备：表 student</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	NAME	age		gender	score</span><br><span class="line">1	张三		23		男		95</span><br><span class="line">2	李四		24		男		98</span><br><span class="line">3	王五		25		女		100</span><br><span class="line">4	赵六		26		女		90</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义两个 int 变量，用于存储男女同学的总分数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_test3()</span><br><span class="line">BEGIN</span><br><span class="line">	-- 定义两个变量</span><br><span class="line">	DECLARE men,women INT;</span><br><span class="line">	-- 查询男同学的总分数，为men赋值</span><br><span class="line">	SELECT SUM(score) INTO men FROM student WHERE gender=&#x27;男&#x27;;</span><br><span class="line">	-- 查询女同学的总分数，为women赋值</span><br><span class="line">	SELECT SUM(score) INTO women FROM student WHERE gender=&#x27;女&#x27;;</span><br><span class="line">	-- 使用变量</span><br><span class="line">	SELECT men,women;</span><br><span class="line">END$</span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用存储过程</span><br><span class="line">CALL pro_test3();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="IF语句"><a href="#IF语句" class="headerlink" title="IF语句"></a>IF语句</h5><ul>
<li><p>if 语句标准语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IF 判断条件1 THEN 执行的sql语句1;</span><br><span class="line">[ELSEIF 判断条件2 THEN 执行的sql语句2;]</span><br><span class="line">...</span><br><span class="line">[ELSE 执行的sql语句n;]</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据准备：表 student</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	NAME	age		gender	score</span><br><span class="line">1	张三		23		男		95</span><br><span class="line">2	李四		24		男		98</span><br><span class="line">3	王五		25		女		100</span><br><span class="line">4	赵六		26		女		90</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据总成绩判断：全班 380 分及以上学习优秀、320 ~ 380 学习良好、320 以下学习一般</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_test4()</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE total INT;							-- 定义总分数变量</span><br><span class="line">	DECLARE description VARCHAR(10);			-- 定义分数描述变量</span><br><span class="line">	SELECT SUM(score) INTO total FROM student; 	-- 为总分数变量赋值</span><br><span class="line">	-- 判断总分数</span><br><span class="line">	IF total &gt;= 380 THEN</span><br><span class="line">		SET description = &#x27;学习优秀&#x27;;</span><br><span class="line">	ELSEIF total &gt;=320 AND total &lt; 380 THEN</span><br><span class="line">		SET description = &#x27;学习良好&#x27;;</span><br><span class="line">	ELSE</span><br><span class="line">		SET description = &#x27;学习一般&#x27;;</span><br><span class="line">	END IF;</span><br><span class="line">END$</span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用pro_test4存储过程</span><br><span class="line">CALL pro_test4();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5><ul>
<li><p>参数传递的语法</p>
<p>IN：代表输入参数，需要由调用者传递实际数据，默认的<br>OUT：代表输出参数，该参数可以作为返回值<br>INOUT：代表既可以作为输入参数，也可以作为输出参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">-- 标准语法</span><br><span class="line">CREATE PROCEDURE 存储过程名称([IN|OUT|INOUT] 参数名 数据类型)</span><br><span class="line">BEGIN</span><br><span class="line">	执行的sql语句;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入总成绩变量，代表学生总成绩，输出分数描述变量，代表学生总成绩的描述</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE pro_test6(IN total INT, OUT description VARCHAR(10))</span><br><span class="line">BEGIN</span><br><span class="line">	-- 判断总分数</span><br><span class="line">	IF total &gt;= 380 THEN </span><br><span class="line">		SET description = &#x27;学习优秀&#x27;;</span><br><span class="line">	ELSEIF total &gt;= 320 AND total &lt; 380 THEN </span><br><span class="line">		SET description = &#x27;学习不错&#x27;;</span><br><span class="line">	ELSE </span><br><span class="line">		SET description = &#x27;学习一般&#x27;;</span><br><span class="line">	END IF;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用pro_test6存储过程</span><br><span class="line">CALL pro_test6(310,@description);</span><br><span class="line">CALL pro_test6((SELECT SUM(score) FROM student), @description);</span><br><span class="line">-- 查询总成绩描述</span><br><span class="line">SELECT @description;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看参数方法</p>
<ul>
<li>@变量名 : <strong>用户会话变量</strong>，代表整个会话过程他都是有作用的，类似于全局变量</li>
<li>@@变量名 : <strong>系统变量</strong></li>
</ul>
</li>
</ul>
<hr>
<h5 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h5><ul>
<li><p>标准语法 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE 表达式</span><br><span class="line">    WHEN 值1 THEN 执行sql语句1;</span><br><span class="line">    [WHEN 值2 THEN 执行sql语句2;]</span><br><span class="line">    ...</span><br><span class="line">    [ELSE 执行sql语句n;]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>标准语法 2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sCASE</span><br><span class="line">    WHEN 判断条件1 THEN 执行sql语句1;</span><br><span class="line">    [WHEN 判断条件2 THEN 执行sql语句2;]</span><br><span class="line">    ...</span><br><span class="line">    [ELSE 执行sql语句n;]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>演示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_test7(IN total INT)</span><br><span class="line">BEGIN</span><br><span class="line">	-- 定义变量</span><br><span class="line">	DECLARE description VARCHAR(10);</span><br><span class="line">	-- 使用case判断</span><br><span class="line">	CASE</span><br><span class="line">	WHEN total &gt;= 380 THEN</span><br><span class="line">		SET description = &#x27;学习优秀&#x27;;</span><br><span class="line">	WHEN total &gt;= 320 AND total &lt; 380 THEN</span><br><span class="line">		SET description = &#x27;学习不错&#x27;;</span><br><span class="line">	ELSE </span><br><span class="line">		SET description = &#x27;学习一般&#x27;;</span><br><span class="line">	END CASE;</span><br><span class="line">	</span><br><span class="line">	-- 查询分数描述信息</span><br><span class="line">	SELECT description;</span><br><span class="line">END$</span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用pro_test7存储过程</span><br><span class="line">CALL pro_test7(390);</span><br><span class="line">CALL pro_test7((SELECT SUM(score) FROM student));</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="WHILE"><a href="#WHILE" class="headerlink" title="WHILE"></a>WHILE</h5><ul>
<li><p>while 循环语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHILE 条件判断语句 DO</span><br><span class="line">	循环体语句;</span><br><span class="line">	条件控制语句;</span><br><span class="line">END WHILE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算 1~100 之间的偶数和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_test6()</span><br><span class="line">BEGIN</span><br><span class="line">	-- 定义求和变量</span><br><span class="line">	DECLARE result INT DEFAULT 0;</span><br><span class="line">	-- 定义初始化变量</span><br><span class="line">	DECLARE num INT DEFAULT 1;</span><br><span class="line">	-- while循环</span><br><span class="line">	WHILE num &lt;= 100 DO</span><br><span class="line">		IF num % 2 = 0 THEN</span><br><span class="line">			SET result = result + num;</span><br><span class="line">		END IF;</span><br><span class="line">		SET num = num + 1;</span><br><span class="line">	END WHILE;</span><br><span class="line">	-- 查询求和结果</span><br><span class="line">	SELECT result;</span><br><span class="line">END$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">-- 调用pro_test6存储过程</span><br><span class="line">CALL pro_test6();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="REPEAT"><a href="#REPEAT" class="headerlink" title="REPEAT"></a>REPEAT</h5><ul>
<li><p>repeat 循环标准语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line">REPEAT</span><br><span class="line">	循环体语句;</span><br><span class="line">	条件控制语句;</span><br><span class="line">	UNTIL 条件判断语句</span><br><span class="line">END REPEAT;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算 1~10 之间的和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_test9()</span><br><span class="line">BEGIN</span><br><span class="line">	-- 定义求和变量</span><br><span class="line">	DECLARE result INT DEFAULT 0;</span><br><span class="line">	-- 定义初始化变量</span><br><span class="line">	DECLARE num INT DEFAULT 1;</span><br><span class="line">	-- repeat循环</span><br><span class="line">	REPEAT</span><br><span class="line">		-- 累加</span><br><span class="line">		SET result = result + num;</span><br><span class="line">		-- 让num+1</span><br><span class="line">		SET num = num + 1;</span><br><span class="line">		-- 停止循环</span><br><span class="line">		UNTIL num &gt; 10</span><br><span class="line">	END REPEAT;</span><br><span class="line">	-- 查询求和结果</span><br><span class="line">	SELECT result;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用pro_test9存储过程</span><br><span class="line">CALL pro_test9();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="LOOP"><a href="#LOOP" class="headerlink" title="LOOP"></a>LOOP</h5><p>LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，如果不加退出循环的语句，那么就变成了死循环</p>
<ul>
<li><p>loop 循环标准语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[循环名称:] LOOP</span><br><span class="line">	条件判断语句</span><br><span class="line">		[LEAVE 循环名称;]</span><br><span class="line">	循环体语句;</span><br><span class="line">	条件控制语句;</span><br><span class="line">END LOOP 循环名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算 1~10 之间的和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_test10()</span><br><span class="line">BEGIN</span><br><span class="line">	-- 定义求和变量</span><br><span class="line">	DECLARE result INT DEFAULT 0;</span><br><span class="line">	-- 定义初始化变量</span><br><span class="line">	DECLARE num INT DEFAULT 1;</span><br><span class="line">	-- loop循环</span><br><span class="line">	l:LOOP</span><br><span class="line">		-- 条件成立，停止循环</span><br><span class="line">		IF num &gt; 10 THEN</span><br><span class="line">			LEAVE l;</span><br><span class="line">		END IF;</span><br><span class="line">		-- 累加</span><br><span class="line">		SET result = result + num;</span><br><span class="line">		-- 让num+1</span><br><span class="line">		SET num = num + 1;</span><br><span class="line">	END LOOP l;</span><br><span class="line">	-- 查询求和结果</span><br><span class="line">	SELECT result;</span><br><span class="line">END$</span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用pro_test10存储过程</span><br><span class="line">CALL pro_test10();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h5><p>游标是用来存储查询结果集的数据类型，在存储过程和函数中可以使用光标对结果集进行循环的处理</p>
<ul>
<li>游标可以遍历返回的多行结果，每次拿到一整行数据</li>
<li>简单来说游标就类似于集合的迭代器遍历</li>
<li>MySQL 中的游标只能用在存储过程和函数中</li>
</ul>
<p>游标的语法</p>
<ul>
<li><p>创建游标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 游标名称 CURSOR FOR 查询sql语句;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开游标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPEN 游标名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用游标获取数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FETCH 游标名称 INTO 变量名1,变量名2,...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭游标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLOSE 游标名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Mysql 通过一个 Error handler 声明来判断指针是否到尾部，并且必须和创建游标的 SQL 语句声明在一起：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE EXIT HANDLER FOR NOT FOUND (do some action，一般是设置标志变量)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>游标的基本使用</p>
<ul>
<li><p>数据准备：表 student</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	NAME	age		gender	score</span><br><span class="line">1	张三		23		男		95</span><br><span class="line">2	李四		24		男		98</span><br><span class="line">3	王五		25		女		100</span><br><span class="line">4	赵六		26		女		90</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 stu_score 表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE stu_score(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	score INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将student表中所有的成绩保存到stu_score表中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE pro_test12()</span><br><span class="line">BEGIN</span><br><span class="line">	-- 定义成绩变量</span><br><span class="line">	DECLARE s_score INT;</span><br><span class="line">	-- 定义标记变量</span><br><span class="line">	DECLARE flag INT DEFAULT 0;</span><br><span class="line">	</span><br><span class="line">	-- 创建游标，查询所有学生成绩数据</span><br><span class="line">	DECLARE stu_result CURSOR FOR SELECT score FROM student;</span><br><span class="line">	-- 游标结束后，将标记变量改为1  这两个必须声明在一起</span><br><span class="line">	DECLARE EXIT HANDLER FOR NOT FOUND SET flag = 1;</span><br><span class="line">	</span><br><span class="line">	-- 开启游标</span><br><span class="line">	OPEN stu_result;</span><br><span class="line">	-- 循环使用游标</span><br><span class="line">	REPEAT</span><br><span class="line">		-- 使用游标，遍历结果,拿到数据</span><br><span class="line">		FETCH stu_result INTO s_score;</span><br><span class="line">		-- 将数据保存到stu_score表中</span><br><span class="line">		INSERT INTO stu_score VALUES (NULL,s_score);</span><br><span class="line">	UNTIL flag=1</span><br><span class="line">	END REPEAT;</span><br><span class="line">	-- 关闭游标</span><br><span class="line">	CLOSE stu_result;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">-- 调用pro_test12存储过程</span><br><span class="line">CALL pro_test12();</span><br><span class="line">-- 查询stu_score表</span><br><span class="line">SELECT * FROM stu_score;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h4><p>存储函数和存储过程是非常相似的，存储函数可以做的事情，存储过程也可以做到</p>
<p>存储函数有返回值，存储过程没有返回值（参数的 out 其实也相当于是返回数据了）</p>
<ul>
<li><p>创建存储函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">-- 标准语法</span><br><span class="line">CREATE FUNCTION 函数名称(参数 数据类型)</span><br><span class="line">RETURNS 返回值类型</span><br><span class="line">BEGIN</span><br><span class="line">	执行的sql语句;</span><br><span class="line">	RETURN 结果;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用存储函数，因为有返回值，所以使用 SELECT 调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 函数名称(实际参数);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除存储函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP FUNCTION 函数名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义存储函数，获取学生表中成绩大于95分的学生数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE FUNCTION fun_test()</span><br><span class="line">RETURN INT</span><br><span class="line">BEGIN</span><br><span class="line">	-- 定义统计变量</span><br><span class="line">	DECLARE result INT;</span><br><span class="line">	-- 查询成绩大于95分的学生数量，给统计变量赋值</span><br><span class="line">	SELECT COUNT(score) INTO result FROM student WHERE score &gt; 95;</span><br><span class="line">	-- 返回统计结果</span><br><span class="line">	SELECT result;</span><br><span class="line">END</span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用fun_test存储函数</span><br><span class="line">SELECT fun_test();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>触发器是与表有关的数据库对象，在 insert&#x2F;update&#x2F;delete 之前或之后触发并执行触发器中定义的 SQL 语句</p>
<ul>
<li>触发器的这种特性可以协助应用在数据库端确保数据的完整性 、日志记录 、数据校验等操作</li>
</ul>
<ul>
<li>使用别名 NEW 和 OLD 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的</li>
<li>现在触发器还只支持行级触发，不支持语句级触发</li>
</ul>
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>OLD的含义</th>
<th>NEW的含义</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT 型触发器</td>
<td>无 (因为插入前状态无数据)</td>
<td>NEW 表示将要或者已经新增的数据</td>
</tr>
<tr>
<td>UPDATE 型触发器</td>
<td>OLD 表示修改之前的数据</td>
<td>NEW 表示将要或已经修改后的数据</td>
</tr>
<tr>
<td>DELETE 型触发器</td>
<td>OLD 表示将要或者已经删除的数据</td>
<td>无 (因为删除后状态无数据)</td>
</tr>
</tbody></table>
<hr>
<h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li><p>创建触发器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER 触发器名称</span><br><span class="line">BEFORE|AFTER  INSERT|UPDATE|DELETE</span><br><span class="line">ON 表名</span><br><span class="line">[FOR EACH ROW]  -- 行级触发器</span><br><span class="line">BEGIN</span><br><span class="line">	触发器要执行的功能;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看触发器的状态、语法等信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TRIGGERS;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除触发器，如果没有指定 schema_name，默认为当前数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TRIGGER [schema_name.]trigger_name;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="触发演示"><a href="#触发演示" class="headerlink" title="触发演示"></a>触发演示</h4><p>通过触发器记录账户表的数据变更日志。包含：增加、修改、删除</p>
<ul>
<li><p>数据准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建db9数据库</span><br><span class="line">CREATE DATABASE db9;</span><br><span class="line">-- 使用db9数据库</span><br><span class="line">USE db9;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建账户表account</span><br><span class="line">CREATE TABLE account(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 账户id</span><br><span class="line">	NAME VARCHAR(20),					-- 姓名</span><br><span class="line">	money DOUBLE						-- 余额</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO account VALUES (NULL,&#x27;张三&#x27;,1000),(NULL,&#x27;李四&#x27;,2000);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建日志表account_log</span><br><span class="line">CREATE TABLE account_log(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 日志id</span><br><span class="line">	operation VARCHAR(20),				-- 操作类型 (insert update delete)</span><br><span class="line">	operation_time DATETIME,			-- 操作时间</span><br><span class="line">	operation_id INT,					-- 操作表的id</span><br><span class="line">	operation_params VARCHAR(200)       -- 操作参数</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 INSERT 型触发器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER account_insert</span><br><span class="line">AFTER INSERT</span><br><span class="line">ON account</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO account_log VALUES (NULL,&#x27;INSERT&#x27;,NOW(),new.id,CONCAT(&#x27;插入后&#123;id=&#x27;,new.id,&#x27;,name=&#x27;,new.name,&#x27;,money=&#x27;,new.money,&#x27;&#125;&#x27;));</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 向account表添加记录</span><br><span class="line">INSERT INTO account VALUES (NULL,&#x27;王五&#x27;,3000);</span><br><span class="line"></span><br><span class="line">-- 查询日志表</span><br><span class="line">SELECT * FROM account_log;</span><br><span class="line">/*</span><br><span class="line">id	operation	operation_time		operation_id	operation_params</span><br><span class="line">1	INSERT	   	2021-01-26 19:51:11		3	     插入后&#123;id=3,name=王五money=2000&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>


</li>
<li><p>创建 UPDATE 型触发器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER account_update</span><br><span class="line">AFTER UPDATE</span><br><span class="line">ON account</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO account_log VALUES (NULL,&#x27;UPDATE&#x27;,NOW(),new.id,CONCAT(&#x27;修改前&#123;id=&#x27;,old.id,&#x27;,name=&#x27;,old.name,&#x27;,money=&#x27;,old.money,&#x27;&#125;&#x27;,&#x27;修改后&#123;id=&#x27;,new.id,&#x27;,name=&#x27;,new.name,&#x27;,money=&#x27;,new.money,&#x27;&#125;&#x27;));</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 修改account表</span><br><span class="line">UPDATE account SET money=3500 WHERE id=3;</span><br><span class="line"></span><br><span class="line">-- 查询日志表</span><br><span class="line">SELECT * FROM account_log;</span><br><span class="line">/*</span><br><span class="line">id	operation	operation_time		operation_id	  operation_params</span><br><span class="line">2	UPDATE	   	2021-01-26 19:58:54		2		 更新前&#123;id=2,name=李四money=1000&#125;</span><br><span class="line">												 更新后&#123;id=2,name=李四money=200&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>


</li>
<li><p>创建 DELETE 型触发器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER account_delete</span><br><span class="line">AFTER DELETE</span><br><span class="line">ON account</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO account_log VALUES (NULL,&#x27;DELETE&#x27;,NOW(),old.id,CONCAT(&#x27;删除前&#123;id=&#x27;,old.id,&#x27;,name=&#x27;,old.name,&#x27;,money=&#x27;,old.money,&#x27;&#125;&#x27;));</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 删除account表数据</span><br><span class="line">DELETE FROM account WHERE id=3;</span><br><span class="line"></span><br><span class="line">-- 查询日志表</span><br><span class="line">SELECT * FROM account_log;</span><br><span class="line">/*</span><br><span class="line">id	operation	operation_time		operation_id	operation_params</span><br><span class="line">3	DELETE		2021-01-26 20:02:48		3	    删除前&#123;id=3,name=王五money=2000&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>对比其他数据库，MySQL 的架构可以在不同场景应用并发挥良好作用，主要体现在存储引擎，插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取分离，可以针对不同的存储需求可以选择最优的存储引擎</p>
<p>存储引擎的介绍：</p>
<ul>
<li>MySQL 数据库使用不同的机制存取表文件 , 机制的差别在于不同的存储方式、索引技巧、锁定水平等不同的功能和能力，在 MySQL 中，将这些不同的技术及配套的功能称为存储引擎</li>
<li>Oracle、SqlServer 等数据库只有一种存储引擎，MySQL <strong>提供了插件式的存储引擎架构</strong>，所以 MySQL 存在多种存储引擎 , 就会让数据库采取了不同的处理数据的方式和扩展功能</li>
<li>在关系型数据库中数据的存储是以表的形式存进行，所以存储引擎也称为表类型（存储和操作此表的类型）</li>
<li>通过选择不同的引擎，能够获取最佳的方案,  也能够获得额外的速度或者功能，提高程序的整体效果。</li>
</ul>
<p>MySQL 支持的存储引擎：</p>
<ul>
<li>MySQL 支持的引擎包括：InnoDB、MyISAM、MEMORY、Archive、Federate、CSV、BLACKHOLE 等</li>
<li>MySQL5.5 之前的默认存储引擎是 MyISAM，5.5 之后就改为了 InnoDB</li>
</ul>
<hr>
<h3 id="引擎对比"><a href="#引擎对比" class="headerlink" title="引擎对比"></a>引擎对比</h3><p>MyISAM 存储引擎：</p>
<ul>
<li>特点：不支持事务和外键，读取速度快，节约资源</li>
<li>应用场景：查询和插入操作为主，只有很少更新和删除操作，并对事务的完整性、并发性要求不高</li>
<li>存储方式：<ul>
<li>每个 MyISAM 在磁盘上存储成 3 个文件，其文件名都和表名相同，拓展名不同</li>
<li>表的定义保存在 .frm 文件，表数据保存在 .MYD (MYData) 文件中，索引保存在 .MYI (MYIndex) 文件中</li>
</ul>
</li>
</ul>
<p>InnoDB 存储引擎：(MySQL5.5 版本后默认的存储引擎)</p>
<ul>
<li>特点：<strong>支持事务</strong>和外键操作，支持并发控制。对比 MyISAM 的存储引擎，InnoDB 写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引</li>
<li>应用场景：对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，读写频繁的操作</li>
<li>存储方式：<ul>
<li>使用共享表空间存储， 这种方式创建的表的表结构保存在 .frm 文件中， 数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中，可以是多个文件</li>
<li>使用多表空间存储，创建的表的表结构存在 .frm 文件中，每个表的数据和索引单独保存在 .ibd 中</li>
</ul>
</li>
</ul>
<p>MEMORY 存储引擎：</p>
<ul>
<li>特点：每个 MEMORY 表实际对应一个磁盘文件 ，该文件中只存储表的结构，表数据保存在内存中，且默认<strong>使用 HASH 索引</strong>，所以数据默认就是无序的，但是在需要快速定位记录可以提供更快的访问，<strong>服务一旦关闭，表中的数据就会丢失</strong>，存储不安全</li>
<li>应用场景：通常用于更新不太频繁的小表，用以快速得到访问结果，类似缓存</li>
<li>存储方式：表结构保存在 .frm 中</li>
</ul>
<p>MERGE 存储引擎：</p>
<ul>
<li><p>特点：</p>
<ul>
<li>是一组 MyISAM 表的组合，这些 MyISAM 表必须结构完全相同，通过将不同的表分布在多个磁盘上</li>
<li>MERGE 表本身并没有存储数据，对 MERGE 类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的 MyISAM 表进行的</li>
</ul>
</li>
<li><p>应用场景：将一系列等同的 MyISAM 表以逻辑方式组合在一起，并作为一个对象引用他们，适合做数据仓库</p>
</li>
<li><p>操作方式：</p>
<ul>
<li>插入操作是通过 INSERT_METHOD 子句定义插入的表，使用 FIRST 或 LAST 值使得插入操作被相应地作用在第一或者最后一个表上；不定义这个子句或者定义为 NO，表示不能对 MERGE 表执行插入操作</li>
<li>对 MERGE 表进行 DROP 操作，但是这个操作只是删除 MERGE 表的定义，对内部的表是没有任何影响的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE order_1(</span><br><span class="line">)ENGINE = MyISAM DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE order_2(</span><br><span class="line">)ENGINE = MyISAM DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE order_all(</span><br><span class="line">	-- 结构与MyISAM表相同</span><br><span class="line">)ENGINE = MERGE UNION = (order_1,order_2) INSERT_METHOD=LAST DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MERGE.png"></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>MEMORY</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>有（平台对文件系统大小的限制）</td>
<td>64TB</td>
<td>有（平台的内存限制）</td>
</tr>
<tr>
<td><strong>事务安全</strong></td>
<td><strong>不支持</strong></td>
<td><strong>支持</strong></td>
<td><strong>不支持</strong></td>
</tr>
<tr>
<td><strong>锁机制</strong></td>
<td><strong>表锁</strong></td>
<td><strong>表锁&#x2F;行锁</strong></td>
<td><strong>表锁</strong></td>
</tr>
<tr>
<td>B+Tree 索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>哈希索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>集群索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>数据索引</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>数据缓存</td>
<td>不支持</td>
<td>支持</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>索引缓存</td>
<td>支持</td>
<td>支持</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>数据可压缩</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>空间使用</td>
<td>低</td>
<td>高</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>内存使用</td>
<td>低</td>
<td>高</td>
<td>中等</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>高</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td><strong>外键</strong></td>
<td><strong>不支持</strong></td>
<td><strong>支持</strong></td>
<td><strong>不支持</strong></td>
</tr>
</tbody></table>
<p>MyISAM 和 InnoDB 的区别？</p>
<ul>
<li><p>事务：InnoDB 支持事务，MyISAM 不支持事务</p>
</li>
<li><p>外键：InnoDB 支持外键，MyISAM 不支持外键</p>
</li>
<li><p>索引：InnoDB 是聚集（聚簇）索引，MyISAM 是非聚集（非聚簇）索引</p>
</li>
<li><p>锁粒度：InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁</p>
</li>
<li><p>存储结构：参考本节上半部分</p>
</li>
</ul>
<hr>
<h3 id="引擎操作"><a href="#引擎操作" class="headerlink" title="引擎操作"></a>引擎操作</h3><ul>
<li><p>查询数据库支持的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW ENGINES;</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%storage_engine%&#x27;; -- 查看Mysql数据库默认的存储引擎 </span><br></pre></td></tr></table></figure>
</li>
<li><p>查询某个数据库中所有数据表的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLE STATUS FROM 数据库名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询某个数据库中某个数据表的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLE STATUS FROM 数据库名称 WHERE NAME = &#x27;数据表名称&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据表，指定存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	列名,数据类型,</span><br><span class="line">    ...</span><br><span class="line">)ENGINE = 引擎名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改数据表的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE = 引擎名称;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="索引机制"><a href="#索引机制" class="headerlink" title="索引机制"></a>索引机制</h2><h3 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>MySQL 官方对索引的定义为：索引（index）是帮助 MySQL 高效获取数据的一种数据结构，<strong>本质是排好序的快速查找数据结构。</strong>在表数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引</p>
<p><strong>索引是在存储引擎层实现的</strong>，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样</p>
<p>索引使用：一张数据表，用于保存数据；一个索引配置文件，用于保存索引；每个索引都指向了某一个数据<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%8B%E7%BB%8D.png"></p>
<p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据的物理地址的指针，这样就可以运用二叉查找快速获取到相应数据</p>
<p>索引的优点：</p>
<ul>
<li>类似于书籍的目录索引，提高数据检索的效率，降低数据库的 IO 成本</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 的消耗</li>
</ul>
<p>索引的缺点：</p>
<ul>
<li>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式<strong>存储在磁盘</strong>上</li>
<li>虽然索引大大提高了查询效率，同时却也降低更新表的速度。对表进行 INSERT、UPDATE、DELETE 操作，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，还会调整因为更新所带来的键值变化后的索引信息，<strong>但是更新数据也需要先从数据库中获取</strong>，索引加快了获取速度，所以可以相互抵消一下。</li>
<li>索引会影响到 WHERE 的查询条件和排序 ORDER BY 两大功能</li>
</ul>
<hr>
<h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><p>索引一般的分类如下：</p>
<ul>
<li><p>功能分类 </p>
<ul>
<li>主键索引：一种特殊的唯一索引，不允许有空值，一般在建表时同时创建主键索引</li>
<li>单列索引：一个索引只包含单个列，一个表可以有多个单列索引（普通索引）</li>
<li>联合索引：顾名思义，就是将单列索引进行组合</li>
<li>唯一索引：索引列的值必须唯一，<strong>允许有空值</strong>，如果是联合索引，则列值组合必须唯一<ul>
<li>NULL 值可以出现多次，因为两个 NULL 比较的结果既不相等，也不不等，结果仍然是未知</li>
<li>可以声明不允许存储 NULL 值的非空唯一索引</li>
</ul>
</li>
<li>外键索引：只有 InnoDB 引擎支持外键索引，用来保证数据的一致性、完整性和实现级联操作</li>
</ul>
</li>
<li><p>结构分类</p>
<ul>
<li>BTree 索引：MySQL 使用最频繁的一个索引数据结构，是 InnoDB 和 MyISAM 存储引擎默认的索引类型，底层基于 B+Tree</li>
<li>Hash 索引：MySQL中 Memory 存储引擎默认支持的索引类型</li>
<li>R-tree 索引（空间索引）：空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型</li>
<li>Full-text 索引（全文索引）：快速匹配全部文档的方式。MyISAM 支持， InnoDB 不支持 FULLTEXT 类型的索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，MEMORY 引擎不支持</li>
</ul>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>BTREE</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>HASH</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-tree</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6 版本之后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
</li>
</ul>
<p>联合索引图示：根据身高年龄建立的组合索引（height、age）</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E5%9B%BE.png"></p>
<hr>
<h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><p>索引在创建表的时候可以同时创建， 也可以随时增加新的索引</p>
<ul>
<li><p>创建索引：如果一个表中有一列是主键，那么会<strong>默认为其创建主键索引</strong>（主键列不需要单独创建索引）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [UNIQUE|FULLTEXT] INDEX 索引名称 [USING 索引类型] ON 表名(列名...);</span><br><span class="line">-- 索引类型默认是 B+TREE</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 单列索引</span><br><span class="line">ALTER TABLE 表名 ADD INDEX 索引名称(列名);</span><br><span class="line"></span><br><span class="line">-- 组合索引</span><br><span class="line">ALTER TABLE 表名 ADD INDEX 索引名称(列名1,列名2,...);</span><br><span class="line"></span><br><span class="line">-- 主键索引</span><br><span class="line">ALTER TABLE 表名 ADD PRIMARY KEY(主键列名); </span><br><span class="line"></span><br><span class="line">-- 外键索引(添加外键约束，就是外键索引)</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名);</span><br><span class="line"></span><br><span class="line">-- 唯一索引</span><br><span class="line">ALTER TABLE 表名 ADD UNIQUE 索引名称(列名);</span><br><span class="line"></span><br><span class="line">-- 全文索引(mysql只支持文本类型)</span><br><span class="line">ALTER TABLE 表名 ADD FULLTEXT 索引名称(列名);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX 索引名称 ON 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>案例练习</p>
<p>数据准备：student</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	NAME	 age	score</span><br><span class="line">1	张三		23		99</span><br><span class="line">2	李四		24		95</span><br><span class="line">3	王五		25		98</span><br><span class="line">4	赵六		26		97</span><br></pre></td></tr></table></figure>

<p>索引操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 为student表中姓名列创建一个普通索引</span><br><span class="line">CREATE INDEX idx_name ON student(NAME);</span><br><span class="line"></span><br><span class="line">-- 为student表中年龄列创建一个唯一索引</span><br><span class="line">CREATE UNIQUE INDEX idx_age ON student(age);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><h4 id="索引对比"><a href="#索引对比" class="headerlink" title="索引对比"></a>索引对比</h4><p>聚簇索引是一种数据存储方式，并不是一种单独的索引类型</p>
<ul>
<li><p>聚簇索引的叶子节点存放的是主键值和数据行，支持覆盖索引</p>
</li>
<li><p>非聚簇索引的叶子节点存放的是主键值或指向数据行的指针（由存储引擎决定）</p>
</li>
</ul>
<p>在 Innodb 下主键索引是聚簇索引，在 MyISAM 下主键索引是非聚簇索引</p>
<hr>
<h4 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h4><h5 id="聚簇索引-1"><a href="#聚簇索引-1" class="headerlink" title="聚簇索引"></a>聚簇索引</h5><p>在 Innodb 存储引擎，B+ 树索引可以分为聚簇索引（也称聚集索引、clustered index）和辅助索引（也称非聚簇索引或二级索引、secondary index、non-clustered index）</p>
<p>InnoDB 中，聚簇索引是按照每张表的主键构造一颗 B+ 树，叶子节点中存放的就是整张表的数据，将聚簇索引的叶子节点称为数据页</p>
<ul>
<li>这个特性决定了<strong>数据也是索引的一部分</strong>，所以一张表只能有一个聚簇索引</li>
<li>辅助索引的存在不影响聚簇索引中数据的组织，所以一张表可以有多个辅助索引</li>
</ul>
<p>聚簇索引的优点：</p>
<ul>
<li>数据访问更快，聚簇索引将索引和数据保存在同一个 B+ 树中，因此从聚簇索引中获取数据比非聚簇索引更快</li>
<li>聚簇索引对于主键的排序查找和范围查找速度非常快</li>
</ul>
<p>聚簇索引的缺点：</p>
<ul>
<li><p>插入速度严重依赖于插入顺序，按照主键的顺序（递增）插入是最快的方式，否则将会出现页分裂，严重影响性能，所以对于 InnoDB 表，一般都会定义一个自增的 ID 列为主键</p>
</li>
<li><p>更新主键的代价很高，将会导致被更新的行移动，所以对于 InnoDB 表，一般定义主键为不可更新</p>
</li>
<li><p>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据</p>
</li>
</ul>
<hr>
<h5 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h5><p>在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引等</p>
<p>辅助索引叶子节点存储的是主键值，而不是数据的物理地址，所以访问数据需要二次查找，推荐使用覆盖索引，可以减少回表查询</p>
<p><strong>检索过程</strong>：辅助索引找到主键值，再通过聚簇索引（二分）找到数据页，最后通过数据页中的 Page Directory（二分）找到对应的数据分组，遍历组内所所有的数据找到数据行</p>
<p>补充：无索引走全表查询，查到数据页后和上述步骤一致</p>
<hr>
<h5 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h5><p>InnoDB 使用 B+Tree 作为索引结构，并且 InnoDB 一定有索引</p>
<p>主键索引：</p>
<ul>
<li><p>在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这个索引的 key 是数据表的主键，叶子节点 data 域保存了完整的数据记录</p>
</li>
<li><p>InnoDB 的表数据文件<strong>通过主键聚集数据</strong>，如果没有定义主键，会选择非空唯一索引代替，如果也没有这样的列，MySQL 会自动为 InnoDB 表生成一个<strong>隐含字段 row_id</strong> 作为主键，这个字段长度为 6 个字节，类型为长整形</p>
</li>
</ul>
<p>辅助索引：</p>
<ul>
<li><p>InnoDB 的所有辅助索引（二级索引）都引用主键作为 data 域</p>
</li>
<li><p>InnoDB 表是基于聚簇索引建立的，因此 InnoDB 的索引能提供一种非常快速的主键查找性能。不过辅助索引也会包含主键列，所以不建议使用过长的字段作为主键，<strong>过长的主索引会令辅助索引变得过大</strong></p>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB%E8%81%9A%E7%B0%87%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png"></p>
<hr>
<h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><h5 id="非聚簇"><a href="#非聚簇" class="headerlink" title="非聚簇"></a>非聚簇</h5><p>MyISAM 的主键索引使用的是非聚簇索引，索引文件和数据文件是分离的，<strong>索引文件仅保存数据的地址</strong></p>
<ul>
<li>主键索引 B+ 树的节点存储了主键，辅助键索引 B+ 树存储了辅助键，表数据存储在独立的地方，这两颗 B+ 树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别</li>
<li>由于索引树是独立的，通过辅助索引检索<strong>无需回表查询</strong>访问主键的索引树</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E6%A3%80%E9%94%81%E6%95%B0%E6%8D%AE%E5%9B%BE.jpg"></p>
<hr>
<h5 id="索引实现-1"><a href="#索引实现-1" class="headerlink" title="索引实现"></a>索引实现</h5><p>MyISAM 的索引方式也叫做非聚集的，之所以这么称呼是为了与 InnoDB 的聚集索引区分</p>
<p>主键索引：MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址</p>
<p>辅助索引：MyISAM 中主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM%E4%B8%BB%E9%94%AE%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png"></p>
<p>参考文章：<a href="https://blog.csdn.net/lm1060891265/article/details/81482136">https://blog.csdn.net/lm1060891265/article/details/81482136</a></p>
<hr>
<h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><h4 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h4><p>文件系统的最小单元是块（block），一个块的大小是 4K，系统从磁盘读取数据到内存时是以磁盘块为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么</p>
<p>InnoDB 存储引擎中有页（Page）的概念，页是 MySQL 磁盘管理的最小单位</p>
<ul>
<li><strong>InnoDB 存储引擎中默认每个页的大小为 16KB，索引中一个节点就是一个数据页</strong>，所以会一次性读取 16KB 的数据到内存</li>
<li>InnoDB 引擎将若干个地址连接磁盘块，以此来达到页的大小 16KB</li>
<li>在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I&#x2F;O 次数，提高查询效率</li>
</ul>
<p>超过 16KB 的一条记录，主键索引页只会存储部分数据和指向<strong>溢出页</strong>的指针，剩余数据都会分散存储在溢出页中</p>
<p>数据页物理结构，从上到下：</p>
<ul>
<li>File Header：上一页和下一页的指针、该页的类型（索引页、数据页、日志页等）、<strong>校验和</strong>、LSN（最近一次修改当前页面时的系统 lsn 值，事务持久性部分详解）等信息</li>
<li>Page Header：记录状态信息</li>
<li>Infimum + Supremum：当前页的最小记录和最大记录（头尾指针），Infimum 所在分组只有一条记录，Supremum 所在分组可以有 1 ~ 8 条记录，剩余的分组可以有 4 ~ 8 条记录</li>
<li>User Records：存储数据的记录</li>
<li>Free Space：尚未使用的存储空间</li>
<li>Page Directory：分组的目录，可以通过目录快速定位（二分法）数据的分组</li>
<li>File Trailer：检验和字段，在刷脏过程中，页首和页尾的校验和一致才能说明页面刷新成功，二者不同说明刷新期间发生了错误；LSN 字段，也是用来校验页面的完整性</li>
</ul>
<p>数据页中包含数据行，数据的存储是基于数据行的，数据行有 next_record 属性指向下一个行数据，所以是可以遍历的，但是一组数据至多 8 个行，通过 Page Directory 先定位到组，然后遍历获取所需的数据行即可</p>
<p>数据行中有三个隐藏字段：trx_id、roll_pointer、row_id（在事务章节会详细介绍它们的作用）</p>
<hr>
<h4 id="BTree"><a href="#BTree" class="headerlink" title="BTree"></a>BTree</h4><p>BTree 的索引类型是基于 B+Tree 树型数据结构的，B+Tree 又是 BTree 数据结构的变种，用在数据库和操作系统中的文件系统，特点是能够保持数据稳定有序</p>
<p>BTree 又叫多路平衡搜索树，一颗 m 叉的 BTree 特性如下：</p>
<ul>
<li>树中每个节点最多包含 m 个孩子</li>
<li>除根节点与叶子节点外，每个节点至少有 [ceil(m&#x2F;2)] 个孩子</li>
<li>若根节点不是叶子节点，则至少有两个孩子</li>
<li>所有的叶子节点都在同一层</li>
<li>每个非叶子节点由 n 个 key 与 n+1 个指针组成，其中 [ceil(m&#x2F;2)-1] &lt;&#x3D; n &lt;&#x3D; m-1</li>
</ul>
<p>5 叉，key 的数量 [ceil(m&#x2F;2)-1] &lt;&#x3D; n &lt;&#x3D; m-1 为 2 &lt;&#x3D; n &lt;&#x3D;4 ，当 n&gt;4 时中间节点分裂到父节点，两边节点分裂</p>
<p>插入 C N G A H E K Q M F W L T Z D P R X Y S 数据的工作流程：</p>
<ul>
<li><p>插入前 4 个字母 C N G A </p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B1.png"></p>
</li>
<li><p>插入 H，n&gt;4，中间元素 G 字母向上分裂到新的节点</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B2.png"></p>
</li>
<li><p>插入 E、K、Q 不需要分裂</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B3.png"></p>
</li>
<li><p>插入 M，中间元素 M 字母向上分裂到父节点 G</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B4.png"></p>
</li>
<li><p>插入 F，W，L，T 不需要分裂</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B5.png"></p>
</li>
<li><p>插入 Z，中间元素 T 向上分裂到父节点中</p>
</li>
</ul>
<p>  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B6.png"></p>
<ul>
<li><p>插入 D，中间元素 D 向上分裂到父节点中，然后插入 P，R，X，Y 不需要分裂</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B7.png"></p>
</li>
<li><p>最后插入 S，NPQR 节点 n&gt;5，中间节点 Q 向上分裂，但分裂后父节点 DGMT 的 n&gt;5，中间节点 M 向上分裂</p>
</li>
</ul>
<p>  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B8.png"></p>
<p>BTree 树就已经构建完成了，BTree 树和二叉树相比， 查询数据的效率更高， 因为对于相同的数据量来说，<strong>BTree 的层级结构比二叉树少</strong>，所以搜索速度快</p>
<p>BTree 结构的数据可以让系统高效的找到数据所在的磁盘块，定义一条记录为一个二元组 [key, data] ，key 为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key 值互不相同，BTree 中的每个节点根据实际情况可以包含大量的关键字信息和分支<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%861.png"></p>
<p>缺点：当进行范围查找时会出现回旋查找</p>
<hr>
<h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p>BTree 数据结构中每个节点中不仅包含数据的 key 值，还有 data 值。磁盘中每一页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I&#x2F;O 次数，进而影响查询效率，所以引入 B+Tree</p>
<p>B+Tree 为 BTree 的变种，B+Tree 与 BTree 的区别为：</p>
<ul>
<li>n 叉 B+Tree 最多含有 n 个 key（哈希值），而 BTree 最多含有 n-1 个 key</li>
</ul>
<ul>
<li>所有<strong>非叶子节点只存储键值 key</strong> 信息，只进行数据索引，使每个非叶子节点所能保存的关键字大大增加</li>
<li>所有<strong>数据都存储在叶子节点</strong>，所以每次数据查询的次数都一样</li>
<li><strong>叶子节点按照 key 大小顺序排列，左边结尾数据都会保存右边节点开始数据的指针，形成一个链表</strong></li>
<li>所有节点中的 key 在叶子节点中也存在（比如 5)，<strong>key 允许重复</strong>，B 树不同节点不存在重复的 key</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-B加Tree数据结构.png" style="zoom:67%;">

<p>B* 树：是 B+ 树的变体，在 B+ 树的非根和非叶子结点再增加指向兄弟的指针</p>
<hr>
<h5 id="优化结构"><a href="#优化结构" class="headerlink" title="优化结构"></a>优化结构</h5><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化，在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，<strong>提高区间访问的性能，防止回旋查找</strong></p>
<p>区间访问的意思是访问索引为 5 - 15 的数据，可以直接根据相邻节点的指针遍历</p>
<p>B+ 树的<strong>叶子节点是数据页</strong>（page），一个页里面可以存多个数据行</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%862.png"></p>
<p>通常在 B+Tree 上有两个头指针，<strong>一个指向根节点，另一个指向关键字最小的叶子节点</strong>，而且所有叶子节点（即数据节点）之间是一种链式环结构。可以对 B+Tree 进行两种查找运算：</p>
<ul>
<li>有范围：对于主键的范围查找和分页查找</li>
<li>有顺序：从根节点开始，进行随机查找，顺序查找</li>
</ul>
<p>InnoDB 中每个数据页的大小默认是 16KB，</p>
<ul>
<li>索引行：一般表的主键类型为 INT（4 字节）或 BIGINT（8 字节），指针大小在 InnoDB 中设置为 6 字节节，也就是说一个页大概存储 16KB&#x2F;(8B+6B)&#x3D;1K 个键值（估值）。则一个深度为 3 的 B+Tree 索引可以维护 <code>10^3 * 10^3 * 10^3 = 10亿</code> 条记录</li>
<li>数据行：一行数据的大小可能是 1k，一个数据页可以存储 16 行</li>
</ul>
<p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2-4 层。MySQL 的 InnoDB 存储引擎在设计时是<strong>将根节点常驻内存的</strong>，也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘 I&#x2F;O 操作</p>
<p>B+Tree 优点：提高查询速度，减少磁盘的 IO 次数，树形结构较小</p>
<hr>
<h5 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h5><p>B+ 树为了保持索引的有序性，在插入新值的时候需要做相应的维护</p>
<p>每个索引中每个块存储在磁盘页中，可能会出现以下两种情况：</p>
<ul>
<li>如果所在的数据页已经满了，这时候需要申请一个新的数据页，然后挪动部分数据过去，这个过程称为<strong>页分裂</strong>，原本放在一个页的数据现在分到两个页中，降低了空间利用率</li>
<li>当相邻两个页由于删除了数据，利用率很低之后，会将数据页做<strong>页合并</strong>，合并的过程可以认为是分裂过程的逆过程</li>
<li>这两个情况都是由 B+ 树的结构决定的</li>
</ul>
<p>一般选用数据小的字段做索引，字段长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</p>
<p>自增主键的插入数据模式，可以让主键索引尽量地保持递增顺序插入，不涉及到挪动其他记录，<strong>避免了页分裂</strong>，页分裂的目的就是保证后一个数据页中的所有行主键值比前一个数据页中主键值大</p>
<p>参考文章：<a href="https://developer.aliyun.com/article/919861">https://developer.aliyun.com/article/919861</a></p>
<hr>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率</p>
<p>创建索引时的原则：</p>
<ul>
<li>对查询频次较高，且数据量比较大的表建立索引</li>
<li>使用唯一索引，区分度越高，使用索引的效率越高</li>
<li>索引字段的选择，最佳候选列应当从 where 子句的条件中提取，使用覆盖索引</li>
<li>使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的 I&#x2F;O 效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升 MySQL 访问索引的 I&#x2F;O 效率</li>
<li>索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价越高。对于插入、更新、删除等 DML 操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低 DML 操作的效率，增加相应操作的时间消耗；另外索引过多的话，MySQL 也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但提高了选择的代价</li>
</ul>
<ul>
<li><p>MySQL 建立联合索引时会遵守<strong>最左前缀匹配原则</strong>，即最左优先，在检索数据时从联合索引的最左边开始匹配</p>
<p>N 个列组合而成的组合索引，相当于创建了 N 个索引，如果查询时 where 句中使用了组成该索引的<strong>前</strong>几个字段，那么这条查询 SQL 可以利用组合索引来提升查询效率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 对name、address、phone列建一个联合索引</span><br><span class="line">ALTER TABLE user ADD INDEX index_three(name,address,phone);</span><br><span class="line">-- 查询语句执行时会依照最左前缀匹配原则，检索时分别会使用索引进行数据匹配。</span><br><span class="line">(name,address,phone)</span><br><span class="line">(name,address)</span><br><span class="line">(name,phone)	-- 只有name字段走了索引</span><br><span class="line">(name)</span><br><span class="line"></span><br><span class="line">-- 索引的字段可以是任意顺序的，优化器会帮助我们调整顺序，下面的SQL语句可以命中索引</span><br><span class="line">SELECT * FROM user WHERE address = &#x27;北京&#x27; AND phone = &#x27;12345&#x27; AND name = &#x27;张三&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 如果联合索引中最左边的列不包含在条件查询中，SQL语句就不会命中索引，比如：</span><br><span class="line">SELECT * FROM user WHERE address = &#x27;北京&#x27; AND phone = &#x27;12345&#x27;; </span><br></pre></td></tr></table></figure></li>
</ul>
<p>哪些情况不要建立索引：</p>
<ul>
<li>记录太少的表</li>
<li>经常增删改的表</li>
<li>频繁更新的字段不适合创建索引</li>
<li>where 条件里用不到的字段不创建索引</li>
</ul>
<hr>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>覆盖索引：包含所有满足查询需要的数据的索引（SELECT 后面的字段刚好是索引字段），可以利用该索引返回 SELECT 列表的字段，而不必根据索引去聚簇索引上读取数据文件</p>
<p>回表查询：要查找的字段不在非主键索引树上时，需要通过叶子节点的主键值去主键索引上获取对应的行数据</p>
<p>使用覆盖索引，防止回表查询：</p>
<ul>
<li><p>表 user 主键为 id，普通索引为 age，查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user WHERE age = 30;</span><br></pre></td></tr></table></figure>

<p>查询过程：先通过普通索引 age&#x3D;30 定位到主键值 id&#x3D;1，再通过聚集索引 id&#x3D;1 定位到行记录数据，需要两次扫描 B+ 树</p>
</li>
<li><p>使用覆盖索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX idx_age ON user;</span><br><span class="line">CREATE INDEX idx_age_name ON user(age,name);</span><br><span class="line">SELECT id,age FROM user WHERE age = 30;</span><br></pre></td></tr></table></figure>

<p>在一棵索引树上就能获取查询所需的数据，无需回表速度更快</p>
</li>
</ul>
<p>使用覆盖索引，要注意 SELECT 列表中只取出需要的列，不可用 SELECT *，所有字段一起做索引会导致索引文件过大，查询性能下降</p>
<hr>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>索引条件下推优化（Index Condition Pushdown，ICP）是 MySQL5.6 添加，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</p>
<p>索引下推充分利用了索引中的数据，在查询出整行数据之前过滤掉无效的数据，再去主键索引树上查找</p>
<ul>
<li><p>不使用索引下推优化时存储引擎通过索引检索到数据，然后回表查询记录返回给 Server 层，<strong>服务器判断数据是否符合条件</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.png"></p>
</li>
<li><p>使用索引下推优化时，如果<strong>存在某些被索引的列的判断条件</strong>时，由存储引擎在索引遍历的过程中判断数据是否符合传递的条件，将符合条件的数据进行回表，检索出来返回给服务器，由此减少 IO 次数</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.png"></p>
</li>
</ul>
<p><strong>适用条件</strong>：</p>
<ul>
<li>需要存储引擎将索引中的数据与条件进行判断（所以<strong>条件列必须都在同一个索引中</strong>），所以优化是基于存储引擎的，只有特定引擎可以使用，适用于 InnoDB 和 MyISAM</li>
<li>存储引擎没有调用跨存储引擎的能力，跨存储引擎的功能有存储过程、触发器、视图，所以调用这些功能的不可以进行索引下推优化</li>
<li>对于 InnoDB 引擎只适用于二级索引，InnoDB 的聚簇索引会将整行数据读到缓冲区，不再需要去回表查询了</li>
</ul>
<p>工作过程：用户表 user，(name, age) 是联合索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user WHERE name LIKE &#x27;张%&#x27; AND　age = 10;	-- 头部模糊匹配会造成索引失效</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优化前：在非主键索引树上找到满足第一个条件的行，然后通过叶子节点记录的主键值再回到主键索引树上查找到对应的行数据，再对比 AND 后的条件是否符合，符合返回数据，需要 4 次回表</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E4%BC%98%E5%8C%961.png"></p>
</li>
<li><p>优化后：检查索引中存储的列信息是否符合索引条件，然后交由存储引擎用剩余的判断条件判断此行数据是否符合要求，<strong>不满足条件的不去读取表中的数据</strong>，满足下推条件的就根据主键值进行回表查询，2 次回表<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E4%BC%98%E5%8C%962.png"></p>
</li>
</ul>
<p>当使用 EXPLAIN 进行分析时，如果使用了索引条件下推，Extra 会显示 Using index condition</p>
<p>参考文章：<a href="https://blog.csdn.net/sinat_29774479/article/details/103470244">https://blog.csdn.net/sinat_29774479/article/details/103470244</a></p>
<p>参考文章：<a href="https://time.geekbang.org/column/article/69636">https://time.geekbang.org/column/article/69636</a></p>
<hr>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当要索引的列字符很多时，索引会变大变慢，可以只索引列开始的部分字符串，节约索引空间，提高索引效率</p>
<p>注意：使用前缀索引就系统就忽略覆盖索引对查询性能的优化了</p>
<p>优化原则：<strong>降低重复的索引值</strong></p>
<p>比如地区表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">area			gdp		code</span><br><span class="line">chinaShanghai	100		aaa</span><br><span class="line">chinaDalian		200		bbb</span><br><span class="line">usaNewYork		300		ccc</span><br><span class="line">chinaFuxin		400		ddd</span><br><span class="line">chinaBeijing	500		eee</span><br></pre></td></tr></table></figure>

<p>发现 area 字段很多都是以 china 开头的，那么如果以前 1-5 位字符做前缀索引就会出现大量索引值重复的情况，索引值重复性越低，查询效率也就越高，所以需要建立前 6 位字符的索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_area ON table_name(area(7));</span><br></pre></td></tr></table></figure>

<p>场景：存储身份证</p>
<ul>
<li>直接创建完整索引，这样可能比较占用空间</li>
<li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引</li>
<li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题（前 6 位相同的很多）</li>
<li>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描</li>
</ul>
<hr>
<h4 id="索引合并"><a href="#索引合并" class="headerlink" title="索引合并"></a>索引合并</h4><p>使用多个索引来完成一次查询的执行方法叫做索引合并 index merge</p>
<ul>
<li><p>Intersection 索引合并：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_test <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key3 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>; # key1 和 key3 列都是单列索引、二级索引</span><br></pre></td></tr></table></figure>

<p>从不同索引中扫描到的记录的 id 值取<strong>交集</strong>（相同 id），然后执行回表操作，要求从每个二级索引获取到的记录都是按照主键值排序</p>
</li>
<li><p>Union 索引合并：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_test <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>从不同索引中扫描到的记录的 id 值取<strong>并集</strong>，然后执行回表操作，要求从每个二级索引获取到的记录都是按照主键值排序</p>
</li>
<li><p>Sort-Union 索引合并</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_test <span class="keyword">WHERE</span> key1 <span class="operator">&lt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">&gt;</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>先将从不同索引中扫描到的记录的主键值进行排序，再按照 Union 索引合并的方式进行查询</p>
</li>
</ul>
<p>索引合并算法的效率并不好，通过将其中的一个索引改成联合索引会优化效率</p>
<hr>
<h2 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h2><h3 id="表优化"><a href="#表优化" class="headerlink" title="表优化"></a>表优化</h3><h4 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h4><h5 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>分区表是将大表的数据按分区字段分成许多小的子集，建立一个以 ftime 年份为分区的表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">    `ftime` datetime NOT NULL,</span><br><span class="line">    `c` int(11) DEFAULT NULL,</span><br><span class="line">    KEY (`ftime`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1</span><br><span class="line">PARTITION BY RANGE (YEAR(ftime))</span><br><span class="line">(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB);</span><br><span class="line">INSERT INTO t VALUES(&#x27;2017-4-1&#x27;,1),(&#x27;2018-4-1&#x27;,1);-- 这两行记录分别落在 p_2018 和 p_2019 这两个分区上</span><br></pre></td></tr></table></figure>

<p>这个表包含了一个.frm 文件和 4 个.ibd 文件，每个分区对应一个.ibd 文件</p>
<ul>
<li>对于引擎层来说，这是 4 个表，针对每个分区表的操作不会相互影响</li>
<li>对于 Server 层来说，这是 1 个表</li>
</ul>
<hr>
<h5 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h5><p>打开表行为：第一次访问一个分区表时，MySQL 需要<strong>把所有的分区都访问一遍</strong>，如果分区表的数量很多，超过了 open_files_limit 参数（默认值 1024），那么就会在访问这个表时打开所有的文件，导致打开表文件的个数超过了上限而报错</p>
<p>通用分区策略：MyISAM 分区表使用的分区策略，每次访问分区都由 Server 层控制，在文件管理、表管理的实现上很粗糙，因此有比较严重的性能问题</p>
<p>本地分区策略：从 MySQL 5.7.9 开始，InnoDB 引擎内部自己管理打开分区的行为，InnoDB 引擎打开文件超过 innodb_open_files 时就会<strong>关掉一些之前打开的文件</strong>，所以即使分区个数大于 open_files_limit，也不会报错</p>
<p>从 MySQL 8.0 版本开始，就不允许创建 MyISAM 分区表，只允许创建已经实现了本地分区策略的引擎，目前只有 InnoDB 和 NDB 这两个引擎支持了本地分区策略</p>
<hr>
<h5 id="Server-层"><a href="#Server-层" class="headerlink" title="Server 层"></a>Server 层</h5><p>从 Server 层看一个分区表就只是一个表</p>
<ul>
<li><p>Session A：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t WHERE ftime = &#x27;2018-4-1&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Session B：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE t TRUNCATE PARTITION p_2017; -- blocked</span><br></pre></td></tr></table></figure></li>
</ul>
<p>现象：Session B 只操作 p_2017 分区，但是由于 Session A 持有整个表 t 的 MDL 读锁，就导致 B 的 ALTER 语句获取 MDL 写锁阻塞</p>
<p>分区表的特点：</p>
<ul>
<li>第一次访问的时候需要访问所有分区</li>
<li>在 Server 层认为这是同一张表，因此<strong>所有分区共用同一个 MDL 锁</strong></li>
<li>在引擎层认为这是不同的表，因此 MDL 锁之后的执行过程，会根据分区表规则，只访问需要的分区</li>
</ul>
<hr>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>分区表的优点：</p>
<ul>
<li><p>对业务透明，相对于用户分表来说，使用分区表的业务代码更简洁</p>
</li>
<li><p>分区表可以很方便的清理历史数据。按照时间分区的分区表，就可以直接通过 <code>alter table t drop partition</code> 这个语法直接删除分区文件，从而删掉过期的历史数据，与使用 drop 语句删除数据相比，优势是速度快、对系统影响小</p>
</li>
</ul>
<p>使用分区表，不建议创建太多的分区，注意事项：</p>
<ul>
<li>分区并不是越细越好，单表或者单分区的数据一千万行，只要没有特别大的索引，对于现在的硬件能力来说都已经是小表</li>
<li>分区不要提前预留太多，在使用之前预先创建即可。比如是按月分区，每年年底时再把下一年度的 12 个新分区创建上即可，并且对于没有数据的历史分区，要及时的 drop 掉</li>
</ul>
<p>参考文档：<a href="https://time.geekbang.org/column/article/82560">https://time.geekbang.org/column/article/82560</a></p>
<hr>
<h4 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h4><h5 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>临时表分为内部临时表和用户临时表</p>
<ul>
<li><p>内部临时表：系统执行 SQL 语句优化时产生的表，例如 Join 连接查询、去重查询等</p>
</li>
<li><p>用户临时表：用户主动创建的临时表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TEMPORARY TABLE temp_t like table_1;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>临时表可以是内存表，也可以是磁盘表（多表操作 → 嵌套查询章节提及）</p>
<ul>
<li>内存表指的是使用 Memory 引擎的表，建立哈希索引，建表语法是 <code>create table … engine=memory</code>，这种表的数据都保存在内存里，系统重启时会被清空，但是表结构还在</li>
<li>磁盘表是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，建立 B+ 树索引，写数据的时候是写到磁盘上的</li>
</ul>
<p>临时表的特点：</p>
<ul>
<li>一个临时表只能被创建它的 session 访问，对其他线程不可见，所以不同 session 的临时表是<strong>可以重名</strong>的</li>
<li>临时表可以与普通表同名，会话内有同名的临时表和普通表时，执行 show create 语句以及增删改查语句访问的都是临时表</li>
<li>show tables 命令不显示临时表</li>
<li>数据库发生异常重启不需要担心数据删除问题，临时表会<strong>自动回收</strong></li>
</ul>
<hr>
<h5 id="重名原理"><a href="#重名原理" class="headerlink" title="重名原理"></a>重名原理</h5><p>执行创建临时表的 SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create temporary table temp_t(id int primary key)engine=innodb;</span><br></pre></td></tr></table></figure>

<p>MySQL 给 InnoDB 表创建一个 frm 文件保存表结构定义，在 ibd 保存表数据。frm 文件放在临时文件目录下，文件名的后缀是 .frm，<strong>前缀是</strong> <code>#sql&#123;进程 id&#125;_&#123;线程 id&#125;_ 序列号</code>，使用 <code>select @@tmpdir</code> 命令，来显示实例的临时文件目录</p>
<p>MySQL 维护数据表，除了物理磁盘上的文件外，内存里也有一套机制区别不同的表，每个表都对应一个 table_def_key</p>
<ul>
<li>一个普通表的 table_def_key 的值是由 <code>库名 + 表名</code> 得到的，所以如果在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现 table_def_key 已经存在了</li>
<li>对于临时表，table_def_key 在 <code>库名 + 表名</code> 基础上，又加入了 <code>server_id + thread_id</code>，所以不同线程之间，临时表可以重名</li>
</ul>
<p>实现原理：每个线程都维护了自己的临时表链表，每次 session 内操作表时，先遍历链表，检查是否有这个名字的临时表，如果有就<strong>优先操作临时表</strong>，如果没有再操作普通表；在 session 结束时对链表里的每个临时表，执行 <code>DROP TEMPORARY TABLE + 表名</code> 操作</p>
<p>执行 rename table 语句无法修改临时表，因为会按照 <code>库名 / 表名.frm</code> 的规则去磁盘找文件，但是临时表文件名的规则是 <code>#sql&#123;进程 id&#125;_&#123;线程 id&#125;_ 序列号.frm</code>，因此会报找不到文件名的错误</p>
<hr>
<h5 id="主备复制"><a href="#主备复制" class="headerlink" title="主备复制"></a>主备复制</h5><p>创建临时表的语句会传到备库执行，因此备库的同步线程就会创建这个临时表。主库在线程退出时会自动删除临时表，但备库同步线程是持续在运行的并不会退出，所以这时就需要在主库上再写一个 DROP TEMPORARY TABLE 传给备库执行</p>
<p>binlog 日志写入规则：</p>
<ul>
<li>binlog_format&#x3D;row，跟临时表有关的语句就不会记录到 binlog</li>
<li>binlog_format&#x3D;statment&#x2F;mixed，binlog 中才会记录临时表的操作，也就会记录 <code>DROP TEMPORARY TABLE</code> 这条命令</li>
</ul>
<p>主库上不同的线程创建同名的临时表是不冲突的，但是备库只有一个执行线程，所以 MySQL 在记录 binlog 时会把主库执行这个语句的线程 id 写到 binlog 中，在备库的应用线程就可以获取执行每个语句的主库线程 id，并利用这个线程 id 来构造临时表的 table_def_key</p>
<ul>
<li>session A 的临时表 t1，在备库的 table_def_key 就是：<code>库名 + t1 +“M 的 serverid&quot; + &quot;session A 的 thread_id”</code></li>
<li>session B 的临时表 t1，在备库的 table_def_key 就是 ：<code>库名 + t1 +&quot;M 的 serverid&quot; + &quot;session B 的 thread_id&quot;</code></li>
</ul>
<p>MySQL 在记录 binlog 的时不论是 create table 还是 alter table 语句都是原样记录，但是如果执行 drop table，系统记录 binlog 就会被服务端改写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE `t_normal` /* generated by server */</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="跨库查询"><a href="#跨库查询" class="headerlink" title="跨库查询"></a>跨库查询</h5><p>分库分表系统的跨库查询使用临时表不用担心线程之间的重名冲突，分库分表就是要把一个逻辑上的大表分散到不同的数据库实例上</p>
<p>比如将一个大表 ht，按照字段 f，拆分成 1024 个分表，分布到 32 个数据库实例上，一般情况下都有一个中间层 proxy 解析 SQL 语句，通过分库规则通过分表规则（比如 N%1024）确定将这条语句路由到哪个分表做查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select v from ht where f=N;</span><br></pre></td></tr></table></figure>

<p>如果这个表上还有另外一个索引 k，并且查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select v from ht where k &gt;= M order by t_modified desc limit 100;</span><br></pre></td></tr></table></figure>

<p>查询条件里面没有用到分区字段 f，只能<strong>到所有的分区</strong>中去查找满足条件的所有行，然后统一做 order by 操作，两种方式：</p>
<ul>
<li>在 proxy 层的进程代码中实现排序，拿到分库的数据以后，直接在内存中参与计算，但是对 proxy 端的压力比较大，很容易出现内存不够用和 CPU 瓶颈问题</li>
<li>把各个分库拿到的数据，汇总到一个 MySQL 实例的一个表中，然后在这个汇总实例上做逻辑操作，执行流程：<ul>
<li>在汇总库上创建一个临时表 temp_ht，表里包含三个字段 v、k、t_modified</li>
<li>在各个分库执行：<code>select v,k,t_modified from ht_x where k &gt;= M order by t_modified desc limit 100</code></li>
<li>把分库执行的结果插入到 temp_ht 表中</li>
<li>在临时表上执行：<code>select v from temp_ht order by t_modified desc limit 100</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h3><h4 id="执行频率"><a href="#执行频率" class="headerlink" title="执行频率"></a>执行频率</h4><p>MySQL 客户端连接成功后，查询服务器状态信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW [SESSION|GLOBAL] STATUS LIKE &#x27;&#x27;;</span><br><span class="line">-- SESSION: 显示当前会话连接的统计结果，默认参数</span><br><span class="line">-- GLOBAL: 显示自数据库上次启动至今的统计结果</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查看 SQL 执行频率：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Com_____&#x27;;</span><br></pre></td></tr></table></figure>

<p>Com_xxx 表示每种语句执行的次数</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A2%91%E7%8E%87.png"></p>
</li>
<li><p>查询 SQL 语句影响的行数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Innodb_rows_%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SQL%E8%AF%AD%E5%8F%A5%E5%BD%B1%E5%93%8D%E7%9A%84%E8%A1%8C%E6%95%B0.png"></p>
</li>
</ul>
<p>Com_xxxx：这些参数对于所有存储引擎的表操作都会进行累计</p>
<p>Innodb_xxxx：这几个参数只是针对 InnoDB 存储引擎的，累加的算法也略有不同</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Com_select</td>
<td>执行 SELECT 操作的次数，一次查询只累加 1</td>
</tr>
<tr>
<td align="left">Com_insert</td>
<td>执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次</td>
</tr>
<tr>
<td align="left">Com_update</td>
<td>执行 UPDATE 操作的次数</td>
</tr>
<tr>
<td align="left">Com_delete</td>
<td>执行 DELETE 操作的次数</td>
</tr>
<tr>
<td align="left">Innodb_rows_read</td>
<td>执行 SELECT 查询返回的行数</td>
</tr>
<tr>
<td align="left">Innodb_rows_inserted</td>
<td>执行 INSERT 操作插入的行数</td>
</tr>
<tr>
<td align="left">Innodb_rows_updated</td>
<td>执行 UPDATE 操作更新的行数</td>
</tr>
<tr>
<td align="left">Innodb_rows_deleted</td>
<td>执行 DELETE 操作删除的行数</td>
</tr>
<tr>
<td align="left">Connections</td>
<td>试图连接 MySQL 服务器的次数</td>
</tr>
<tr>
<td align="left">Uptime</td>
<td>服务器工作时间</td>
</tr>
<tr>
<td align="left">Slow_queries</td>
<td>慢查询的次数</td>
</tr>
</tbody></table>
<hr>
<h4 id="定位低效"><a href="#定位低效" class="headerlink" title="定位低效"></a>定位低效</h4><p>SQL 执行慢有两种情况：</p>
<ul>
<li>偶尔慢：DB 在刷新脏页（学完事务就懂了）<ul>
<li>redo log 写满了</li>
<li>内存不够用，要从 LRU 链表中淘汰</li>
<li>MySQL 认为系统空闲的时候</li>
<li>MySQL 关闭时</li>
</ul>
</li>
<li>一直慢的原因：索引没有设计好、SQL 语句没写好、MySQL 选错了索引</li>
</ul>
<p>通过以下两种方式定位执行效率较低的 SQL 语句</p>
<ul>
<li><p>慢日志查询： 慢查询日志在查询结束以后才记录，执行效率出现问题时查询日志并不能定位问题</p>
<p>配置文件修改：修改 .cnf 文件 <code>vim /etc/mysql/my.cnf</code>，重启 MySQL 服务器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slow_query_log=ON</span><br><span class="line">slow_query_log_file=/usr/local/mysql/var/localhost-slow.log</span><br><span class="line">long_query_time=1	<span class="comment">#记录超过long_query_time秒的SQL语句的日志</span></span><br><span class="line">log-queries-not-using-indexes = 1</span><br></pre></td></tr></table></figure>

<p>使用命令配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET slow_query_log=ON;</span><br><span class="line">mysql&gt; SET GLOBAL slow_query_log=ON;</span><br></pre></td></tr></table></figure>

<p>查看是否配置成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%query%&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SHOW PROCESSLIST：<strong>实时查看</strong>当前 MySQL 在进行的连接线程，包括线程的状态、是否锁表、SQL 的执行情况，同时对一些锁表操作进行优化</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SHOW_PROCESSLIST%E5%91%BD%E4%BB%A4.png"></p>
</li>
</ul>
<hr>
<h4 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h4><h5 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h5><p>通过 EXPLAIN 命令获取执行 SQL 语句的信息，包括在 SELECT 语句执行过程中如何连接和连接的顺序，执行计划在优化器优化完成后、执行器之前生成，然后执行器会调用存储引擎检索数据</p>
<p>查询 SQL 语句的执行计划：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM table_1 WHERE id = 1;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-explain%E6%9F%A5%E8%AF%A2SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>SELECT 的序列号</td>
</tr>
<tr>
<td>select_type</td>
<td>表示 SELECT 的类型</td>
</tr>
<tr>
<td>table</td>
<td>访问数据库中表名称，有时可能是简称或者临时表名称（<table_name>）</table_name></td>
</tr>
<tr>
<td>type</td>
<td>表示表的连接类型</td>
</tr>
<tr>
<td>possible_keys</td>
<td>表示查询时，可能使用的索引</td>
</tr>
<tr>
<td>key</td>
<td>表示实际使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>索引字段的长度</td>
</tr>
<tr>
<td>ref</td>
<td>表示与索引列进行等值匹配的对象，常数、某个列、函数等，type 必须在（range, const] 之间，左闭右开</td>
</tr>
<tr>
<td>rows</td>
<td>扫描出的行数，表示 MySQL 根据表统计信息及索引选用情况，<strong>估算</strong>的找到所需的记录扫描的行数</td>
</tr>
<tr>
<td>filtered</td>
<td>条件过滤的行百分比，单表查询没意义，用于连接查询中对驱动表的扇出进行过滤，查询优化器预测所有扇出值满足剩余查询条件的百分比，相乘以后表示多表查询中还要对被驱动执行查询的次数</td>
</tr>
<tr>
<td>extra</td>
<td>执行情况的说明和描述</td>
</tr>
</tbody></table>
<p>MySQL <strong>执行计划的局限</strong>：</p>
<ul>
<li>只是计划，不是执行 SQL 语句，可以随着底层优化器输入的更改而更改</li>
<li>EXPLAIN 不会告诉显示关于触发器、存储过程的信息对查询的影响情况， 不考虑各种 Cache</li>
<li>EXPLAIN 不能显示 MySQL 在执行查询时的动态，因为执行计划在执行<strong>查询之前生成</strong></li>
<li>EXPALIN 只能解释 SELECT 操作，其他操作要重写为 SELECT 后查看执行计划</li>
<li>EXPLAIN PLAN 显示的是在解释语句时数据库将如何运行 SQL 语句，由于执行环境和 EXPLAIN PLAN 环境的不同，此计划可能与 SQL 语句<strong>实际的执行计划不同</strong>，部分统计信息是估算的，并非精确值</li>
</ul>
<p>SHOW WARINGS：在使用 EXPALIN 命令后执行该语句，可以查询与执行计划相关的拓展信息，展示出 Level、Code、Message 三个字段，当 Code 为 1003 时，Message 字段展示的信息类似于将查询语句重写后的信息，但是不是等价，不能执行复制过来运行</p>
<p>环境准备：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87.png"></p>
<hr>
<h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>id 代表 SQL 执行的顺序的标识，每个 SELECT 关键字对应一个唯一 id，所以在同一个 SELECT 关键字中的表的 id 都是相同的。SELECT 后的 FROM 可以跟随多个表，每个表都会对应一条记录，这些记录的 id 都是相同的，</p>
<ul>
<li><p>id 相同时，执行顺序由上至下。连接查询的执行计划，记录的 id 值都是相同的，出现在前面的表为驱动表，后面为被驱动表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t_role r, t_user u, user_role ur WHERE r.id = ur.role_id AND u.id = ur.user_id ;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-explain%E4%B9%8Bid%E7%9B%B8%E5%90%8C.png"></p>
</li>
<li><p>id 不同时，id 值越大优先级越高，越先被执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t_role WHERE id = (SELECT role_id FROM user_role WHERE user_id = (SELECT id FROM t_user WHERE username = &#x27;stu1&#x27;))</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-explain%E4%B9%8Bid%E4%B8%8D%E5%90%8C.png"></p>
</li>
<li><p>id 有相同也有不同时，id 相同的可以认为是一组，从上往下顺序执行；在所有的组中，id 的值越大的组，优先级越高，越先执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t_role r , (SELECT * FROM user_role ur WHERE ur.`user_id` = &#x27;2&#x27;) a WHERE r.id = a.role_id ; </span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-explain%E4%B9%8Bid%E7%9B%B8%E5%90%8C%E5%92%8C%E4%B8%8D%E5%90%8C.png"></p>
</li>
<li><p>id 为 NULL 时代表的是临时表</p>
</li>
</ul>
<hr>
<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>表示查询中每个 select 子句的类型（简单 OR 复杂）</p>
<table>
<thead>
<tr>
<th>select_type</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>简单的 SELECT 查询，查询中不包含子查询或者 UNION</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>查询中若包含任何复杂的子查询，最外层（也就是最左侧）查询标记为该标识</td>
</tr>
<tr>
<td>UNION</td>
<td>对于 UNION 或者 UNION ALL 的复杂查询，除了最左侧的查询，其余的小查询都是 UNION</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>UNION 需要使用临时表进行去重，临时表的是 UNION RESULT</td>
</tr>
<tr>
<td>DEPENDENT UNION</td>
<td>对于 UNION 或者 UNION ALL 的复杂查询，如果各个小查询都依赖外层查询，是相关子查询，除了最左侧的小查询为 DEPENDENT SUBQUERY，其余都是 DEPENDENT UNION</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>子查询不是相关子查询，该子查询第一个 SELECT 代表的查询就是这种类型，会进行物化（该子查询只需要执行一次）</td>
</tr>
<tr>
<td>DEPENDENT SUBQUERY</td>
<td>子查询是相关子查询，该子查询第一个 SELECT 代表的查询就是这种类型，不会物化（该子查询需要执行多次）</td>
</tr>
<tr>
<td>DERIVED</td>
<td>在 FROM 列表中包含的子查询，被标记为 DERIVED（衍生），也就是生成物化派生表的这个子查询</td>
</tr>
<tr>
<td>MATERIALIZED</td>
<td>将子查询物化后与与外层进行连接查询，生成物化表的子查询</td>
</tr>
</tbody></table>
<p>子查询为 DERIVED：<code>SELECT * FROM (SELECT key1 FROM t1) AS derived_1 WHERE key1 &gt; 10</code></p>
<p>子查询为 MATERIALIZED：<code>SELECT * FROM t1 WHERE key1 IN (SELECT key1 FROM t2)</code></p>
<hr>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>对表的访问方式，表示 MySQL 在表中找到所需行的方式，又称访问类型</p>
<table>
<thead>
<tr>
<th>type</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ALL</td>
<td>全表扫描，如果是 InnoDB 引擎是扫描聚簇索引</td>
</tr>
<tr>
<td>index</td>
<td>可以使用覆盖索引，但需要扫描全部索引</td>
</tr>
<tr>
<td>range</td>
<td>索引范围扫描，常见于 between、&lt;、&gt; 等的查询</td>
</tr>
<tr>
<td>index_subquery</td>
<td>子查询可以普通索引，则子查询的 type 为 index_subquery</td>
</tr>
<tr>
<td>unique_subquery</td>
<td>子查询可以使用主键或唯一二级索引，则子查询的 type 为 index_subquery</td>
</tr>
<tr>
<td>index_merge</td>
<td>索引合并</td>
</tr>
<tr>
<td>ref_or_null</td>
<td>非唯一性索引（普通二级索引）并且可以存储 NULL，进行等值匹配</td>
</tr>
<tr>
<td>ref</td>
<td>非唯一性索引与常量等值匹配</td>
</tr>
<tr>
<td>eq_ref</td>
<td>唯一性索引（主键或不存储 NULL 的唯一二级索引）进行等值匹配，如果二级索引是联合索引，那么所有联合的列都要进行等值匹配</td>
</tr>
<tr>
<td>const</td>
<td>通过主键或者唯一二级索引与常量进行等值匹配</td>
</tr>
<tr>
<td>system</td>
<td>system 是 const 类型的特例，当查询的表只有一条记录的情况下，使用 system</td>
</tr>
<tr>
<td>NULL</td>
<td>MySQL 在优化过程中分解语句，执行时甚至不用访问表或索引</td>
</tr>
</tbody></table>
<p>从上到下，性能从差到好，一般来说需要保证查询至少达到 range 级别， 最好达到 ref </p>
<hr>
<h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p>possible_keys：</p>
<ul>
<li>指出 MySQL 能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</li>
<li>如果该列是 NULL，则没有相关的索引</li>
</ul>
<p>key：</p>
<ul>
<li>显示 MySQL 在查询中实际使用的索引，若没有使用索引，显示为 NULL</li>
<li>查询中若使用了<strong>覆盖索引</strong>，则该索引可能出现在 key 列表，不出现在 possible_keys</li>
</ul>
<p>key_len：</p>
<ul>
<li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</li>
<li>key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，即 key_len 是根据表定义计算而得，不是通过表内检索出的</li>
<li>在不损失精确性的前提下，长度越短越好</li>
</ul>
<hr>
<h5 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h5><p>其他的额外的执行计划信息，在该列展示：</p>
<ul>
<li>No tables used：查询语句中使用 FROM dual 或者没有 FROM 语句</li>
<li>Impossible WHERE：查询语句中的 WHERE 子句条件永远为 FALSE，会导致没有符合条件的行</li>
<li>Using index：该值表示相应的 SELECT 操作中使用了<strong>覆盖索引</strong>（Covering Index）</li>
<li>Using index condition：第一种情况是搜索条件中虽然出现了索引列，但是部分条件无法形成扫描区间（<strong>索引失效</strong>），会根据可用索引的条件先搜索一遍再匹配无法使用索引的条件，回表查询数据；第二种是使用了<strong>索引条件下推</strong>优化</li>
<li>Using where：搜索的数据需要在 Server 层判断，无法使用索引下推</li>
<li>Using join buffer：连接查询被驱动表无法利用索引，需要连接缓冲区来存储中间结果</li>
<li>Using filesort：无法利用索引完成排序（优化方向），需要对数据使用外部排序算法，将取得的数据在内存或磁盘中进行排序</li>
<li>Using temporary：表示 MySQL 需要使用临时表来存储结果集，常见于<strong>排序、去重（UNION）、分组</strong>等场景</li>
<li>Select tables optimized away：说明仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</li>
<li>No tables used：Query 语句中使用 from dual 或不含任何 from 子句</li>
</ul>
<p>参考文章：<a href="https://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765237.html">https://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765237.html</a></p>
<hr>
<h4 id="PROFILES"><a href="#PROFILES" class="headerlink" title="PROFILES"></a>PROFILES</h4><p>SHOW PROFILES 能够在做 SQL 优化时分析当前会话中语句执行的<strong>资源消耗</strong>情况</p>
<ul>
<li><p>通过 have_profiling 参数，能够看到当前 MySQL 是否支持 profile：<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-have_profiling.png"></p>
</li>
<li><p>默认 profiling 是关闭的，可以通过 set 语句在 Session 级别开启 profiling：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-profiling.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET profiling=1; #开启profiling 开关；</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 SHOW PROFILES 指令， 来查看 SQL 语句执行的耗时:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW PROFILES;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%9F%A5%E7%9C%8BSQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%80%97%E6%97%B6.png"></p>
</li>
<li><p>查看到该 SQL 执行过程中每个线程的状态和消耗的时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW PROFILE FOR QUERY query_id;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SQL%E6%89%A7%E8%A1%8C%E6%AF%8F%E4%B8%AA%E7%8A%B6%E6%80%81%E6%B6%88%E8%80%97%E7%9A%84%E6%97%B6%E9%97%B4.png"></p>
</li>
<li><p>在获取到最消耗时间的线程状态后，MySQL 支持选择 all、cpu、block io 、context switch、page faults 等类型查看 MySQL 在使用什么资源上耗费了过高的时间。例如，选择查看 CPU 的耗费时间：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SQL%E6%89%A7%E8%A1%8C%E6%AF%8F%E4%B8%AA%E7%8A%B6%E6%80%81%E6%B6%88%E8%80%97%E7%9A%84CPU.png"></p>
<ul>
<li>Status：SQL 语句执行的状态</li>
<li>Durationsql：执行过程中每一个步骤的耗时</li>
<li>CPU_user：当前用户占有的 CPU</li>
<li>CPU_system：系统占有的 CPU</li>
</ul>
</li>
</ul>
<hr>
<h4 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h4><p>MySQL 提供了对 SQL 的跟踪， 通过 trace 文件可以查看优化器<strong>生成执行计划的过程</strong></p>
<ul>
<li><p>打开 trace 功能，设置格式为 JSON，并设置 trace 的最大使用内存，避免解析过程中因默认内存过小而不能够完整展示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=ON;	-- 会话内有效</span><br><span class="line">SET optimizer_trace_max_mem_size=1000000;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 SQL 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tb_item WHERE id &lt; 4;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查 information_schema.optimizer_trace：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.optimizer_trace \G; -- \G代表竖列展示</span><br></pre></td></tr></table></figure>

<p>执行信息主要有三个阶段：prepare 阶段、optimize 阶段（成本分析）、execute 阶段（执行）</p>
</li>
</ul>
<hr>
<h3 id="索引优化-1"><a href="#索引优化-1" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>索引是数据库优化最重要的手段之一，通过索引通常可以帮助用户解决大多数的 MySQL 的性能优化问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tb_seller` (</span><br><span class="line">	`sellerid` varchar (100),</span><br><span class="line">	`name` varchar (100),</span><br><span class="line">	`nickname` varchar (50),</span><br><span class="line">	`password` varchar (60),</span><br><span class="line">	`status` varchar (1),</span><br><span class="line">	`address` varchar (100),</span><br><span class="line">	`createtime` datetime,</span><br><span class="line">    PRIMARY KEY(`sellerid`)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8mb4;</span><br><span class="line">INSERT INTO `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values(&#x27;xiaomi&#x27;,&#x27;小米科技&#x27;,&#x27;小米官方旗舰店&#x27;,&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;,&#x27;1&#x27;,&#x27;西安市&#x27;,&#x27;2088-01-01 12:00:00&#x27;);</span><br><span class="line">CREATE INDEX idx_seller_name_sta_addr ON tb_seller(name, status, address); # 联合索引</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87.png"></p>
<hr>
<h4 id="避免失效"><a href="#避免失效" class="headerlink" title="避免失效"></a>避免失效</h4><h5 id="语句错误"><a href="#语句错误" class="headerlink" title="语句错误"></a>语句错误</h5><ul>
<li><p>全值匹配：对索引中所有列都指定具体值，这种情况索引生效，执行效率高</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status=&#x27;1&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%951.png"></p>
</li>
<li><p><strong>最左前缀法则</strong>：联合索引遵守最左前缀法则</p>
<p>匹配最左前缀法则，走索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27;;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status=&#x27;1&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%952.png"></p>
<p>违法最左前缀法则 ， 索引失效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE status=&#x27;1&#x27;;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE status=&#x27;1&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%953.png"></p>
<p>如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%954.png"></p>
<p>虽然索引列失效，但是系统会<strong>使用了索引下推进行了优化</strong></p>
</li>
<li><p><strong>范围查询</strong>右边的列，不能使用索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status&gt;&#x27;1&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure>

<p>根据前面的两个字段 name ， status 查询是走索引的， 但是最后一个条件 address 没有用到索引，使用了索引下推</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%955.png"></p>
</li>
<li><p>在索引列上<strong>函数或者运算（+ - 数值）操作</strong>， 索引将失效：会破坏索引值的有序性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE SUBSTRING(name,3,2) = &#x27;科技&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%956.png"></p>
</li>
<li><p><strong>字符串不加单引号</strong>，造成索引失效：隐式类型转换，当字符串和数字比较时会<strong>把字符串转化为数字</strong></p>
<p>在查询时，没有对字符串加单引号，查询优化器会调用 CAST 函数将 status 转换为 int 进行比较，造成索引失效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status = 1;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%957.png"></p>
<p>如果 status 是 int 类型，SQL 为 <code>SELECT * FROM tb_seller WHERE status = &#39;1&#39; </code> 并不会造成索引失效，因为会将 <code>&#39;1&#39;</code> 转换为 <code>1</code>，并<strong>不会对索引列产生操作</strong></p>
</li>
<li><p>多表连接查询时，如果两张表的<strong>字符集不同</strong>，会造成索引失效，因为会进行类型转换</p>
<p>解决方法：CONVERT 函数是加在输入参数上、修改表的字符集</p>
</li>
<li><p><strong>用 OR 分割条件，索引失效</strong>，导致全表查询：</p>
<p>OR 前的条件中的列有索引而后面的列中没有索引或 OR 前后两个列是同一个复合索引，都造成索引失效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;阿里巴巴&#x27; OR createtime = &#x27;2088-01-01 12:00:00&#x27;;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; OR status=&#x27;1&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9510.png"></p>
<p><strong>AND 分割的条件不影响</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;阿里巴巴&#x27; AND createtime = &#x27;2088-01-01 12:00:00&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9511.png"></p>
</li>
<li><p><strong>以 % 开头的 LIKE 模糊查询</strong>，索引失效：</p>
<p>如果是尾部模糊匹配，索引不会失效；如果是头部模糊匹配，索引失效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name like &#x27;%科技%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9512.png"></p>
<p>解决方案：通过覆盖索引来解决 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT sellerid,name,status FROM tb_seller WHERE name like &#x27;%科技%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9513.png"></p>
<p>原因：在覆盖索引的这棵 B+ 数上只需要进行 like 的匹配，或者是基于覆盖索引查询再进行 WHERE 的判断就可以获得结果</p>
</li>
</ul>
<hr>
<h5 id="系统优化-1"><a href="#系统优化-1" class="headerlink" title="系统优化"></a>系统优化</h5><p>系统优化为全表扫描：</p>
<ul>
<li><p>如果 MySQL 评估使用索引比全表更慢，则不使用索引，索引失效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_address ON tb_seller(address);</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE address=&#x27;西安市&#x27;;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE address=&#x27;北京市&#x27;;</span><br></pre></td></tr></table></figure>

<p>北京市的键值占 9&#x2F;10（区分度低），所以优化为全表扫描，type &#x3D; ALL</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9514.png"></p>
</li>
<li><p>IS  NULL、IS NOT NULL  <strong>有时</strong>索引失效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name IS NULL;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name IS NOT NULL;</span><br></pre></td></tr></table></figure>

<p>NOT NULL 失效的原因是 name 列全部不是 null，优化为全表扫描，当 NULL 过多时，IS NULL 失效</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9515.png"></p>
</li>
<li><p>IN 肯定会走索引，但是当 IN 的取值范围较大时会导致索引失效，走全表扫描：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE sellerId IN (&#x27;alibaba&#x27;,&#x27;huawei&#x27;);-- 都走索引</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE sellerId NOT IN (&#x27;alibaba&#x27;,&#x27;huawei&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://time.geekbang.org/column/article/74687">MySQL 实战 45 讲</a>该章节最后提出了一种场景，获取到数据以后 Server 层还会做判断</p>
</li>
</ul>
<hr>
<h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><p>索引失效一般是针对联合索引，联合索引一般由几个字段组成，排序方式是先按照第一个字段进行排序，然后排序第二个，依此类推，图示（a, b）索引，<strong>a 相等的情况下 b 是有序的</strong></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-索引失效底层原理1.png" style="zoom:67%;">

<ul>
<li><p>最左前缀法则：当不匹配前面的字段的时候，后面的字段都是无序的。这种无序不仅体现在叶子节点，也会<strong>导致查询时扫描的非叶子节点也是无序的</strong>，因为索引树相当于忽略的第一个字段，就无法使用二分查找</p>
</li>
<li><p>范围查询右边的列，不能使用索引，比如语句： <code>WHERE a &gt; 1 AND b = 1 </code>，在 a 大于 1 的时候，b 是无序的，a &gt; 1 是扫描时有序的，但是找到以后进行寻找 b 时，索引树就不是有序的了</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-索引失效底层原理2.png" style="zoom:67%;">
</li>
<li><p>以 % 开头的 LIKE 模糊查询，索引失效，比如语句：<code>WHERE a LIKE &#39;%d&#39;</code>，前面的不确定，导致不符合最左匹配，直接去索引中搜索以 d 结尾的节点，所以没有顺序<br>                            <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%863.png"></p>
</li>
</ul>
<p>参考文章：<a href="https://mp.weixin.qq.com/s/B_M09dzLe9w7cT46rdGIeQ">https://mp.weixin.qq.com/s/B_M09dzLe9w7cT46rdGIeQ</a></p>
<hr>
<h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Handler_read%&#x27;;	</span><br><span class="line">SHOW GLOBAL STATUS LIKE &#x27;Handler_read%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5.png"></p>
<ul>
<li><p>Handler_read_first：索引中第一条被读的次数，如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）</p>
</li>
<li><p>Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，值越低表示索引不经常使用（这个值越高越好）</p>
</li>
<li><p>Handler_read_next：按照键顺序读下一行的请求数，如果范围约束或执行索引扫描来查询索引列，值增加</p>
</li>
<li><p>Handler_read_prev：按照键顺序读前一行的请求数，该读方法主要用于优化 ORDER BY … DESC</p>
</li>
<li><p>Handler_read_rnd：根据固定位置读一行的请求数，如果执行大量查询并对结果进行排序则该值较高，可能是使用了大量需要 MySQL 扫描整个表的查询或连接，这个值较高意味着运行效率低，应该建立索引来解决</p>
</li>
<li><p>Handler_read_rnd_next：在数据文件中读下一行的请求数，如果正进行大量的表扫描，该值较高，说明表索引不正确或写入的查询没有利用索引</p>
</li>
</ul>
<hr>
<h3 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h3><h4 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h4><h5 id="自增机制"><a href="#自增机制" class="headerlink" title="自增机制"></a>自增机制</h5><p>自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，因此索引更紧凑</p>
<p>表的结构定义存放在后缀名为.frm 的文件中，但是并不会保存自增值，不同的引擎对于自增值的保存策略不同：</p>
<ul>
<li>MyISAM 引擎的自增值保存在数据文件中</li>
<li>InnoDB 引擎的自增值保存在了内存里，每次打开表都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为当前的自增值；8.0 版本后，才有了自增值持久化的能力，将自增值的变更记录在了 redo log 中，重启的时候依靠 redo log 恢复重启之前的值</li>
</ul>
<p>在插入一行数据的时候，自增值的行为如下：</p>
<ul>
<li>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段</li>
<li>如果插入数据时 id 字段指定了具体的值，比如某次要插入的值是 X，当前的自增值是 Y<ul>
<li>如果 X&lt;Y，那么这个表的自增值不变</li>
<li>如果 X≥Y，就需要把当前自增值修改为新的自增值</li>
</ul>
</li>
</ul>
<p>参数说明：auto_increment_offset 和 auto_increment_increment 分别表示自增的初始值和步长，默认值都是 1</p>
<p>语句执行失败也不回退自增 id，所以保证了自增 id 是递增的，但不保证是连续的（不能回退，所以有些回滚事务的自增 id 就不会重新使用，导致出现不连续）</p>
<hr>
<h5 id="自增-ID"><a href="#自增-ID" class="headerlink" title="自增 ID"></a>自增 ID</h5><p>MySQL 不同的自增 id 在达到上限后的表现不同：</p>
<ul>
<li><p>表的自增 id 如果是 int 类型，达到上限 2^32-1 后，再申请时值就不会改变，进而导致继续插入数据时报主键冲突的错误</p>
</li>
<li><p>row_id 长度为 6 个字节，达到上限后则会归 0 再重新递增，如果出现相同的 row_id，后写的数据会覆盖之前的数据，造成旧数据丢失，影响的是数据可靠性，所以应该在 InnoDB 表中主动创建自增主键报主键冲突，插入失败影响的是可用性，而一般情况下，<strong>可靠性优先于可用性</strong></p>
</li>
<li><p>Xid 长度 8 字节，由 Server 层维护，只需要不在同一个 binlog 文件中出现重复值即可，虽然理论上会出现重复值，但是概率极小</p>
</li>
<li><p>InnoDB 的 max_trx_id 递增值每次 MySQL 重启都会被保存起来，重启也不会重置为 0，所以会导致一直增加到达上限，然后从 0 开始，这时原事务 0 修改的数据对当前事务就是可见的，产生脏读的现象</p>
<p>只读事务不分配 trx_id，所以 trx_id 的增加速度变慢了</p>
</li>
<li><p>thread_id 长度 4 个字节，到达上限后就会重置为 0，MySQL 设计了一个唯一数组的逻辑，给新线程分配 thread_id 时做判断，保证不会出现两个相同的 thread_id：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	new_id = thread_id_counter++;</span><br><span class="line">&#125; <span class="keyword">while</span> (!thread_ids.<span class="built_in">insert_unique</span>(new_id).second);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>参考文章：<a href="https://time.geekbang.org/column/article/83183">https://time.geekbang.org/column/article/83183</a></p>
<hr>
<h4 id="覆盖索引-1"><a href="#覆盖索引-1" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>复合索引叶子节点不仅保存了复合索引的值，还有主键索引，所以使用覆盖索引的时候，加上主键也会用到索引</p>
<p>尽量使用覆盖索引，避免 SELECT *：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT name,status,address FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status=&#x27;1&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%958.png"></p>
<p>如果查询列，超出索引列，也会降低性能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT name,status,address,password FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status=&#x27;1&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%959.png"></p>
<hr>
<h4 id="减少访问"><a href="#减少访问" class="headerlink" title="减少访问"></a>减少访问</h4><p>避免对数据进行重复检索：能够一次连接就获取到结果的，就不用两次连接，这样可以大大减少对数据库无用的重复请求</p>
<ul>
<li><p>查询数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id,name FROM tb_book;</span><br><span class="line">SELECT id,status FROM tb_book; -- 向数据库提交两次请求，数据库就要做两次查询操作</span><br><span class="line">-- &gt; 优化为:</span><br><span class="line">SELECT id,name,statu FROM tb_book;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb_test VALUES(1,&#x27;Tom&#x27;);</span><br><span class="line">INSERT INTO tb_test VALUES(2,&#x27;Cat&#x27;);</span><br><span class="line">INSERT INTO tb_test VALUES(3,&#x27;Jerry&#x27;);	-- 连接三次数据库</span><br><span class="line">-- &gt;优化为</span><br><span class="line">INSERT INTO tb_test VALUES(1,&#x27;Tom&#x27;),(2,&#x27;Cat&#x27;)，(3,&#x27;Jerry&#x27;);	-- 连接一次</span><br></pre></td></tr></table></figure>
</li>
<li><p>在事务中进行数据插入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">INSERT INTO tb_test VALUES(1,&#x27;Tom&#x27;);</span><br><span class="line">INSERT INTO tb_test VALUES(2,&#x27;Cat&#x27;);</span><br><span class="line">INSERT INTO tb_test VALUES(3,&#x27;Jerry&#x27;);</span><br><span class="line">commit;	-- 手动提交，分段提交</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据有序插入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb_test VALUES(1,&#x27;Tom&#x27;);</span><br><span class="line">INSERT INTO tb_test VALUES(2,&#x27;Cat&#x27;);</span><br><span class="line">INSERT INTO tb_test VALUES(3,&#x27;Jerry&#x27;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>增加 cache 层：在应用中增加缓存层来达到减轻数据库负担的目的。可以部分数据从数据库中抽取出来放到应用端以文本方式存储，或者使用框架（Mybatis）提供的一级缓存 &#x2F; 二级缓存，或者使用 Redis 数据库来缓存数据 </p>
<hr>
<h4 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h4><p>当使用 load 命令导入数据的时候，适当的设置可以提高导入的效率：</p>
<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> load data.png)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD DATA LOCAL INFILE = &#x27;/home/seazean/sql1.log&#x27; INTO TABLE `tb_user_1` FIELD TERMINATED BY &#x27;,&#x27; LINES TERMINATED BY &#x27;\n&#x27;; -- 文件格式如上图</span><br></pre></td></tr></table></figure>

<p>对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率：</p>
<ol>
<li><p><strong>主键顺序插入</strong>：因为 InnoDB 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率，如果 InnoDB 表没有主键，那么系统会自动默认创建一个内部列作为主键</p>
<p>主键是否连续对性能影响不大，只要是递增的就可以，比如雪花算法产生的 ID 不是连续的，但是是递增的，因为递增可以让主键索引尽量地保持顺序插入，<strong>避免了页分裂</strong>，因此索引更紧凑</p>
<ul>
<li>插入 ID 顺序排列数据：</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E6%8F%92%E5%85%A5ID%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E6%95%B0%E6%8D%AE.png"></p>
<ul>
<li>插入 ID 无序排列数据：</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E6%8F%92%E5%85%A5ID%E6%97%A0%E5%BA%8F%E6%8E%92%E5%88%97%E6%95%B0%E6%8D%AE.png"></p>
</li>
<li><p><strong>关闭唯一性校验</strong>：在导入数据前执行 <code>SET UNIQUE_CHECKS=0</code>，关闭唯一性校验；导入结束后执行 <code>SET UNIQUE_CHECKS=1</code>，恢复唯一性校验，可以提高导入的效率。</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E5%85%B3%E9%97%AD%E5%94%AF%E4%B8%80%E6%80%A7%E6%A0%A1%E9%AA%8C.png"></p>
</li>
<li><p><strong>手动提交事务</strong>：如果应用使用自动提交的方式，建议在导入前执行<code>SET AUTOCOMMIT=0</code>，关闭自动提交；导入结束后再打开自动提交，可以提高导入的效率。</p>
<p>事务需要控制大小，事务太大可能会影响执行的效率。MySQL 有 innodb_log_buffer_size 配置项，超过这个值的日志会写入磁盘数据，效率会下降，所以在事务大小达到配置项数据级前进行事务提交可以提高效率</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1.png"></p>
</li>
</ol>
<hr>
<h4 id="分组排序"><a href="#分组排序" class="headerlink" title="分组排序"></a>分组排序</h4><h5 id="ORDER"><a href="#ORDER" class="headerlink" title="ORDER"></a>ORDER</h5><p>数据准备：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `emp` (</span><br><span class="line">  `id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` VARCHAR(100) NOT NULL,</span><br><span class="line">  `age` INT(3) NOT NULL,</span><br><span class="line">  `salary` INT(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB DEFAULT CHARSET=utf8mb4;</span><br><span class="line">INSERT INTO `emp` (`id`, `name`, `age`, `salary`) VALUES(&#x27;1&#x27;,&#x27;Tom&#x27;,&#x27;25&#x27;,&#x27;2300&#x27;);-- ...</span><br><span class="line">CREATE INDEX idx_emp_age_salary ON emp(age, salary);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一种是通过对返回数据进行排序，所有不通过索引直接返回结果的排序都叫 FileSort 排序，会在内存中重新排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM emp ORDER BY age DESC;	-- 年龄降序</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> ORDER BY排序1.png)</p>
</li>
<li><p>第二种通过有序索引顺序扫描直接返回<strong>有序数据</strong>，这种情况为 Using index，不需要额外排序，操作效率高</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT id, age, salary FROM emp ORDER BY age DESC;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> ORDER BY排序2.png)</p>
</li>
<li><p>多字段排序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT id,age,salary FROM emp ORDER BY age DESC, salary DESC;</span><br><span class="line">EXPLAIN SELECT id,age,salary FROM emp ORDER BY salary DESC, age DESC;</span><br><span class="line">EXPLAIN SELECT id,age,salary FROM emp ORDER BY age DESC, salary ASC;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> ORDER BY排序3.png)</p>
<p>尽量减少额外的排序，通过索引直接返回有序数据。<strong>需要满足 Order by 使用相同的索引、Order By 的顺序和索引顺序相同、Order  by 的字段都是升序或都是降序</strong>，否则需要额外的操作，就会出现 FileSort</p>
</li>
<li><p>ORDER BY RAND() 命令用来进行随机排序，会使用了临时内存表，临时内存表排序的时使用 rowid 排序方法</p>
</li>
</ul>
<p>优化方式：创建合适的索引能够减少 Filesort 的出现，但是某些情况下条件限制不能让 Filesort 消失，就要加快 Filesort 的排序操作</p>
<p>内存临时表，MySQL 有两种 Filesort 排序算法：</p>
<ul>
<li><p>rowid 排序：首先根据条件取出排序字段和信息，然后在<strong>排序区 sort buffer（Server 层）</strong>中排序，如果 sort buffer 不够，则在临时表 temporary table 中存储排序结果。完成排序后再根据行指针<strong>回表读取记录</strong>，该操作可能会导致大量随机 I&#x2F;O 操作</p>
<p>说明：对于临时内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，不会导致多访问磁盘，优先选择该方式</p>
</li>
<li><p>全字段排序：一次性取出满足条件的所有数据，需要回表，然后在排序区 sort  buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法高</p>
</li>
</ul>
<p>具体的选择方式：</p>
<ul>
<li><p>MySQL 通过比较系统变量 max_length_for_sort_data 的大小和 Query 语句取出的字段的大小，来判定使用哪种排序算法。如果前者大，则说明 sort  buffer 空间足够，使用第二种优化之后的算法，否则使用第一种。</p>
</li>
<li><p>可以适当提高 sort_buffer_size  和 max_length_for_sort_data 系统变量，来增大排序区的大小，提高排序的效率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @@max_length_for_sort_data = 10000; 		-- 设置全局变量</span><br><span class="line">SET max_length_for_sort_data = 10240; 			-- 设置会话变量</span><br><span class="line">SHOW VARIABLES LIKE &#x27;max_length_for_sort_data&#x27;;	-- 默认1024</span><br><span class="line">SHOW VARIABLES LIKE &#x27;sort_buffer_size&#x27;;			-- 默认262114</span><br></pre></td></tr></table></figure></li>
</ul>
<p>磁盘临时表：排序使用优先队列（堆）的方式</p>
<hr>
<h5 id="GROUP"><a href="#GROUP" class="headerlink" title="GROUP"></a>GROUP</h5><p>GROUP BY 也会进行排序操作，与 ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作，所以在 GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引</p>
<ul>
<li><p>分组查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX idx_emp_age_salary ON emp;</span><br><span class="line">EXPLAIN SELECT age,COUNT(*) FROM emp GROUP BY age;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> GROUP BY排序1.png)</p>
<p>Using temporary：表示 MySQL 需要使用临时表（不是 sort buffer）来存储结果集，常见于排序和分组查询</p>
</li>
<li><p>查询包含 GROUP BY 但是用户想要避免排序结果的消耗， 则可以执行 ORDER BY NULL 禁止排序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT age,COUNT(*) FROM emp GROUP BY age ORDER BY NULL;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> GROUP BY排序2.png)</p>
</li>
<li><p>创建索引：索引本身有序，不需要临时表，也不需要再额外排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_emp_age_salary ON emp(age, salary);</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> GROUP BY排序3.png)</p>
</li>
<li><p>数据量很大时，使用 SQL_BIG_RESULT 提示优化器直接使用直接用磁盘临时表</p>
</li>
</ul>
<hr>
<h4 id="联合查询-1"><a href="#联合查询-1" class="headerlink" title="联合查询"></a>联合查询</h4><p>对于包含 OR 的查询子句，如果要利用索引，则 OR 之间的<strong>每个条件列都必须用到索引，而且不能使用到条件之间的复合索引</strong>，如果没有索引，则应该考虑增加索引</p>
<ul>
<li><p>执行查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM emp WHERE id = 1 OR age = 30;	-- 两个索引，并且不是复合索引</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> OR条件查询1.png)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Extra: Using sort_union(idx_emp_age_salary,PRIMARY); Using <span class="built_in">where</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 UNION 替换 OR，求并集：</p>
<p>注意：该优化只针对多个索引列有效，如果有列没有被索引，查询效率可能会因为没有选择 OR 而降低</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM emp WHERE id = 1 UNION SELECT * FROM emp WHERE age = 30;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> OR条件查询2.png)</p>
</li>
<li><p>UNION 要优于 OR 的原因：</p>
<ul>
<li>UNION 语句的 type 值为 ref，OR 语句的 type 值为 range</li>
<li>UNION 语句的 ref 值为 const，OR 语句的 ref 值为 null，const 表示是常量值引用，非常快</li>
</ul>
</li>
</ul>
<hr>
<h4 id="嵌套查询-1"><a href="#嵌套查询-1" class="headerlink" title="嵌套查询"></a>嵌套查询</h4><p>MySQL 4.1 版本之后，开始支持 SQL 的子查询</p>
<ul>
<li>可以使用 SELECT 语句来创建一个单列的查询结果，然后把结果作为过滤条件用在另一个查询中</li>
<li>使用子查询可以一次性的完成逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死</li>
<li>在有些情况下，<strong>子查询是可以被更高效的连接（JOIN）替代</strong></li>
</ul>
<p>例如查找有角色的所有的用户信息：</p>
<ul>
<li><p>执行计划：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t_user WHERE id IN (SELECT user_id FROM user_role);</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A21.png"></p>
</li>
<li><p>优化后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t_user u , user_role ur WHERE u.id = ur.user_id;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A22.png"></p>
<p>连接查询之所以效率更高 ，是因为<strong>不需要在内存中创建临时表</strong>来完成逻辑上需要两个步骤的查询工作</p>
</li>
</ul>
<hr>
<h4 id="分页查询-1"><a href="#分页查询-1" class="headerlink" title="分页查询"></a>分页查询</h4><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能</p>
<p>一个常见的问题是 <code>LIMIT 200000,10</code>，此时需要 MySQL 扫描前 200010 记录，仅仅返回 200000 - 200010 之间的记录，其他记录丢弃，查询排序的代价非常大</p>
<ul>
<li><p>分页查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_user_1 LIMIT 200000,10;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A21.png"></p>
</li>
<li><p>优化方式一：内连接查询，在索引列 id 上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_user_1 t,(SELECT id FROM tb_user_1 ORDER BY id LIMIT 200000,10) a WHERE t.id = a.id;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A22.png"></p>
</li>
<li><p>优化方式二：方案适用于主键自增的表，可以把 LIMIT 查询转换成某个位置的查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_user_1 WHERE id &gt; 200000 LIMIT 10;			-- 写法 1</span><br><span class="line">EXPLAIN SELECT * FROM tb_user_1 WHERE id BETWEEN 200000 and 200010;	-- 写法 2</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A23.png"></p>
</li>
</ul>
<hr>
<h4 id="使用提示"><a href="#使用提示" class="headerlink" title="使用提示"></a>使用提示</h4><p>SQL 提示，是优化数据库的一个重要手段，就是在 SQL 语句中加入一些提示来达到优化操作的目的</p>
<ul>
<li><p>USE INDEX：在查询语句中表名的后面添加 USE INDEX 来提供 MySQL 去参考的索引列表，可以让 MySQL 不再考虑其他可用的索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_seller_name ON tb_seller(name);</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller USE INDEX(idx_seller_name) WHERE name=&#x27;小米科技&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E6%8F%90%E7%A4%BA1.png"></p>
</li>
<li><p>IGNORE INDEX：让 MySQL 忽略一个或者多个索引，则可以使用 IGNORE INDEX 作为提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller IGNORE INDEX(idx_seller_name) WHERE name = &#x27;小米科技&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E6%8F%90%E7%A4%BA2.png"></p>
</li>
<li><p>FORCE INDEX：强制 MySQL 使用一个特定的索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller FORCE INDEX(idx_seller_name_sta_addr) WHERE NAME=&#x27;小米科技&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E6%8F%90%E7%A4%BA3.png"></p>
</li>
</ul>
<hr>
<h4 id="统计计数"><a href="#统计计数" class="headerlink" title="统计计数"></a>统计计数</h4><p>在不同的 MySQL 引擎中，count(*) 有不同的实现方式：</p>
<ul>
<li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高，但不支持事务</li>
<li>show table status 命令通过采样估算可以快速获取，但是不准确</li>
<li>InnoDB 表执行 count(*) 会遍历全表，虽然结果准确，但会导致性能问题</li>
</ul>
<p>解决方案：</p>
<ul>
<li><p>计数保存在 Redis 中，但是更新 MySQL 和 Redis 的操作不是原子的，会存在数据一致性的问题</p>
</li>
<li><p>计数直接放到数据库里单独的一张计数表中，利用事务解决计数精确问题：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-计数count优化.png" style="zoom: 50%;">

<p>会话 B 的读操作在 T3 执行的，这时更新事务还没有提交，所以计数值加 1 这个操作对会话 B 还不可见，因此会话 B 查询的计数值和最近 100 条记录，返回的结果逻辑上就是一致的</p>
<p>并发系统性能的角度考虑，应该先插入操作记录再更新计数表，因为更新计数表涉及到行锁的竞争，<strong>先插入再更新能最大程度地减少事务之间的锁等待，提升并发度</strong></p>
</li>
</ul>
<p>count 函数的按照效率排序：<code>count(字段) &lt; count(主键id) &lt; count(1) ≈ count(*)</code>，所以建议尽量使用 count(*)</p>
<ul>
<li>count(主键 id)：InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来返回给 Server 层，Server 判断 id 不为空就按行累加</li>
<li>count(1)：InnoDB 引擎遍历整张表但不取值，Server 层对于返回的每一行，放一个数字 1 进去，判断不为空就按行累加</li>
<li>count(字段)：如果这个字段是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个字段定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加</li>
<li>count(*)：不取值，按行累加</li>
</ul>
<p>参考文章：<a href="https://time.geekbang.org/column/article/72775">https://time.geekbang.org/column/article/72775</a></p>
<hr>
<h3 id="缓冲优化"><a href="#缓冲优化" class="headerlink" title="缓冲优化"></a>缓冲优化</h3><h4 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h4><p>三个原则：</p>
<ul>
<li>将尽量多的内存分配给 MySQL 做缓存，但也要给操作系统和其他程序预留足够内存</li>
<li>MyISAM 存储引擎的数据文件读取依赖于操作系统自身的 IO 缓存，如果有 MyISAM 表，就要预留更多的内存给操作系统做 IO 缓存</li>
<li>排序区、连接区等缓存是分配给每个数据库会话（Session）专用的，值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发数较高时会导致物理内存耗尽</li>
</ul>
<hr>
<h4 id="缓冲内存"><a href="#缓冲内存" class="headerlink" title="缓冲内存"></a>缓冲内存</h4><p>Buffer Pool 本质上是 InnoDB 向操作系统申请的一段连续的内存空间。InnoDB 的数据是按数据页为单位来读写，每个数据页的大小默认是 16KB。数据是存放在磁盘中，每次读写数据都需要进行磁盘 IO 将数据读入内存进行操作，效率会很低，所以提供了 Buffer Pool 来暂存这些数据页，缓存中的这些页又叫缓冲页</p>
<p>工作原理：</p>
<ul>
<li>从数据库读取数据时，会首先从缓存中读取，如果缓存中没有，则从磁盘读取后放入 Buffer Pool</li>
<li>向数据库写入数据时，会写入缓存，缓存中修改的数据会<strong>定期刷新</strong>到磁盘，这一过程称为刷脏</li>
</ul>
<p>Buffer Pool 中每个缓冲页都有对应的控制信息，包括表空间编号、页号、偏移量、链表信息等，控制信息存放在占用的内存称为控制块，控制块与缓冲页是一一对应的，但并不是物理上相连的，都在缓冲池中</p>
<p>MySQL 提供了缓冲页的快速查找方式：<strong>哈希表</strong>，使用表空间号和页号作为 Key，缓冲页控制块的地址作为 Value 创建一个哈希表，获取数据页时根据 Key 进行哈希寻址：</p>
<ul>
<li>如果不存在对应的缓存页，就从 free 链表中选一个空闲缓冲页，把磁盘中的对应页加载到该位置</li>
<li>如果存在对应的缓存页，直接获取使用，提高查询数据的效率</li>
</ul>
<p>当内存数据页跟磁盘数据页内容不一致时，称这个内存页为脏页；内存数据写入磁盘后，内存和磁盘上的数据页一致，称为干净页</p>
<hr>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><h5 id="Free-链表"><a href="#Free-链表" class="headerlink" title="Free 链表"></a>Free 链表</h5><p>MySQL 启动时完成对 Buffer Pool 的初始化，先向操作系统申请连续的内存空间，然后将内存划分为若干对控制块和缓冲页。为了区分空闲和已占用的数据页，将所有空闲缓冲页对应的<strong>控制块作为一个节点</strong>放入一个链表中，就是 Free 链表（<strong>空闲链表</strong>）</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-空闲链表.png" style="zoom: 50%;">

<p>基节点：是一块单独申请的内存空间（占 40 字节），并不在 Buffer Pool 的那一大片连续内存空间里</p>
<p>磁盘加载页的流程：</p>
<ul>
<li>从 Free 链表中取出一个空闲的缓冲页</li>
<li>把缓冲页对应的控制块的信息填上（页所在的表空间、页号之类的信息）</li>
<li>把缓冲页对应的 Free 链表节点（控制块）从链表中移除，表示该缓冲页已经被使用</li>
</ul>
<p>参考文章：<a href="https://blog.csdn.net/li1325169021/article/details/121124440">https://blog.csdn.net/li1325169021/article/details/121124440</a></p>
<hr>
<h5 id="Flush-链表"><a href="#Flush-链表" class="headerlink" title="Flush 链表"></a>Flush 链表</h5><p>Flush 链表是一个用来<strong>存储脏页</strong>的链表，对于已经修改过的缓冲脏页，第一次修改后加入到<strong>链表头部</strong>，以后每次修改都不会重新加入，只修改部分控制信息，出于性能考虑并不是直接更新到磁盘，而是在未来的某个时间进行刷脏</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-脏页链表.png" style="zoom:50%;">

<p><strong>后台有专门的线程每隔一段时间把脏页刷新到磁盘</strong>：</p>
<ul>
<li>从 Flush 链表中刷新一部分页面到磁盘：<ul>
<li><strong>后台线程定时</strong>从 Flush 链表刷脏，根据系统的繁忙程度来决定刷新速率，这种方式称为 BUF_FLUSH_LIST</li>
<li>线程刷脏的比较慢，导致用户线程加载一个新的数据页时发现没有空闲缓冲页，此时会尝试从 LRU 链表尾部寻找缓冲页直接释放，如果该页面是已经修改过的脏页就<strong>同步刷新</strong>到磁盘，速度较慢，这种方式称为 BUF_FLUSH_SINGLE_PAGE</li>
</ul>
</li>
<li>从 LRU 链表的冷数据中刷新一部分页面到磁盘，即：BUF_FLUSH_LRU<ul>
<li>后台线程会定时从 LRU 链表的尾部开始扫描一些页面，扫描的页面数量可以通过系统变量 <code>innodb_lru_scan_depth</code> 指定，如果在 LRU 链表中发现脏页，则把它们刷新到磁盘，这种方式称为 BUF_FLUSH_LRU</li>
<li>控制块里会存储该缓冲页是否被修改的信息，所以可以很容易的获取到某个缓冲页是否是脏页</li>
</ul>
</li>
</ul>
<p>参考文章：<a href="https://blog.csdn.net/li1325169021/article/details/121125765">https://blog.csdn.net/li1325169021/article/details/121125765</a></p>
<hr>
<h5 id="LRU-链表"><a href="#LRU-链表" class="headerlink" title="LRU 链表"></a>LRU 链表</h5><p>当 Buffer Pool 中没有空闲缓冲页时就需要淘汰掉最近最少使用的部分缓冲页，为了实现这个功能，MySQL 创建了一个 LRU 链表，当访问某个页时：</p>
<ul>
<li>如果该页不在 Buffer Pool 中，把该页从磁盘加载进来后会将该缓冲页对应的控制块作为节点放入 <strong>LRU 链表的头部</strong></li>
<li>如果该页在 Buffer Pool 中，则直接把该页对应的控制块移动到 LRU 链表的头部，所以 LRU 链表尾部就是最近最少使用的缓冲页</li>
</ul>
<p>MySQL 基于局部性原理提供了预读功能：</p>
<ul>
<li>线性预读：系统变量 <code>innodb_read_ahead_threshold</code>，如果顺序访问某个区（extent：16 KB 的页，连续 64 个形成一个区，一个区默认 1MB 大小）的页面数超过了该系统变量值，就会触发一次<strong>异步读取</strong>下一个区中全部的页面到 Buffer Pool 中</li>
<li>随机预读：如果某个区 13 个连续的页面都被加载到 Buffer Pool，无论这些页面是否是顺序读取，都会触发一次<strong>异步读取</strong>本区所有的其他页面到 Buffer Pool 中</li>
</ul>
<p>预读会造成加载太多用不到的数据页，造成那些使用<strong>频率很高的数据页被挤到 LRU 链表尾部</strong>，所以 InnoDB 将 LRU 链表分成两段：</p>
<ul>
<li>一部分存储使用频率很高的数据页，这部分链表也叫热数据，young 区，靠近链表头部的区域</li>
<li>一部分存储使用频率不高的冷数据，old 区，靠近链表尾部，默认占 37%，可以通过系统变量 <code>innodb_old_blocks_pct</code> 指定</li>
</ul>
<p>当磁盘上的某数据页被初次加载到 Buffer Pool 中会被放入 old 区，淘汰时优先淘汰 old 区</p>
<ul>
<li>当对 old 区的数据进行访问时，会在控制块记录下访问时间，等待后续的访问时间与第一次访问的时间是否在某个时间间隔内，通过系统变量 <code>innodb_old_blocks_time</code> 指定时间间隔，默认 1000ms，成立就<strong>移动到 young 区的链表头部</strong></li>
<li><code>innodb_old_blocks_time</code> 为 0 时，每次访问一个页面都会放入 young 区的头部</li>
</ul>
<hr>
<h4 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h4><p>InnoDB 用一块内存区做 IO 缓存池，该缓存池不仅用来缓存 InnoDB 的索引块，也用来缓存 InnoDB 的数据块，可以通过下面的指令查看 Buffer Pool 的状态信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure>

<p><code>Buffer pool hit rate</code> 字段代表<strong>内存命中率</strong>，表示 Buffer Pool 对查询的加速效果</p>
<p>核心参数：</p>
<ul>
<li><p><code>innodb_buffer_pool_size</code>：该变量决定了 Innodb 存储引擎表数据和索引数据的最大缓存区大小，默认 128M</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_buffer_pool_size&#x27;;</span><br></pre></td></tr></table></figure>

<p>在保证操作系统及其他程序有足够内存可用的情况下，<code>innodb_buffer_pool_size</code> 的值越大，缓存命中率越高，建议设置成可用物理内存的 60%~80%</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">innodb_buffer_pool_size=512M</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>innodb_log_buffer_size</code>：该值决定了 Innodb 日志缓冲区的大小，保存要写入磁盘上的日志文件数据</p>
<p>对于可能产生大量更新记录的大事务，增加该值的大小，可以避免 Innodb 在事务提交前就执行不必要的日志写入磁盘操作，影响执行效率，通过配置文件修改：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">innodb_log_buffer_size=10M</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在多线程下，访问 Buffer Pool 中的各种链表都需要加锁，所以将 Buffer Pool 拆成若干个小实例，<strong>每个线程对应一个实例</strong>，独立管理内存空间和各种链表（类似 ThreadLocal），多线程访问各自实例互不影响，提高了并发能力</p>
<p>MySQL 5.7.5 之前 <code>innodb_buffer_pool_size</code> 只支持在系统启动时修改，现在已经支持运行时修改 Buffer Pool 的大小，但是每次调整参数都会重新向操作系统申请一块连续的内存空间，<strong>将旧的缓冲池的内容拷贝到新空间</strong>非常耗时，所以 MySQL 开始以一个 chunk 为单位向操作系统申请内存，所以一个 Buffer Pool 实例可以由多个 chunk 组成</p>
<ul>
<li>在系统启动时设置系统变量 <code>innodb_buffer_pool_instance</code> 可以指定 Buffer Pool 实例的个数，但是当 Buffer Pool 小于 1GB 时，设置多个实例时无效的</li>
<li>指定系统变量 <code>innodb_buffer_pool_chunk_size</code> 来改变 chunk 的大小，只能在启动时修改，运行中不能修改，而且该变量并不包含缓冲页的控制块的内存大小</li>
<li><code>innodb_buffer_pool_size</code> 必须是 <code>innodb_buffer_pool_chunk_size × innodb_buffer_pool_instance</code> 的倍数，默认值是 <code>128M × 16 = 2G</code>，Buffer Pool 必须是 2G 的整数倍，如果指定 5G，会自动调整成 6G</li>
<li>如果启动时 <code>chunk × instances</code> &gt; <code>pool_size</code>，那么 chunk 的值会自动设置为 <code>pool_size ÷ instances</code></li>
</ul>
<hr>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><h4 id="Change"><a href="#Change" class="headerlink" title="Change"></a>Change</h4><p>InnoDB 管理的 Buffer Pool 中有一块内存叫 Change Buffer 用来对<strong>增删改操作</strong>提供缓存，参数 <code>innodb_change_buffer_max_size </code> 来动态设置，设置为 50 时表示 Change Buffer 的大小最多只能占用 Buffer Pool 的 50%</p>
<ul>
<li>唯一索引的更新不能使用 Change Buffer，需要将数据页读入内存，判断没有冲突在写入</li>
<li>普通索引可以使用 Change Buffer，<strong>直接写入 Buffer 就结束</strong>，不用校验唯一性</li>
</ul>
<p>Change Buffer 并不是数据页，只是对操作的缓存，所以需要将 Change Buffer 中的操作应用到旧数据页，得到新的数据页（脏页）的过程称为 Merge</p>
<ul>
<li>触发时机：访问数据页时会触发 Merge、后台有定时线程进行 Merge、在数据库正常关闭（shutdown）的过程中也会触发</li>
<li>工作流程：首先从磁盘读入数据页到内存（因为 Buffer Pool 中不一定存在对应的数据页），从 Change Buffer 中找到对应的操作应用到数据页，得到新的数据页即为脏页，然后写入 redo log，等待刷脏即可</li>
</ul>
<p>说明：Change Buffer 中的记录，在事务提交时也会写入 redo log，所以是可以保证不丢失的</p>
<p>业务场景：</p>
<ul>
<li><p>对于<strong>写多读少</strong>的业务来说，页面在写完以后马上被访问到的概率比较小，此时 Change Buffer 的使用效果最好，常见的就是账单类、日志类的系统</p>
</li>
<li><p>一个业务的更新模式是写入后马上做查询，那么即使满足了条件，将更新先记录在 Change Buffer，但之后由于马上要访问这个数据页，会立即触发 Merge 过程，这样随机访问 IO 的次数不会减少，并且增加了 Change Buffer 的维护代价</p>
</li>
</ul>
<p>补充：Change Buffer 的前身是 Insert Buffer，只能对 Insert 操作优化，后来增加了 Update&#x2F;Delete 的支持，改为 Change Buffer</p>
<hr>
<h4 id="Net"><a href="#Net" class="headerlink" title="Net"></a>Net</h4><p>Server 层针对优化<strong>查询</strong>的内存为 Net Buffer，内存的大小是由参数 <code>net_buffer_length</code>定义，默认 16k，实现流程：</p>
<ul>
<li>获取一行数据写入 Net Buffer，重复获取直到 Net Buffer 写满，调用网络接口发出去</li>
<li>若发送成功就清空 Net Buffer，然后继续取下一行；若发送函数返回 EAGAIN 或 WSAEWOULDBLOCK，表示本地网络栈 <code>socket send buffer</code> 写满了，<strong>进入等待</strong>，直到网络栈重新可写再继续发送</li>
</ul>
<p>MySQL 采用的是边读边发的逻辑，因此对于数据量很大的查询来说，不会在 Server 端保存完整的结果集，如果客户端读结果不及时，会堵住 MySQL 的查询过程，但是<strong>不会把内存打爆导致 OOM</strong></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-查询内存优化.png" style="zoom:50%;">

<p>SHOW PROCESSLIST 获取线程信息后，处于 Sending to client 状态代表服务器端的网络栈写满，等待客户端接收数据</p>
<p>假设有一个业务的逻辑比较复杂，每读一行数据以后要处理很久的逻辑，就会导致客户端要过很久才会去取下一行数据，导致 MySQL 的阻塞，一直处于 Sending to client 的状态</p>
<p>解决方法：如果一个查询的返回结果很是很多，建议使用 mysql_store_result 这个接口，直接把查询结果保存到本地内存</p>
<p>参考文章：<a href="https://blog.csdn.net/qq_33589510/article/details/117673449">https://blog.csdn.net/qq_33589510/article/details/117673449</a></p>
<hr>
<h4 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h4><p>read_rnd_buffer 是 MySQL 的随机读缓冲区，当按任意顺序读取记录行时将分配一个随机读取缓冲区，进行排序查询时，MySQL 会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，大小是由 read_rnd_buffer_size 参数控制的</p>
<p><strong>Multi-Range Read 优化</strong>，将随机 IO 转化为顺序 IO 以降低查询过程中 IO 开销，因为大多数的数据都是按照主键递增顺序插入得到，所以按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能</p>
<p>二级索引为 a，聚簇索引为 id，优化回表流程：</p>
<ul>
<li>根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中</li>
<li>将 read_rnd_buffer 中的 id 进行<strong>递增排序</strong></li>
<li>排序后的 id 数组，依次回表到主键 id 索引中查记录，并作为结果返回</li>
</ul>
<p>说明：如果步骤 1 中 read_rnd_buffer 放满了，就会先执行步骤 2 和 3，然后清空 read_rnd_buffer，之后继续找索引 a 的下个记录</p>
<p>使用 MRR 优化需要设进行设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET optimizer_switch=&#x27;mrr_cost_based=off&#x27;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h4><p>MyISAM 存储引擎使用 key_buffer 缓存索引块，加速 MyISAM 索引的读写速度。对于 MyISAM 表的数据块没有特别的缓存机制，完全依赖于操作系统的 IO 缓存</p>
<ul>
<li><p>key_buffer_size：该变量决定 MyISAM 索引块缓存区的大小，直接影响到 MyISAM 表的存取效率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;key_buffer_size&#x27;;	-- 单位是字节</span><br></pre></td></tr></table></figure>

<p>在 MySQL 配置文件中设置该值，建议至少将1&#x2F;4可用内存分配给 key_buffer_size：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/mysql/my.cnf</span><br><span class="line">key_buffer_size=1024M</span><br></pre></td></tr></table></figure>
</li>
<li><p>read_buffer_size：如果需要经常顺序扫描 MyISAM 表，可以通过增大 read_buffer_size 的值来改善性能。但 read_buffer_size 是每个 Session 独占的，如果默认值设置太大，并发环境就会造成内存浪费</p>
</li>
<li><p>read_rnd_buffer_size：对于需要做排序的 MyISAM 表的查询，如带有 ORDER BY 子句的语句，适当增加该的值，可以改善此类的 SQL 的性能，但是 read_rnd_buffer_size 是每个 Session 独占的，如果默认值设置太大，就会造成内存浪费</p>
</li>
</ul>
<hr>
<h3 id="存储优化"><a href="#存储优化" class="headerlink" title="存储优化"></a>存储优化</h3><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><p>系统表空间是用来放系统信息的，比如数据字典什么的，对应的磁盘文件是 ibdata，数据表空间是一个个的表数据文件，对应的磁盘文件就是表名.ibd</p>
<p>表数据既可以存在共享表空间里，也可以是单独的文件，这个行为是由参数 innodb_file_per_table 控制的：</p>
<ul>
<li>OFF：表示表的数据放在系统共享表空间，也就是跟数据字典放在一起</li>
<li>ON ：表示每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中（默认）</li>
</ul>
<p>一个表单独存储为一个文件更容易管理，在不需要这个表时通过 drop table 命令，系统就会直接删除这个文件；如果是放在共享表空间中，即使表删掉了，空间也是不会回收的</p>
<hr>
<h4 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h4><p>MySQL 的数据删除就是移除掉某个记录后，该位置就被标记为<strong>可复用</strong>，如果有符合范围条件的数据可以插入到这里。符合范围条件的意思是假设删除记录 R4，之后要再插入一个 ID 在 300 和 600 之间的记录时，就会复用这个位置</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-删除数据.png" style="zoom:50%;">

<p>InnoDB 的数据是按页存储的如果删掉了一个数据页上的所有记录，整个数据页就可以被复用了，如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用</p>
<p>删除命令其实只是把记录的位置，或者<strong>数据页标记为了可复用，但磁盘文件的大小是不会变的</strong>，这些可以复用还没有被使用的空间，看起来就像是空洞，造成数据库的稀疏，因此需要进行紧凑处理</p>
<hr>
<h4 id="重建数据"><a href="#重建数据" class="headerlink" title="重建数据"></a>重建数据</h4><p>重建表就是按照主键 ID 递增的顺序，把数据一行一行地从旧表中读出来再插入到新表中，让数据更加紧凑。重建表时 MySQL 会自动完成转存数据、交换表名、删除旧表的操作，线上操作会阻塞大量的线程增删改查的操作</p>
<p>重建命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> A ENGINE<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure>

<p>工作流程：新建临时表 tmp_table B（在 Server 层创建的），把表 A 中的数据导入到表 B 中，操作完成后用表 B 替换表 A，完成重建</p>
<p>重建表的步骤需要 DDL 不是 Online 的，因为在导入数据的过程有新的数据要写入到表 A 的话，就会造成数据丢失</p>
<p>MySQL 5.6 版本开始引入的 <strong>Online DDL</strong>，重建表的命令默认执行此步骤：</p>
<ul>
<li>建立一个临时文件 tmp_file（InnoDB 创建），扫描表 A 主键的所有数据页</li>
<li>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中</li>
<li>生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态</li>
<li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3</li>
<li>用临时文件替换表 A 的数据文件</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-重建表.png" style="zoom: 67%;">

<p>Online DDL 操作会先获取 MDL 写锁，再退化成 MDL 读锁。但 MDL 写锁持有时间比较短，所以可以称为 Online； 而 MDL 读锁，不阻止数据增删查改，但会阻止其它线程修改表结构（可以对比 <code>ANALYZE TABLE t</code>  命令）</p>
<p>问题：重建表可以收缩表空间，但是执行指令后整体占用空间增大</p>
<p>原因：在重建表后 InnoDB 不会把整张表占满，每个页留了 1&#x2F;16 给后续的更新使用。表在未整理之前页已经占用 15&#x2F;16 以上，收缩之后需要保持数据占用空间在 15&#x2F;16，所以文件占用空间更大才能保持</p>
<p>注意：临时文件也要占用空间，如果空间不足会重建失败</p>
<hr>
<h4 id="原地置换"><a href="#原地置换" class="headerlink" title="原地置换"></a>原地置换</h4><p>DDL 中的临时表 tmp_table 是在 Server 层创建的，Online DDL 中的临时文件 tmp_file 是 InnoDB 在内部创建出来的，整个 DDL 过程都在 InnoDB 内部完成，对于 Server 层来说，没有把数据挪动到临时表，是一个原地操作，这就是 inplace</p>
<p>两者的关系：</p>
<ul>
<li>DDL 过程如果是 Online 的，就一定是 inplace 的</li>
<li>inplace 的 DDL，有可能不是 Online 的，截止到 MySQL 8.0，全文索引（FULLTEXT）和空间索引（SPATIAL）属于这种情况</li>
</ul>
<hr>
<h3 id="并发优化"><a href="#并发优化" class="headerlink" title="并发优化"></a>并发优化</h3><p>MySQL Server 是多线程结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。在 MySQL 中，控制并发连接和线程的主要参数：</p>
<ul>
<li><p>max_connections：控制允许连接到 MySQL 数据库的最大连接数，默认值是 151</p>
<p>如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这时可以考虑增大 max_connections 的值</p>
<p>MySQL 最大可支持的连接数取决于很多因素，包括操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度、期望的响应时间等。在 Linux 平台下，性能好的服务器，可以支持 500-1000 个连接，需要根据服务器性能进行评估设定</p>
</li>
<li><p>innodb_thread_concurrency：并发线程数，代表系统内同时运行的线程数量（已经被移除）</p>
</li>
<li><p>back_log：控制 MySQL 监听 TCP 端口时的积压请求栈的大小</p>
<p>如果 Mysql 的连接数达到 max_connections 时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即 back_log。如果等待连接的数量超过 back_log，将不被授予连接资源直接报错</p>
<p>5.6.6 版本之前默认值为 50，之后的版本默认为 <code>50 + (max_connections/5)</code>，但最大不超过900，如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大 back_log 的值</p>
</li>
<li><p>table_open_cache：控制所有 SQL 语句执行线程可打开表缓存的数量</p>
<p>在执行 SQL 语句时，每个执行线程至少要打开1个表缓存，该参数的值应该根据设置的最大连接数以及每个连接执行关联查询中涉及的表的最大数量来设定：<code>max_connections * N</code></p>
</li>
<li><p>thread_cache_size：可控制 MySQL 缓存客户服务线程的数量</p>
<p>为了加快连接数据库的速度，MySQL 会缓存一定数量的客户服务线程以备重用，池化思想</p>
</li>
<li><p>innodb_lock_wait_timeout：设置 InnoDB 事务等待行锁的时间，默认值是 50ms</p>
<p>对于需要快速反馈的业务系统，可以将行锁的等待时间调小，以避免事务被长时间挂起； 对于后台运行的批量处理程序来说，可以将行锁的等待时间调大，以避免发生大的回滚操作</p>
</li>
</ul>
<hr>
<h2 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h2><h3 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>事务（Transaction）是访问和更新数据库的程序执行单元；事务中可能包含一个或多个 SQL 语句，这些语句要么都执行，要么都不执行，作为一个关系型数据库，MySQL 支持事务。</p>
<p>单元中的每条 SQL 语句都相互依赖，形成一个整体</p>
<ul>
<li><p>如果某条 SQL 语句执行失败或者出现错误，那么整个单元就会回滚，撤回到事务最初的状态</p>
</li>
<li><p>如果单元中所有的 SQL 语句都执行成功，则事务就顺利执行</p>
</li>
</ul>
<p>事务的四大特征：ACID</p>
<ul>
<li>原子性 (atomicity)</li>
<li>一致性 (consistency)</li>
<li>隔离性 (isolaction)</li>
<li>持久性 (durability)</li>
</ul>
<p>事务的几种状态：</p>
<ul>
<li>活动的（active）：事务对应的数据库操作正在执行中</li>
<li>部分提交的（partially committed）：事务的最后一个操作执行完，但是内存还没刷新至磁盘</li>
<li>失败的（failed）：当事务处于活动状态或部分提交状态时，如果数据库遇到了错误或刷脏失败，或者用户主动停止当前的事务</li>
<li>中止的（aborted）：失败状态的事务回滚完成后的状态</li>
<li>提交的（committed）：当处于部分提交状态的事务刷脏成功，就处于提交状态</li>
</ul>
<hr>
<h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><p>事务管理的三个步骤</p>
<ol>
<li><p>开启事务：记录回滚点，并通知服务器，将要执行一组操作，要么同时成功、要么同时失败</p>
</li>
<li><p>执行 SQL 语句：执行具体的一条或多条 SQL 语句</p>
</li>
<li><p>结束事务（提交|回滚）</p>
<ul>
<li>提交：没出现问题，数据进行更新</li>
<li>回滚：出现问题，数据恢复到开启事务时的状态</li>
</ul>
</li>
</ol>
<p>事务操作：</p>
<ul>
<li><p>显式开启事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION [READ ONLY|READ WRITE|WITH CONSISTENT SNAPSHOT]; #可以跟一个或多个状态，最后的是一致性读</span><br><span class="line">BEGIN [WORK];</span><br></pre></td></tr></table></figure>

<p>说明：不填状态默认是读写事务</p>
</li>
<li><p>回滚事务，用来手动中止事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交事务，显示执行是手动提交，MySQL 默认为自动提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存点：在事务的执行过程中设置的还原点，调用 ROLLBACK 时可以指定回滚到哪个点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAVEPOINT point_name;						#设置保存点</span><br><span class="line">RELEASE point_name							#删除保存点</span><br><span class="line">ROLLBACK [WORK] TO [SAVEPOINT] point_name	#回滚至某个保存点，不填默认回滚到事务执行之前的状态</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作演示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 开启事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 张三给李四转账500元</span><br><span class="line">-- 1.张三账户-500</span><br><span class="line">UPDATE account SET money=money-500 WHERE NAME=&#x27;张三&#x27;;</span><br><span class="line">-- 2.李四账户+500</span><br><span class="line">UPDATE account SET money=money+500 WHERE NAME=&#x27;李四&#x27;;</span><br><span class="line"></span><br><span class="line">-- 回滚事务(出现问题)</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 提交事务(没出现问题)</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h4><p>提交方式的相关语法：</p>
<ul>
<li><p>查看事务提交方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@AUTOCOMMIT;  		-- 会话，1 代表自动提交    0 代表手动提交</span><br><span class="line">SELECT @@GLOBAL.AUTOCOMMIT;	-- 系统</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改事务提交方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @@AUTOCOMMIT=数字;	-- 系统</span><br><span class="line">SET AUTOCOMMIT=数字;		-- 会话</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>系统变量的操作</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] 变量名 <span class="operator">=</span> 值;					<span class="comment">-- 默认是会话</span></span><br><span class="line"><span class="keyword">SET</span> @@[(<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION).]变量名 <span class="operator">=</span> 值;				<span class="comment">-- 默认是系统</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] VARIABLES [<span class="keyword">LIKE</span> <span class="string">&#x27;变量%&#x27;</span>];	  <span class="comment">-- 默认查看会话内系统变量值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>工作原理：</p>
<ul>
<li>自动提交：如果没有 START TRANSACTION 显式地开始一个事务，那么<strong>每条 SQL 语句都会被当做一个事务执行提交操作</strong>；显式开启事务后，会在本次事务结束（提交或回滚）前暂时关闭自动提交</li>
<li>手动提交：不需要显式的开启事务，所有的 SQL 语句都在一个事务中，直到执行了提交或回滚，然后进入下一个事务</li>
<li>隐式提交：存在一些特殊的命令，在事务中执行了这些命令会马上<strong>强制执行 COMMIT 提交事务</strong><ul>
<li><strong>DDL 语句</strong> (CREATE&#x2F;DROP&#x2F;ALTER)、LOCK TABLES 语句、LOAD DATA 导入数据语句、主从复制语句等</li>
<li>当一个事务还没提交或回滚，显式的开启一个事务会隐式的提交上一个事务</li>
</ul>
</li>
</ul>
<hr>
<h4 id="事务-ID"><a href="#事务-ID" class="headerlink" title="事务 ID"></a>事务 ID</h4><p>事务在执行过程中对某个表执行了<strong>增删改操作或者创建表</strong>，就会为当前事务分配一个独一无二的事务 ID（对临时表并不会分配 ID），如果当前事务没有被分配 ID，默认是 0</p>
<p>说明：只读事务不能对普通的表进行增删改操作，但是可以对临时表增删改，读写事务可以对数据表执行增删改查操作</p>
<p>事务 ID 本质上就是一个数字，服务器在内存中维护一个全局变量：</p>
<ul>
<li>每当需要为某个事务分配 ID，就会把全局变量的值赋值给事务 ID，然后变量自增 1</li>
<li>每当变量值为 256 的倍数时，就将该变量的值刷新到系统表空间的 Max Trx ID 属性中，该属性占 8 字节</li>
<li>系统再次启动后，会读取表空间的 Max Trx ID 属性到内存，加上 256 后赋值给全局变量，因为关机时的事务 ID 可能并不是 256 的倍数，会比 Max Trx ID 大，所以需要加上 256 保持事务 ID 是一个<strong>递增的数字</strong></li>
</ul>
<p><strong>聚簇索引</strong>的行记录除了完整的数据，还会自动添加 trx_id、roll_pointer 隐藏列，如果表中没有主键并且没有非空唯一索引，也会添加一个 row_id 的隐藏列作为聚簇索引</p>
<hr>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><h4 id="四种级别"><a href="#四种级别" class="headerlink" title="四种级别"></a>四种级别</h4><p>事务的隔离级别：多个客户端操作时，各个客户端的事务之间应该是隔离的，<strong>不同的事务之间不该互相影响</strong>，而如果多个事务操作同一批数据时，则需要设置不同的隔离级别，否则就会产生问题。</p>
<p>隔离级别分类：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>名称</th>
<th>会引发的问题</th>
<th>数据库默认隔离级别</th>
</tr>
</thead>
<tbody><tr>
<td>Read Uncommitted</td>
<td>读未提交</td>
<td>脏读、不可重复读、幻读</td>
<td></td>
</tr>
<tr>
<td>Read Committed</td>
<td>读已提交</td>
<td>不可重复读、幻读</td>
<td>Oracle &#x2F; SQL Server</td>
</tr>
<tr>
<td>Repeatable Read</td>
<td>可重复读</td>
<td>幻读</td>
<td>MySQL</td>
</tr>
<tr>
<td>Serializable</td>
<td>可串行化</td>
<td>无</td>
<td></td>
</tr>
</tbody></table>
<p>一般来说，隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差</p>
<ul>
<li><p>脏写 (Dirty Write)：当两个或多个事务选择同一行，最初的事务修改的值被后面事务修改的值覆盖，所有的隔离级别都可以避免脏写（又叫丢失更新），因为有行锁</p>
</li>
<li><p>脏读 (Dirty Reads)：在一个事务处理过程中读取了另一个<strong>未提交</strong>的事务中修改过的数据</p>
</li>
<li><p>不可重复读 (Non-Repeatable Reads)：在一个事务处理过程中读取了另一个事务中修改并<strong>已提交</strong>的数据</p>
<blockquote>
<p>可重复读的意思是不管读几次，结果都一样，可以重复的读，可以理解为快照读，要读的数据集不会发生变化</p>
</blockquote>
</li>
<li><p>幻读 (Phantom Reads)：在事务中按某个条件先后两次查询数据库，后一次查询查到了前一次查询没有查到的行，<strong>数据条目</strong>发生了变化。比如查询某数据不存在，准备插入此记录，但执行插入时发现此记录已存在，无法插入</p>
</li>
</ul>
<p>隔离级别操作语法：</p>
<ul>
<li><p>查询数据库隔离级别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@TX_ISOLATION;			-- 会话</span><br><span class="line">SELECT @@GLOBAL.TX_ISOLATION;	-- 系统</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改数据库隔离级别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL 级别字符串;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h4><p>InnoDB 存储引擎支持事务，所以加锁分析是基于该存储引擎</p>
<ul>
<li><p>Read Uncommitted 级别，任何操作都不会加锁</p>
</li>
<li><p>Read Committed 级别，增删改操作会加写锁（行锁），读操作不加锁</p>
<p>在 Server 层过滤条件时发现不满足的记录会调用 unlock_row 方法释放该记录的行锁，保证最后只有满足条件的记录加锁，但是扫表过程中每条记录的<strong>加锁操作不能省略</strong>。所以对数据量很大的表做批量修改时，如果无法使用相应的索引（全表扫描），在 Server 过滤数据时就会特别慢，出现虽然没有修改某些行的数据，但是还是被锁住了的现象（锁表），这种情况同样适用于  RR</p>
</li>
<li><p>Repeatable Read 级别，增删改操作会加写锁，读操作不加锁。因为读写锁不兼容，<strong>加了读锁后其他事务就无法修改数据</strong>，影响了并发性能，为了保证隔离性和并发性，MySQL 通过 MVCC 解决了读写冲突。RR 级别下的锁有很多种，锁机制章节详解</p>
</li>
<li><p>Serializable 级别，读加共享锁，写加排他锁，读写互斥，使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差</p>
<ul>
<li>串行化：让所有事务按顺序单独执行，写操作会加写锁，读操作会加读锁</li>
<li>可串行化：让所有操作相同数据的事务顺序执行，通过加锁实现</li>
</ul>
</li>
</ul>
<p>参考文章：<a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">https://tech.meituan.com/2014/08/20/innodb-lock.html</a></p>
<hr>
<h3 id="原子特性"><a href="#原子特性" class="headerlink" title="原子特性"></a>原子特性</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>原子性是指事务是一个不可分割的工作单位，事务的操作如果成功就必须要完全应用到数据库，失败则不能对数据库有任何影响。比如事务中一个 SQL 语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态</p>
<p>InnoDB 存储引擎提供了两种事务日志：redo log（重做日志）和 undo log（回滚日志）</p>
<ul>
<li>redo log 用于保证事务持久性</li>
<li>undo log 用于保证事务原子性和隔离性</li>
</ul>
<p>undo log 属于逻辑日志，根据每行操作进行记录，记录了 SQL 执行相关的信息，用来回滚行记录到某个版本</p>
<p>当事务对数据库进行修改时，InnoDB 会先记录对应的 undo log，如果事务执行失败或调用了 rollback 导致事务回滚，InnoDB 会根据 undo log 的内容<strong>做与之前相反的操作</strong>：</p>
<ul>
<li><p>对于每个 insert，回滚时会执行 delete</p>
</li>
<li><p>对于每个 delete，回滚时会执行 insert</p>
</li>
<li><p>对于每个 update，回滚时会执行一个相反的 update，把数据修改回去</p>
</li>
</ul>
<p>参考文章：<a href="https://www.cnblogs.com/kismetv/p/10331633.html">https://www.cnblogs.com/kismetv/p/10331633.html</a></p>
<hr>
<h4 id="DML-解析"><a href="#DML-解析" class="headerlink" title="DML 解析"></a>DML 解析</h4><h5 id="INSERT-1"><a href="#INSERT-1" class="headerlink" title="INSERT"></a>INSERT</h5><p>乐观插入：当前数据页的剩余空间充足，直接将数据进行插入</p>
<p>悲观插入：当前数据页的剩余空间不足，需要进行页分裂，申请一个新的页面来插入数据，会造成更多的 redo log，undo log 影响不大</p>
<p>当向某个表插入一条记录，实际上需要向聚簇索引和所有二级索引都插入一条记录，但是 undo log <strong>只针对聚簇索引记录</strong>，在回滚时会根据聚簇索引去所有的二级索引进行回滚操作</p>
<p>roll_pointer 是一个指针，<strong>指向记录对应的 undo log 日志</strong>，一条记录就是一个数据行，行格式中的 roll_pointer 就指向 undo log</p>
<hr>
<h5 id="DELETE-1"><a href="#DELETE-1" class="headerlink" title="DELETE"></a>DELETE</h5><p>插入到页面中的记录会根据 next_record 属性组成一个单向链表，这个链表称为正常链表，被删除的记录也会通过 next_record 组成一个垃圾链表，该链表中所占用的存储空间可以被重新利用，并不会直接清除数据</p>
<p>在页面 Page Header 中，PAGE_FREE 属性指向垃圾链表的头节点，删除的工作过程：</p>
<ul>
<li><p>将要删除的记录的 delete_flag 位置为 1，其他不做修改，这个过程叫 <strong>delete mark</strong></p>
</li>
<li><p>在事务提交前，delete_flag &#x3D; 1 的记录一直都会处于中间状态</p>
</li>
<li><p>事务提交后，有专门的线程将 delete_flag &#x3D; 1 的记录从正常链表移除并加入垃圾链表，这个过程叫 <strong>purge</strong></p>
<p>purge 线程在执行删除操作时会创建一个 ReadView，根据事务的可见性移除数据（隔离特性部分详解）</p>
</li>
</ul>
<p>当有新插入的记录时，首先判断 PAGE_FREE 指向的头节点是否足够容纳新纪录：</p>
<ul>
<li>如果可以容纳新纪录，就会直接重用已删除的记录的存储空间，然后让 PAGE_FREE 指向垃圾链表的下一个节点</li>
<li>如果不能容纳新纪录，就直接向页面申请新的空间存储，并不会遍历垃圾链表</li>
</ul>
<p>重用已删除的记录空间，可能会造成空间碎片，当数据页容纳不了一条记录时，会判断将碎片空间加起来是否可以容纳，判断为真就会重新组织页内的记录：</p>
<ul>
<li>开辟一个临时页面，将页内记录一次插入到临时页面，此时临时页面时没有碎片的</li>
<li>把临时页面的内容复制到本页，这样就解放出了内存碎片，但是会耗费很大的性能资源</li>
</ul>
<hr>
<h5 id="UPDATE-1"><a href="#UPDATE-1" class="headerlink" title="UPDATE"></a>UPDATE</h5><p>执行 UPDATE 语句，对于更新主键和不更新主键有两种不同的处理方式</p>
<p>不更新主键的情况：</p>
<ul>
<li><p>就地更新（in-place update），如果更新后的列和更新前的列占用的存储空间一样大，就可以直接在原记录上修改</p>
</li>
<li><p>先删除旧纪录，再插入新纪录，这里的删除不是 delete mark，而是直接将记录加入垃圾链表，并且修改页面的相应的控制信息，执行删除的线程不是 purge，是执行更新的用户线程，插入新记录时可能造成页空间不足，从而导致页分裂</p>
</li>
</ul>
<p>更新主键的情况：</p>
<ul>
<li>将旧纪录进行 delete mark，在更新语句提交后由 purge 线程移入垃圾链表</li>
<li>根据更新的各列的值创建一条新纪录，插入到聚簇索引中</li>
</ul>
<p>在对一条记录修改前会<strong>将记录的隐藏列 trx_id 和 roll_pointer 的旧值记录到 undo log 对应的属性中</strong>，这样当前记录的 roll_pointer 指向当前 undo log 记录，当前 undo log 记录的 roll_pointer 指向旧的 undo log 记录，<strong>形成一个版本链</strong></p>
<p>UPDATE、DELETE 操作产生的 undo 日志会用于其他事务的 MVCC 操作，所以不能立即删除，INSERT 可以删除的原因是 MVCC 是对现有数据的快照</p>
<hr>
<h4 id="回滚日志"><a href="#回滚日志" class="headerlink" title="回滚日志"></a>回滚日志</h4><p>undo log 是采用段的方式来记录，Rollback Segement 称为回滚段，本质上就是一个类型是 Rollback Segement Header 的页面</p>
<p>每个回滚段中有 1024 个 undo slot，每个 slot 存放 undo 链表页面的头节点页号，每个链表对应一个叫 undo log segment 的段</p>
<ul>
<li>在以前老版本，只支持 1 个 Rollback Segement，只能记录 1024 个 undo log segment</li>
<li>MySQL5.5 开始支持 128 个 Rollback Segement，支持 128*1024 个 undo 操作</li>
</ul>
<p>工作流程：</p>
<ul>
<li><p>事务执行前需要到系统表空间第 5 号页面中分配一个回滚段（页），获取一个 Rollback Segement Header 页面的地址</p>
</li>
<li><p>回滚段页面有 1024 个 undo slot，首先去回滚段的两个 cached 链表获取缓存的 slot，缓存中没有就在回滚段页面中找一个可用的 undo slot 分配给当前事务</p>
</li>
<li><p>如果是缓存中获取的 slot，则该 slot 对应的 undo log segment 已经分配了，需要重新分配，然后从 undo log segment 中申请一个页面作为日志链表的头节点，并填入对应的 slot 中</p>
</li>
<li><p>每个事务 undo 日志在记录的时候<strong>占用两个 undo 页面的组成链表</strong>，分别为 insert undo 链表和 update undo 链表，链表的头节点页面为 first undo page 会包含一些管理信息，其他页面为 normal undo page</p>
<p>说明：事务执行过程的临时表也需要两个 undo 链表，不和普通表共用，这些链表并不是事务开始就分配，而是按需分配</p>
</li>
</ul>
<hr>
<h3 id="隔离特性"><a href="#隔离特性" class="headerlink" title="隔离特性"></a>隔离特性</h3><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><p>隔离性是指，事务内部的操作与其他事务是隔离的，多个并发事务之间要相互隔离，不能互相干扰</p>
<ul>
<li><p>严格的隔离性，对应了事务隔离级别中的 serializable，实际应用中对性能考虑很少使用可串行化</p>
</li>
<li><p>与原子性、持久性侧重于研究事务本身不同，隔离性研究的是<strong>不同事务</strong>之间的相互影响</p>
</li>
</ul>
<p>隔离性让并发情形下的事务之间互不干扰：</p>
<ul>
<li>一个事务的写操作对另一个事务的写操作（写写）：锁机制保证隔离性</li>
<li>一个事务的写操作对另一个事务的读操作（读写）：MVCC 保证隔离性</li>
</ul>
<p>锁机制：事务在修改数据之前，需要先获得相应的锁，获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁（详解见锁机制）</p>
<hr>
<h4 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h4><p>MVCC 全称 Multi-Version Concurrency Control，即多版本并发控制，用来<strong>解决读写冲突的无锁并发控制</strong>，可以在发生读写请求冲突时不用加锁解决，这个读是指的快照读（也叫一致性读或一致性无锁读），而不是当前读：</p>
<ul>
<li>快照读：实现基于 MVCC，因为是多版本并发，所以快照读读到的数据不一定是当前最新的数据，有可能是历史版本的数据</li>
<li>当前读：又叫加锁读，读取数据库记录是当前<strong>最新的版本</strong>（产生幻读、不可重复读），可以对读取的数据进行加锁，防止其他事务修改数据，是悲观锁的一种操作，读写操作加共享锁或者排他锁和串行化事务的隔离级别都是当前读</li>
</ul>
<p>数据库并发场景：</p>
<ul>
<li><p>读-读：不存在任何问题，也不需要并发控制</p>
</li>
<li><p>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</p>
</li>
<li><p>写-写：有线程安全问题，可能会存在脏写（丢失更新）问题</p>
</li>
</ul>
<p>MVCC 的优点：</p>
<ul>
<li>在并发读写数据库时，做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了并发读写的性能</li>
<li>可以解决脏读，不可重复读等事务隔离问题（加锁也能解决），但不能解决更新丢失问题（写锁会解决）</li>
</ul>
<p>提高读写和写写的并发性能：</p>
<ul>
<li>MVCC + 悲观锁：MVCC 解决读写冲突，悲观锁解决写写冲突</li>
<li>MVCC + 乐观锁：MVCC 解决读写冲突，乐观锁解决写写冲突</li>
</ul>
<p>参考文章：<a href="https://www.jianshu.com/p/8845ddca3b23">https://www.jianshu.com/p/8845ddca3b23</a></p>
<hr>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h5><p>实现原理主要是隐藏字段，undo日志，Read View 来实现的</p>
<p>InnoDB 存储引擎，数据库中的<strong>聚簇索引</strong>每行数据，除了自定义的字段，还有数据库隐式定义的字段：</p>
<ul>
<li>DB_TRX_ID：最近修改事务 ID，记录创建该数据或最后一次修改该数据的事务 ID</li>
<li>DB_ROLL_PTR：回滚指针，<strong>指向记录对应的 undo log 日志</strong>，undo log 中又指向上一个旧版本的 undo log</li>
<li>DB_ROW_ID：隐含的自增 ID（<strong>隐藏主键</strong>），如果数据表没有主键，InnoDB 会自动以 DB_ROW_ID 作为聚簇索引</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MVCC%E7%89%88%E6%9C%AC%E9%93%BE%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5.png"></p>
<hr>
<h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>undo log 是逻辑日志，记录的是每个事务对数据执行的操作，而不是记录的全部数据，要<strong>根据 undo log 逆推出以往事务的数据</strong></p>
<p>undo log 的作用：</p>
<ul>
<li>保证事务进行 rollback 时的原子性和一致性，当事务进行回滚的时候可以用 undo log 的数据进行恢复</li>
<li>用于 MVCC 快照读，通过读取 undo log 的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本</li>
</ul>
<p>undo log 主要分为两种：</p>
<ul>
<li><p>insert undo log：事务在 insert 新记录时产生的 undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p>
</li>
<li><p>update undo log：事务在进行 update 或 delete 时产生的 undo log，在事务回滚时需要，在快照读时也需要。不能随意删除，只有在当前读或事务回滚不涉及该日志时，对应的日志才会被 purge 线程统一清除</p>
</li>
</ul>
<p>每次对数据库记录进行改动，都会产生的新版本的 undo log，随着更新次数的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，把这个链表称之为<strong>版本链</strong>，版本链的头节点就是当前的最新的 undo log，链尾就是最早的旧 undo log</p>
<p>说明：因为 DELETE 删除记录，都是移动到垃圾链表中，不是真正的删除，所以才可以通过版本链访问原始数据</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MVCC版本链.png" style="zoom: 80%;">

<p>注意：undo 是逻辑日志，这里只是直观的展示出来</p>
<p>工作流程：</p>
<ul>
<li>有个事务插入 persion 表一条新记录，name 为 Jerry，age 为 24</li>
<li>事务 1 修改该行数据时，数据库会先对该行加排他锁，然后先记录 undo log，然后修改该行 name 为 Tom，并且修改隐藏字段的事务 ID 为当前事务 1 的 ID（默认为 1 之后递增），回滚指针指向拷贝到 undo log 的副本记录，事务提交后，释放锁</li>
<li>以此类推</li>
</ul>
<hr>
<h5 id="读视图"><a href="#读视图" class="headerlink" title="读视图"></a>读视图</h5><p>Read View 是事务进行读数据操作时产生的读视图，该事务执行快照读的那一刻会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的 ID，用来做可见性判断，根据视图判断当前事务能够看到哪个版本的数据</p>
<p>注意：这里的快照并不是把所有的数据拷贝一份副本，而是由 undo log 记录的逻辑日志，根据库中的数据进行计算出历史数据</p>
<p>工作流程：将版本链的头节点的事务 ID（最新数据事务 ID，大概率不是当前线程）DB_TRX_ID 取出来，与系统当前活跃事务的 ID 对比进行可见性分析，不可见就通过 DB_ROLL_PTR 回滚指针去取出 undo log 中的下一个 DB_TRX_ID 比较，直到找到最近的满足可见性的 DB_TRX_ID，该事务 ID 所在的旧记录就是当前事务能看见的最新的记录</p>
<p>Read View 几个属性：</p>
<ul>
<li>m_ids：生成 Read View 时当前系统中活跃的事务 id 列表（未提交的事务集合，当前事务也在其中）</li>
<li>min_trx_id：生成 Read View 时当前系统中活跃的最小的事务 id，也就是 m_ids 中的最小值（已提交的事务集合）</li>
<li>max_trx_id：生成 Read View 时当前系统应该分配给下一个事务的 id 值，m_ids 中的最大值加 1（未开始事务）</li>
<li>creator_trx_id：生成该 Read View 的事务的事务 id，就是判断该 id 的事务能读到什么数据</li>
</ul>
<p>creator 创建一个 Read View，进行可见性算法分析：（解决了读未提交）</p>
<ul>
<li><p>db_trx_id &#x3D;&#x3D; creator_trx_id：表示这个数据就是当前事务自己生成的，自己生成的数据自己肯定能看见，所以此数据对 creator 是可见的</p>
</li>
<li><p>db_trx_id &lt;  min_trx_id：该版本对应的事务 ID 小于 Read view 中的最小活跃事务 ID，则这个事务在当前事务之前就已经被提交了，对 creator 可见（因为比已提交的最大事务 ID 小的并不一定已经提交，所以应该判断是否在活跃事务列表）</p>
</li>
<li><p>db_trx_id &gt;&#x3D; max_trx_id：该版本对应的事务 ID 大于 Read view 中当前系统的最大事务 ID，则说明该数据是在当前 Read view 创建之后才产生的，对 creator 不可见</p>
</li>
<li><p>min_trx_id&lt;&#x3D; db_trx_id &lt; max_trx_id：判断 db_trx_id 是否在活跃事务列表 m_ids 中</p>
<ul>
<li>在列表中，说明该版本对应的事务正在运行，数据不能显示（<strong>不能读到未提交的数据</strong>）</li>
<li>不在列表中，说明该版本对应的事务已经被提交，数据可以显示（<strong>可以读到已经提交的数据</strong>）</li>
</ul>
</li>
</ul>
<hr>
<h5 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h5><p>表 user 数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span>		name		age</span><br><span class="line">1		张三		   18	</span><br></pre></td></tr></table></figure>

<p>Transaction 20：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;	-- 开启事务</span><br><span class="line">UPDATE user SET name = &#x27;李四&#x27; WHERE id = 1;</span><br><span class="line">UPDATE user SET name = &#x27;王五&#x27; WHERE id = 1;</span><br></pre></td></tr></table></figure>

<p>Transaction 60：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;	-- 开启事务</span><br><span class="line">-- 操作表的其他数据</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MVCC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B1.png"></p>
<p>ID 为 0 的事务创建 Read View：</p>
<ul>
<li>m_ids：20、60</li>
<li>min_trx_id：20</li>
<li>max_trx_id：61</li>
<li>creator_trx_id：0</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MVCC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B2.png"></p>
<p>只有红框部分才复合条件，所以只有张三对应的版本的数据可以被看到</p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1t5411u7Fg">https://www.bilibili.com/video/BV1t5411u7Fg</a></p>
<hr>
<h5 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h5><p>只有在聚簇索引中才有 trx_id 和 roll_pointer 的隐藏列，对于二级索引判断可见性的方式：</p>
<ul>
<li>二级索引页面的 Page Header 中有一个 PAGE_MAX_TRX_ID 属性，代表修改当前页面的最大的事务 ID，SELECT 语句访问某个二级索引时会判断 ReadView 的 min_trx_id 是否大于该属性，大于说明该页面的所有属性对 ReadView 可见</li>
<li>如果属性判断不可见，就需要利用二级索引获取主键值进行<strong>回表操作</strong>，得到聚簇索引后按照聚簇索引的可见性判断的方法操作</li>
</ul>
<hr>
<h4 id="RC-RR"><a href="#RC-RR" class="headerlink" title="RC RR"></a>RC RR</h4><p>Read View 用于支持 RC（Read Committed，读已提交）和 RR（Repeatable Read，可重复读）隔离级别的实现，所以 <strong>SELECT 在 RC 和 RR 隔离级别使用 MVCC 读取记录</strong></p>
<p>RR、RC 生成时机：</p>
<ul>
<li>RC 隔离级别下，每次读取数据前都会生成最新的 Read View（当前读）</li>
<li>RR 隔离级别下，在第一次数据读取时才会创建 Read View（快照读）</li>
</ul>
<p>RC、RR 级别下的 InnoDB 快照读区别</p>
<ul>
<li><p>RC 级别下，事务中每次快照读都会新生成一个 Read View，这就是在 RC 级别下的事务中可以看到别的事务提交的更新的原因</p>
</li>
<li><p>RR 级别下，某个事务的对某条记录的<strong>第一次快照读</strong>会创建一个 Read View， 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，使用的是同一个 Read View，所以一个事务的查询结果每次都是相同的</p>
<p>RR 级别下，通过 <code>START TRANSACTION WITH CONSISTENT SNAPSHOT</code> 开启事务，会在执行该语句后立刻生成一个 Read View，不是在执行第一条 SELECT 语句时生成（所以说 <code>START TRANSACTION</code> 并不是事务的起点，执行第一条语句才算起点）</p>
</li>
</ul>
<p>解决幻读问题：</p>
<ul>
<li><p>快照读：通过 MVCC 来进行控制的，在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，但是<strong>并不能完全避免幻读</strong></p>
<p>场景：RR 级别，T1 事务开启，创建 Read View，此时 T2 去 INSERT 新的一行然后提交，然后 T1 去 UPDATE 该行会发现更新成功，并且把这条新记录的 trx_id 变为当前的事务 id，所以对当前事务就是可见的。因为 <strong>Read View 并不能阻止事务去更新数据，更新数据都是先读后写并且是当前读</strong>，读取到的是最新版本的数据</p>
</li>
<li><p>当前读：通过 next-key 锁（行锁 + 间隙锁）来解决问题</p>
</li>
</ul>
<hr>
<h3 id="持久特性"><a href="#持久特性" class="headerlink" title="持久特性"></a>持久特性</h3><h4 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h4><p>持久性是指一个事务一旦被提交了，那么对数据库中数据的改变就是永久性的，接下来的其他操作或故障不应该对其有任何影响。</p>
<p>Buffer Pool 的使用提高了读写数据的效率，但是如果 MySQL 宕机，此时 Buffer Pool 中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证，所以引入了 redo log 日志：</p>
<ul>
<li>redo log <strong>记录数据页的物理修改</strong>，而不是某一行或某几行的修改，用来恢复提交后的数据页，只能<strong>恢复到最后一次提交</strong>的位置</li>
<li>redo log 采用的是 WAL（Write-ahead logging，<strong>预写式日志</strong>），所有修改要先写入日志，再更新到磁盘，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求</li>
<li>简单的 redo log 是纯粹的物理日志，复杂的 redo log 会存在物理日志和逻辑日志</li>
</ul>
<p>工作过程：MySQL 发生了宕机，InnoDB 会判断一个数据页在崩溃恢复时丢失了更新，就会将它读到内存，然后根据 redo log 内容更新内存，更新完成后，内存页变成脏页，然后进行刷脏</p>
<p>缓冲池的<strong>刷脏策略</strong>：</p>
<ul>
<li>redo log 文件是固定大小的，如果写满了就要擦除以前的记录，在擦除之前需要把对应的更新持久化到磁盘中</li>
<li>Buffer Pool 内存不足，需要淘汰部分数据页（LRU 链表尾部），如果淘汰的是脏页，就要先将脏页写到磁盘（要避免大事务）</li>
<li>系统空闲时，后台线程会自动进行刷脏（Flush 链表部分已经详解）</li>
<li>MySQL 正常关闭时，会把内存的脏页都刷新到磁盘上</li>
</ul>
<hr>
<h4 id="重做日志"><a href="#重做日志" class="headerlink" title="重做日志"></a>重做日志</h4><h5 id="日志缓冲"><a href="#日志缓冲" class="headerlink" title="日志缓冲"></a>日志缓冲</h5><p>服务器启动时会向操作系统申请一片连续内存空间作为 redo log buffer（重做日志缓冲区），可以通过 <code>innodb_log_buffer_size</code> 系统变量指定 redo log buffer 的大小，默认是 16MB</p>
<p>log buffer 被划分为若干 redo log block（块，类似数据页的概念），每个默认大小 512 字节，每个 block 由 12 字节的 log block head、496 字节的 log block body、4 字节的 log block trailer 组成</p>
<ul>
<li>当数据修改时，先修改 Change Buffer 中的数据，然后在 redo log buffer 记录这次操作，写入 log buffer 的过程是<strong>顺序写入</strong>的（先写入前面的 block，写满后继续写下一个）</li>
<li>log buffer 中有一个指针 buf_free，来标识该位置之前都是填满的 block，该位置之后都是空闲区域（<strong>碰撞指针</strong>）</li>
</ul>
<p>MySQL 规定对底层页面的一次原子访问称为一个 Mini-Transaction（MTR），比如在 B+ 树上插入一条数据就算一个 MTR</p>
<ul>
<li><p>一个事务包含若干个 MTR，一个 MTR 对应一组若干条 redo log，一组 redo log 是不可分割的，在进行数据恢复时也把一组 redo log 当作一个不可分割的整体处理</p>
</li>
<li><p>所以不是每生成一条 redo 日志就将其插入到 log buffer 中，而是一个 MTR 结束后<strong>将一组 redo 日志写入 log buffer</strong></p>
</li>
</ul>
<p>InnoDB 的 redo log 是<strong>固定大小</strong>的，redo 日志在磁盘中以文件组的形式存储，同一组中的每个文件大小一样格式一样，</p>
<ul>
<li><code>innodb_log_group_home_dir</code> 代表磁盘存储 redo log 的文件目录，默认是当前数据目录</li>
<li><code>innodb_log_file_size</code> 代表文件大小，默认 48M，<code>innodb_log_files_in_group</code> 代表文件个数，默认 2 最大 100，所以日志的文件大小为 <code>innodb_log_file_size * innodb_log_files_in_group</code></li>
</ul>
<p>redo 日志文件也是由若干个 512 字节的 block 组成，日志文件的前 2048 个字节（前 4 个 block）用来存储一些管理信息，以后的用来存储 log buffer 中的 block 镜像</p>
<p>注意：block 并不代表一组 redo log，一组日志可能占用不到一个 block 或者几个 block，依赖于 MTR 的大小</p>
<hr>
<h5 id="日志刷盘"><a href="#日志刷盘" class="headerlink" title="日志刷盘"></a>日志刷盘</h5><p>redo log 需要在事务提交时将日志写入磁盘，但是比将内存中的 Buffer Pool 修改的数据写入磁盘的速度快，原因：</p>
<ul>
<li>刷脏是随机 IO，因为每次修改的数据位置随机；redo log 和 binlog 都是<strong>顺序写</strong>，磁盘的顺序 IO 比随机 IO 速度要快</li>
<li>刷脏是以数据页（Page）为单位的，一个页上的一个小修改都要整页写入；redo log 中只包含真正需要写入的部分，减少无效 IO</li>
<li><strong>组提交机制</strong>，可以大幅度降低磁盘的 IO 消耗</li>
</ul>
<p>InnoDB 引擎会在适当的时候，把内存中 redo log buffer 持久化（fsync）到磁盘，具体的<strong>刷盘策略</strong>：</p>
<ul>
<li>在事务提交时需要进行刷盘，通过修改参数 <code>innodb_flush_log_at_trx_commit</code> 设置：<ul>
<li>0：表示当提交事务时，并不将缓冲区的 redo 日志写入磁盘，而是等待<strong>后台线程每秒刷新一次</strong></li>
<li>1：在事务提交时将缓冲区的 redo 日志<strong>同步写入</strong>到磁盘，保证一定会写入成功（默认值）</li>
<li>2：在事务提交时将缓冲区的 redo 日志异步写入到磁盘，不能保证提交时肯定会写入，只是有这个动作。日志已经在操作系统的缓存，如果操作系统没有宕机而 MySQL 宕机，也是可以恢复数据的</li>
</ul>
</li>
<li>写入 redo log buffer 的日志超过了总容量的一半，就会将日志刷入到磁盘文件，这会影响执行效率，所以开发中应<strong>避免大事务</strong></li>
<li>服务器关闭时</li>
<li>checkpoint 时（下小节详解）</li>
<li>并行的事务提交（组提交）时，会将将其他事务的 redo log 持久化到磁盘。假设事务 A 已经写入 redo log  buffer 中，这时另外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是 1，那么事务 B 要把 redo log buffer 里的日志全部持久化到磁盘，<strong>因为多个事务共用一个 redo log buffer</strong>，所以一次 fsync 可以刷盘多个事务的 redo log，提升了并发量</li>
</ul>
<p>服务器启动后 redo 磁盘空间不变，所以 redo 磁盘中的日志文件是被<strong>循环使用</strong>的，采用循环写数据的方式，写完尾部重新写头部，所以要确保头部 log 对应的修改已经持久化到磁盘</p>
<hr>
<h5 id="日志序号"><a href="#日志序号" class="headerlink" title="日志序号"></a>日志序号</h5><p>lsn (log sequence number) 代表已经写入的 redo 日志量、flushed_to_disk_lsn 指刷新到磁盘中的 redo 日志量，两者都是<strong>全局变量</strong>，如果两者的值相同，说明 log buffer 中所有的 redo 日志都已经持久化到磁盘</p>
<p>工作过程：写入 log buffer 数据时，buf_free 会进行偏移，偏移量就会加到 lsn 上</p>
<p>MTR 的执行过程中修改过的页对应的控制块会加到 Buffer Pool 的 flush 链表中，链表中脏页是按照第一次修改的时间进行排序的（头插），控制块中有两个指针用来记录脏页被修改的时间：</p>
<ul>
<li>oldest_modification：第一次修改 Buffer Pool 中某个缓冲页时，将修改该页的 MTR <strong>开始时</strong>对应的 lsn 值写入这个属性</li>
<li>newest_modification：每次修改页面，都将 MTR 结束时全局的 lsn 值写入这个属性，所以该值是该页面最后一次修改后的 lsn 值</li>
</ul>
<p>全局变量 checkpoint_lsn 表示<strong>当前系统可以被覆盖的 redo 日志总量</strong>，当 redo 日志对应的脏页已经被刷新到磁盘后，该文件空间就可以被覆盖重用，此时执行一次 checkpoint 来更新 checkpoint_lsn 的值存入管理信息（刷脏和执行一次 checkpoint 并不是同一个线程），该值的增量就代表磁盘文件中当前位置向后可以被覆盖的文件的量，所以该值是一直增大的</p>
<p><strong>checkpoint</strong>：从 flush 链表尾部中找出还未刷脏的页面，该页面是当前系统中最早被修改的脏页，该页面之前产生的脏页都已经刷脏，然后将该页 oldest_modification 值赋值给 checkpoint_lsn，因为 lsn 小于该值时产生的 redo 日志都可以被覆盖了</p>
<p>但是在系统忙碌时，后台线程的刷脏操作不能将脏页快速刷出，导致系统无法及时执行 checkpoint ，这时需要用户线程从 flush 链表中把最早修改的脏页刷新到磁盘中，然后执行 checkpoint</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">write pos ------- checkpoint_lsn <span class="comment">// 两值之间的部分表示可以写入的日志量，当 pos 追赶上 lsn 时必须执行 checkpoint</span></span><br></pre></td></tr></table></figure>

<p>使用命令可以查看当前 InnoDB 存储引擎各种 lsn 的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h5><p>恢复的起点：在从 redo 日志文件组的管理信息中获取最近发生 checkpoint 的信息，<strong>从 checkpoint_lsn 对应的日志文件开始恢复</strong></p>
<p>恢复的终点：扫描日志文件的 block，block 的头部记录着当前 block 使用了多少字节，填满的 block 总是 512 字节， 如果某个 block 不是 512 字节，说明该 block 就是需要恢复的最后一个 block</p>
<p>恢复的过程：按照 redo log 依次执行恢复数据，优化方式</p>
<ul>
<li>使用哈希表：根据 redo log 的 space id 和 page number 属性计算出哈希值，将对同一页面的修改放入同一个槽里，可以一次性完成对某页的恢复，<strong>避免了随机 IO</strong></li>
<li>跳过已经刷新到磁盘中的页面：数据页的 File Header 中的 FILE_PAGE_LSN 属性（类似 newest_modification）表示最近一次修改页面时的 lsn 值，数据页被刷新到磁盘中，那么该页 lsn 属性肯定大于 checkpoint_lsn</li>
</ul>
<p>参考书籍：<a href="https://book.douban.com/subject/35231266/">https://book.douban.com/subject/35231266/</a></p>
<hr>
<h4 id="工作流程-2"><a href="#工作流程-2" class="headerlink" title="工作流程"></a>工作流程</h4><h5 id="日志对比"><a href="#日志对比" class="headerlink" title="日志对比"></a>日志对比</h5><p>MySQL 中还存在 binlog（二进制日志）也可以记录写操作并用于数据的恢复，<strong>保证数据不丢失</strong>，二者的区别是：</p>
<ul>
<li>作用不同：redo log 是用于 crash recovery （故障恢复），保证 MySQL 宕机也不会影响持久性；binlog 是用于 point-in-time recovery 的，保证服务器可以基于时间点恢复数据，此外 binlog 还用于主从复制</li>
<li>层次不同：redo log 是 InnoDB 存储引擎实现的，而 binlog 是MySQL的 Server 层实现的，同时支持 InnoDB 和其他存储引擎</li>
<li>内容不同：redo log 是物理日志，内容基于磁盘的 Page；binlog 的内容是二进制的，根据 binlog_format 参数的不同，可能基于SQL 语句、基于数据本身或者二者的混合（日志部分详解）</li>
<li>写入时机不同：binlog 在事务提交时一次写入；redo log 的写入时机相对多元</li>
</ul>
<p>binlog 为什么不支持崩溃恢复？</p>
<ul>
<li>binlog 记录的是语句，并不记录数据页级的数据（哪个页改了哪些地方），所以没有能力恢复数据页</li>
<li>binlog 是追加写，保存全量的日志，没有标志确定从哪个点开始的数据是已经刷盘了，而 redo log 只要在 checkpoint_lsn 后面的就是没有刷盘的</li>
</ul>
<hr>
<h5 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h5><p>更新一条记录的过程：写之前一定先读</p>
<ul>
<li><p>在 B+ 树中定位到该记录，如果该记录所在的页面不在 Buffer Pool 里，先将其加载进内存</p>
</li>
<li><p>首先更新该记录对应的聚簇索引，更新聚簇索引记录时：</p>
<ul>
<li><p>更新记录前向 undo 页面写 undo 日志，由于这是更改页面，所以需要记录一下相应的 redo 日志</p>
<p>注意：修改 undo页面也是在<strong>修改页面</strong>，事务凡是修改页面就需要先记录相应的 redo 日志</p>
</li>
<li><p>然后<strong>先记录对应的的 redo 日志</strong>（等待 MTR 提交后写入 redo log buffer），<strong>最后进行真正的更新记录</strong></p>
</li>
</ul>
</li>
<li><p>更新其他的二级索引记录，不会再记录 undo log，只记录 redo log 到 buffer 中</p>
</li>
<li><p>在一条更新语句执行完成后（也就是将所有待更新记录都更新完了），就会开始记录该语句对应的 binlog 日志，此时记录的 binlog 并没有刷新到硬盘上，还在内存中，在事务提交时才会统一将该事务运行过程中的所有 binlog 日志刷新到硬盘</p>
</li>
</ul>
<p>假设表中有字段 id 和 a，存在一条 <code>id = 1, a = 2</code> 的记录，此时执行更新语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> a<span class="operator">=</span><span class="number">2</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>InnoDB 会真正的去执行把值修改成 (1,2) 这个操作，先加行锁，在去更新，并不会提前判断相同就不修改了</p>
<p>参考文章：<a href="https://mp.weixin.qq.com/s/wcJ2KisSaMnfP4nH5NYaQA">https://mp.weixin.qq.com/s/wcJ2KisSaMnfP4nH5NYaQA</a></p>
<hr>
<h5 id="两段提交"><a href="#两段提交" class="headerlink" title="两段提交"></a>两段提交</h5><p>当客户端执行 COMMIT 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，分两阶段来完成 XA 事务的提交：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-update的执行流程.png" style="zoom: 33%;">

<p>流程说明：执行引擎将这行新数据读入到内存中（Buffer Pool）后，先将此次更新操作记录到 redo log buffer 里，然后更新记录。最后将 redo log 刷盘后事务处于 prepare 状态，执行器会生成这个操作的 binlog，并<strong>把 binlog 写入磁盘</strong>，完成提交</p>
<p>两阶段：</p>
<ul>
<li>Prepare 阶段：存储引擎将该事务的 <strong>redo 日志刷盘</strong>，并且将本事务的状态设置为 PREPARE，代表执行完成随时可以提交事务</li>
<li>Commit 阶段：先将事务执行过程中产生的 binlog 刷新到硬盘，再执行存储引擎的提交工作，引擎把 redo log 改成提交状态</li>
</ul>
<p>redo log 和 binlog 都可以用于表示事务的提交状态，而<strong>两阶段提交就是让这两个状态保持逻辑上的一致</strong>，也有利于主从复制，更好的保持主从数据的一致性</p>
<hr>
<h5 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h5><p>系统崩溃前没有提交的事务的 redo log 可能已经刷盘（定时线程或者 checkpoint），怎么处理崩溃恢复？</p>
<p>工作流程：获取 undo 链表首节点页面的 undo segement header 中的 TRX_UNDO_STATE 属性，表示当前链表的事务属性，事务状态是活跃（未提交）的就全部回滚，如果是 PREPARE 状态，就需要根据 binlog 的状态进行判断：</p>
<ul>
<li>如果在时刻 A 发生了崩溃（crash），由于此时 binlog 还没完成，所以需要进行回滚</li>
<li>如果在时刻 B 发生了崩溃，redo log 和 binlog 有一个共<strong>同的数据字段叫 XID</strong>，崩溃恢复的时候，会按顺序扫描 redo log：<ul>
<li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，说明 binlog 也已经记录完整，直接从 redo log 恢复数据</li>
<li>如果 redo log 里面的事务只有 prepare，就根据 XID 去 binlog 中判断对应的事务是否存在并完整，如果完整可以恢复数据</li>
</ul>
</li>
</ul>
<p>判断一个事务的 binlog 是否完整的方法：</p>
<ul>
<li>statement 格式的 binlog，最后会有 COMMIT</li>
<li>row 格式的 binlog，最后会有一个 XID event</li>
<li>MySQL 5.6.2 版本以后，引入了 binlog-checksum 参数用来验证 binlog 内容的正确性（可能日志中间出错）</li>
</ul>
<p>参考文章：<a href="https://time.geekbang.org/column/article/73161">https://time.geekbang.org/column/article/73161</a></p>
<hr>
<h4 id="刷脏优化"><a href="#刷脏优化" class="headerlink" title="刷脏优化"></a>刷脏优化</h4><p>系统在进行刷脏时会占用一部分系统资源，会影响系统的性能，<strong>产生系统抖动</strong></p>
<ul>
<li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长</li>
<li>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的</li>
</ul>
<p>InnoDB 刷脏页的控制策略：</p>
<ul>
<li><code>innodb_io_capacity</code> 参数代表磁盘的读写能力，建议设置成磁盘的 IOPS（每秒的 IO 次数）</li>
<li>刷脏速度参考两个因素：脏页比例和 redo log 写盘速度<ul>
<li>参数 <code>innodb_max_dirty_pages_pct</code> 是脏页比例上限，默认值是 75%，InnoDB 会根据当前的脏页比例，算出一个范围在 0 到 100 之间的数字</li>
<li>InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，InnoDB 根据差值算出一个范围在 0 到 100 之间的数字</li>
<li>两者较大的值记为 R，执行引擎按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度</li>
</ul>
</li>
<li><code>innodb_flush_neighbors</code> 参数置为 1 代表控制刷脏时检查相邻的数据页，如果也是脏页就一起刷脏，并检查邻居的邻居，这个行为会一直蔓延直到不是脏页，在 MySQL 8.0 中该值的默认值是 0，不建议开启此功能</li>
</ul>
<hr>
<h3 id="一致特性"><a href="#一致特性" class="headerlink" title="一致特性"></a>一致特性</h3><p>一致性是指事务执行前后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</p>
<p>数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）</p>
<p>实现一致性的措施：</p>
<ul>
<li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证</li>
<li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等</li>
<li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致</li>
</ul>
<hr>
<h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><h3 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>锁机制：数据库为了保证数据的一致性，在共享的资源被并发访问时变得安全有序所设计的一种规则</p>
<p>利用 MVCC 性质进行读取的操作叫<strong>一致性读</strong>，读取数据前加锁的操作叫<strong>锁定读</strong></p>
<p>锁的分类：</p>
<ul>
<li>按操作分类：<ul>
<li>共享锁：也叫读锁。对同一份数据，多个事务读操作可以同时加锁而不互相影响 ，但不能修改数据</li>
<li>排他锁：也叫写锁。当前的操作没有完成前，会阻断其他操作的读取和写入</li>
</ul>
</li>
<li>按粒度分类：<ul>
<li>表级锁：会锁定整个表，开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低，偏向 MyISAM</li>
<li>行级锁：会锁定当前操作行，开销大，加锁慢；会出现死锁；锁定力度小，发生锁冲突概率低，并发度高，偏向 InnoDB</li>
<li>页级锁：锁的力度、发生冲突的概率和加锁开销介于表锁和行锁之间，会出现死锁，并发性能一般</li>
</ul>
</li>
<li>按使用方式分类：<ul>
<li>悲观锁：每次查询数据时都认为别人会修改，很悲观，所以查询时加锁</li>
<li>乐观锁：每次查询数据时都认为别人不会修改，很乐观，但是更新时会判断一下在此期间别人有没有去更新这个数据</li>
</ul>
</li>
</ul>
<ul>
<li><p>不同存储引擎支持的锁</p>
<table>
<thead>
<tr>
<th>存储引擎</th>
<th>表级锁</th>
<th>行级锁</th>
<th>页级锁</th>
</tr>
</thead>
<tbody><tr>
<td>MyISAM</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>InnoDB</td>
<td><strong>支持</strong></td>
<td><strong>支持</strong></td>
<td>不支持</td>
</tr>
<tr>
<td>MEMORY</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>BDB</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
</li>
</ul>
<p>从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如 Web 应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理系统</p>
<hr>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>对一条记录加锁的本质就是<strong>在内存中</strong>创建一个锁结构与之关联，结构包括</p>
<ul>
<li>事务信息：锁对应的事务信息，一个锁属于一个事务</li>
<li>索引信息：对于行级锁，需要记录加锁的记录属于哪个索引</li>
<li>表锁和行锁信息：表锁记录着锁定的表，行锁记录了 Space ID 所在表空间、Page Number 所在的页号、n_bits 使用了多少比特</li>
<li>type_mode：一个 32 比特的数，被分成 lock_mode、lock_type、rec_lock_type 三个部分<ul>
<li>lock_mode：锁模式，记录是共享锁、排他锁、意向锁之类</li>
<li>lock_type：代表表级锁还是行级锁</li>
<li>rec_lock_type：代表行锁的具体类型和 is_waiting 属性，is_waiting &#x3D; true 时表示当前事务尚未获取到锁，处于等待状态。事务获取锁后的锁结构是 is_waiting 为 false，释放锁时会检查是否与当前记录关联的锁结构，如果有就唤醒对应事务的线程</li>
</ul>
</li>
</ul>
<p>一个事务可能操作多条记录，为了节省内存，满足下面条件的锁使用同一个锁结构：</p>
<ul>
<li>在同一个事务中的加锁操作</li>
<li>被加锁的记录在同一个页面中</li>
<li>加锁的类型是一样的</li>
<li>加锁的状态是一样的</li>
</ul>
<hr>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)</p>
<p>MDL 叫元数据锁，主要用来保护 MySQL 内部对象的元数据，保证数据读写的正确性，<strong>当对一个表做增删改查的时候，加 MDL 读锁；当要对表做结构变更操作 DDL 的时候，加 MDL 写锁</strong>，两种锁不相互兼容，所以可以保证 DDL、DML、DQL 操作的安全</p>
<p>说明：DDL 操作执行前会隐式提交当前会话的事务，因为 DDL 一般会在若干个特殊事务中完成，开启特殊事务前需要提交到其他事务</p>
<p>MDL 锁的特性：</p>
<ul>
<li><p>MDL 锁不需要显式使用，在访问一个表的时候会被自动加上，在事务开始时申请，整个事务提交后释放（执行完单条语句不释放）</p>
</li>
<li><p>MDL 锁是在 Server 中实现，不是 InnoDB 存储引擎层能直接实现的锁</p>
</li>
<li><p>MDL 锁还能实现其他粒度级别的锁，比如全局锁、库级别的锁、表空间级别的锁</p>
</li>
</ul>
<p>FLUSH TABLES WITH READ LOCK 简称（FTWRL），全局读锁，让整个库处于只读状态，DDL DML 都被阻塞，工作流程：</p>
<ol>
<li>上全局读锁（lock_global_read_lock）</li>
<li>清理表缓存（close_cached_tables）</li>
<li>上全局 COMMIT 锁（make_global_read_lock_block_commit）</li>
</ol>
<p>该命令主要用于备份工具做<strong>一致性备份</strong>，由于 FTWRL 需要持有两把全局的 MDL 锁，并且还要关闭所有表对象，因此杀伤性很大</p>
<hr>
<h3 id="MyISAM-1"><a href="#MyISAM-1" class="headerlink" title="MyISAM"></a>MyISAM</h3><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>MyISAM 存储引擎只支持表锁，这也是 MySQL 开始几个版本中唯一支持的锁类型</p>
<p>MyISAM 引擎在执行查询语句之前，会<strong>自动</strong>给涉及到的所有表加读锁，在执行增删改之前，会<strong>自动</strong>给涉及的表加写锁，这个过程并不需要用户干预，所以用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁</p>
<ul>
<li><p>加锁命令：（对 InnoDB 存储引擎也适用）</p>
<p>读锁：所有连接只能读取数据，不能修改</p>
<p>写锁：其他连接不能查询和修改数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 读锁</span><br><span class="line">LOCK TABLE table_name READ;</span><br><span class="line"></span><br><span class="line">-- 写锁</span><br><span class="line">LOCK TABLE table_name WRITE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解锁命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 将当前会话所有的表进行解锁</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>锁的兼容性：</p>
<ul>
<li>对 MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求</li>
<li>对 MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作</li>
</ul>
<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 锁的兼容性.png)</p>
<p>锁调度：<strong>MyISAM 的读写锁调度是写优先</strong>，因为写锁后其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞，所以 MyISAM 不适合做写为主的表的存储引擎</p>
<hr>
<h4 id="锁操作"><a href="#锁操作" class="headerlink" title="锁操作"></a>锁操作</h4><h5 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h5><p>两个客户端操作 Client 1和 Client 2，简化为 C1、C2</p>
<ul>
<li><p>数据准备：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tb_book` (</span><br><span class="line">  `id` INT(11) AUTO_INCREMENT,</span><br><span class="line">  `name` VARCHAR(50) DEFAULT NULL,</span><br><span class="line">  `publish_time` DATE DEFAULT NULL,</span><br><span class="line">  `status` CHAR(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=MYISAM DEFAULT CHARSET=utf8 ;</span><br><span class="line"></span><br><span class="line">INSERT INTO tb_book (id, NAME, publish_time, STATUS) VALUES(NULL,&#x27;java编程思想&#x27;,&#x27;2088-08-01&#x27;,&#x27;1&#x27;);</span><br><span class="line">INSERT INTO tb_book (id, NAME, publish_time, STATUS) VALUES(NULL,&#x27;mysql编程思想&#x27;,&#x27;2088-08-08&#x27;,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>C1、C2 加读锁，同时查询可以正常查询出数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCK TABLE tb_book READ;	-- C1、C2</span><br><span class="line">SELECT * FROM tb_book;		-- C1、C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 读锁1.png)</p>
</li>
<li><p>C1 加读锁，C1、C2 查询未锁定的表，C1 报错，C2 正常查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCK TABLE tb_book READ;	-- C1</span><br><span class="line">SELECT * FROM tb_user;		-- C1、C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 读锁2.png)</p>
<p>C1、C2 执行插入操作，C1 报错，C2 等待获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb_book VALUES(NULL,&#x27;Spring高级&#x27;,&#x27;2088-01-01&#x27;,&#x27;1&#x27;);	-- C1、C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 读锁3.png)</p>
<p>当在 C1 中释放锁指令 UNLOCK TABLES，C2 中的 INSERT 语句立即执行</p>
</li>
</ul>
<hr>
<h5 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h5><p>两个客户端操作 Client 1和 Client 2，简化为 C1、C2</p>
<ul>
<li><p>C1 加写锁，C1、C2查询表，C1 正常查询，C2 需要等待</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCK TABLE tb_book WRITE;	-- C1</span><br><span class="line">SELECT * FROM tb_book;		-- C1、C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 写锁1.png)</p>
<p>当在 C1 中释放锁指令 UNLOCK TABLES，C2 中的 SELECT 语句立即执行</p>
</li>
<li><p>C1、C2 同时加写锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCK TABLE tb_book WRITE;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 写锁2.png)</p>
</li>
<li><p>C1 加写锁，C1、C2查询未锁定的表，C1 报错，C2 正常查询</p>
</li>
</ul>
<hr>
<h4 id="锁状态"><a href="#锁状态" class="headerlink" title="锁状态"></a>锁状态</h4><ul>
<li><p>查看锁竞争：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW OPEN TABLES;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E9%94%81%E4%BA%89%E7%94%A8%E6%83%85%E5%86%B5%E6%9F%A5%E7%9C%8B1.png"></p>
<p>In_user：表当前被查询使用的次数，如果该数为零，则表是打开的，但是当前没有被使用</p>
<p>Name_locked：表名称是否被锁定，名称锁定用于取消表或对表进行重命名等操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCK TABLE tb_book READ;	-- 执行命令</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E9%94%81%E4%BA%89%E7%94%A8%E6%83%85%E5%86%B5%E6%9F%A5%E7%9C%8B2.png"></p>
</li>
<li><p>查看锁状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Table_locks%&#x27;;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 锁状态.png)</p>
<p>Table_locks_immediate：指的是能立即获得表级锁的次数，每立即获取锁，值加 1</p>
<p>Table_locks_waited：指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加 1，此值高说明存在着较为严重的表级锁争用情况</p>
</li>
</ul>
<hr>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><h5 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h5><p>InnoDB 与 MyISAM 的最大不同有两点：一是支持事务；二是采用了行级锁，<strong>InnoDB 同时支持表锁和行锁</strong></p>
<p>行级锁，也称为记录锁（Record Lock），InnoDB  实现了以下两种类型的行锁：</p>
<ul>
<li>共享锁 (S)：又称为读锁，简称 S 锁，多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改</li>
<li>排他锁 (X)：又称为写锁，简称 X 锁，不能与其他锁并存，获取排他锁的事务是可以对数据读取和修改</li>
</ul>
<p>RR 隔离界别下，对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会<strong>自动给涉及数据集加排他锁</strong>（行锁），在 commit 时自动释放；对于普通 SELECT 语句，不会加任何锁（只是针对 InnoDB 层来说的，因为在 Server 层会<strong>加 MDL 读锁</strong>），通过 MVCC 防止并发冲突</p>
<p>在事务中加的锁，并不是不需要了就释放，而是在事务中止或提交时自动释放，这个就是<strong>两阶段锁协议</strong>。所以一般将更新共享资源（并发高）的 SQL 放到事务的最后执行，可以让其他线程尽量的减少等待时间</p>
<p>锁的兼容性：</p>
<ul>
<li>共享锁和共享锁     兼容</li>
<li>共享锁和排他锁     冲突</li>
<li>排他锁和排他锁     冲突</li>
<li>排他锁和共享锁     冲突</li>
</ul>
<p>显式给数据集加共享锁或排他锁：<strong>加锁读就是当前读，读取的是最新数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE	-- 共享锁</span><br><span class="line">SELECT * FROM table_name WHERE ... FOR UPDATE			-- 排他锁</span><br></pre></td></tr></table></figure>

<p>注意：<strong>锁默认会锁聚簇索引（锁就是加在索引上）</strong>，但是当使用覆盖索引时，加共享锁只锁二级索引，不锁聚簇索引</p>
<hr>
<h5 id="锁操作-1"><a href="#锁操作-1" class="headerlink" title="锁操作"></a>锁操作</h5><p>两个客户端操作 Client 1和 Client 2，简化为 C1、C2</p>
<ul>
<li><p>环境准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_innodb_lock(</span><br><span class="line">	id INT(11),</span><br><span class="line">	name VARCHAR(16),</span><br><span class="line">	sex VARCHAR(1)</span><br><span class="line">)ENGINE = INNODB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO test_innodb_lock VALUES(1,&#x27;100&#x27;,&#x27;1&#x27;);</span><br><span class="line">-- ..........</span><br><span class="line"></span><br><span class="line">CREATE INDEX idx_test_innodb_lock_id ON test_innodb_lock(id);</span><br><span class="line">CREATE INDEX idx_test_innodb_lock_name ON test_innodb_lock(name);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭自动提交功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET AUTOCOMMIT=0;	-- C1、C2</span><br></pre></td></tr></table></figure>

<p>正常查询数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM test_innodb_lock;	-- C1、C2</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询 id 为 3 的数据，正常查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM test_innodb_lock WHERE id=3;	-- C1、C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁操作1.png)</p>
</li>
<li><p>C1 更新 id 为 3 的数据，但不提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET name=&#x27;300&#x27; WHERE id=3;	-- C1</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁操作2.png)</p>
<p>C2 查询不到 C1 修改的数据，因为隔离界别为 REPEATABLE READ，C1 提交事务，C2 查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMIT;	-- C1</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁操作3.png)</p>
<p>提交后仍然查询不到 C1 修改的数据，因为隔离级别可以防止脏读、不可重复读，所以 C2 需要提交才可以查询到其他事务对数据的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMIT;	-- C2</span><br><span class="line">SELECT * FROM test_innodb_lock WHERE id=3;	-- C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁操作4.png)</p>
</li>
<li><p>C1 更新 id 为 3 的数据，但不提交，C2 也更新 id 为 3 的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET name=&#x27;3&#x27; WHERE id=3;	-- C1</span><br><span class="line">UPDATE test_innodb_lock SET name=&#x27;30&#x27; WHERE id=3;	-- C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁操作5.png)</p>
<p>当 C1 提交，C2 直接解除阻塞，直接更新</p>
</li>
<li><p>操作不同行的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET name=&#x27;10&#x27; WHERE id=1;	-- C1</span><br><span class="line">UPDATE test_innodb_lock SET name=&#x27;30&#x27; WHERE id=3;	-- C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁操作6.png)</p>
<p>由于 C1、C2 操作的不同行，获取不同的行锁，所以都可以正常获取行锁</p>
</li>
</ul>
<hr>
<h4 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h4><h5 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h5><p>InnoDB 会对间隙（GAP）进行加锁，就是间隙锁 （RR 隔离级别下才有该锁）。间隙锁之间不存在冲突关系，<strong>多个事务可以同时对一个间隙加锁</strong>，但是间隙锁会阻止往这个间隙中插入一个记录的操作</p>
<p>InnoDB 加锁的基本单位是 next-key lock，该锁是行锁和 gap lock 的组合（X or S 锁），但是加锁过程是分为间隙锁和行锁两段执行</p>
<ul>
<li>可以<strong>保护当前记录和前面的间隙</strong>，遵循左开右闭原则，单纯的是间隙锁左开右开</li>
<li>假设有 10、11、13，那么可能的间隙锁包括：(负无穷,10]、(10,11]、(11,13]、(13,正无穷)</li>
</ul>
<p>几种索引的加锁情况：</p>
<ul>
<li>唯一索引加锁在值存在时是行锁，next-key lock 会退化为行锁，值不存在会变成间隙锁</li>
<li>普通索引加锁会继续向右遍历到不满足条件的值为止，next-key lock 退化为间隙锁</li>
<li>范围查询无论是否是唯一索引，都需要访问到不满足条件的第一个值为止</li>
<li>对于联合索引且是唯一索引，如果 where 条件只包括联合索引的一部分，那么会加间隙锁</li>
</ul>
<p>间隙锁优点：RR 级别下间隙锁可以解决事务的一部分的<strong>幻读问题</strong>，通过对间隙加锁，可以防止读取过程中数据条目发生变化。一部分的意思是不会对全部间隙加锁，只能加锁一部分的间隙</p>
<p>间隙锁危害：</p>
<ul>
<li>当锁定一个范围的键值后，即使某些不存在的键值也会被无辜的锁定，造成在锁定的时候无法插入锁定键值范围内的任何数据，在某些场景下这可能会对性能造成很大的危害，影响并发度</li>
<li>事务 A B 同时锁住一个间隙后，A 往当前间隙插入数据时会被 B 的间隙锁阻塞，B 也执行插入间隙数据的操作时就会<strong>产生死锁</strong></li>
</ul>
<p>现场演示：</p>
<ul>
<li><p>关闭自动提交功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET AUTOCOMMIT=0;	-- C1、C2</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询数据表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM test_innodb_lock;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 间隙锁1.png)</p>
</li>
<li><p>C1 根据 id 范围更新数据，C2 插入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET name=&#x27;8888&#x27; WHERE id &lt; 4;	-- C1</span><br><span class="line">INSERT INTO test_innodb_lock VALUES(2,&#x27;200&#x27;,&#x27;2&#x27;);		-- C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 间隙锁2.png)</p>
<p>出现间隙锁，C2 被阻塞，等待 C1 提交事务后才能更新</p>
</li>
</ul>
<hr>
<h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p>InnoDB 为了支持多粒度的加锁，允许行锁和表锁同时存在，支持在不同粒度上的加锁操作，InnoDB 增加了意向锁（Intention Lock）</p>
<p>意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁，意向锁分为两种：</p>
<ul>
<li>意向共享锁（IS）：事务有意向对表加共享锁</li>
<li>意向排他锁（IX）：事务有意向对表加排他锁</li>
</ul>
<p><strong>IX，IS 是表级锁</strong>，不会和行级的 X，S 锁发生冲突，意向锁是在加表级锁之前添加，为了在加表级锁时可以快速判断表中是否有记录被上锁，比如向一个表添加表级 X 锁的时：</p>
<ul>
<li>没有意向锁，则需要遍历整个表判断是否有锁定的记录</li>
<li>有了意向锁，首先判断是否存在意向锁，然后判断该意向锁与即将添加的表级锁是否兼容即可，因为意向锁的存在代表有表级锁的存在或者即将有表级锁的存在</li>
</ul>
<p>兼容性如下所示：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%84%8F%E5%90%91%E9%94%81%E5%85%BC%E5%AE%B9%E6%80%A7.png"></p>
<p><strong>插入意向锁</strong> Insert Intention Lock 是在插入一行记录操作之前设置的一种间隙锁，是行级锁</p>
<p>插入意向锁释放了一种插入信号，即多个事务在相同的索引间隙插入时如果不是插入相同的间隙位置就不需要互相等待。假设某列有索引，只要两个事务插入位置不同，如事务 A 插入 3，事务 B 插入 4，那么就可以同时插入</p>
<hr>
<h5 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h5><p>系统会自动给 AUTO_INCREMENT 修饰的列进行递增赋值，实现方式：</p>
<ul>
<li>AUTO_INC 锁：表级锁，执行插入语句时会自动添加，在该语句执行完成后释放，并不是事务结束</li>
<li>轻量级锁：为插入语句生成 AUTO_INCREMENT 修饰的列时获取该锁，生成以后释放掉，不需要等到插入语句执行完后释放</li>
</ul>
<p>系统变量 <code>innodb_autoinc_lock_mode</code> 控制采取哪种方式：</p>
<ul>
<li>0：全部采用 AUTO_INC 锁</li>
<li>1：全部采用轻量级锁</li>
<li>2：混合使用，在插入记录的数量确定时采用轻量级锁，不确定时采用 AUTO_INC 锁</li>
</ul>
<hr>
<h5 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h5><p>一般情况下 INSERT 语句是不需要在内存中生成锁结构的，会进行隐式的加锁，保护的是插入后的安全</p>
<p>注意：如果插入的间隙被其他事务加了间隙锁，此次插入会被阻塞，并在该间隙插入一个插入意向锁</p>
<ul>
<li>聚簇索引：索引记录有 trx_id 隐藏列，表示最后改动该记录的事务 id，插入数据后事务 id 就是当前事务。其他事务想获取该记录的锁时会判断当前记录的事务 id 是否是活跃的，如果不是就可以正常加锁；如果是就创建一个 X 的锁结构，该锁的 is_waiting 是 false，为自己的事务创建一个锁结构，is_waiting 是 true（类似 Java 中的锁升级）</li>
<li>二级索引：获取数据页 Page Header 中的 PAGE_MAX_TRX_ID 属性，代表修改当前页面的最大的事务 ID，如果小于当前活跃的最小事务 id，就证明插入该数据的事务已经提交，否则就需要获取到主键值进行回表操作</li>
</ul>
<p>隐式锁起到了延迟生成锁的效果，如果其他事务与隐式锁没有冲突，就可以避免锁结构的生成，节省了内存资源</p>
<p>INSERT 在两种情况下会生成锁结构：</p>
<ul>
<li><p>重复键：在插入主键或唯一二级索引时遇到重复的键值会报错，在报错前需要对对应的聚簇索引进行加锁</p>
<ul>
<li>隔离级别 &lt;&#x3D; Read Uncommitted，加 S 型 Record Lock</li>
<li>隔离级别 &gt;&#x3D; Repeatable Read，加 S 型 next_key 锁</li>
</ul>
</li>
<li><p>外键检查：如果待插入的记录在父表中可以找到，会对父表的记录加 S 型 Record Lock。如果待插入的记录在父表中找不到</p>
<ul>
<li>隔离级别 &lt;&#x3D; Read Committed，不加锁</li>
<li>隔离级别 &gt;&#x3D; Repeatable Read，加间隙锁</li>
</ul>
</li>
</ul>
<hr>
<h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><h5 id="优化锁"><a href="#优化锁" class="headerlink" title="优化锁"></a>优化锁</h5><p>InnoDB 存储引擎实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高，但是在整体并发处理能力方面要远远优于 MyISAM 的表锁，当系统并发量较高的时候，InnoDB 的整体性能远远好于 MyISAM</p>
<p>但是使用不当可能会让 InnoDB 的整体性能表现不仅不能比 MyISAM 高，甚至可能会更差</p>
<p>优化建议：</p>
<ul>
<li>尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁</li>
<li>合理设计索引，尽量缩小锁的范围</li>
<li>尽可能减少索引条件及索引范围，避免间隙锁</li>
<li>尽量控制事务大小，减少锁定资源量和时间长度</li>
<li>尽可使用低级别事务隔离（需要业务层面满足需求）</li>
</ul>
<hr>
<h5 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h5><p>索引失效造成<strong>行锁升级为表锁</strong>，不通过索引检索数据，全局扫描的过程中 InnoDB 会将对表中的所有记录加锁，实际效果和<strong>表锁</strong>一样，实际开发过程应避免出现索引失效的状况</p>
<ul>
<li><p>查看当前表的索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM test_innodb_lock;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭自动提交功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET AUTOCOMMIT=0;	-- C1、C2</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行更新语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET sex=&#x27;2&#x27; WHERE name=10;	-- C1</span><br><span class="line">UPDATE test_innodb_lock SET sex=&#x27;2&#x27; WHERE id=3;		-- C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁升级.png)</p>
<p>索引失效：执行更新时 name 字段为 varchar 类型，造成索引失效，最终行锁变为表锁</p>
</li>
</ul>
<hr>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>不同事务由于互相持有对方需要的锁而导致事务都无法继续执行的情况称为死锁</p>
<p>死锁情况：线程 A 修改了 id &#x3D; 1 的数据，请求修改 id &#x3D; 2 的数据，线程 B 修改了 id &#x3D; 2 的数据，请求修改 id &#x3D; 1 的数据，产生死锁</p>
<p>解决策略：</p>
<ul>
<li><p>直接进入等待直到超时，超时时间可以通过参数 innodb_lock_wait_timeout 来设置，默认 50 秒，但是时间的设置不好控制，超时可能不是因为死锁，而是因为事务处理比较慢，所以一般不采取该方式</p>
</li>
<li><p>主动死锁检测，发现死锁后<strong>主动回滚死锁链条中较小的一个事务</strong>，让其他事务得以继续执行，将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启该功能（事务较小的意思就是事务执行过程中插入、删除、更新的记录条数）</p>
<p>死锁检测并不是每个语句都要检测，只有在加锁访问的行上已经有锁时，当前事务被阻塞了才会检测，也是从当前事务开始进行检测</p>
</li>
</ul>
<p>通过执行 <code>SHOW ENGINE INNODB STATUS</code> 可以查看最近发生的一次死循环，全局系统变量 <code>innodb_print_all_deadlocks</code> 设置为 on，就可以将每个死锁信息都记录在 MySQL 错误日志中</p>
<p>死锁一般是行级锁，当表锁发生死锁时，会在事务中访问其他表时<strong>直接报错</strong>，破坏了持有并等待的死锁条件</p>
<hr>
<h4 id="锁状态-1"><a href="#锁状态-1" class="headerlink" title="锁状态"></a>锁状态</h4><p>查看锁信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;innodb_row_lock%&#x27;;</span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB 锁争用.png" style="zoom: 80%;">

<p>参数说明：</p>
<ul>
<li><p>Innodb_row_lock_current_waits：当前正在等待锁定的数量</p>
</li>
<li><p>Innodb_row_lock_time：从系统启动到现在锁定总时间长度</p>
</li>
<li><p>Innodb_row_lock_time_avg：每次等待所花平均时长</p>
</li>
<li><p>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间</p>
</li>
<li><p>Innodb_row_lock_waits：系统启动后到现在总共等待的次数</p>
</li>
</ul>
<p>当等待的次数很高，而且每次等待的时长也不短的时候，就需要分析系统中为什么会有如此多的等待，然后根据分析结果制定优化计划</p>
<p>查看锁状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.innodb_locks;	#锁的概况</span><br><span class="line">SHOW ENGINE INNODB STATUS\G; #InnoDB整体状态，其中包括锁的情况</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB%E6%9F%A5%E7%9C%8B%E9%94%81%E7%8A%B6%E6%80%81.png"></p>
<p>lock_id 是锁 id；lock_trx_id 为事务 id；lock_mode 为 X 代表排它锁（写锁）；lock_type 为 RECORD 代表锁为行锁（记录锁）</p>
<hr>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>悲观锁：在整个数据处理过程中，将数据处于锁定状态，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据，修改删除数据时也加锁，其它事务同样无法读取这些数据</p>
<p>悲观锁和乐观锁使用前提：</p>
<ul>
<li>对于读的操作远多于写的操作的时候，一个更新操作加锁会阻塞所有的读取操作，降低了吞吐量，最后需要释放锁，锁是需要一些开销的，这时候可以选择乐观锁</li>
<li>如果是读写比例差距不是非常大或者系统没有响应不及时，吞吐量瓶颈的问题，那就不要去使用乐观锁，它增加了复杂度，也带来了业务额外的风险，这时候可以选择悲观锁</li>
</ul>
<p>乐观锁的实现方式：就是 CAS，比较并交换</p>
<ul>
<li><p>版本号</p>
<ol>
<li><p>给数据表中添加一个 version 列，每次更新后都将这个列的值加 1</p>
</li>
<li><p>读取数据时，将版本号读取出来，在执行更新的时候，比较版本号</p>
</li>
<li><p>如果相同则执行更新，如果不相同，说明此条数据已经发生了变化</p>
</li>
<li><p>用户自行根据这个通知来决定怎么处理，比如重新开始一遍，或者放弃本次更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建city表</span><br><span class="line">CREATE TABLE city(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,  -- 城市id</span><br><span class="line">	NAME VARCHAR(20),                   -- 城市名称</span><br><span class="line">	VERSION INT                         -- 版本号</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO city VALUES (NULL,&#x27;北京&#x27;,1),(NULL,&#x27;上海&#x27;,1),(NULL,&#x27;广州&#x27;,1),(NULL,&#x27;深圳&#x27;,1);</span><br><span class="line"></span><br><span class="line">-- 修改北京为北京市</span><br><span class="line">-- 1.查询北京的version</span><br><span class="line">SELECT VERSION FROM city WHERE NAME=&#x27;北京&#x27;;</span><br><span class="line">-- 2.修改北京为北京市，版本号+1。并对比版本号</span><br><span class="line">UPDATE city SET NAME=&#x27;北京市&#x27;,VERSION=VERSION+1 WHERE NAME=&#x27;北京&#x27; AND VERSION=1;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>时间戳</p>
<ul>
<li>和版本号方式基本一样，给数据表中添加一个列，名称无所谓，数据类型需要是 <strong>timestamp</strong></li>
<li>每次更新后都将最新时间插入到此列</li>
<li>读取数据时，将时间读取出来，在执行更新的时候，比较时间</li>
<li>如果相同则执行更新，如果不相同，说明此条数据已经发生了变化</li>
</ul>
</li>
</ul>
<p>乐观锁的异常情况：如果 version 被其他事务抢先更新，则在当前事务中更新失败，trx_id 没有变成当前事务的 ID，当前事务再次查询还是旧值，就会出现<strong>值没变但是更新不了</strong>的现象（anomaly）</p>
<p>解决方案：每次 CAS 更新不管成功失败，就结束当前事务；如果失败则重新起一个事务进行查询更新</p>
<hr>
<h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><h3 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步</p>
<p>MySQL 支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制</p>
<p>MySQL 复制的优点主要包含以下三个方面：</p>
<ul>
<li><p>主库出现问题，可以快速切换到从库提供服务</p>
</li>
<li><p>可以在从库上执行查询操作，从主库中更新，实现读写分离</p>
</li>
<li><p>可以在从库中执行备份，以避免备份期间影响主库的服务（备份时会加全局读锁）</p>
</li>
</ul>
<hr>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h4 id="主从结构"><a href="#主从结构" class="headerlink" title="主从结构"></a>主从结构</h4><p>MySQL 的主从之间维持了一个<strong>长连接</strong>。主库内部有一个线程，专门用于服务从库的长连接，连接过程：</p>
<ul>
<li>从库执行 change master 命令，设置主库的 IP、端口、用户名、密码以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量</li>
<li>从库执行 start slave 命令，这时从库会启动两个线程，就是图中的 io_thread 和 sql_thread，其中 io_thread 负责与主库建立连接</li>
<li>主库校验完用户名、密码后，开始按照从传过来的位置，从本地读取 binlog 发给从库，开始主从复制</li>
</ul>
<p>主从复制原理图：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E5%9B%BE.jpg"></p>
<p>主从复制主要依赖的是 binlog，MySQL 默认是异步复制，需要三个线程：</p>
<ul>
<li>binlog thread：在主库事务提交时，负责把数据变更记录在二进制日志文件 binlog 中，并通知 slave 有数据更新</li>
<li>I&#x2F;O thread：负责从主服务器上<strong>拉取二进制日志</strong>，并将 binlog 日志内容依次写到 relay log 中转日志的最末端，并将新的 binlog 文件名和 offset 记录到 master-info 文件中，以便下一次读取日志时从指定 binlog 日志文件及位置开始读取新的 binlog 日志内容</li>
<li>SQL thread：监测本地 relay log 中新增了日志内容，读取中继日志并重做其中的 SQL 语句，从库在 relay-log.info 中记录当前应用中继日志的文件名和位点以便下一次执行</li>
</ul>
<p>同步与异步：</p>
<ul>
<li>异步复制有数据丢失风险，例如数据还未同步到从库，主库就给客户端响应，然后主库挂了，此时从库晋升为主库的话数据是缺失的</li>
<li>同步复制，主库需要将 binlog 复制到所有从库，等所有从库响应了之后主库才进行其他逻辑，这样的话性能很差，一般不会选择</li>
<li>MySQL 5.7 之后出现了半同步复制，有参数可以选择成功同步几个从库就返回响应</li>
</ul>
<hr>
<h4 id="主主结构"><a href="#主主结构" class="headerlink" title="主主结构"></a>主主结构</h4><p>主主结构就是两个数据库之间总是互为主从关系，这样在切换的时候就不用再修改主从关系</p>
<p>循环复制：在库 A 上更新了一条语句，然后把生成的 binlog 发给库 B，库 B 执行完这条更新语句后也会生成 binlog，会再发给 A</p>
<p>解决方法：</p>
<ul>
<li>两个库的 server id 必须不同，如果相同则它们之间不能设定为主主关系</li>
<li>一个库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog</li>
<li>每个库在收到从主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志</li>
</ul>
<hr>
<h3 id="主从延迟"><a href="#主从延迟" class="headerlink" title="主从延迟"></a>主从延迟</h3><h4 id="延迟原因"><a href="#延迟原因" class="headerlink" title="延迟原因"></a>延迟原因</h4><p>正常情况主库执行更新生成的所有 binlog，都可以传到从库并被正确地执行，从库就能达到跟主库一致的状态，这就是最终一致性</p>
<p>主从延迟是主从之间是存在一定时间的数据不一致，就是同一个事务在从库执行完成的时间和主库执行完成的时间的差值，即 T2-T1</p>
<ul>
<li>主库 A 执行完成一个事务，写入 binlog，该时刻记为 T1</li>
<li>日志传给从库 B，从库 B 执行完这个事务，该时刻记为 T2</li>
</ul>
<p>通过在从库执行 <code>show slave status</code> 命令，返回结果会显示 seconds_behind_master 表示当前从库延迟了多少秒</p>
<ul>
<li>每一个事务的 binlog 都有一个时间字段，用于记录主库上写入的时间</li>
<li>从库取出当前正在执行的事务的时间字段，跟系统的时间进行相减，得到的就是 seconds_behind_master</li>
</ul>
<p>主从延迟的原因：</p>
<ul>
<li>从库的机器性能比主库的差，导致从库的复制能力弱</li>
<li>从库的查询压力大，建立一主多从的结构</li>
<li>大事务的执行，主库必须要等到事务完成之后才会写入 binlog，导致从节点出现应用 binlog 延迟</li>
<li>主库的 DDL，从库与主库的 DDL 同步是串行进行，DDL 在主库执行时间很长，那么从库也会消耗同样的时间</li>
<li>锁冲突问题也可能导致从节点的 SQL 线程执行慢</li>
</ul>
<p>主从同步问题永远都是<strong>一致性和性能的权衡</strong>，需要根据实际的应用场景，可以采取下面的办法：</p>
<ul>
<li><p>优化 SQL，避免慢 SQL，减少批量操作</p>
</li>
<li><p>降低多线程大事务并发的概率，优化业务逻辑</p>
</li>
<li><p>业务中大多数情况查询操作要比更新操作更多，搭建<strong>一主多从</strong>结构，让这些从库来分担读的压力</p>
</li>
<li><p>尽量采用短的链路，主库和从库服务器的距离尽量要短，提升端口带宽，减少 binlog 传输的网络延时</p>
</li>
<li><p>实时性要求高的业务读强制走主库，从库只做备份</p>
</li>
</ul>
<hr>
<h4 id="并行复制"><a href="#并行复制" class="headerlink" title="并行复制"></a>并行复制</h4><h5 id="MySQL5-6"><a href="#MySQL5-6" class="headerlink" title="MySQL5.6"></a>MySQL5.6</h5><p>高并发情况下，主库的会产生大量的 binlog，在从库中有两个线程 IO Thread 和 SQL Thread 单线程执行，会导致主库延迟变大。为了改善复制延迟问题，MySQL 5.6 版本增加了并行复制功能，以采用多线程机制来促进执行</p>
<p>coordinator 就是原来的 SQL Thread，并行复制中它不再直接更新数据，<strong>只负责读取中转日志和分发事务</strong>：</p>
<ul>
<li>线程分配完成并不是立即执行，为了防止造成更新覆盖，更新同一 DB 的两个事务必须被分发到同一个工作线程</li>
<li>同一个事务不能被拆开，必须放到同一个工作线程</li>
</ul>
<p>MySQL 5.6 版本的策略：每个线程对应一个 hash 表，用于保存当前这个线程的执行队列里的事务所涉及的表，hash 表的 key 是数据库 名，value 是一个数字，表示队列中有多少个事务修改这个库，适用于主库上有多个 DB 的情况</p>
<p>每个事务在分发的时候，跟线程的<strong>冲突</strong>（事务操作的是同一个库）关系包括以下三种情况：</p>
<ul>
<li>如果跟所有线程都不冲突，coordinator 线程就会把这个事务分配给最空闲的线程</li>
<li>如果只跟一个线程冲突，coordinator 线程就会把这个事务分配给这个存在冲突关系的线程</li>
<li>如果跟多于一个线程冲突，coordinator 线程就进入等待状态，直到和这个事务存在冲突关系的线程只剩下 1 个</li>
</ul>
<p>优缺点：</p>
<ul>
<li>构造 hash 值的时候很快，只需要库名，而且一个实例上 DB 数也不会很多，不会出现需要构造很多个项的情况</li>
<li>不要求 binlog 的格式，statement 格式的 binlog 也可以很容易拿到库名（日志章节详解了 binlog）</li>
<li>主库上的表都放在同一个 DB 里面，这个策略就没有效果了；或者不同 DB 的热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果，需要<strong>把相同热度的表均匀分到这些不同的 DB 中</strong>，才可以使用这个策略</li>
</ul>
<hr>
<h5 id="MySQL5-7"><a href="#MySQL5-7" class="headerlink" title="MySQL5.7"></a>MySQL5.7</h5><p>MySQL 5.7 由参数 slave-parallel-type 来控制并行复制策略：</p>
<ul>
<li>配置为 DATABASE，表示使用 MySQL 5.6 版本的<strong>按库（DB）并行策略</strong></li>
<li>配置为 LOGICAL_CLOCK，表示的<strong>按提交状态并行</strong>执行</li>
</ul>
<p>按提交状态并行复制策略的思想是：</p>
<ul>
<li>所有处于 commit 状态的事务可以并行执行；同时处于 prepare 状态的事务，在从库执行时是可以并行的</li>
<li>处于 prepare 状态的事务，与处于 commit 状态的事务之间，在从库执行时也是可以并行的</li>
</ul>
<p>MySQL 5.7.22 版本里，MySQL 增加了一个新的并行复制策略，基于 WRITESET 的并行复制，新增了一个参数 binlog-transaction-dependency-tracking，用来控制是否启用这个新策略：</p>
<ul>
<li><p>COMMIT_ORDER：表示根据同时进入 prepare 和 commit 来判断是否可以并行的策略</p>
</li>
<li><p>WRITESET：表示的是对于每个事务涉及更新的每一行，计算出这一行的 hash 值，组成该事务的 writeset 集合，如果两个事务没有操作相同的行，也就是说它们的 writeset 没有交集，就可以并行（<strong>按行并行</strong>）</p>
<p>为了唯一标识，这个 hash 表的值是通过 <code>库名 + 表名 + 索引名 + 值</code>（表示的是某一行）计算出来的</p>
</li>
<li><p>WRITESET_SESSION：是在 WRITESET 的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序</p>
</li>
</ul>
<p>MySQL 5.7.22 按行并发的优势：</p>
<ul>
<li>writeset 是在主库生成后直接写入到 binlog 里面的，这样在备库执行的时候，不需要解析 binlog 内容，节省了计算量</li>
<li>不需要把整个事务的 binlog 都扫一遍才能决定分发到哪个线程，更省内存</li>
<li>从库的分发策略不依赖于 binlog 内容，所以 binlog 是 statement 格式也可以，更节约内存（因为 row 才记录更改的行）</li>
</ul>
<p>MySQL 5.7.22 的并行复制策略在通用性上是有保证的，但是对于表上没主键、唯一和外键约束的场景，WRITESET 策略也是没法并行的，也会暂时退化为单线程模型</p>
<p>参考文章：<a href="https://time.geekbang.org/column/article/77083">https://time.geekbang.org/column/article/77083</a></p>
<hr>
<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><h4 id="读写延迟"><a href="#读写延迟" class="headerlink" title="读写延迟"></a>读写延迟</h4><p>读写分离：可以降低主库的访问压力，提高系统的并发能力</p>
<ul>
<li>主库不建查询的索引，从库建查询的索引。因为索引需要维护的，比如插入一条数据，不仅要在聚簇索引上面插入，对应的二级索引也得插入</li>
<li>将读操作分到从库了之后，可以在主库把查询要用的索引删了，减少写操作对主库的影响</li>
</ul>
<p>读写分离产生了读写延迟，造成数据的不一致性。假如客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，可能读到的还是以前的数据，叫过期读</p>
<p>解决方案：</p>
<ul>
<li>强制将写之后<strong>立刻读的操作转移到主库</strong>，比如刚注册的用户，直接登录从库查询可能查询不到，先走主库登录</li>
<li><strong>二次查询</strong>，如果从库查不到数据，则再去主库查一遍，由 API 封装，比较简单，但导致主库压力大</li>
<li>更新主库后，读从库之前先 sleep 一下，类似于执行一条 <code>select sleep(1)</code> 命令，大多数情况下主备延迟在 1 秒之内</li>
</ul>
<hr>
<h4 id="确保机制"><a href="#确保机制" class="headerlink" title="确保机制"></a>确保机制</h4><h5 id="无延迟"><a href="#无延迟" class="headerlink" title="无延迟"></a>无延迟</h5><p>确保主备无延迟的方法：</p>
<ul>
<li>每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0，如果不等于那就等到参数变为 0 执行查询请求</li>
<li>对比位点，Master_Log_File 和 Read_Master_Log_Pos 表示的是读到的主库的最新位点，Relay_Master_Log_File 和 Exec_Master_Log_Pos 表示的是备库执行的最新位点，这两组值完全相同就说明接收到的日志已经同步完成</li>
<li>对比 GTID 集合，Retrieved_Gtid_Set 是备库收到的所有日志的 GTID 集合，Executed_Gtid_Set 是备库所有已经执行完成的 GTID 集合，如果这两个集合相同也表示备库接收到的日志都已经同步完成</li>
</ul>
<hr>
<h5 id="半同步"><a href="#半同步" class="headerlink" title="半同步"></a>半同步</h5><p>半同步复制就是 semi-sync replication，适用于一主一备的场景，工作流程：</p>
<ul>
<li>事务提交的时候，主库把 binlog 发给从库</li>
<li>从库收到 binlog 以后，发回给主库一个 ack，表示收到了</li>
<li>主库收到这个 ack 以后，才能给客户端返回事务完成的确认</li>
</ul>
<p>在一主多从场景中，主库只要等到一个从库的 ack，就开始给客户端返回确认，这时在从库上执行查询请求，有两种情况：</p>
<ul>
<li>如果查询是落在这个响应了 ack 的从库上，是能够确保读到最新数据</li>
<li>如果查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题</li>
</ul>
<p>在业务更新的高峰期，主库的位点或者 GTID 集合更新很快，导致从库来不及处理，那么两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况</p>
<hr>
<h5 id="等位点"><a href="#等位点" class="headerlink" title="等位点"></a>等位点</h5><p>在<strong>从库执行判断位点</strong>的命令，参数 file 和 pos 指的是主库上的文件名和位置，timeout 可选，设置为正整数 N 表示最多等待 N 秒</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT master_pos_wait(file, pos[, timeout]);</span><br></pre></td></tr></table></figure>

<p>命令正常返回的结果是一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务</p>
<ul>
<li>如果执行期间，备库同步线程发生异常，则返回 NULL</li>
<li>如果等待超过 N 秒，就返回 -1</li>
<li>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回 0</li>
</ul>
<p>工作流程：先执行 trx1，再执行一个查询请求的逻辑，要<strong>保证能够查到正确的数据</strong></p>
<ul>
<li>trx1 事务更新完成后，马上执行 <code>show master status</code> 得到当前主库执行到的 File 和 Position</li>
<li>选定一个从库执行判断位点语句，如果返回值是 &gt;&#x3D;0 的正整数，说明从库已经同步完事务，可以在这个从库执行查询语句</li>
<li>如果出现其他情况，需要到主库执行查询语句</li>
</ul>
<p>注意：如果所有的从库都延迟超过 timeout  秒，查询压力就都跑到主库上，所以需要进行权衡</p>
<hr>
<h5 id="等GTID"><a href="#等GTID" class="headerlink" title="等GTID"></a>等GTID</h5><p>数据库开启了 GTID 模式，MySQL 提供了判断 GTID 的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT wait_for_executed_gtid_set(gtid_set [, timeout])</span><br></pre></td></tr></table></figure>

<ul>
<li>等待直到这个库执行的事务中包含传入的 gtid_set，返回 0</li>
<li>超时返回 1</li>
</ul>
<p>工作流程：先执行 trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据</p>
<ul>
<li>trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid</li>
<li>选定一个从库执行查询语句，如果返回值是 0，则在这个从库执行查询语句，否则到主库执行查询语句</li>
</ul>
<p>对比等待位点方法，减少了一次 <code>show master status</code> 的方法，将参数 session_track_gtids 设置为 OWN_GTID，然后通过 API 接口 mysql_session_track_get_first 从返回包解析出 GTID 的值即可</p>
<p>总结：所有的等待无延迟的方法，都需要根据具体的业务场景去判断实施</p>
<p>参考文章：<a href="https://time.geekbang.org/column/article/77636">https://time.geekbang.org/column/article/77636</a></p>
<hr>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>负载均衡是应用中使用非常普遍的一种优化方法，机制就是利用某种均衡算法，将固定的负载量分布到不同的服务器上，以此来降低单台服务器的负载，达到优化的效果</p>
<ul>
<li><p>分流查询：通过 MySQL 的主从复制，实现读写分离，使增删改操作走主节点，查询操作走从节点，从而可以降低单台服务器的读写压力</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.jpg"></p>
</li>
<li><p>分布式数据库架构：适合大数据量、负载高的情况，具有良好的拓展性和高可用性。通过在多台服务器之间分布数据，可以实现在多台服务器之间的负载均衡，提高访问效率</p>
</li>
</ul>
<hr>
<h3 id="主从搭建"><a href="#主从搭建" class="headerlink" title="主从搭建"></a>主从搭建</h3><h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><ol>
<li><p>在master 的配置文件（&#x2F;etc&#x2F;mysql&#x2F;my.cnf）中，配置如下内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mysql 服务ID,保证整个集群环境中唯一</span></span><br><span class="line">server-id=1</span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql binlog 日志的存储路径和文件名</span></span><br><span class="line">log-bin=/var/lib/mysql/mysqlbin</span><br><span class="line"></span><br><span class="line"><span class="comment">#错误日志,默认已经开启</span></span><br><span class="line"><span class="comment">#log-err</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql的安装目录</span></span><br><span class="line"><span class="comment">#basedir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql的临时目录</span></span><br><span class="line"><span class="comment">#tmpdir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql的数据存放目录</span></span><br><span class="line"><span class="comment">#datadir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否只读,1 代表只读, 0 代表读写</span></span><br><span class="line">read-only=0</span><br><span class="line"></span><br><span class="line"><span class="comment">#忽略的数据, 指不需要同步的数据库</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定同步的数据库</span></span><br><span class="line"><span class="comment">#binlog-do-db=db01</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行完毕之后，需要重启 MySQL</p>
</li>
<li><p>创建同步数据的账户，并且进行授权操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;seazean&#x27;@&#x27;192.168.0.137&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 master 状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW MASTER STATUS;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%9F%A5%E7%9C%8Bmaster%E7%8A%B6%E6%80%81.jpg"></p>
<ul>
<li>File：从哪个日志文件开始推送日志文件 </li>
<li>Position：从哪个位置开始推送日志</li>
<li>Binlog_Ignore_DB：指定不需要同步的数据库</li>
</ul>
</li>
</ol>
<hr>
<h4 id="slave"><a href="#slave" class="headerlink" title="slave"></a>slave</h4><ol>
<li><p>在 slave 端配置文件中，配置如下内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mysql服务端ID,唯一</span></span><br><span class="line">server-id=2</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定binlog日志</span></span><br><span class="line">log-bin=/var/lib/mysql/mysqlbin</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行完毕之后，需要重启 MySQL</p>
</li>
<li><p>指定当前从库对应的主库的IP地址、用户名、密码，从哪个日志文件开始的那个位置开始同步推送日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST= &#x27;192.168.0.138&#x27;, MASTER_USER=&#x27;seazean&#x27;, MASTER_PASSWORD=&#x27;seazean&#x27;, MASTER_LOG_FILE=&#x27;mysqlbin.000001&#x27;, MASTER_LOG_POS=413;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启同步操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START SLAVE;</span><br><span class="line">SHOW SLAVE STATUS;</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止同步操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STOP SLAVE;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ol>
<li><p>在主库中创建数据库，创建表并插入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE db01;</span><br><span class="line">USE db01;</span><br><span class="line">CREATE TABLE user(</span><br><span class="line">	id INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">	name VARCHAR(50) NOT NULL,</span><br><span class="line">	sex VARCHAR(1),</span><br><span class="line">	PRIMARY KEY (id)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO user(id,NAME,sex) VALUES(NULL,&#x27;Tom&#x27;,&#x27;1&#x27;);</span><br><span class="line">INSERT INTO user(id,NAME,sex) VALUES(NULL,&#x27;Trigger&#x27;,&#x27;0&#x27;);</span><br><span class="line">INSERT INTO user(id,NAME,sex) VALUES(NULL,&#x27;Dawn&#x27;,&#x27;1&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在从库中查询数据，进行验证：</p>
<p>在从库中，可以查看到刚才创建的数据库：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%AA%8C%E8%AF%811.jpg"></p>
<p>在该数据库中，查询表中的数据：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%AA%8C%E8%AF%812.jpg"></p>
</li>
</ol>
<hr>
<h3 id="主从切换"><a href="#主从切换" class="headerlink" title="主从切换"></a>主从切换</h3><h4 id="正常切换"><a href="#正常切换" class="headerlink" title="正常切换"></a>正常切换</h4><p>正常切换步骤：</p>
<ul>
<li><p>在开始切换之前先对主库进行锁表 <code>flush tables with read lock</code>，然后等待所有语句执行完成，切换完成后可以释放锁</p>
</li>
<li><p>检查 slave 同步状态，在 slave 执行 <code>show processlist</code></p>
</li>
<li><p>停止 slave io 线程，执行命令 <code>STOP SLAVE IO_THREAD</code></p>
</li>
<li><p>提升 slave 为 master</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Stop slave;</span><br><span class="line">Reset master;</span><br><span class="line">Reset slave <span class="keyword">all</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> read_only<span class="operator">=</span>off;	<span class="comment">-- 设置为可更新状态</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将原来 master 变为 slave（参考搭建流程中的 slave 方法）</p>
</li>
</ul>
<p><strong>可靠性优先策略</strong>：</p>
<ul>
<li>判断备库 B 现在的 seconds_behind_master，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步</li>
<li>把主库 A 改成只读状态，即把 readonly 设置为 true</li>
<li>判断备库 B 的 seconds_behind_master 的值，直到这个值变成 0 为止（该步骤比较耗时，所以步骤 1 中要尽量等待该值变小）</li>
<li>把备库 B 改成可读写状态，也就是把 readonly 设置为 false</li>
<li>把业务请求切到备库 B</li>
</ul>
<p>可用性优先策略：先做最后两步，会造成主备数据不一致的问题</p>
<p>参考文章：<a href="https://time.geekbang.org/column/article/76795">https://time.geekbang.org/column/article/76795</a></p>
<hr>
<h4 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h4><p>主库发生故障后从库会上位，<strong>其他从库指向新的主库</strong>，所以需要一个健康检测的机制来判断主库是否宕机</p>
<ul>
<li><p>select 1 判断，但是高并发下检测不出线程的锁等待的阻塞问题</p>
</li>
<li><p>查表判断，在系统库（mysql 库）里创建一个表，比如命名为 health_check，里面只放一行数据，然后定期执行。但是当 binlog 所在磁盘的空间占用率达到 100%，所有的更新和事务提交语句都被阻塞，查询语句可以继续运行</p>
</li>
<li><p>更新判断，在健康检测表中放一个 timestamp 字段，用来表示最后一次执行检测的时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE mysql.health_check SET t_modified=now();</span><br></pre></td></tr></table></figure>

<p>节点可用性的检测都应该包含主库和备库，为了让主备之间的更新不产生冲突，可以在 mysql.health_check 表上存入多行数据，并用主备的 server_id 做主键，保证主、备库各自的检测命令不会发生冲突</p>
</li>
</ul>
<hr>
<h4 id="基于位点"><a href="#基于位点" class="headerlink" title="基于位点"></a>基于位点</h4><p>主库上位后，从库 B 执行 CHANGE MASTER TO 命令，指定 MASTER_LOG_FILE、MASTER_LOG_POS 表示从新主库 A 的哪个文件的哪个位点开始同步，这个位置就是<strong>同步位点</strong>，对应主库的文件名和日志偏移量</p>
<p>寻找位点需要找一个稍微往前的，然后再通过判断跳过那些在从库 B 上已经执行过的事务，获取位点方法：</p>
<ul>
<li>等待新主库 A 把中转日志（relay log）全部同步完成</li>
<li>在 A 上执行 show master status 命令，得到当前 A 上最新的 File 和 Position</li>
<li>取原主库故障的时刻 T，用 mysqlbinlog 工具解析新主库 A 的 File，得到 T 时刻的位点</li>
</ul>
<p>通常情况下该值并不准确，在切换的过程中会发生错误，所以要先主动跳过这些错误：</p>
<ul>
<li><p>切换过程中，可能会重复执行一个事务，所以需要主动跳过所有重复的事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL sql_slave_skip_counter=1;</span><br><span class="line">START SLAVE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 slave_skip_errors 参数，直接设置跳过指定的错误，保证主从切换的正常进行</p>
<ul>
<li>1062 错误是插入数据时唯一键冲突</li>
<li>1032 错误是删除数据时找不到行</li>
</ul>
<p>该方法针对的是主备切换时，由于找不到精确的同步位点，只能采用这种方法来创建从库和新主库的主备关系。等到主备间的同步关系建立完成并稳定执行一段时间后，还需要把这个参数设置为空，以免真的出现了主从数据不一致也跳过了</p>
</li>
</ul>
<hr>
<h4 id="基于GTID"><a href="#基于GTID" class="headerlink" title="基于GTID"></a>基于GTID</h4><h5 id="GTID"><a href="#GTID" class="headerlink" title="GTID"></a>GTID</h5><p>GTID 的全称是 Global Transaction Identifier，全局事务 ID，是一个事务<strong>在提交时生成</strong>的，是这个事务的唯一标识，组成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GTID=source_id:transaction_id</span><br></pre></td></tr></table></figure>

<ul>
<li>source_id：是一个实例第一次启动时自动生成的，是一个全局唯一的值</li>
<li>transaction_id：初始值是 1，每次提交事务的时候分配给这个事务，并加 1，是连续的（区分事务 ID，事务 ID 是在执行时生成）</li>
</ul>
<p>启动 MySQL 实例时，加上参数 <code>gtid_mode=on</code> 和 <code>enforce_gtid_consistency=on</code> 就可以启动 GTID 模式，每个事务都会和一个 GTID 一一对应，每个 MySQL 实例都维护了一个 GTID 集合，用来存储当前实例<strong>执行过的所有事务</strong></p>
<p>GTID 有两种生成方式，使用哪种方式取决于 session 变量 gtid_next：</p>
<ul>
<li><p><code>gtid_next=automatic</code>：使用默认值，把 source_id:transaction_id （递增）分配给这个事务，然后加入本实例的 GTID 集合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@@SESSION.GTID_NEXT = &#x27;source_id:transaction_id&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>gtid_next=GTID</code>：指定的 GTID 的值，如果该值已经存在于实例的 GTID 集合中，接下来执行的事务会直接被系统忽略；反之就将该值分配给接下来要执行的事务，系统不需要给这个事务生成新的 GTID，也不用加 1</p>
<p>注意：一个 GTID 只能给一个事务使用，所以执行下一个事务，要把 gtid_next 设置成另外一个 GTID 或者 automatic</p>
</li>
</ul>
<p>业务场景：</p>
<ul>
<li><p>主库 X 和从库 Y 执行一条相同的指令后进行事务同步</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO t VALUES(1,1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>当 Y 同步 X 时，会出现主键冲突，导致实例 X 的同步线程停止，解决方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET gtid_next=&#x27;(这里是主库 X 的 GTID 值)&#x27;;</span><br><span class="line">BEGIN;</span><br><span class="line">COMMIT;</span><br><span class="line">SET gtid_next=automatic;</span><br><span class="line">START SLAVE;</span><br></pre></td></tr></table></figure>

<p>前三条语句通过<strong>提交一个空事务</strong>，把 X 的 GTID 加到实例 Y 的 GTID 集合中，实例 Y 就会直接跳过这个事务</p>
</li>
</ul>
<hr>
<h5 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h5><p>在 GTID 模式下，CHANGE MASTER TO 不需要指定日志名和日志偏移量，指定 <code>master_auto_position=1</code> 代表使用 GTID 模式</p>
<p>新主库实例 A 的 GTID 集合记为 set_a，从库实例 B 的 GTID 集合记为 set_b，主备切换逻辑：</p>
<ul>
<li>实例 B 指定主库 A，基于主备协议建立连接，实例 B 并把 set_b 发给主库 A</li>
<li>实例 A 算出 set_a 与 set_b 的差集，就是所有存在于 set_a 但不存在于 set_b 的 GTID 的集合，判断 A 本地是否包含了这个<strong>差集</strong>需要的所有 binlog 事务<ul>
<li>如果不包含，表示 A 已经把实例 B 需要的 binlog 给删掉了，直接返回错误</li>
<li>如果确认全部包含，A 从自己的 binlog 文件里面，找出第一个不在 set_b 的事务，发给 B</li>
</ul>
</li>
<li>实例 A 之后就从这个事务开始，往后读文件，按顺序取 binlog 发给 B 去执行</li>
</ul>
<p>参考文章：<a href="https://time.geekbang.org/column/article/77427">https://time.geekbang.org/column/article/77427</a></p>
<hr>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h3><p>在任何一种数据库中，都会有各种各样的日志，记录着数据库工作的过程，可以帮助数据库管理员追踪数据库曾经发生过的各种事件</p>
<p>MySQL日志主要包括六种：</p>
<ol>
<li>重做日志（redo log）</li>
<li>回滚日志（undo log）</li>
<li>归档日志（binlog）（二进制日志）</li>
<li>错误日志（errorlog）</li>
<li>慢查询日志（slow query log）</li>
<li>一般查询日志（general log）</li>
<li>中继日志（relay log）</li>
</ol>
<hr>
<h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志是 MySQL 中最重要的日志之一，记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，可以首先查看此日志</p>
<p>该日志是默认开启的，默认位置是：<code>/var/log/mysql/error.log</code></p>
<p>查看指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;log_error%&#x27;;</span><br></pre></td></tr></table></figure>

<p>查看日志内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f /var/log/mysql/error.log</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="归档日志"><a href="#归档日志" class="headerlink" title="归档日志"></a>归档日志</h3><h4 id="基本介绍-10"><a href="#基本介绍-10" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>归档日志（BINLOG）也叫二进制日志，是因为采用二进制进行存储，记录了所有的 DDL（数据定义语言）语句和 DML（数据操作语言）语句，但<strong>不包括数据查询语句，在事务提交前的最后阶段写入</strong></p>
<p>作用：<strong>灾难时的数据恢复和 MySQL 的主从复制</strong></p>
<p>归档日志默认情况下是没有开启的，需要在 MySQL 配置文件中开启，并配置 MySQL 日志的格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/mysql</span><br><span class="line">vim my.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如: mysqlbin.000001</span></span><br><span class="line">log_bin=mysqlbin</span><br><span class="line"><span class="comment"># 配置二进制日志的格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br></pre></td></tr></table></figure>

<p>日志存放位置：配置时给定了文件名但是没有指定路径，日志默认写入MySQL 的数据目录</p>
<p>日志格式：</p>
<ul>
<li><p>STATEMENT：该日志格式在日志文件中记录的都是 <strong>SQL 语句</strong>，每一条对数据进行修改的 SQL 都会记录在日志文件中，通过 mysqlbinlog 工具，可以查看到每条语句的文本。主从复制时，从库会将日志解析为原语句，并在从库重新执行一遍</p>
<p>缺点：可能会导致主备不一致，因为记录的 SQL 在不同的环境中可能选择的索引不同，导致结果不同</p>
</li>
<li><p>ROW：该日志格式在日志文件中记录的是每一行的<strong>数据变更</strong>，而不是记录 SQL 语句。比如执行 SQL 语句 <code>update tb_book set status=&#39;1&#39;</code>，如果是 STATEMENT，在日志中会记录一行 SQL 语句； 如果是 ROW，由于是对全表进行更新，就是每一行记录都会发生变更，ROW 格式的日志中会记录每一行的数据变更</p>
<p>缺点：记录的数据比较多，占用很多的存储空间</p>
</li>
<li><p>MIXED：这是 MySQL 默认的日志格式，混合了STATEMENT 和 ROW 两种格式，MIXED 格式能尽量利用两种模式的优点，而避开它们的缺点</p>
</li>
</ul>
<hr>
<h4 id="日志刷盘-1"><a href="#日志刷盘-1" class="headerlink" title="日志刷盘"></a>日志刷盘</h4><p>事务执行过程中，先将日志写（write）到 binlog cache，事务提交时再把 binlog cache 写（fsync）到 binlog 文件中，一个事务的 binlog 是不能被拆开的，所以不论这个事务多大也要确保一次性写入</p>
<p>事务提交时执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache</p>
<p>write 和 fsync 的时机由参数 sync_binlog 控制的：</p>
<ul>
<li>sync_binlog&#x3D;0：表示每次提交事务都只 write，不 fsync</li>
<li>sync_binlog&#x3D;1：表示每次提交事务都会执行 fsync</li>
<li>sync_binlog&#x3D;N(N&gt;1)：表示每次提交事务都 write，但累积 N 个事务后才 fsync，但是如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志</li>
</ul>
<hr>
<h4 id="日志读取"><a href="#日志读取" class="headerlink" title="日志读取"></a>日志读取</h4><p>日志文件存储位置：&#x2F;var&#x2F;lib&#x2F;mysql</p>
<p>由于日志以二进制方式存储，不能直接读取，需要用 mysqlbinlog 工具来查看，语法如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlbinlog log-file;</span><br></pre></td></tr></table></figure>

<p>查看 STATEMENT 格式日志：</p>
<ul>
<li><p>执行插入语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb_book VALUES(NULL,&#x27;Lucene&#x27;,&#x27;2088-05-01&#x27;,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>cd /var/lib/mysql</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-rw-r-----  1 mysql mysql      177 5月  23 21:08 mysqlbin.000001</span><br><span class="line">-rw-r-----  1 mysql mysql       18 5月  23 21:04 mysqlbin.index</span><br></pre></td></tr></table></figure>

<p>mysqlbin.index：该文件是日志索引文件 ， 记录日志的文件名；</p>
<p>mysqlbing.000001：日志文件</p>
</li>
<li><p>查看日志内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlbinlog mysqlbing.000001;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%961.png"></p>
<p>日志结尾有 COMMIT</p>
</li>
</ul>
<p>查看 ROW 格式日志：</p>
<ul>
<li><p>修改配置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置二进制日志的格式</span></span><br><span class="line">binlog_format=ROW</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb_book VALUES(NULL,&#x27;SpringCloud实战&#x27;,&#x27;2088-05-05&#x27;,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看日志内容：日志格式 ROW，直接查看数据是乱码，可以在 mysqlbinlog 后面加上参数 -vv </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqlbinlog -vv mysqlbin.000002</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%962.png"></p>
</li>
</ul>
<hr>
<h4 id="日志删除"><a href="#日志删除" class="headerlink" title="日志删除"></a>日志删除</h4><p>对于比较繁忙的系统，生成日志量大，这些日志如果长时间不清除，将会占用大量的磁盘空间，需要删除日志</p>
<ul>
<li><p>Reset Master 指令删除全部 binlog 日志，删除之后，日志编号将从 xxxx.000001重新开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reset Master	-- MySQL指令</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行指令 <code>PURGE MASTER LOGS TO &#39;mysqlbin.***</code>，该命令将删除 <code> ***</code> 编号之前的所有日志</p>
</li>
<li><p>执行指令 <code>PURGE MASTER LOGS BEFORE &#39;yyyy-mm-dd hh:mm:ss&#39;</code> ，该命令将删除日志为 <code>yyyy-mm-dd hh:mm:ss</code> 之前产生的日志</p>
</li>
<li><p>设置参数 <code>--expire_logs_days=#</code>，此参数的含义是设置日志的过期天数，过了指定的天数后日志将会被自动删除，这样做有利于减少管理日志的工作量，配置 my.cnf 文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">log_bin=mysqlbin</span><br><span class="line">binlog_format=ROW</span><br><span class="line">--expire_logs_days=3</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="数据恢复-1"><a href="#数据恢复-1" class="headerlink" title="数据恢复"></a>数据恢复</h4><p>误删库或者表时，需要根据 binlog 进行数据恢复</p>
<p>一般情况下数据库有定时的全量备份，假如每天 0 点定时备份，12 点误删了库，恢复流程：</p>
<ul>
<li>取最近一次全量备份，用备份恢复出一个临时库</li>
<li>从日志文件中取出凌晨 0 点之后的日志</li>
<li>把除了误删除数据的语句外日志，全部应用到临时库</li>
</ul>
<p>跳过误删除语句日志的方法：</p>
<ul>
<li>如果原实例没有使用 GTID 模式，只能在应用到包含 12 点的 binlog 文件的时候，先用 –stop-position 参数执行到误操作之前的日志，然后再用 –start-position 从误操作之后的日志继续执行</li>
<li>如果实例使用了 GTID 模式，假设误操作命令的 GTID 是 gtid1，那么只需要提交一个空事务先将这个 GTID 加到临时实例的 GTID 集合，之后按顺序执行 binlog 的时就会自动跳过误操作的语句</li>
</ul>
<hr>
<h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的 SQL 语句</p>
<p>默认情况下，查询日志是未开启的。如果需要开启查询日志，配置 my.cnf：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该选项用来开启查询日志，可选值0或者1，0代表关闭，1代表开启 </span></span><br><span class="line">general_log=1</span><br><span class="line"><span class="comment"># 设置日志的文件名，如果没有指定，默认的文件名为host_name.log，存放在/var/lib/mysql</span></span><br><span class="line">general_log_file=mysql_query.log</span><br></pre></td></tr></table></figure>

<p>配置完毕之后，在数据库执行以下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tb_book;</span><br><span class="line">SELECT * FROM tb_book WHERE id = 1;</span><br><span class="line">UPDATE tb_book SET name = &#x27;lucene入门指南&#x27; WHERE id = 5;</span><br><span class="line">SELECT * FROM tb_book WHERE id &lt; 8</span><br></pre></td></tr></table></figure>

<p>执行完毕之后， 再次来查询日志文件：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97.png"></p>
<hr>
<h3 id="慢日志"><a href="#慢日志" class="headerlink" title="慢日志"></a>慢日志</h3><p>慢查询日志记录所有执行时间超过 long_query_time 并且扫描记录数不小于 min_examined_row_limit 的所有的 SQL 语句的日志long_query_time 默认为 10 秒，最小为 0， 精度到微秒</p>
<p>慢查询日志默认是关闭的，可以通过两个参数来控制慢查询日志，配置文件 <code>/etc/mysql/my.cnf</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该参数用来控制慢查询日志是否开启，可选值0或者1，0代表关闭，1代表开启 </span></span><br><span class="line">slow_query_log=1 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 该参数用来指定慢查询日志的文件名，存放在 /var/lib/mysql</span></span><br><span class="line">slow_query_log_file=slow_query.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该选项用来配置查询的时间限制，超过这个时间将认为值慢查询，将需要进行日志记录，默认10s</span></span><br><span class="line">long_query_time=10</span><br></pre></td></tr></table></figure>

<p>日志读取：</p>
<ul>
<li><p>直接通过 cat 指令查询该日志文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> slow_query.log</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%85%A2%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%961.png"></p>
</li>
<li><p>如果慢查询日志内容很多，直接查看文件比较繁琐，可以借助 mysql 自带的 mysqldumpslow 工具对慢查询日志进行分类汇总：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqldumpslow slow_query.log</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%85%A2%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%962.png"></p>
</li>
</ul>
<hr>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>建立科学的，<strong>规范的数据表</strong>就需要满足一些规则来优化数据的设计和存储，这些规则就称为范式</p>
<p><strong>1NF：</strong>数据库表的每一列都是不可分割的原子数据项，不能是集合、数组等非原子数据项。即表中的某个列有多个值时，必须拆分为不同的列。简而言之，<strong>第一范式每一列不可再拆分，称为原子性</strong></p>
<p>基本表：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E6%99%AE%E9%80%9A%E8%A1%A8.png"></p>
<p>第一范式表：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F.png"></p>
<hr>
<h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p><strong>2NF：</strong>在满足第一范式的基础上，非主属性完全依赖于主码（主关键字、主键），消除非主属性对主码的部分函数依赖。简而言之，<strong>表中的每一个字段 （所有列）都完全依赖于主键，记录的唯一性</strong></p>
<p>作用：遵守第二范式减少数据冗余，通过主键区分相同数据。</p>
<ol>
<li>函数依赖：A → B，如果通过 A 属性(属性组)的值，可以确定唯一 B 属性的值，则称 B 依赖于 A<ul>
<li>学号 → 姓名；(学号，课程名称) → 分数</li>
</ul>
</li>
<li>完全函数依赖：A → B，如果A是一个属性组，则 B 属性值的确定需要依赖于 A 属性组的所有属性值<ul>
<li>(学号，课程名称) → 分数</li>
</ul>
</li>
<li>部分函数依赖：A → B，如果 A 是一个属性组，则 B 属性值的确定只需要依赖于 A 属性组的某些属性值<ul>
<li>(学号，课程名称) → 姓名</li>
</ul>
</li>
<li>传递函数依赖：A → B，B → C，如果通过A属性(属性组)的值，可以确定唯一 B 属性的值，在通过 B 属性(属性组)的值，可以确定唯一 C 属性的值，则称 C 传递函数依赖于 A<ul>
<li>学号 → 系名，系名 → 系主任</li>
</ul>
</li>
<li>码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码<ul>
<li>该表中的码：(学号，课程名称)</li>
<li>主属性：码属性组中的所有属性</li>
<li>非主属性：除码属性组以外的属性</li>
</ul>
</li>
</ol>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F.png"></p>
<hr>
<h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p><strong>3NF：</strong>在满足第二范式的基础上，表中的任何属性不依赖于其它非主属性，消除传递依赖。简而言之，<strong>非主键都直接依赖于主键，而不是通过其它的键来间接依赖于主键</strong>。</p>
<p>作用：可以通过主键 id 区分相同数据，修改数据的时候只需要修改一张表（方便修改），反之需要修改多表。</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F.png"></p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F.png"></p>
<hr>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>NoSQL（Not-Only SQL）：泛指非关系型的数据库，作为关系型数据库的补充</p>
<p>MySQL 支持 ACID 特性，保证可靠性和持久性，读取性能不高，因此需要缓存的来减缓数据库的访问压力</p>
<p>作用：应对基于海量用户和海量数据前提下的数据处理问题</p>
<p>特征：</p>
<ul>
<li>可扩容，可伸缩，SQL 数据关系过于复杂，Nosql 不存关系，只存数据</li>
<li>大数据量下高性能，数据不存取在磁盘 IO，存取在内存</li>
<li>灵活的数据模型，设计了一些数据存储格式，能保证效率上的提高</li>
<li>高可用，集群</li>
</ul>
<p>常见的 NoSQL：Redis、memcache、HBase、MongoDB</p>
<p>参考书籍：<a href="https://book.douban.com/subject/25900156/">https://book.douban.com/subject/25900156/</a></p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1CJ411m7Gc">https://www.bilibili.com/video/BV1CJ411m7Gc</a></p>
<hr>
<h3 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h3><p>Redis (REmote DIctionary Server) ：用 C 语言开发的一个开源的高性能键值对（key-value）数据库</p>
<p>特征：</p>
<ul>
<li>数据间没有必然的关联关系，<strong>不存关系，只存数据</strong></li>
<li>数据<strong>存储在内存</strong>，存取速度快，解决了磁盘 IO 速度慢的问题</li>
<li>内部采用<strong>单线程</strong>机制进行工作</li>
<li>高性能，官方测试数据，50 个并发执行 100000 个请求，读的速度是 110000 次&#x2F;s，写的速度是 81000 次&#x2F;s</li>
<li>多数据类型支持<ul>
<li>字符串类型：string（String）</li>
<li>列表类型：list（LinkedList）</li>
<li>散列类型：hash（HashMap）</li>
<li>集合类型：set（HashSet）</li>
<li>有序集合类型：zset&#x2F;sorted_set（TreeSet）</li>
</ul>
</li>
<li>支持持久化，可以进行数据灾难恢复</li>
</ul>
<hr>
<h3 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h3><p>安装：</p>
<ul>
<li><p>Redis 5.0 被包含在默认的 Ubuntu 20.04 软件源中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install redis-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查 Redis 状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl status redis-server</span><br></pre></td></tr></table></figure></li>
</ul>
<p>启动：</p>
<ul>
<li><p>启动服务器——参数启动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server [--port port]</span><br><span class="line"><span class="comment">#redis-server --port 6379</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务器——配置文件启动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server config_file_name</span><br><span class="line"><span class="comment">#redis-server /etc/redis/conf/redis-6397.conf</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动客户端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli [-h host] [-p port]</span><br><span class="line"><span class="comment">#redis-cli -h 192.168.2.185 -p 6397</span></span><br></pre></td></tr></table></figure>

<p>注意：服务器启动指定端口使用的是–port，客户端启动指定端口使用的是-p</p>
</li>
</ul>
<hr>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><h4 id="系统目录"><a href="#系统目录" class="headerlink" title="系统目录"></a>系统目录</h4><ol>
<li><p>创建文件结构</p>
<p>创建配置文件存储目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> conf</span><br></pre></td></tr></table></figure>

<p>创建服务器文件存储目录（包含日志、数据、临时配置文件等）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> data</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建配置文件副本放入 conf 目录，Ubuntu 系统配置文件 redis.conf 在目录 <code>/etc/redis</code> 中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> redis.conf | grep -v <span class="string">&quot;#&quot;</span> | grep -v <span class="string">&quot;^$&quot;</span> -&gt; /conf/redis-6379.conf</span><br></pre></td></tr></table></figure>

<p>去除配置文件的注释和空格，输出到新的文件，命令方式采用 redis-port.conf</p>
</li>
</ol>
<hr>
<h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><ul>
<li><p>设置服务器以守护进程的方式运行，关闭后服务器控制台中将打印服务器运行信息（同日志内容相同）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">daemonize <span class="built_in">yes</span>|no</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定主机地址，绑定本地IP地址，否则SSH无法访问：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> ip</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置服务器端口：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">port port</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置服务器文件保存地址：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span> path</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置数据库的数量：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">databases 16</span><br></pre></td></tr></table></figure>
</li>
<li><p>多服务器快捷配置：</p>
<p>导入并加载指定配置文件信息，用于快速创建 redis 公共配置较多的 redis 实例配置文件，便于维护</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">include /path/conf_name.conf</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul>
<li><p>服务器允许客户端连接最大数量，默认 0，表示无限制，当客户端连接到达上限后，Redis 会拒绝新的连接：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">maxclients count</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端闲置等待最大时长，达到最大值后关闭对应连接，如需关闭该功能，设置为 0：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">timeout</span> seconds</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h4><p>设置日志记录</p>
<ul>
<li><p>设置服务器以指定日志记录级别</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">loglevel debug|verbose|notice|warning</span><br></pre></td></tr></table></figure>
</li>
<li><p>日志记录文件名</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">logfile filename</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意：日志级别开发期设置为 verbose 即可，生产环境中配置为 notice，简化日志输出量，降低写日志 IO 的频度</p>
<p><strong>配置文件：</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> 192.168.2.185</span><br><span class="line">port 6379</span><br><span class="line"><span class="comment">#timeout 0</span></span><br><span class="line">daemonize no</span><br><span class="line">logfile /etc/redis/data/redis-6379.<span class="built_in">log</span></span><br><span class="line"><span class="built_in">dir</span> /etc/redis/data</span><br><span class="line">dbfilename <span class="string">&quot;dump-6379.rdb&quot;</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h4><p>帮助信息：</p>
<ul>
<li><p>获取命令帮助文档</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span> [<span class="built_in">command</span>]</span><br><span class="line"><span class="comment">#help set</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取组中所有命令信息名称</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span> [@group-name]</span><br><span class="line"><span class="comment">#help @string</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>退出服务</p>
<ul>
<li><p>退出客户端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">quit</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>退出客户端服务器快捷键：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Ctrl+C</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="数据库-2"><a href="#数据库-2" class="headerlink" title="数据库"></a>数据库</h2><h3 id="服务器-1"><a href="#服务器-1" class="headerlink" title="服务器"></a>服务器</h3><p>Redis 服务器将所有数据库保存在<strong>服务器状态 redisServer 结构</strong>的 db 数组中，数组的每一项都是 redisDb 结构，代表一个数据库，每个数据库之间相互独立，**共用 **Redis 内存，不区分大小。在初始化服务器时，根据 dbnum 属性决定创建数据库的数量，该属性由服务器配置的 database 选项决定，默认 16</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 保存服务器所有的数据库</span></span><br><span class="line">    redisDB *db;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器数据库的数量</span></span><br><span class="line">    <span class="type">int</span> dbnum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-服务器数据库.png" style="zoom: 67%;">

<p><strong>在服务器内部</strong>，客户端状态 redisClient 结构的 db 属性记录了目标数据库，是一个指向 redisDb 结构的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录客户端正在使用的数据库，指向 redisServer.db 数组中的某一个 db</span></span><br><span class="line">    redisDB *db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个 Redis 客户端都有目标数据库，执行数据库读写命令时目标数据库就会成为这些命令的操作对象，默认情况下 Redis 客户端的目标数据库为 0 号数据库，客户端可以执行 SELECT 命令切换目标数据库，原理是通过修改 redisClient.db 指针指向服务器中不同数据库</p>
<p>命令操作：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">select index	<span class="comment">#切换数据库，index从0-15取值</span></span><br><span class="line">move key db		<span class="comment">#数据移动到指定数据库，db是数据库编号</span></span><br><span class="line">ping			<span class="comment">#测试数据库是否连接正常，返回PONG</span></span><br><span class="line"><span class="built_in">echo</span> message	<span class="comment">#控制台输出信息</span></span><br></pre></td></tr></table></figure>

<p>Redis 没有可以返回客户端目标数据库的命令，但是 redis-cli 客户端旁边会提示当前所使用的目标数据库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SELECT 1 </span><br><span class="line">OK </span><br><span class="line">redis[1]&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="键空间"><a href="#键空间" class="headerlink" title="键空间"></a>键空间</h3><h4 id="key-space"><a href="#key-space" class="headerlink" title="key space"></a>key space</h4><p>Redis 是一个键值对（key-value pair）数据库服务器，每个数据库都由一个 redisDb 结构表示，redisDb.dict <strong>字典中保存了数据库的所有键值对</strong>，将这个字典称为键空间（key space）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDB</span> &#123;</span></span><br><span class="line">    <span class="comment">// 数据库键空间，保存所有键值对</span></span><br><span class="line">    dict *dict</span><br><span class="line">&#125; redisDB;</span><br></pre></td></tr></table></figure>

<p>键空间和用户所见的数据库是直接对应的：</p>
<ul>
<li>键空间的键就是数据库的键，每个键都是一个字符串对象</li>
<li>键空间的值就是数据库的值，每个值可以是任意一种 Redis 对象</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%AE%E7%A9%BA%E9%97%B4.png"></p>
<p>当使用 Redis 命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会<strong>进行一些维护操作</strong>：</p>
<ul>
<li>在读取一个键后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中 hit 次数或键空间不命中 miss 次数，这两个值可以在 <code>INFO stats</code> 命令的 keyspace_hits 属性和 keyspace_misses 属性中查看</li>
<li>更新键的 LRU（最后使用）时间，该值可以用于计算键的闲置时间，使用 <code>OBJECT idletime key</code> 查看键 key 的闲置时间</li>
<li>如果在读取一个键时发现该键已经过期，服务器会<strong>先删除过期键</strong>，再执行其他操作</li>
<li>如果客户端使用 WATCH 命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务注意到这个键已经被修改过</li>
<li>服务器每次修改一个键之后，都会对 dirty 键计数器的值增1，该计数器会触发服务器的持久化以及复制操作</li>
<li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知</li>
</ul>
<hr>
<h4 id="读写指令"><a href="#读写指令" class="headerlink" title="读写指令"></a>读写指令</h4><p>常见键操作指令：</p>
<ul>
<li><p>增加指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">  <span class="built_in">set</span> key value				<span class="comment">#添加一个字符串类型的键值对</span></span><br><span class="line"></span><br><span class="line">* 删除指令</span><br><span class="line"></span><br><span class="line">  ```sh</span><br><span class="line">  del key						<span class="comment">#删除指定key</span></span><br><span class="line">  <span class="built_in">unlink</span> key   				<span class="comment">#非阻塞删除key，真正的删除会在后续异步操作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rename key newkey			<span class="comment">#改名</span></span><br><span class="line">renamenx key newkey			<span class="comment">#改名</span></span><br></pre></td></tr></table></figure>

<p>值得更新需要参看具体得 Redis 对象得操作方式，比如字符串对象执行 <code>SET key value</code> 就可以完成修改</p>
</li>
<li><p>查询指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">exists key					<span class="comment">#获取key是否存在</span></span><br><span class="line">randomkey					<span class="comment">#随机返回一个键</span></span><br><span class="line">keys pattern				<span class="comment">#查询key</span></span><br></pre></td></tr></table></figure>

<p>KEYS 命令需要<strong>遍历存储的键值对</strong>，操作延时高，一般不被建议用于生产环境中</p>
<p>查询模式规则：* 匹配任意数量的任意符号、? 配合一个任意符号、[] 匹配一个指定符号</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">keys *						<span class="comment">#查询所有key</span></span><br><span class="line">keys aa*					<span class="comment">#查询所有以aa开头</span></span><br><span class="line">keys *bb					<span class="comment">#查询所有以bb结尾</span></span><br><span class="line">keys ??cc					<span class="comment">#查询所有前面两个字符任意，后面以cc结尾 </span></span><br><span class="line">keys user:?					<span class="comment">#查询所有以user:开头，最后一个字符任意</span></span><br><span class="line">keys u[st]er:1				<span class="comment">#查询所有以u开头，以er:1结尾，中间包含一个字母，s或t</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>其他指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> key					<span class="comment">#获取key的类型</span></span><br><span class="line">dbsize						<span class="comment">#获取当前数据库的数据总量，即key的个数</span></span><br><span class="line">flushdb						<span class="comment">#清除当前数据库的所有数据(慎用)</span></span><br><span class="line">flushall					<span class="comment">#清除所有数据(慎用)</span></span><br></pre></td></tr></table></figure>

<p>在执行 FLUSHDB 这样的危险命令之前，最好先执行一个 SELECT 命令，保证当前所操作的数据库是目标数据库</p>
</li>
</ul>
<hr>
<h4 id="时效设置"><a href="#时效设置" class="headerlink" title="时效设置"></a>时效设置</h4><p>客户端可以以秒或毫秒的精度为数据库中的某个键设置生存时间（TimeTo Live, TTL），在经过指定时间之后，服务器就会自动删除生存时间为 0 的键；也可以以 UNIX 时间戳的方式设置过期时间（expire time），当键的过期时间到达，服务器会自动删除这个键</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">expire key seconds			<span class="comment">#为指定key设置生存时间，单位为秒</span></span><br><span class="line">pexpire key milliseconds	<span class="comment">#为指定key设置生存时间，单位为毫秒</span></span><br><span class="line">expireat key timestamp		<span class="comment">#为指定key设置过期时间，单位为时间戳</span></span><br><span class="line">pexpireat key mil-timestamp	<span class="comment">#为指定key设置过期时间，单位为毫秒时间戳</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实际上 EXPIRE、EXPIRE、EXPIREAT 三个命令<strong>底层都是转换为 PEXPIREAT 命令</strong>来实现的</li>
<li>SETEX 命令可以在设置一个字符串键的同时为键设置过期时间，但是该命令是一个类型限定命令</li>
</ul>
<p>redisDb 结构的 expires 字典保存了数据库中所有键的过期时间，字典称为过期字典：</p>
<ul>
<li>键是一个指针，指向键空间中的某个键对象（复用键空间的对象，不会产生内存浪费）</li>
<li>值是一个 long long 类型的整数，保存了键的过期时间，是一个毫秒精度的 UNIX 时间戳</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDB</span> &#123;</span></span><br><span class="line">    <span class="comment">// 过期字典，保存所有键的过期时间</span></span><br><span class="line">    dict *expires</span><br><span class="line">&#125; redisDB;</span><br></pre></td></tr></table></figure>

<p>客户端执行 PEXPIREAT 命令，服务器会在数据库的过期字典中关联给定的数据库键和过期时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">PEXPIREAT</span>(<span class="params">key, expire_time_in_ms</span>):</span><br><span class="line">	<span class="comment"># 如果给定的键不存在于键空间，那么不能设置过期时间</span></span><br><span class="line">	<span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> redisDb.<span class="built_in">dict</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment"># 在过期字典中关联键和过期时间</span></span><br><span class="line">	redisDB.expires[key] = expire_time_in_ms</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 过期时间设置成功</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="时效状态"><a href="#时效状态" class="headerlink" title="时效状态"></a>时效状态</h4><p>TTL 和 PTTL 命令通过计算键的过期时间和当前时间之间的差，返回这个键的剩余生存时间</p>
<ul>
<li>返回正数代表该数据在内存中还能存活的时间</li>
<li>返回 -1 代表永久性，返回 -2 代表键不存在</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ttl key			<span class="comment">#获取key的剩余时间，每次获取会自动变化(减小)，类似于倒计时</span></span><br><span class="line">pttl key		<span class="comment">#获取key的剩余时间，单位是毫秒，每次获取会自动变化(减小)</span></span><br></pre></td></tr></table></figure>

<p>PERSIST 是 PEXPIREAT 命令的反操作，在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">persist key		<span class="comment">#切换key从时效性转换为永久性</span></span><br></pre></td></tr></table></figure>

<p>Redis 通过过期字典可以检查一个给定键是否过期：</p>
<ul>
<li>检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间</li>
<li>检查当前 UNIX 时间戳是否大于键的过期时间：如果是那么键已经过期，否则键未过期</li>
</ul>
<p>补充：AOF、RDB 和复制功能对过期键的处理</p>
<ul>
<li>RDB ：<ul>
<li>生成 RDB 文件，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的 RDB 文件中</li>
<li>载入 RDB 文件，如果服务器以主服务器模式运行，那么在载入时会对键进行检查，过期键会被忽略；如果服务器以从服务器模式运行，会载入所有键，包括过期键，但是主从服务器进行数据同步时就会删除这些键</li>
</ul>
</li>
<li>AOF：<ul>
<li>写入 AOF 文件，如果数据库中的某个键已经过期，但还没有被删除，那么 AOF 文件不会因为这个过期键而产生任何影响；当该过期键被删除，程序会向 AOF 文件追加一条 DEL 命令，显式的删除该键</li>
<li>AOF 重写，会对数据库中的键进行检查，忽略已经过期的键</li>
</ul>
</li>
<li>复制：当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制<ul>
<li>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个 DEL 命令，告知从服务器删除这个过期键</li>
<li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，会当作未过期键处理，只有在接到主服务器发来的 DEL 命令之后，才会删除过期键（数据不一致）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="过期删除"><a href="#过期删除" class="headerlink" title="过期删除"></a>过期删除</h3><h4 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h4><p>删除策略就是<strong>针对已过期数据的处理策略</strong>，已过期的数据不一定被立即删除，在不同的场景下使用不同的删除方式会有不同效果，在内存占用与 CPU 占用之间寻找一种平衡，顾此失彼都会造成整体 Redis 性能的下降，甚至引发服务器宕机或内存泄露</p>
<p>针对过期数据有三种删除策略：</p>
<ul>
<li>定时删除</li>
<li>惰性删除</li>
<li>定期删除</li>
</ul>
<p>Redis 采用惰性删除和定期删除策略的结合使用</p>
<hr>
<h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><p>在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间到达时，立即执行对键的删除操作</p>
<ul>
<li>优点：节约内存，到时就删除，快速释放掉不必要的内存占用</li>
<li>缺点：对 CPU 不友好，无论 CPU 此时负载多高均占用 CPU，会影响 Redis 服务器响应时间和指令吞吐量</li>
<li>总结：用处理器性能换取存储空间（拿时间换空间）</li>
</ul>
<p>创建一个定时器需要用到 Redis 服务器中的时间事件，而时间事件的实现方式是无序链表，查找一个事件的时间复杂度为 O(N)，并不能高效地处理大量时间事件，所以采用这种方式并不现实</p>
<hr>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>数据到达过期时间不做处理，等下次访问到该数据时执行 <strong>expireIfNeeded()</strong> 判断：</p>
<ul>
<li>如果输入键已经过期，那么 expireIfNeeded 函数将输入键从数据库中删除，接着访问就会返回空</li>
<li>如果输入键未过期，那么 expireIfNeeded 函数不做动作</li>
</ul>
<p>所有的 Redis 读写命令在执行前都会调用 expireIfNeeded 函数进行检查，该函数就像一个过滤器，在命令真正执行之前过滤掉过期键</p>
<p>惰性删除的特点： </p>
<ul>
<li>优点：节约 CPU 性能，删除的目标仅限于当前处理的键，不会在删除其他无关的过期键上花费任何 CPU 时间</li>
<li>缺点：内存压力很大，出现长期占用内存的数据，如果过期键永远不被访问，这种情况相当于内存泄漏</li>
<li>总结：用存储空间换取处理器性能（拿空间换时间）</li>
</ul>
<hr>
<h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>定期删除策略是每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响</p>
<ul>
<li>如果删除操作执行得太频繁，或者执行时间太长，就会退化成定时删除策略，将 CPU 时间过多地消耗在删除过期键上</li>
<li>如果删除操作执行得太少，或者执行时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况</li>
</ul>
<p>定期删除是<strong>周期性轮询 Redis 库中的时效性</strong>数据，从过期字典中随机抽取一部分键检查，利用过期数据占比的方式控制删除频度</p>
<ul>
<li><p>Redis 启动服务器初始化时，读取配置 server.hz 的值，默认为 10，执行指令 info server 可以查看，每秒钟执行 server.hz 次 <code>serverCron() → activeExpireCycle()</code></p>
</li>
<li><p>activeExpireCycle() 对某个数据库中的每个 expires 进行检测，工作模式：</p>
<ul>
<li><p>轮询每个数据库，从数据库中取出一定数量的随机键进行检查，并删除其中的过期键</p>
</li>
<li><p>全局变量 current_db 用于记录 activeExpireCycle() 的检查进度（哪一个数据库），下一次调用时接着该进度处理</p>
</li>
<li><p>随着函数的不断执行，服务器中的所有数据库都会被检查一遍，这时将 current_db 重置为 0，然后再次开始新一轮的检查</p>
</li>
</ul>
</li>
</ul>
<p>定期删除特点：</p>
<ul>
<li>CPU 性能占用设置有峰值，检测频度可自定义设置</li>
<li>内存压力不是很大，长期占用内存的<strong>冷数据会被持续清理</strong></li>
<li>周期性抽查存储空间（随机抽查，重点抽查）</li>
</ul>
<hr>
<h3 id="数据淘汰"><a href="#数据淘汰" class="headerlink" title="数据淘汰"></a>数据淘汰</h3><h4 id="逐出算法"><a href="#逐出算法" class="headerlink" title="逐出算法"></a>逐出算法</h4><p>数据淘汰策略：当新数据进入 Redis 时，在执行每一个命令前，会调用 <strong>freeMemoryIfNeeded()</strong> 检测内存是否充足。如果内存不满足新加入数据的最低存储要求，Redis 要临时删除一些数据为当前指令清理存储空间，清理数据的策略称为<strong>逐出算法</strong></p>
<p>逐出数据的过程不是 100% 能够清理出足够的可使用的内存空间，如果不成功则反复执行，当对所有数据尝试完毕，如不能达到内存清理的要求，<strong>出现 Redis 内存打满异常</strong>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(error) OOM <span class="built_in">command</span> not allowed when used memory &gt;<span class="string">&#x27;maxmemory&#x27;</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="策略配置"><a href="#策略配置" class="headerlink" title="策略配置"></a>策略配置</h4><p>Redis 如果不设置最大内存大小或者设置最大内存大小为 0，在 64 位操作系统下不限制内存大小，在 32 位操作系统默认为 3GB 内存，一般推荐设置 Redis 内存为最大物理内存的四分之三</p>
<p>内存配置方式：</p>
<ul>
<li><p>通过修改文件配置（永久生效）：修改配置文件 maxmemory 字段，单位为字节</p>
</li>
<li><p>通过命令修改（重启失效）：</p>
<ul>
<li><p><code>config set maxmemory 104857600</code>：设置 Redis 最大占用内存为 100MB</p>
</li>
<li><p><code>config get maxmemory</code>：获取 Redis 最大占用内存</p>
</li>
<li><p><code>info</code> ：可以查看 Redis 内存使用情况，<code>used_memory_human</code> 字段表示实际已经占用的内存，<code>maxmemory</code> 表示最大占用内存</p>
</li>
</ul>
</li>
</ul>
<p>影响数据淘汰的相关配置如下，配置 conf 文件：</p>
<ul>
<li><p>每次选取待删除数据的个数，采用随机获取数据的方式作为待检测删除数据，防止全库扫描，导致严重的性能消耗，降低读写性能</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">maxmemory-samples count</span><br></pre></td></tr></table></figure>
</li>
<li><p>达到最大内存后的，对被挑选出来的数据进行删除的策略</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">maxmemory-policy policy</span><br></pre></td></tr></table></figure>

<p>数据删除的策略 policy：3 类 8 种</p>
<p>第一类：检测易失数据（可能会过期的数据集 server.db[i].expires）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">volatile-lru	<span class="comment"># 对设置了过期时间的 key 选择最近最久未使用使用的数据淘汰</span></span><br><span class="line">volatile-lfu	<span class="comment"># 对设置了过期时间的 key 选择最近使用次数最少的数据淘汰</span></span><br><span class="line">volatile-ttl	<span class="comment"># 对设置了过期时间的 key 选择将要过期的数据淘汰</span></span><br><span class="line">volatile-random	<span class="comment"># 对设置了过期时间的 key 选择任意数据淘汰</span></span><br></pre></td></tr></table></figure>

<p>第二类：检测全库数据（所有数据集 server.db[i].dict ）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">allkeys-lru		<span class="comment"># 对所有 key 选择最近最少使用的数据淘汰</span></span><br><span class="line">allkeLyRs-lfu	<span class="comment"># 对所有 key 选择最近使用次数最少的数据淘汰</span></span><br><span class="line">allkeys-random	<span class="comment"># 对所有 key 选择任意数据淘汰，相当于随机</span></span><br></pre></td></tr></table></figure>

<p>第三类：放弃数据驱逐</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">no-enviction	<span class="comment">#禁止驱逐数据(redis4.0中默认策略)，会引发OOM(Out Of Memory)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>数据淘汰策略配置依据：使用 INFO 命令输出监控信息，查询缓存 hit 和 miss 的次数，根据需求调优 Redis 配置</p>
<hr>
<h3 id="排序机制"><a href="#排序机制" class="headerlink" title="排序机制"></a>排序机制</h3><h4 id="基本介绍-11"><a href="#基本介绍-11" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Redis 的 SORT 命令可以对列表键、集合键或者有序集合键的值进行排序，并不更改集合中的数据位置，只是查询</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SORT key [ASC/DESC]			<span class="comment">#对key中数据排序，默认对数字排序，并不更改集合中的数据位置，只是查询</span></span><br><span class="line">SORT key ALPHA				<span class="comment">#对key中字母排序，按照字典序</span></span><br></pre></td></tr></table></figure>





<hr>
<h4 id="SORT"><a href="#SORT" class="headerlink" title="SORT"></a>SORT</h4><p><code>SORT &lt;key&gt;</code> 命令可以对一个包含数字值的键 key 进行排序</p>
<p>假设 <code>RPUSH numbers 3 1 2</code>，执行 <code>SORT numbers</code> 的详细步骤：</p>
<ul>
<li><p>创建一个和 key 列表长度相同的数组，数组每项都是 redisSortObject 结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisSortObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 被排序键的值</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 权重</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="comment">// 排序数字值时使用</span></span><br><span class="line">        <span class="type">double</span> score;</span><br><span class="line">        <span class="comment">// 排序带有 BY 选项的字符串</span></span><br><span class="line">        robj *cmpobj;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历数组，将各个数组项的 obj 指针分别指向 numbers 列表的各个项</p>
</li>
<li><p>遍历数组，将 obj 指针所指向的列表项转换成一个 double 类型的浮点数，并将浮点数保存在对应数组项的 u.score 属性里</p>
</li>
<li><p>根据数组项 u.score 属性的值，对数组进行数字值排序，排序后的数组项按 u.score 属性的值<strong>从小到大排列</strong></p>
</li>
<li><p>遍历数组，将各个数组项的 obj 指针所指向的值作为排序结果返回给客户端，程序首先访问数组的索引 0，依次向后访问</p>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-sort%E6%8E%92%E5%BA%8F.png"></p>
<p>对于 <code>SORT key [ASC/DESC]</code> 函数：</p>
<ul>
<li>在执行升序排序时，排序算法使用的对比函数产生升序对比结果</li>
<li>在执行降序排序时，排序算法使用的对比函数产生降序对比结果</li>
</ul>
<hr>
<h4 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h4><p>SORT 命令默认使用被排序键中包含的元素作为排序的权重，元素本身决定了元素在排序之后所处的位置，通过使用 BY 选项，SORT 命令可以指定某些字符串键，或者某个哈希键所包含的某些域（field）来作为元素的权重，对一个键进行排序</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SORT &lt;key&gt; BY &lt;pattern&gt;			<span class="comment"># 数值</span></span><br><span class="line">SORT &lt;key&gt; BY &lt;pattern&gt; ALPHA	<span class="comment"># 字符</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SADD fruits <span class="string">&quot;apple&quot;</span> <span class="string">&quot;banana&quot;</span> <span class="string">&quot;cherry&quot;</span> </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; SORT fruits ALPHA</span><br><span class="line">1)	<span class="string">&quot;apple&quot;</span></span><br><span class="line">2)	<span class="string">&quot;banana&quot;</span></span><br><span class="line">3)	<span class="string">&quot;cherry&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; MSET apple-price 8 banana-price 5.5 cherry-price 7 </span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 使用水果的价钱进行排序</span></span><br><span class="line">redis&gt; SORT fruits BY *-price</span><br><span class="line">1)	<span class="string">&quot;banana&quot;</span></span><br><span class="line">2)	<span class="string">&quot;cherry&quot;</span></span><br><span class="line">3)	<span class="string">&quot;apple&quot;</span></span><br></pre></td></tr></table></figure>

<p>实现原理：排序时的 u.score 属性就会被设置为对应的权重</p>
<hr>
<h4 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h4><p>SORT 命令默认会将排序后的所有元素都返回给客户端，通过 LIMIT 选项可以让 SORT 命令只返回其中一部分已排序的元素</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">LIMIT &lt;offset&gt; &lt;count&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>offset 参数表示要跳过的已排序元素数量</li>
<li>count 参数表示跳过给定数量的元素后，要返回的已排序元素数量</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对应 a b c d e f  g</span></span><br><span class="line">redis&gt; SORT alphabet ALPHA LIMIT 2 3</span><br><span class="line">1) 	<span class="string">&quot;c&quot;</span></span><br><span class="line">2) 	<span class="string">&quot;d&quot;</span></span><br><span class="line">3) 	<span class="string">&quot;e&quot;</span></span><br></pre></td></tr></table></figure>

<p>实现原理：在排序后的 redisSortObject 结构数组中，将指针移动到数组的索引 2 上，依次访问 array[2]、array[3]、array[4] 这 3 个数组项，并将数组项的 obj 指针所指向的元素返回给客户端</p>
<hr>
<h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>SORT 命令默认在对键进行排序后，返回被排序键本身所包含的元素，通过使用 GET 选项， 可以在对键进行排序后，根据被排序的元素以及 GET 选项所指定的模式，查找并返回某些键的值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SORT &lt;key&gt; GET &lt;pattern&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SADD students <span class="string">&quot;tom&quot;</span> <span class="string">&quot;jack&quot;</span> <span class="string">&quot;sea&quot;</span></span><br><span class="line"><span class="comment">#设置全名</span></span><br><span class="line">redis&gt; SET tom-name <span class="string">&quot;Tom Li&quot;</span> </span><br><span class="line">OK </span><br><span class="line">redis&gt; SET jack-name <span class="string">&quot;Jack Wang&quot;</span> </span><br><span class="line">OK </span><br><span class="line">redis&gt; SET sea-name <span class="string">&quot;Sea Zhang&quot;</span></span><br><span class="line">OK </span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SORT students ALPHA GET *-name</span><br><span class="line">1)	<span class="string">&quot;Jack Wang&quot;</span></span><br><span class="line">2)	<span class="string">&quot;Sea Zhang&quot;</span></span><br><span class="line">3) 	<span class="string">&quot;Tom Li&quot;</span></span><br></pre></td></tr></table></figure>

<p>实现原理：对 students 进行排序后，对于 jack 元素和 *-name 模式，查找程序返回键 jack-name，然后获取 jack-name 键对应的值</p>
<hr>
<h4 id="STORE"><a href="#STORE" class="headerlink" title="STORE"></a>STORE</h4><p>SORT 命令默认只向客户端返回排序结果，而不保存排序结果，通过使用 STORE 选项可以将排序结果保存在指定的键里面</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SORT &lt;key&gt; STORE &lt;sort_key&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SADD students <span class="string">&quot;tom&quot;</span> <span class="string">&quot;jack&quot;</span> <span class="string">&quot;sea&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3 </span><br><span class="line">redis&gt; SORT students ALPHA STORE sorted_students </span><br><span class="line">(<span class="built_in">integer</span>) 3 </span><br></pre></td></tr></table></figure>

<p>实现原理：排序后，检查 sorted_students 键是否存在，如果存在就删除该键，设置 sorted_students 为空白的列表键，遍历排序数组将元素依次放入</p>
<hr>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>调用 SORT 命令，除了 GET 选项之外，改变其他选项的摆放顺序并不会影响命令执行选项的顺序</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SORT &lt;key&gt; ALPHA [ASC/DESC] BY &lt;by-pattern&gt; LIMIT &lt;offset&gt; &lt;count&gt; GET &lt;get-pattern&gt; STORE &lt;store_key&gt;</span><br></pre></td></tr></table></figure>

<p>执行顺序：</p>
<ul>
<li>排序：命令会使用 ALPHA 、ASC 或 DESC、BY 这几个选项，对输入键进行排序，并得到一个排序结果集</li>
<li>限制排序结果集的长度：使用 LIMIT 选项，对排序结果集的长度进行限制</li>
<li>获取外部键：根据排序结果集中的元素以及 GET 选项指定的模式，查找并获取指定键的值，并用这些值来作为新的排序结果集</li>
<li>保存排序结果集：使用 STORE 选项，将排序结果集保存到指定的键上面去</li>
<li>向客户端返回排序结果集：最后一步命令遍历排序结果集，并依次向客户端返回排序结果集中的元素</li>
</ul>
<hr>
<h3 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h3><p>数据库通知是可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况</p>
<ul>
<li>关注某个键执行了什么命令的通知称为键空间通知（key-space notification）</li>
<li>关注某个命令被什么键执行的通知称为键事件通知（key-event notification）</li>
</ul>
<p>图示订阅 0 号数据库 message 键：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-数据库通知.png" style="zoom: 67%;">

<p>服务器配置的 notify-keyspace-events 选项决定了服务器所发送通知的类型</p>
<ul>
<li>AKE 代表服务器发送所有类型的键空间通知和键事件通知</li>
<li>AK 代表服务器发送所有类型的键空间通知</li>
<li>AE 代表服务器发送所有类型的键事件通知</li>
<li>K$ 代表服务器只发送和字符串键有关的键空间通知</li>
<li>EL 代表服务器只发送和列表键有关的键事件通知</li>
<li>…..</li>
</ul>
<p>发送数据库通知的功能是由 notifyKeyspaceEvent 函数实现的：</p>
<ul>
<li>如果给定的通知类型 type 不是服务器允许发送的通知类型，那么函数会直接返回</li>
<li>如果给定的通知是服务器允许发送的通知<ul>
<li>检测服务器是否允许发送键空间通知，允许就会构建并发送事件通知</li>
<li>检测服务器是否允许发送键事件通知，允许就会构建并发送事件通知</li>
</ul>
</li>
</ul>
<hr>
<h2 id="体系架构-1"><a href="#体系架构-1" class="headerlink" title="体系架构"></a>体系架构</h2><h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><h4 id="基本介绍-12"><a href="#基本介绍-12" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Redis 服务器是一个事件驱动程序，服务器需要处理两类事件</p>
<ul>
<li>文件事件 (file event)：服务器通过套接字与客户端（或其他 Redis 服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端的通信会产生相应的文件事件，服务器通过监听并处理这些事件完成一系列网络通信操作</li>
<li>时间事件 (time event)：Redis 服务器中的一些操作（比如 serverCron 函数）需要在指定时间执行，而时间事件就是服务器对这类定时操作的抽象</li>
</ul>
<hr>
<h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><h5 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h5><p>Redis 基于 Reactor 模式开发了网络事件处理器，这个处理器被称为文件事件处理器 (file event handler)</p>
<ul>
<li><p>使用 I&#x2F;O 多路复用 (multiplexing) 程序来同时监听多个套接字，并根据套接字执行的任务来为套接字关联不同的事件处理器</p>
</li>
<li><p>当被监听的套接字准备好执行连接应答 (accept)、 读取 (read)、 写入 (write)、 关闭 (close) 等操作时，与操作相对应的文件事件就会产生，这时文件事件分派器会调用套接字关联好的事件处理器来处理事件</p>
</li>
</ul>
<p>文件事件处理器<strong>以单线程方式运行</strong>，但通过使用  I&#x2F;O 多路复用程序来监听多个套接字， 既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，保持了 Redis 内部单线程设计的简单性</p>
<p>文件事件处理器的组成结构：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-文件事件处理器.png" style="zoom:80%;">

<p>尽管多个文件事件可能会并发出现，但是 I&#x2F;O 多路复用程序将所有产生事件的套接字处理请求放入一个<strong>单线程的执行队列</strong>中，通过队列有序、同步的向文件事件分派器传送套接字，上一个套接字产生的事件处理完后，才会继续向分派器传送下一个</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-IO多路复用程序.png" style="zoom: 67%;">

<p>Redis 单线程也能高效的原因：</p>
<ul>
<li>纯内存操作</li>
<li>核心是基于非阻塞的 IO 多路复用机制，单线程可以高效处理多个请求</li>
<li>底层使用 C 语言实现，C 语言实现的程序距离操作系统更近，执行速度相对会更快</li>
<li>单线程同时也<strong>避免了多线程的上下文频繁切换问题</strong>，预防了多线程可能产生的竞争问题</li>
</ul>
<hr>
<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>Redis 的 I&#x2F;O 多路复用程序的所有功能都是通过包装常见的 select 、epoll、 evport 和 kqueue 这些函数库来实现的，Redis 在 I&#x2F;O 多路复用程序的实现源码中用 #include 宏定义了相应的规则，编译时自动选择系统中<strong>性能最高的多路复用函数</strong>来作为底层实现</p>
<p>I&#x2F;O 多路复用程序监听多个套接字的 AE_READABLE 事件和 AE_WRITABLE 事件，这两类事件和套接字操作之间的对应关系如下：</p>
<ul>
<li>当套接字变得<strong>可读</strong>时（客户端对套接字执行 write 操作或者 close 操作），或者有新的<strong>可应答</strong>（acceptable）套接字出现时（客户端对服务器的监听套接字执行 connect 连接操作），套接字产生 AE_READABLE 事件</li>
<li>当套接字变得可写时（客户端对套接字执行 read 操作，对于服务器来说就是可以写了），套接字产生 AE_WRITABLE 事件</li>
</ul>
<p>I&#x2F;O 多路复用程序允许服务器同时监听套接字的 AE_READABLE 和 AE_WRITABLE 事件， 如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理 AE_READABLE  事件， 等 AE_READABLE 事件处理完之后才处理 AE_WRITABLE 事件</p>
<hr>
<h5 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h5><p>Redis 为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求：</p>
<ul>
<li>连接应答处理器，用于对连接服务器的各个客户端进行应答，Redis 服务器初始化时将该处理器与 AE_READABLE 事件关联</li>
<li>命令请求处理器，用于接收客户端传来的命令请求，执行套接字的读入操作，与 AE_READABLE 事件关联</li>
<li>命令回复处理器，用于向客户端返回命令的执行结果，执行套接字的写入操作，与 AE_WRITABLE 事件关联</li>
<li>复制处理器，当主服务器和从服务器进行复制操作时，主从服务器都需要关联该处理器</li>
</ul>
<p>Redis 客户端与服务器进行连接并发送命令的整个过程：</p>
<ul>
<li>Redis 服务器正在运作监听套接字的 AE_READABLE 事件，关联连接应答处理器</li>
<li>当 Redis 客户端向服务器发起连接，监听套接字将产生 AE_READABLE 事件，触发连接应答处理器执行，对客户端的连接请求进行应答，创建客户端套接字以及客户端状态，并将客户端套接字的 <strong>AE_READABLE 事件与命令请求处理器</strong>进行关联</li>
<li>客户端向服务器发送命令请求，客户端套接字产生 AE_READABLE 事件，引发命令请求处理器执行，读取客户端的命令内容传给相关程序去执行</li>
<li>执行命令会产生相应的命令回复，为了将这些命令回复传送回客户端，服务器会将客户端套接字的 <strong>AE_WRITABLE 事件与命令回复处理器</strong>进行关联</li>
<li>当客户端尝试读取命令回复时，客户端套接字产生 AE_WRITABLE 事件，触发命令回复处理器执行，在命令回复全部写入套接字后，服务器就会解除客户端套接字的 AE_WRITABLE 事件与命令回复处理器之间的关联</li>
</ul>
<hr>
<h4 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h4><p>Redis 的时间事件分为以下两类：</p>
<ul>
<li>定时事件：在指定的时间之后执行一次（Redis 中暂时未使用）</li>
<li>周期事件：每隔指定时间就执行一次</li>
</ul>
<p>一个时间事件主要由以下三个属性组成：</p>
<ul>
<li>id：服务器为时间事件创建的全局唯一 ID（标识号），从小到大顺序递增，新事件的 ID 比旧事件的 ID 号要大</li>
<li>when：毫秒精度的 UNIX 时间戳，记录了时间事件的到达（arrive）时间</li>
<li>timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理事件</li>
</ul>
<p>时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值：</p>
<ul>
<li>定时事件：事件处理器返回 AE_NOMORE，该事件在到达一次后就会被删除</li>
<li>周期事件：事件处理器返回非 AE_NOMORE 的整数值，服务器根据该值对事件的 when 属性更新，让该事件在一段时间后再次交付</li>
</ul>
<p>服务器将所有时间事件都放在一个<strong>无序链表</strong>中，新的时间事件插入到链表的表头：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-时间事件.png" style="zoom:67%;">

<p>无序链表指是链表不按 when 属性的大小排序，每当时间事件执行器运行时就必须遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器处理</p>
<p>无序链表并不影响时间事件处理器的性能，因为正常模式下的 Redis 服务器<strong>只使用 serverCron 一个时间事件</strong>，在 benchmark 模式下服务器也只使用两个时间事件，所以无序链表不会影响服务器的性能，几乎可以按照一个指针处理</p>
<p>服务器 → serverCron 详解该时间事件 </p>
<hr>
<h4 id="事件调度"><a href="#事件调度" class="headerlink" title="事件调度"></a>事件调度</h4><p>服务器中同时存在文件事件和时间事件两种事件类型，调度伪代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 事件调度伪代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aeProcessEvents</span>():</span><br><span class="line">	<span class="comment"># 获取到达时间离当前时间最接近的时间事件 </span></span><br><span class="line">    time_event = aeSearchNearestTime()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算最接近的时间事件距离到达还有多少亳秒</span></span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line">    <span class="comment"># 如果事件已到达，那么 remaind_ms 的值可能为负数，设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line">        remaind_ms = <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment"># 根据 remaind_ms 的值，创建 timeval 结构</span></span><br><span class="line">	timeval = create_timeval_with_ms(remaind_ms) </span><br><span class="line">    <span class="comment"># 【阻塞并等待文件事件】产生，最大阻塞时间由传入的timeval结构决定，remaind_ms的值为0时调用后马上返回，不阻塞</span></span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理所有已产生的文件事件</span></span><br><span class="line">	processFileEvents() </span><br><span class="line">	<span class="comment"># 处理所有已到达的时间事件</span></span><br><span class="line">	processTimeEvents()</span><br></pre></td></tr></table></figure>

<p>事件的调度和执行规则：</p>
<ul>
<li>aeApiPoll 函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，可以避免服务器对时间事件进行频繁的轮询（忙等待），也可以确保 aeApiPoll 函数不会阻塞过长时间</li>
<li>对文件事件和时间事件的处理都是<strong>同步、有序、原子地执行</strong>，服务器不会中途中断事件处理，也不会对事件进行抢占，所以两种处理器都要尽可地减少程序的阻塞时间，并在有需要时<strong>主动让出执行权</strong>，从而降低事件饥饿的可能性<ul>
<li>命令回复处理器在写入字节数超过了某个预设常量，就会主动用 break 跳出写入循环，将余下的数据留到下次再写</li>
<li>时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行</li>
</ul>
</li>
<li>时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间通常会比设定的到达时间稍晚</li>
</ul>
<hr>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，因为这是 Redis 的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络），多线程只是用来<strong>处理网络数据的读写和协议解析</strong>， 执行命令仍然是单线程顺序执行，因此不需要担心线程安全问题。</p>
<p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 <code>redis.conf</code> ：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">io-threads-do-reads yesCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>开启多线程后，还需要设置线程数，否则是不生效的，同样需要修改 redis 配置文件 :</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">io-threads 4 <span class="comment">#官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span></span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-多线程.png" style="zoom:80%;">



<p>参考文章：<a href="https://mp.weixin.qq.com/s/dqmiR0ECf4lB6Y2OyK-dyA">https://mp.weixin.qq.com/s/dqmiR0ECf4lB6Y2OyK-dyA</a></p>
<hr>
<h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><h4 id="基本介绍-13"><a href="#基本介绍-13" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Redis 服务器是典型的一对多程序，一个服务器可以与多个客户端建立网络连接，服务器对每个连接的客户端建立了相应的 redisClient 结构（客户端状态，<strong>在服务器端的存储结构</strong>），保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构</p>
<p>Redis 服务器状态结构的 clients 属性是一个链表，这个链表保存了所有与服务器连接的客户端的状态结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 一个链表，保存了所有客户端状态</span></span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%9C%8D%E5%8A%A1%E5%99%A8clients%E9%93%BE%E8%A1%A8.png"></p>
<hr>
<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="redisClient"><a href="#redisClient" class="headerlink" title="redisClient"></a>redisClient</h5><p>客户端的数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 套接字</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    robj *name;</span><br><span class="line">    <span class="comment">// 标志</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入缓冲区</span></span><br><span class="line">    sds querybuf;</span><br><span class="line">    <span class="comment">// 输出缓冲区 buf 数组</span></span><br><span class="line">    <span class="type">char</span> buf[REDIS_REPLY_CHUNK_BYTES];</span><br><span class="line">    <span class="comment">// 记录了 buf 数组目前已使用的字节数量</span></span><br><span class="line">    <span class="type">int</span> bufpos; </span><br><span class="line">    <span class="comment">// 可变大小的输出缓冲区，链表 + 字符串对象</span></span><br><span class="line">    <span class="built_in">list</span> *reply;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 命令数组</span></span><br><span class="line">    rboj **argv;</span><br><span class="line">    <span class="comment">// 命令数组的长度</span></span><br><span class="line">   	<span class="type">int</span> argc;</span><br><span class="line">    <span class="comment">// 命令的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span>  *<span class="title">cmd</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否通过身份验证</span></span><br><span class="line">    <span class="type">int</span> authenticated;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建客户端的时间</span></span><br><span class="line">    <span class="type">time_t</span> ctime;</span><br><span class="line">    <span class="comment">// 客户端与服务器最后一次进行交互的时间</span></span><br><span class="line">    <span class="type">time_t</span> lastinteraction;</span><br><span class="line">    <span class="comment">// 输出缓冲区第一次到达软性限制 (soft limit) 的时间</span></span><br><span class="line">    <span class="type">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端状态包括两类属性</p>
<ul>
<li>一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，都要用到这些属性</li>
<li>另一类是和特定功能相关的属性，比如操作数据库时用到的 db 属性和 dict id 属性，执行事务时用到的 mstate 属性，以及执行 WATCH 命令时用到的 watched_keys 属性等，代码中没有列出</li>
</ul>
<hr>
<h5 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h5><p>客户端状态的 fd 属性记录了客户端正在使用的套接字描述符，根据客户端类型的不同，fd 属性的值可以是 -1 或者大于 -1 的整数：</p>
<ul>
<li>伪客户端 (fake client) 的 fd 属性的值为 -1，命令请求来源于 AOF 文件或者 Lua 脚本，而不是网络，所以不需要套接字连接</li>
<li>普通客户端的 fd 属性的值为大于 -1 的整数，因为合法的套接字描述符不能是 -1</li>
</ul>
<p>执行 <code>CLIENT list</code> 命令可以列出目前所有连接到服务器的普通客户端，不包括伪客户端</p>
<hr>
<h5 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h5><p>在默认情况下，一个连接到服务器的客户端是没有名字的，使用 <code>CLIENT setname</code> 命令可以为客户端设置一个名字</p>
<hr>
<h5 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h5><p>客户端的标志属性 flags 记录了客户端的角色以及客户端目前所处的状态，每个标志使用一个常量表示</p>
<ul>
<li>flags 的值可以是单个标志：<code>flags = &lt;flag&gt; </code></li>
<li>flags 的值可以是多个标志的二进制：<code>flags = &lt;flagl&gt; | &lt;flag2&gt; | ... </code></li>
</ul>
<p>一部分标志记录<strong>客户端的角色</strong>：</p>
<ul>
<li>REDIS_MASTER 表示客户端是一个从服务器，REDIS_SLAVE 表示客户端是一个从服务器，在主从复制时使用</li>
<li>REDIS_PRE_PSYNC 表示客户端是一个版本低于 Redis2.8 的从服务器，主服务器不能使用 PSYNC 命令与该从服务器进行同步，这个标志只能在 REDIS_ SLAVE 标志处于打开状态时使用</li>
<li>REDIS_LUA_CLIENT 表示客户端是专门用于处理 Lua 脚本里面包含的 Redis 命令的伪客户端</li>
</ul>
<p>一部分标志记录目前<strong>客户端所处的状态</strong>：</p>
<ul>
<li>REDIS_UNIX_SOCKET 表示服务器使用 UNIX 套接字来连接客户端</li>
<li>REDIS_BLOCKED 表示客户端正在被 BRPOP、BLPOP 等命令阻塞</li>
<li>REDIS_UNBLOCKED 表示客户端已经从 REDIS_BLOCKED 所表示的阻塞状态脱离，在 REDIS_BLOCKED 标志打开的情况下使用</li>
<li>REDIS_MULTI 标志表示客户端正在执行事务</li>
<li>REDIS_DIRTY_CAS 表示事务使用 WATCH 命令监视的数据库键已经被修改</li>
<li>…..</li>
</ul>
<hr>
<h5 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h5><p>客户端状态的输入缓冲区用于保存客户端发送的命令请求，输入缓冲区的大小会根据输入内容动态地缩小或者扩大，但最大大小不能超过 1GB，否则服务器将关闭这个客户端，比如执行 <code>SET key value </code>，那么缓冲区 querybuf 的内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">*3\r\n<span class="variable">$3</span>\r\nSET\r\n<span class="variable">$3</span>\r\nkey\r\n<span class="variable">$5</span>\r\nvalue\r\n <span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p>输出缓冲区是服务器用于保存执行客户端命令所得的命令回复，每个客户端都有两个输出缓冲区可用：</p>
<ul>
<li>一个是固定大小的缓冲区，保存长度比较小的回复，比如 OK、简短的字符串值、整数值、错误回复等</li>
<li>一个是可变大小的缓冲区，保存那些长度比较大的回复， 比如一个非常长的字符串值或者一个包含了很多元素的集合等</li>
</ul>
<p>buf 是一个大小为 REDIS_REPLY_CHUNK_BYTES (常量默认 16*1024 &#x3D; 16KB) 字节的字节数组，bufpos 属性记录了 buf 数组目前已使用的字节数量，当 buf 数组的空间已经用完或者回复数据太大无法放进 buf 数组里，服务器就会开始使用可变大小的缓冲区</p>
<p>通过使用 reply 链表连接多个字符串对象，可以为客户端保存一个非常长的命令回复，而不必受到固定大小缓冲区 16KB 大小的限制</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8F%AF%E5%8F%98%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA.png"></p>
<hr>
<h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><p>服务器对 querybuf 中的命令请求的内容进行分析，得出的命令参数以及参数的数量分别保存到客户端状态的 argv 和 argc 属性</p>
<ul>
<li>argv 属性是一个数组，数组中的每项都是字符串对象，其中 argv[0] 是要执行的命令，而之后的其他项则是命令的参数</li>
<li>argc 属性负责记录 argv 数组的长度</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-命令数组.png" style="zoom: 67%;">

<p>服务器将根据项 argv[0] 的值，在命令表中查找命令所对应的命令的 redisCommand，将客户端状态的 cmd 指向该结构</p>
<p>命令表是一个字典结构，键是 SDS 结构保存命令的名字；值是命令所对应的 redisCommand 结构，保存了命令的实现函数、命令标志、 命令应该给定的参数个数、命令的总执行次数和总消耗时长等统计信息</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-命令查找.png" style="zoom:67%;">



<hr>
<h5 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h5><p>客户端状态的 authenticated 属性用于记录客户端是否通过了身份验证</p>
<ul>
<li>authenticated 值为 0，表示客户端未通过身份验证</li>
<li>authenticated 值为 1，表示客户端已通过身份验证</li>
</ul>
<p>当客户端 authenticated &#x3D; 0 时，除了 AUTH 命令之外， 客户端发送的所有其他命令都会被服务器拒绝执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; PING </span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">redis&gt; AUTH 123321 </span><br><span class="line">OK</span><br><span class="line">redis&gt; PING </span><br><span class="line">PONG </span><br></pre></td></tr></table></figure>



<hr>
<h5 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h5><p>ctime 属性记录了创建客户端的时间，这个时间可以用来计算客户端与服务器已经连接了多少秒，<code>CLIENT list</code> 命令的 age 域记录了这个秒数</p>
<p>lastinteraction 属性记录了客户端与服务器最后一次进行互动 (interaction) 的时间，互动可以是客户端向服务器发送命令请求，也可以是服务器向客户端发送命令回复。该属性可以用来计算客户端的空转 (idle) 时长， 就是距离客户端与服务器最后一次进行互动已经过去了多少秒，<code>CLIENT list</code> 命令的 idle 域记录了这个秒数</p>
<p>obuf_soft_limit_reached_time 属性记录了<strong>输出缓冲区第一次到达软性限制</strong> (soft limit) 的时间</p>
<hr>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p>服务器使用不同的方式来创建和关闭不同类型的客户端</p>
<p>如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端使用 connect 函数连接到服务器时，服务器就会调用连接应答处理器为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构 clients 链表的末尾</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%9C%8D%E5%8A%A1%E5%99%A8clients%E9%93%BE%E8%A1%A8.png"></p>
<p>服务器会在初始化时创建负责执行 Lua 脚本中包含的 Redis 命令的伪客户端，并将伪客户端关联在服务器状态的 lua_client 属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 保存伪客户端</span></span><br><span class="line">    redisClient *lua_client；</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>lua_client 伪客户端在服务器运行的整个生命周期会一直存在，只有服务器被关闭时，这个客户端才会被关闭</p>
<p>载入 AOF 文件时， 服务器会创建用于执行 AOF 文件包含的 Redis 命令的伪客户端，并在载入完成之后，关闭这个伪客户端</p>
<hr>
<h5 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h5><p>一个普通客户端可以因为多种原因而被关闭：</p>
<ul>
<li>客户端进程退出或者被杀死，那么客户端与服务器之间的网络连接将被关闭，从而造成客户端被关闭</li>
<li>客户端向服务器发送了带有不符合协议格式的命令请求，那么这个客户端会<strong>被服务器关闭</strong></li>
<li>客户端是 <code>CLIENT KILL</code> 命令的目标</li>
<li>如果用户为服务器设置了 timeout 配置选项，那么当客户端的空转时间超过该值时将被关闭，特殊情况不会被关闭：<ul>
<li>客户端是主服务器（REDIS_MASTER ）或者从服务器（打开了 REDIS_SLAVE 标志）</li>
<li>正在被 BLPOP 等命令阻塞（REDIS_BLOCKED）</li>
<li>正在执行 SUBSCRIBE、PSUBSCRIBE 等订阅命令</li>
</ul>
</li>
<li>客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为 1GB）</li>
<li>发送给客户端的命令回复的大小超过了输出缓冲区的限制大小</li>
</ul>
<p>理论上来说，可变缓冲区可以保存任意长的命令回复，但是为了回复过大占用过多的服务器资源，服务器会时刻检查客户端的输出缓冲区的大小，并在缓冲区的大小超出范围时，执行相应的限制操作：</p>
<ul>
<li>硬性限制 (hard limit)：输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器会关闭客户端（serverCron 函数中执行），积存在输出缓冲区中的所有内容会被<strong>直接释放</strong>，不会返回给客户端</li>
<li>软性限制 (soft limit)：输出缓冲区的大小超过了软性限制所设置的大小，小于硬性限制的大小，服务器的操作：<ul>
<li>用属性 obuf_soft_limit_reached_time 记录下客户端到达软性限制的起始时间，继续监视客户端</li>
<li>如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端</li>
<li>如果在指定时间内不再超出软性限制，那么客户端就不会被关闭，并且 o_s_l_r_t 属性清零</li>
</ul>
</li>
</ul>
<p>使用 client-output-buffer-limit 选项可以为普通客户端、从服务器客户端、执行发布与订阅功能的客户端分别设置不同的软性限制和硬性限制，格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">client-output-buffer-limit &lt;class&gt; &lt;hard <span class="built_in">limit</span>&gt; &lt;soft <span class="built_in">limit</span>&gt; &lt;soft seconds&gt;</span><br><span class="line"></span><br><span class="line">client-output-buffer-limit normal 0 0 0 </span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60 </span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行：将普通客户端的硬性限制和软性限制都设置为 0，表示不限制客户端的输出缓冲区大小</li>
<li>第二行：将从服务器客户端的硬性限制设置为 256MB，软性限制设置为 64MB，软性限制的时长为 60 秒</li>
<li>第三行：将执行发布与订阅功能的客户端的硬性限制设置为 32MB，软性限制设置为 8MB，软性限制的时长为 60 秒</li>
</ul>
<hr>
<h3 id="服务器-2"><a href="#服务器-2" class="headerlink" title="服务器"></a>服务器</h3><h4 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h4><p>Redis 服务器与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转，所以一个命令请求从发送到获得回复的过程中，客户端和服务器需要完成一系列操作</p>
<h5 id="命令请求"><a href="#命令请求" class="headerlink" title="命令请求"></a>命令请求</h5><p>Redis 服务器的命令请求来自 Redis 客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，通过连接到服务器的套接字，将协议格式的命令请求发送给服务器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SET KEY VALUE -&gt;	<span class="comment"># 命令</span></span><br><span class="line">*3\r\nS3\r\nSET\r\n<span class="variable">$3</span>\r\nKEY\r\n<span class="variable">$5</span>\r\nVALUE\r\n	<span class="comment"># 协议格式</span></span><br></pre></td></tr></table></figure>

<p>当客户端与服务器之间的连接套接字因为客户端的写入而变得可读，服务器调用<strong>命令请求处理器</strong>来执行以下操作：</p>
<ul>
<li>读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面</li>
<li>对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的 argv 属性和 argc 属性里</li>
<li>调用命令执行器，执行客户端指定的命令</li>
</ul>
<p>最后客户端接收到协议格式的命令回复之后，会将这些回复转换成用户可读的格式打印给用户观看，至此整体流程结束</p>
<hr>
<h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h5><p>命令执行器开始对命令操作：</p>
<ul>
<li><p>查找命令：首先根据客户端状态的 argv[0] 参数，在<strong>命令表 (command table)</strong> 中查找参数所指定的命令，并将找到的命令保存到客户端状态的 cmd 属性里面，是一个 redisCommand 结构</p>
<p>命令查找算法与字母的大小写无关，所以命令名字的大小写不影响命令表的查找结果</p>
</li>
<li><p>执行预备操作：</p>
<ul>
<li>检查客户端状态的 cmd 指针是否指向 NULL，根据 redisCommand 检查请求参数的数量是否正确</li>
<li>检查客户端是否通过身份验证</li>
<li>如果服务器打开了 maxmemory 功能，执行命令之前要先检查服务器的内存占用，在有需要时进行内存回收（<strong>逐出算法</strong>）</li>
<li>如果服务器上一次执行 BGSAVE 命令出错，并且服务器打开了 stop-writes-on-bgsave-error 功能，那么如果本次执行的是写命令，服务会拒绝执行，并返回错误</li>
<li>如果客户端当前正在用 SUBSCRIBE 或 PSUBSCRIBE 命令订阅频道，那么服务器会拒绝除了 SUBSCRIBE、SUBSCRIBE、 UNSUBSCRIBE、PUNSUBSCRIBE 之外的其他命令</li>
<li>如果服务器正在进行载入数据，只有 sflags 带有 1 标识（比如 INFO、SHUTDOWN、PUBLISH等）的命令才会被执行</li>
<li>如果服务器执行 Lua 脚本而超时并进入阻塞状态，那么只会执行客户端发来的 SHUTDOWN nosave 和 SCRIPT KILL 命令</li>
<li>如果客户端正在执行事务，那么服务器只会执行客户端发来的 EXEC、DISCARD、MULTI、WATCH 四个命令，其他命令都会被<strong>放进事务队列</strong>中</li>
<li>如果服务器打开了监视器功能，那么会将要执行的命令和参数等信息发送给监视器</li>
</ul>
</li>
<li><p>调用命令的实现函数：被调用的函数会执行指定的操作并产生相应的命令回复，回复会被保存在客户端状态的输出缓冲区里面（buf 和 reply 属性），然后实现函数还会<strong>为客户端的套接字关联命令回复处理器</strong>，这个处理器负责将命令回复返回给客户端</p>
</li>
<li><p>执行后续工作：</p>
<ul>
<li>如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志</li>
<li>根据执行命令所耗费的时长，更新命令的 redisCommand 结构的 milliseconds 属性，并将命令 calls 计数器的值增一</li>
<li>如果服务器开启了 AOF 持久化功能，那么 AOF 持久化模块会将执行的命令请求写入到 AOF 缓冲区里面</li>
<li>如果有其他从服务器正在复制当前这个服务器，那么服务器会将执行的命令传播给所有从服务器</li>
</ul>
</li>
<li><p>将命令回复发送给客户端：客户端<strong>套接字变为可写状态</strong>时，服务器就会执行命令回复处理器，将客户端输出缓冲区中的命令回复发送给客户端，发送完毕之后回复处理器会清空客户端状态的输出缓冲区，为处理下一个命令请求做好准备</p>
</li>
</ul>
<hr>
<h5 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h5><p>每个 redisCommand 结构记录了一个Redis 命令的实现信息，主要属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> &#123;</span></span><br><span class="line">    <span class="comment">// 命令的名字，比如&quot;set&quot;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数指针，指向命令的实现函数，比如setCommand</span></span><br><span class="line">    <span class="comment">// redisCommandProc 类型的定义为 typedef void redisCommandProc(redisClient *c)</span></span><br><span class="line">    redisCommandProc *proc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 命令参数的个数，用于检查命令请求的格式是否正确。如果这个值为负数-N, 那么表示参数的数量大于等于N。</span></span><br><span class="line">    <span class="comment">// 注意命令的名字本身也是一个参数，比如 SET msg &quot;hello&quot;，命令的参数是&quot;SET&quot;、&quot;msg&quot;、&quot;hello&quot; 三个</span></span><br><span class="line">	<span class="type">int</span> arity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串形式的标识值，这个值记录了命令的属性，，</span></span><br><span class="line">    <span class="comment">// 比如这个命令是写命令还是读命令，这个命令是否允许在载入数据时使用，是否允许在Lua脚本中使用等等</span></span><br><span class="line">    <span class="type">char</span> *sflags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对sflags标识进行分析得出的二进制标识，由程序自动生成。服务器对命令标识进行检查时使用的都是 flags 属性</span></span><br><span class="line">    <span class="comment">// 而不是sflags属性，因为对二进制标识的检查可以方便地通过&amp; ^ ~ 等操作来完成</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器总共执行了多少次这个命令</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> calls;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器执行这个命令所耗费的总时长</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> milliseconds;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="serverCron"><a href="#serverCron" class="headerlink" title="serverCron"></a>serverCron</h4><h5 id="基本介绍-14"><a href="#基本介绍-14" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>Redis 服务器以周期性事件的方式来运行 serverCron 函数，服务器初始化时读取配置 server.hz 的值，默认为 10，代表每秒钟执行 10 次，即<strong>每隔 100 毫秒执行一次</strong>，执行指令 info server 可以查看</p>
<p>serverCron 函数负责定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行</p>
<ul>
<li>更新服务器的各类统计信息，比如时间、内存占用、 数据库占用情况等</li>
<li>清理数据库中的过期键值对</li>
<li>关闭和清理连接失效的客户端</li>
<li>进行 AOF 或 RDB 持久化操作</li>
<li>如果服务器是主服务器，那么对从服务器进行定期同步</li>
<li>如果处于集群模式，对集群进行定期同步和连接测试</li>
</ul>
<hr>
<h5 id="时间缓存"><a href="#时间缓存" class="headerlink" title="时间缓存"></a>时间缓存</h5><p>Redis 服务器中有很多功能需要获取系统的当前时间，而每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的执行次数，服务器状态中的 unixtime 属性和 mstime 属性被用作当前时间的缓存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 保存了秒级精度的系统当前UNIX时间戳</span></span><br><span class="line">    <span class="type">time_t</span> unixtime;</span><br><span class="line">	<span class="comment">// 保存了毫秒级精度的系统当前UNIX时间戳 </span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mstime;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>serverCron 函数默认以每 100 毫秒一次的频率更新两个属性，所以属性记录的时间的精确度并不高</p>
<ul>
<li>服务器只会在打印日志、更新服务器的 LRU 时钟、决定是否执行持久化任务、计算服务器上线时间（uptime）这类对时间精确度要求不高的功能上</li>
<li>对于为键设置过期时间、添加慢查询日志这种需要高精确度时间的功能来说，服务器还是会再次执行系统调用，从而获得最准确的系统当前时间</li>
</ul>
<hr>
<h5 id="LRU-时钟"><a href="#LRU-时钟" class="headerlink" title="LRU 时钟"></a>LRU 时钟</h5><p>服务器状态中的 lruclock 属性保存了服务器的 LRU 时钟</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 默认每10秒更新一次的时钟缓存，用于计算键的空转(idle)时长。 </span></span><br><span class="line">    <span class="type">unsigned</span> lruclock:<span class="number">22</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个 Redis 对象都会有一个 lru 属性， 这个 lru 属性保存了对象最后一次被命令访问的时间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObiect</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> lru:<span class="number">22</span>; </span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>当服务器要计算一个数据库键的空转时间（即数据库键对应的值对象的空转时间），程序会用服务器的 lruclock 属性记录的时间减去对象的 lru 属性记录的时间</p>
<p>serverCron 函数默认以每 100 毫秒一次的频率更新这个属性，所以得出的空转时间也是模糊的</p>
<hr>
<h5 id="命令次数"><a href="#命令次数" class="headerlink" title="命令次数"></a>命令次数</h5><p>serverCron 中的 trackOperationsPerSecond 函数以每 100 毫秒一次的频率执行，函数功能是以<strong>抽样计算</strong>的方式，估算并记录服务器在最近一秒钟处理的命令请求数量，这个值可以通过 INFO status 命令的 instantaneous_ops_per_sec 域查看：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; INFO stats</span><br><span class="line"><span class="comment"># Stats </span></span><br><span class="line">instantaneous_ops_per_sec:6</span><br></pre></td></tr></table></figure>

<p>根据上一次抽样时间 ops_sec_last_sample_time 和当前系统时间，以及上一次已执行的命令数 ops_sec_last_sample_ops 和服务器当前已经执行的命令数，计算出两次函数调用期间，服务器平均每毫秒处理了多少个命令请求，该值乘以 1000 得到每秒内的执行命令的估计值，放入 ops_sec_samples 环形数组里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 上一次进行抽样的时间</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ops_sec_last_sample_time;</span><br><span class="line">    <span class="comment">// 上一次抽样时，服务器已执行命令的数量 </span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ops_sec_last_sample_ops;</span><br><span class="line">    <span class="comment">// REDIS_OPS_SEC_SAMPLES 大小（默认值为16)的环形数组，数组的每一项记录一次的抽样结果</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ops_sec_samples[REDIS_OPS_SEC_SAMPLES];</span><br><span class="line">    <span class="comment">// ops_sec_samples数组的索引值，每次抽样后将值自增一，值为16时重置为0，让数组成为一个环形数组</span></span><br><span class="line">    <span class="type">int</span> ops_sec_idx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<hr>
<h5 id="内存峰值"><a href="#内存峰值" class="headerlink" title="内存峰值"></a>内存峰值</h5><p>服务器状态里的 stat_peak_memory 属性记录了服务器内存峰值大小，循环函数每次执行时都会查看服务器当前使用的内存数量，并与 stat_peak_memory 保存的数值进行比较，设置为较大的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 已使用内存峰值</span></span><br><span class="line">    <span class="type">size_t</span> stat_peak_memory;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>INFO memory 命令的 used_memory_peak 和 used_memory_peak_human 两个域分别以两种格式记录了服务器的内存峰值：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; INFO memory </span><br><span class="line"><span class="comment"># Memory </span></span><br><span class="line">...</span><br><span class="line">used_memory_peak:501824 </span><br><span class="line">used_memory_peak_human:490.06K</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="SIGTERM"><a href="#SIGTERM" class="headerlink" title="SIGTERM"></a>SIGTERM</h5><p>服务器启动时，Redis 会为服务器进程的 SIGTERM 信号关联处理器 sigtermHandler 函数，该信号处理器负责在服务器接到 SIGTERM 信号时，打开服务器状态的 shutdown_asap 标识</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 关闭服务器的标识：值为1时关闭服务器，值为0时不做操作</span></span><br><span class="line">    <span class="type">int</span> shutdown_asap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每次 serverCron 函数运行时，程序都会对服务器状态的 shutdown_asap 属性进行检查，并根据属性的值决定是否关闭服务器</p>
<p>服务器在接到 SIGTERM 信号之后，关闭服务器并打印相关日志的过程：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[6794 | signal handler] (1384435690) Received SIGTERM, scheduling shutdown ... </span><br><span class="line">[6794] 14 Nov 21:28:10.108 <span class="comment"># User requested shutdown ... </span></span><br><span class="line">[6794] 14 Nov 21:28:10.108 * Saving the final RDB snapshot before exiting. </span><br><span class="line">[6794) 14 Nov 21:28:10.161 * DB saved on disk </span><br><span class="line">[6794) 14 Nov 21:28:10.161 <span class="comment"># Redisis now ready to exit, bye bye ... </span></span><br></pre></td></tr></table></figure>



<hr>
<h5 id="管理资源"><a href="#管理资源" class="headerlink" title="管理资源"></a>管理资源</h5><p>serverCron 函数每次执行都会调用 clientsCron 和 databasesCron 函数，进行管理客户端资源和数据库资源</p>
<p>clientsCron 函数对一定数量的客户端进行以下两个检查：</p>
<ul>
<li>如果客户端与服务器之间的连接巳经超时（很长一段时间客户端和服务器都没有互动），那么程序释放这个客户端</li>
<li>如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存</li>
</ul>
<p>databasesCron 函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时对字典进行收缩操作</p>
<hr>
<h5 id="持久状态"><a href="#持久状态" class="headerlink" title="持久状态"></a>持久状态</h5><p>服务器状态中记录执行 BGSAVE 命令和 BGREWRITEAOF 命令的子进程的 ID</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录执行BGSAVE命令的子进程的ID，如果服务器没有在执行BGSAVE，那么这个属性的值为-1</span></span><br><span class="line">    <span class="type">pid_t</span> rdb_child_pid;</span><br><span class="line">    <span class="comment">// 记录执行BGREWRITEAOF命令的子进程的ID，如果服务器没有在执行那么这个属性的值为-1</span></span><br><span class="line">    <span class="type">pid_t</span> aof_child_pid</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>serverCron 函数执行时，会检查两个属性的值，只要其中一个属性的值不为 -1，程序就会执行一次 wait3 函数，检查子进程是否有信号发来服务器进程：</p>
<ul>
<li>如果有信号到达，那么表示新的 RDB 文件已经生成或者 AOF 重写完毕，服务器需要进行相应命令的后续操作，比如用新的 RDB 文件替换现有的 RDB 文件，用重写后的 AOF 文件替换现有的 AOF 文件</li>
<li>如果没有信号到达，那么表示持久化操作未完成，程序不做动作</li>
</ul>
<p>如果两个属性的值都为 -1，表示服务器没有进行持久化操作</p>
<ul>
<li><p>查看是否有 BGREWRITEAOF 被延迟，然后执行 AOF 后台重写</p>
</li>
<li><p>查看服务器的自动保存条件是否已经被满足，并且服务器没有在进行持久化，就开始一次新的 BGSAVE 操作</p>
<p>因为条件 1 可能会引发一次 AOF，所以在这个检查中会再次确认服务器是否已经在执行持久化操作</p>
</li>
<li><p>检查服务器设置的 AOF 重写条件是否满足，条件满足并且服务器没有进行持久化，就进行一次 AOF 重写</p>
</li>
</ul>
<p>如果服务器开启了 AOF 持久化功能，并且 AOF 缓冲区里还有待写入的数据， 那么 serverCron 函数会调用相应的程序，将 AOF 缓冲区中的内容写入到 AOF 文件里</p>
<hr>
<h5 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h5><p>在服务器执行 BGSAVE 命令的期间，如果客户端发送 BGREWRITEAOF 命令，那么服务器会将 BGREWRITEAOF 命令的执行时间延迟到 BGSAVE 命令执行完毕之后，用服务器状态的 aof_rewrite_scheduled 属性标识延迟与否</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 如果值为1，那么表示有 BGREWRITEAOF命令被延迟了</span></span><br><span class="line">    <span class="type">int</span> aof_rewrite_scheduled;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>serverCron 函数会检查 BGSAVE 或者 BGREWRITEAOF 命令是否正在执行，如果这两个命令都没在执行，并且 aof_rewrite_scheduled 属性的值为 1，那么服务器就会执行之前被推延的 BGREWRITEAOF 命令</p>
<hr>
<h5 id="执行次数"><a href="#执行次数" class="headerlink" title="执行次数"></a>执行次数</h5><p>服务器状态的 cronloops 属性记录了 serverCron 函数执行的次数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// serverCron 函数每执行一次，这个属性的值就增 1</span></span><br><span class="line">    <span class="type">int</span> cronloops;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="缓冲限制"><a href="#缓冲限制" class="headerlink" title="缓冲限制"></a>缓冲限制</h5><p>服务器会关闭那些输入或者输出<strong>缓冲区大小超出限制</strong>的客户端</p>
<hr>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><h5 id="初始结构"><a href="#初始结构" class="headerlink" title="初始结构"></a>初始结构</h5><p>一个 Redis 服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设置过程</p>
<p>第一步：创建一个 redisServer 类型的实例变量 server 作为服务器的状态，并为结构中的各个属性设置默认值，由 initServerConfig 函数进行初始化一般属性：</p>
<ul>
<li>设置服务器的运行 ID、默认运行频率、默认配置文件路径、默认端口号、默认 RDB 持久化条件和 AOF 持久化条件</li>
<li>初始化服务器的 LRU 时钟，创建命令表</li>
</ul>
<p>第二步：载入配置选项，用户可以通过给定配置参数或者指定配置文件，对 server 变量相关属性的默认值进行修改</p>
<p>第三步：初始化服务器数据结构（除了命令表之外），因为服务器<strong>必须先载入用户指定的配置选项才能正确地对数据结构进行初始化</strong>，所以载入配置完成后才进性数据结构的初始化，服务器将调用 initServer 函数：</p>
<ul>
<li>server.clients 链表，记录了的客户端的状态结构；server.db 数组，包含了服务器的所有数据库</li>
<li>用于保存频道订阅信息的 server.pubsub_channels 字典， 以及保存模式订阅信息的 server.pubsub_patterns 链表</li>
<li>用于执行 Lua 脚本的 Lua 环境 server.lua </li>
<li>保存慢查询日志的 server.slowlog 属性</li>
</ul>
<p>initServer 还进行了非常重要的设置操作：</p>
<ul>
<li>为服务器设置进程信号处理器</li>
<li>创建共享对象，包含 OK、ERR、<strong>整数 1 到 10000 的字符串对象</strong>等</li>
<li><strong>打开服务器的监听端口</strong></li>
<li><strong>为 serverCron 函数创建时间事件</strong>， 等待服务器正式运行时执行 serverCron 函数</li>
<li>如果 AOF 持久化功能已经打开，那么打开现有的 AOF 文件，如果 AOF 文件不存在，那么创建并打开一个新的 AOF 文件 ，为 AOF 写入做好准备</li>
<li><strong>初始化服务器的后台 I&#x2F;O 模块</strong>（BIO）, 为将来的 I&#x2F;O 操作做好准备</li>
</ul>
<p>当 initServer 函数执行完毕之后， 服务器将用 ASCII 字符在日志中打印出 Redis 的图标， 以及 Redis 的版本号信息</p>
<hr>
<h5 id="还原状态"><a href="#还原状态" class="headerlink" title="还原状态"></a>还原状态</h5><p>在完成了对服务器状态的初始化之后，服务器需要载入RDB文件或者AOF 文件， 并根据文件记录的内容来还原服务器的数据库状态：</p>
<ul>
<li>如果服务器启用了 AOF 持久化功能，那么服务器使用 AOF 文件来还原数据库状态</li>
<li>如果服务器没有启用 AOF 持久化功能，那么服务器使用 RDB 文件来还原数据库状态</li>
</ul>
<p>当服务器完成数据库状态还原工作之后，服务器将在日志中打印出载入文件并还原数据库状态所耗费的时长</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[7171] 22 Nov 22:43:49.084 * DB loaded from disk: 0.071 seconds </span><br></pre></td></tr></table></figure>



<hr>
<h5 id="驱动循环"><a href="#驱动循环" class="headerlink" title="驱动循环"></a>驱动循环</h5><p>在初始化的最后一步，服务器将打印出以下日志，并开始<strong>执行服务器的事件循环</strong>（loop）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">7171</span>] <span class="number">22</span> Nov <span class="number">22</span>:<span class="number">43</span>:<span class="number">49.084</span> * The server is now ready to accept connections on pert <span class="number">6379</span></span><br></pre></td></tr></table></figure>

<p>服务器现在开始可以接受客户端的连接请求，并处理客户端发来的命令请求了</p>
<hr>
<h3 id="慢日志-1"><a href="#慢日志-1" class="headerlink" title="慢日志"></a>慢日志</h3><h4 id="基本介绍-15"><a href="#基本介绍-15" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Redis 的慢查询日志功能用于记录执行时间超过给定时长的命令请求，通过产生的日志来监视和优化查询速度</p>
<p>服务器配置有两个和慢查询日志相关的选项：</p>
<ul>
<li>slowlog-log-slower-than 选项指定执行时间超过多少微秒的命令请求会被记录到日志上</li>
<li>slowlog-max-len 选项指定服务器最多保存多少条慢查询日志</li>
</ul>
<p>服务器使用先进先出 FIFO 的方式保存多条慢查询日志，当服务器存储的慢查询日志数量等于 slowlog-max-len 选项的值时，在添加一条新的慢查询日志之前，会先将最旧的一条慢查询日志删除</p>
<p>配置选项可以通过 CONFIG SET option value 命令进行设置</p>
<p>常用命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SLOWLOG GET [n]	<span class="comment"># 查看 n 条服务器保存的慢日志</span></span><br><span class="line">SLOWLOG LEN		<span class="comment"># 查看日志数量</span></span><br><span class="line">SLOWLOG RESET	<span class="comment"># 清除所有慢查询日志</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="日志保存"><a href="#日志保存" class="headerlink" title="日志保存"></a>日志保存</h4><p>服务器状态中包含了慢查询日志功能有关的属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	<span class="comment">// 下一条慢查询日志的ID</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> slowlog_entry_id;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 保存了所有慢查询日志的链表</span></span><br><span class="line">	<span class="built_in">list</span> *slowlog;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 服务器配置选项的值 </span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> slowlog-<span class="built_in">log</span>-slower-than;</span><br><span class="line">	<span class="comment">// 服务器配置选项的值</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> slowlog_max_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>slowlog_entry_id 属性的初始值为 0，每当创建一条新的慢查询日志时，这个属性就会用作新日志的 id 值，之后该属性增一</p>
<p>slowlog 链表保存了服务器中的所有慢查询日志，链表中的每个节点是一个 slowlogEntry 结构， 代表一条慢查询日志：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slowlogEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 唯一标识符</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> id;</span><br><span class="line">   	<span class="comment">// 命令执行时的时间，格式为UNIX时间戳</span></span><br><span class="line">    <span class="type">time_t</span> time;</span><br><span class="line">	<span class="comment">// 执行命令消耗的时间，以微秒为单位 </span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> duration;</span><br><span class="line">	<span class="comment">// 命令与命令参数</span></span><br><span class="line">	robj **argv;</span><br><span class="line">	<span class="comment">// 命令与命令参数的数量</span></span><br><span class="line">	<span class="type">int</span> argc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="添加日志"><a href="#添加日志" class="headerlink" title="添加日志"></a>添加日志</h4><p>在每次执行命令的前后，程序都会记录微秒格式的当前 UNIX 时间戳，两个时间之差就是执行命令所耗费的时长，函数会检查命令的执行时长是否超过 slowlog-log-slower-than 选项所设置：</p>
<ul>
<li><p>如果是的话，就为命令创建一个新的日志，并将新日志添加到 slowlog 链表的表头</p>
</li>
<li><p>检查慢查询日志的长度是否超过 slowlog-max-len 选项所设置的长度，如果是将多出来的日志从 slowlog 链表中删除掉</p>
</li>
<li><p>将 redisServer. slowlog_entry_id 的值增 1</p>
</li>
</ul>
<hr>
<h2 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h4><p>Redis 构建了简单动态字符串（SDS）的数据类型，作为 Redis 的默认字符串表示，包含字符串的键值对在底层都是由 SDS 实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量，等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 【字节】数组，用于保存字符串（不是字符数组）</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SDS 遵循 C 字符串<strong>以空字符结尾</strong>的惯例，保存空字符的 1 字节不计算在 len 属性，SDS 会自动为空字符分配额外的 1 字节空间和添加空字符到字符串末尾，所以空字符对于 SDS 的使用者来说是完全透明的</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-SDS%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<hr>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>常数复杂度获取字符串长度：</p>
<ul>
<li>C 字符串不记录自身的长度，获取时需要遍历整个字符串，遇到空字符串为止，时间复杂度为 O(N)</li>
<li>SDS 获取字符串长度的时间复杂度为 O(1)，设置和更新 SDS 长度由函数底层自动完成</li>
</ul>
<p>杜绝缓冲区溢出：</p>
<ul>
<li><p>C 字符串调用 strcat 函数拼接字符串时，如果字符串内存不够容纳目标字符串，就会造成缓冲区溢出（Buffer Overflow）</p>
<p>s1 和 s2 是内存中相邻的字符串，执行 <code>strcat(s1, &quot; Cluster&quot;)</code>（有空格）：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98.png"></p>
</li>
<li><p>SDS 空间分配策略：当对 SDS 进行修改时，首先检查 SDS 的空间是否满足修改所需的要求， 如果不满足会自动将 SDS 的空间扩展至执行修改所需的大小，然后执行实际的修改操作， 避免了缓冲区溢出的问题</p>
</li>
</ul>
<p>二进制安全：</p>
<ul>
<li>C 字符串中的字符必须符合某种编码（比如 ASCII）方式，除了字符串末尾以外其他位置不能包含空字符，否则会被误认为是字符串的结尾，所以只能保存文本数据</li>
<li>SDS 的 API 都是二进制安全的，使用字节数组 buf 保存一系列的二进制数据，<strong>使用 len 属性来判断数据的结尾</strong>，所以可以保存图片、视频、压缩文件等二进制数据</li>
</ul>
<p>兼容 C 字符串的函数：SDS 会在为 buf 数组分配空间时多分配一个字节来保存空字符，所以可以重用一部分 C 字符串函数库的函数</p>
<hr>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>C 字符串<strong>每次</strong>增长或者缩短都会进行一次内存重分配，拼接操作通过重分配扩展底层数组空间，截断操作通过重分配释放不使用的内存空间，防止出现内存泄露</p>
<p>SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联，在 SDS 中 buf 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节，字节的数量由 free 属性记录</p>
<p>内存重分配涉及复杂的算法，需要执行<strong>系统调用</strong>，是一个比较耗时的操作，SDS 的两种优化策略：</p>
<ul>
<li><p>空间预分配：当 SDS 的 API 进行修改并且需要进行空间扩展时，程序不仅会为 SDS 分配修改所必需的空间， 还会为 SDS 分配额外的未使用空间</p>
<ul>
<li><p>对 SDS 修改之后，SDS 的长度（len 属性）小于 1MB，程序分配和 len 属性同样大小的未使用空间，此时 len 和 free 相等</p>
<p>s 为 Redis，执行 <code>sdscat(s, &quot; Cluster&quot;)</code> 后，len 变为 13 字节，所以也分配了 13 字节的 free 空间，总长度变为 27 字节（额外的一字节保存空字符，13 + 13 + 1 &#x3D; 27）</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-SDS%E5%86%85%E5%AD%98%E9%A2%84%E5%88%86%E9%85%8D.png"></p>
</li>
<li><p>对 SDS 修改之后，SDS 的长度大于等于 1MB，程序会分配 1MB 的未使用空间</p>
</li>
</ul>
<p>在扩展 SDS 空间前，API 会先检查 free 空间是否足够，如果足够就无需执行内存重分配，所以通过预分配策略，SDS 将连续增长 N 次字符串所需内存的重分配次数从<strong>必定 N 次降低为最多 N 次</strong></p>
</li>
<li><p>惰性空间释放：当 SDS 的 API 需要缩短字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些字节的数量记录起来，并等待将来使用</p>
<p>SDS 提供了相应的 API 来真正释放 SDS 的未使用空间，所以不用担心空间惰性释放策略造成的内存浪费问题</p>
</li>
</ul>
<hr>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表提供了高效的节点重排能力，C 语言并没有内置这种数据结构，所以 Redis 构建了链表数据类型</p>
<p>链表节点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="type">void</span> *value</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>多个 listNode 通过 prev 和 next 指针组成<strong>双端链表</strong>：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<p>list 链表结构：提供了表头指针 head 、表尾指针 tail 以及链表长度计数器 len</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点值复制函数，用于复制链表节点所保存的值</span></span><br><span class="line">    <span class="type">void</span> *(*dup) (<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数，用于释放链表节点所保存的值</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>) (<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数，用于对比链表节点所保存的值和另一个输入值是否相等</span></span><br><span class="line">    <span class="type">int</span> (*match) (<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E9%93%BE%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<p>Redis 链表的特性：</p>
<ul>
<li>双端：链表节点带有 prev 和 next 指针，获取某个节点的前置节点和后置节点的时间复杂度都是 O(1)</li>
<li>无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL，对链表的访问以 NULL 为终点</li>
<li>带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针，获取链表的表头节点和表尾节点的时间复杂度为 O(1)</li>
<li>带链表长度计数器：使用 len 属性来对 list 持有的链表节点进行计数，获取链表中节点数量的时间复杂度为 O(1)</li>
<li>多态：链表节点使用 void * 指针来保存节点值， 并且可以通过 dup、free 、match 三个属性为节点值设置类型特定函数，所以链表可以保存各种<strong>不同类型的值</strong></li>
</ul>
<hr>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>Redis 字典使用的哈希表结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组，数组中每个元素指向 dictEntry 结构</span></span><br><span class="line">	dictEntry **table;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 哈希表大小，数组的长度</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 哈希表大小掩码，用于计算索引值，总是等于 【size-1】</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 该哈希表已有节点的数量 </span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>哈希表节点结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">	<span class="type">void</span> *key;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 值，可以是一个指针，或者整数</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;	<span class="comment">// 指针</span></span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 指向下个哈希表节点，形成链表，用来解决冲突问题</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<hr>
<h4 id="字典结构"><a href="#字典结构" class="headerlink" title="字典结构"></a>字典结构</h4><p>字典，又称为符号表、关联数组、映射（Map），用于保存键值对的数据结构，字典中的每个键都是独一无二的。底层采用哈希表实现，一个哈希表包含多个哈希表节点，每个节点保存一个键值对</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表，数组中的每个项都是一个dictht哈希表，</span></span><br><span class="line">    <span class="comment">// 一般情况下字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rehash 索引，当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="type">int</span> rehashidx;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p>
<ul>
<li>type 属性是指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数</li>
<li>privdata 属性保存了需要传给那些类型特定函数的可选参数</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%AD%97%E5%85%B8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<hr>
<h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>Redis 使用 MurmurHash 算法来计算键的哈希值，这种算法的优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快</p>
<p>将一个新的键值对添加到字典里，需要先根据键 key 计算出哈希值，然后进行取模运算（取余）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask</span><br></pre></td></tr></table></figure>

<p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上时，就称这些键发生了哈希冲突（collision）</p>
<p>Redis 的哈希表使用链地址法（separate chaining）来解决键哈希冲突， 每个哈希表节点都有一个 next 指针，多个节点通过 next 指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题</p>
<p>dictEntry 节点组成的链表没有指向链表表尾的指针，为了速度考虑，程序总是将新节点添加到链表的表头位置（<strong>头插法</strong>），时间复杂度为 O(1)</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%AD%97%E5%85%B8%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81.png"></p>
<hr>
<h4 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h4><p>负载因子的计算方式：哈希表中的<strong>节点数量</strong> &#x2F; 哈希表的大小（<strong>长度</strong>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size</span><br></pre></td></tr></table></figure>

<p>为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时 ，程序会自动对哈希表的大小进行相应的扩展或者收缩</p>
<p>哈希表执行扩容的条件：</p>
<ul>
<li><p>服务器没有执行 BGSAVE 或者 BGREWRITEAOF 命令，哈希表的负载因子大于等于 1</p>
</li>
<li><p>服务器正在执行 BGSAVE 或者 BGREWRITEAOF 命令，哈希表的负载因子大于等于 5</p>
<p>原因：执行该命令的过程中，Redis 需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on­-write）技术来优化子进程的使用效率，通过提高执行扩展操作的负载因子，尽可能地避免在子进程存在期间进行哈希表扩展操作，可以避免不必要的内存写入操作，最大限度地节约内存</p>
</li>
</ul>
<p>哈希表执行收缩的条件：负载因子小于 0.1（自动执行，servreCron 中检测），缩小为字典中数据个数的 50% 左右</p>
<hr>
<h4 id="重新散列"><a href="#重新散列" class="headerlink" title="重新散列"></a>重新散列</h4><p>扩展和收缩哈希表的操作通过 rehash（重新散列）来完成，步骤如下：</p>
<ul>
<li>为字典的 ht[1] 哈希表分配空间，空间大小的分配情况：<ul>
<li>如果执行的是扩展操作，ht[1] 的大小为第一个大于等于 $ht[0].used * 2$ 的 $2^n$</li>
<li>如果执行的是收缩操作，ht[1] 的大小为第一个大于等于 $ht[0].used$ 的 $2^n$</li>
</ul>
</li>
<li>将保存在 ht[0] 中所有的键值对重新计算哈希值和索引值，迁移到 ht[1] 上</li>
<li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后（ht[0] 变为空表），释放 ht[0]，将 ht[1] 设置为 ht[0]，并在 ht[1] 创建一个新的空白哈希表，为下一次 rehash 做准备</li>
</ul>
<p>如果哈希表里保存的键值对数量很少，rehash 就可以在瞬间完成，但是如果哈希表里数据很多，那么要一次性将这些键值对全部 rehash 到 ht[1] 需要大量计算，可能会导致服务器在一段时间内停止服务</p>
<p>Redis 对 rehash 做了优化，使 rehash 的动作并不是一次性、集中式的完成，而是分多次，渐进式的完成，又叫<strong>渐进式 rehash</strong></p>
<ul>
<li>为 ht[1] 分配空间，此时字典同时持有 ht[0] 和 ht[1] 两个哈希表</li>
<li>在字典中维护了一个索引计数器变量 rehashidx，并将变量的值设为 0，表示 rehash 正式开始</li>
<li>在 rehash 进行期间，每次对字典执行增删改查操作时，程序除了执行指定的操作以外，还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]，rehash 完成之后<strong>将 rehashidx 属性的值增一</strong></li>
<li>随着字典操作的不断执行，最终在某个时间点上 ht[0] 的所有键值对都被 rehash 至 ht[1]，这时程序将 rehashidx 属性的值设为 -1，表示 rehash 操作已完成</li>
</ul>
<p>渐进式 rehash 采用<strong>分而治之</strong>的方式，将 rehash 键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式 rehash 带来的庞大计算量</p>
<p>渐进式 rehash 期间的哈希表操作：</p>
<ul>
<li>字典的查找、删除、更新操作会在两个哈希表上进行，比如查找一个键会先在 ht[0] 上查找，查找不到就去 ht[1] 继续查找</li>
<li>字典的添加操作会直接在 ht[1] 上添加，不在 ht[0] 上进行任何添加</li>
</ul>
<hr>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><h4 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h4><p>跳跃表（skiplist）是一种有序（<strong>默认升序</strong>）的数据结构，在链表的基础上<strong>增加了多级索引以提升查找的效率</strong>，索引是占内存的，所以是一个<strong>空间换时间</strong>的方案，跳表平均 O(logN)、最坏 O(N) 复杂度的节点查找，效率与平衡树相当但是实现更简单</p>
<p>原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，因此当节点本身比较大或者元素数量比较多的时候，其优势可以被放大，而缺点（占内存）则可以忽略</p>
<p>Redis 只在两个地方应用了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点，O(1) 的时间复杂度定位头尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skiplistNode</span> *<span class="title">head</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表的长度，也就是表内的节点数量 (表头节点不计算在内)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数 (表头节点的层高不计算在内)</span></span><br><span class="line">    <span class="type">int</span> level</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E8%B7%B3%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<hr>
<h4 id="属性分析"><a href="#属性分析" class="headerlink" title="属性分析"></a>属性分析</h4><p>层：level 数组包含多个元素，每个元素包含指向其他节点的指针。根据幕次定律（power law，越大的数出现的概率越小）<strong>随机</strong>生成一个介于 1 和 32 之间的值（Redis5 之后最大为 64）作为 level 数组的大小，这个大小就是层的高度，节点的第一层是 level[0] &#x3D; L1</p>
<p>前进指针：forward 用于从表头到表尾方向<strong>正序（升序）遍历节点</strong>，遇到 NULL 停止遍历</p>
<p>跨度：span 用于记录两个节点之间的距离，用来<strong>计算排位（rank）</strong>：</p>
<ul>
<li><p>两个节点之间的跨度越大相距的就越远，指向 NULL 的所有前进指针的跨度都为 0</p>
</li>
<li><p>在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，结果就是目标节点在跳跃表中的排位，按照上图所示：</p>
<p>查找分值为 3.0 的节点，沿途经历的层：查找的过程只经过了一个层，并且层的跨度为 3，所以目标节点在跳跃表中的排位为 3</p>
<p>查找分值为 2.0 的节点，沿途经历的层：经过了两个跨度为 1 的节点，因此可以计算出目标节点在跳跃表中的排位为 2</p>
</li>
</ul>
<p>后退指针：backward 用于从表尾到表头方向<strong>逆序（降序）遍历节点</strong></p>
<p>分值：score 属性一个 double 类型的浮点数，跳跃表中的所有节点都<strong>按分值从小到大来排序</strong></p>
<p>成员对象：obj 属性是一个指针，指向一个 SDS 字符串对象。同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值可以是相同的，分值相同的节点将按照成员对象在字典序中的大小来进行排序（从小到大）</p>
<p>个人笔记：JUC → 并发包 → ConcurrentSkipListMap 详解跳跃表</p>
<hr>
<h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><h4 id="底层结构-1"><a href="#底层结构-1" class="headerlink" title="底层结构"></a>底层结构</h4><p>整数集合（intset）是用于保存整数值的集合数据结构，是 Redis 集合键的底层实现之一</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">	<span class="comment">// 编码方式</span></span><br><span class="line">	<span class="type">uint32_t</span> encoding;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 集合包含的元素数量，也就是 contents 数组的长度</span></span><br><span class="line">	<span class="type">uint32_t</span> length;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>encoding 取值为三种：INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64</p>
<p>整数集合的每个元素都是 contents 数组的一个数组项（item），在数组中按值的大小从小到大<strong>有序排列</strong>，并且数组中<strong>不包含任何重复项</strong>。虽然 contents 属性声明为 int8_t 类型，但实际上数组并不保存任何 int8_t 类型的值， 真正类型取决于 encoding 属性</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<p>说明：底层存储结构是数组，所以为了保证有序性和不重复性，每次添加一个元素的时间复杂度是 O(N)</p>
<hr>
<h4 id="升级降级"><a href="#升级降级" class="headerlink" title="升级降级"></a>升级降级</h4><p>整数集合添加的新元素的类型比集合现有所有元素的类型都要长时，需要先进行升级（upgrade），升级流程：</p>
<ul>
<li><p>根据新元素的类型长度以及集合元素的数量（包括新元素在内），扩展整数集合底层数组的空间大小</p>
</li>
<li><p>将底层数组现有的所有元素都转换成与新元素相同的类型，并将转换后的元素放入正确的位置，放置过程保证数组的有序性</p>
<p>图示 32 * 4 &#x3D; 128 位，首先将 3 放入索引 2（64 位 - 95 位），然后将 2 放置索引 1，将 1 放置在索引 0，从后向前依次放置在对应的区间，最后放置 65535 元素到索引 3（96 位- 127 位），修改 length 属性为 4</p>
</li>
<li><p>将新元素添加到底层数组里</p>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E5%8D%87%E7%BA%A7.png"></p>
<p>每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为 O(N)</p>
<p>引发升级的新元素的长度总是比整数集合现有所有元素的长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素，升级之后新元素的摆放位置：</p>
<ul>
<li>在新元素小于所有现有元素的情况下，新元素会被放置在底层数组的最开头（索引 0）</li>
<li>在新元素大于所有现有元素的情况下，新元素会被放置在底层数组的最末尾（索引 length-1）</li>
</ul>
<p>整数集合升级策略的优点：</p>
<ul>
<li><p>提升整数集合的灵活性：C 语言是静态类型语言，为了避免类型错误通常不会将两种不同类型的值放在同一个数据结构里面，整数集合可以自动升级底层数组来适应新元素，所以可以随意的添加整数</p>
</li>
<li><p>节约内存：要让数组可以同时保存 int16、int32、int64 三种类型的值，可以直接使用 int64_t 类型的数组作为整数集合的底层实现，但是会造成内存浪费，整数集合可以确保升级操作只会在有需要的时候进行，尽量节省内存</p>
</li>
</ul>
<p>整数集合<strong>不支持降级操作</strong>，一旦对数组进行了升级，编码就会一直保持升级后的状态</p>
<hr>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><h4 id="底层结构-2"><a href="#底层结构-2" class="headerlink" title="底层结构"></a>底层结构</h4><p>压缩列表（ziplist）是 Redis 为了节约内存而开发的，是列表键和哈希键的底层实现之一。是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<ul>
<li>zlbytes：uint32_t 类型 4 字节，记录整个压缩列表占用的内存字节数，在对压缩列表进行内存重分配或者计算 zlend 的位置时使用</li>
<li>zltail：uint32_t 类型 4 字节，记录压缩列表表尾节点距离起始地址有多少字节，通过这个偏移量程序无须遍历整个压缩列表就可以确定表尾节点的地址</li>
<li>zllen：uint16_t 类型 2 字节，记录了压缩列表包含的节点数量，当该属性的值小于 UINT16_MAX (65535) 时，该值就是压缩列表中节点的数量；当这个值等于 UINT16_MAX 时节点的真实数量需要遍历整个压缩列表才能计算得出</li>
<li>entryX：列表节点，压缩列表中的各个节点，<strong>节点的长度由节点保存的内容决定</strong></li>
<li>zlend：uint8_t 类型 1 字节，是一个特殊值 0xFF (255)，用于标记压缩列表的末端</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%A4%BA%E4%BE%8B.png"></p>
<p>列表 zlbytes 属性的值为 0x50 (十进制 80)，表示压缩列表的总长为 80 字节，列表 zltail 属性的值为 0x3c (十进制 60)，假设表的起始地址为 p，计算得出表尾节点 entry3 的地址 p + 60</p>
<hr>
<h4 id="列表节点"><a href="#列表节点" class="headerlink" title="列表节点"></a>列表节点</h4><p>列表节点 entry 的数据结构：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9.png"></p>
<p>previous_entry_length：以字节为单位记录了压缩列表中前一个节点的长度，程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址，完成<strong>从表尾向表头遍历</strong>操作</p>
<ul>
<li>如果前一节点的长度小于 254 字节，该属性的长度为 1 字节，前一节点的长度就保存在这一个字节里</li>
<li>如果前一节点的长度大于等于 254 字节，该属性的长度为 5 字节，其中第一字节会被设置为 0xFE（十进制 254），之后的四个字节则用于保存前一节点的长度</li>
</ul>
<p>encoding：记录了节点的 content 属性所保存的数据类型和长度</p>
<ul>
<li><p>长度为 1 字节、2 字节或者 5 字节，值的最高位为 00、01 或者 10 的是字节数组编码，数组的长度由编码除去最高两位之后的其他位记录，下划线 <code>_</code> 表示留空，而 <code>b</code>、<code>x</code> 等变量则代表实际的二进制数据</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E7%BC%96%E7%A0%81.png"></p>
</li>
<li><p>长度为 1 字节，值的最高位为 11 的是整数编码，整数值的类型和长度由编码除去最高两位之后的其他位记录</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E6%95%B4%E6%95%B0%E7%BC%96%E7%A0%81.png"></p>
</li>
</ul>
<p>content：每个压缩列表节点可以保存一个字节数组或者一个整数值</p>
<ul>
<li><p>字节数组可以是以下三种长度的其中一种：</p>
<ul>
<li><p>长度小于等于 $63 (2^6-1)$ 字节的字节数组</p>
</li>
<li><p>长度小于等于 $16383(2^{14}-1)$ 字节的字节数组</p>
</li>
<li><p>长度小于等于 $4294967295(2^{32}-1)$ 字节的字节数组</p>
</li>
</ul>
</li>
<li><p>整数值则可以是以下六种长度的其中一种：</p>
<ul>
<li><p>4 位长，介于 0 至 12 之间的无符号整数</p>
</li>
<li><p>1 字节长的有符号整数</p>
</li>
<li><p>3 字节长的有符号整数</p>
</li>
<li><p>int16_t 类型整数</p>
</li>
<li><p>int32_t 类型整数</p>
</li>
<li><p>int64_t 类型整数</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h4><p>Redis 将在特殊情况下产生的连续多次空间扩展操作称之为连锁更新（cascade update）</p>
<p>假设在一个压缩列表中，有多个连续的、长度介于 250 到 253 字节之间的节点 e1 至 eN。将一个长度大于等于 254 字节的新节点 new 设置为压缩列表的头节点，new 就成为 e1 的前置节点。e1 的 previous_entry_length 属性仅为 1 字节，无法保存新节点 new 的长度，所以要对压缩列表执行空间重分配操作，并将 e1 节点的 previous_entry_length 属性从 1 字节长扩展为 5 字节长。由于 e1 原本的长度介于 250 至 253 字节之间，所以扩展后 e1 的长度就变成了 254 至 257 字节之间，导致 e2 的  previous_entry_length 属性无法保存 e1 的长度，程序需要不断地对压缩列表执行空间重分配操作，直到 eN 为止</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B01.png"></p>
<p> 删除节点也可能会引发连锁更新，big.length &gt;&#x3D; 254，small.length &lt; 254，删除 small 节点</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B02.png"></p>
<p>连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配，每次重分配的最坏复杂度为 O(N)，所以连锁更新的最坏复杂度为 O(N^2)</p>
<p>说明：尽管连锁更新的复杂度较高，但出现的记录是非常低的，即使出现只要被更新的节点数量不多，就不会对性能造成影响</p>
<hr>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="redisObj"><a href="#redisObj" class="headerlink" title="redisObj"></a>redisObj</h3><h4 id="对象系统"><a href="#对象系统" class="headerlink" title="对象系统"></a>对象系统</h4><p>Redis 使用对象来表示数据库中的键和值，当在 Redis 数据库中新创建一个键值对时至少会创建两个对象，一个对象用作键值对的键（<strong>键对象</strong>），另一个对象用作键值对的值（<strong>值对象</strong>）</p>
<p>Redis 中对象由一个 redisObject 结构表示，该结构中和保存数据有关的三个属性分别是 type、 encoding、ptr：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObiect</span> &#123;</span></span><br><span class="line">	<span class="comment">// 类型</span></span><br><span class="line">	<span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">	<span class="comment">// 编码</span></span><br><span class="line">	<span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">	<span class="comment">// 指向底层数据结构的指针</span></span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>Redis 并没有直接使用数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，而每种对象又通过不同的编码映射到不同的底层数据结构</p>
<p>Redis 自身是一个 Map，其中所有的数据都是采用 key : value 的形式存储，<strong>键对象都是字符串对象</strong>，而值对象有五种基本类型和三种高级类型对象</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A0%81.png"></p>
<ul>
<li>对一个数据库键执行 TYPE 命令，返回的结果为数据库键对应的值对象的类型，而不是键对象的类型</li>
<li>对一个数据库键执行 OBJECT ENCODING 命令，查看数据库键对应的值对象的编码</li>
</ul>
<hr>
<h4 id="命令多态"><a href="#命令多态" class="headerlink" title="命令多态"></a>命令多态</h4><p>Redis 中用于操作键的命令分为两种类型：</p>
<ul>
<li>一种命令可以对任何类型的键执行，比如说 DEL 、EXPIRE、RENAME、 TYPE 等（基于类型的多态）</li>
<li>只能对特定类型的键执行，比如 SET 只能对字符串键执行、HSET 对哈希键执行、SADD 对集合键执行，如果类型步匹配会报类型错误： <code>(error) WRONGTYPE Operation against a key holding the wrong kind of value</code></li>
</ul>
<p>Redis 为了确保只有指定类型的键可以执行某些特定的命令，在执行类型特定的命令之前，先通过值对象 redisObject 结构 type 属性检查操作类型是否正确，然后再决定是否执行指定的命令</p>
<p>对于多态命令，比如列表对象有 ziplist 和 linkedlist 两种实现方式，通过 redisObject 结构 encoding 属性确定具体的编码类型，底层调用对应的 API 实现具体的操作（基于编码的多态）</p>
<hr>
<h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>对象的整个生命周期可以划分为创建对象、 操作对象、 释放对象三个阶段</p>
<p>C 语言没有自动回收内存的功能，所以 Redis 在对象系统中构建了引用计数（reference counting）技术实现的内存回收机制，程序可以跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObiect</span> &#123;</span></span><br><span class="line">	<span class="comment">// 引用计数</span></span><br><span class="line">	<span class="type">int</span> refcount;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>对象的引用计数信息会随着对象的使用状态而不断变化，创建时引用计数 refcount 初始化为 1，每次被一个新程序使用时引用计数加 1，当对象不再被一个程序使用时引用计数值会被减 1，当对象的引用计数值变为 0 时，对象所占用的内存会被释放</p>
<hr>
<h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><p>对象的引用计数属性带有对象共享的作用，共享对象机制更节约内存，数据库中保存的相同值对象越多，节约的内存就越多</p>
<p>让多个键共享一个对象的步骤：</p>
<ul>
<li><p>将数据库键的值指针指向一个现有的值对象</p>
</li>
<li><p>将被共享的值对象的引用计数增一</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-对象共享.png" style="zoom:67%;"></li>
</ul>
<p>Redis 在初始化服务器时创建一万个（配置文件可以修改）字符串对象，包含了<strong>从 0 到 9999 的所有整数值</strong>，当服务器需要用到值为 0 到 9999 的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象</p>
<p>比如创建一个值为 100 的键 A，并使用 OBJECT REFCOUNT 命令查看键 A 的值对象的引用计数，会发现值对象的引用计数为 2，引用这个值对象的两个程序分别是持有这个值对象的服务器程序，以及共享这个值对象的键 A</p>
<p>共享对象在嵌套了字符串对象的对象（linkedlist 编码的列表、hashtable 编码的哈希、zset 编码的有序集合）中也能使用</p>
<p>Redis 不共享包含字符串对象的原因：验证共享对象和目标对象是否相同的复杂度越高，消耗的 CPU 时间也会越多</p>
<ul>
<li>整数值的字符串对象， 验证操作的复杂度为 O(1)</li>
<li>字符串值的字符串对象， 验证操作的复杂度为 O(N)</li>
<li>如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，验证操作的复杂度为 O(N^2)</li>
</ul>
<hr>
<h4 id="空转时长"><a href="#空转时长" class="headerlink" title="空转时长"></a>空转时长</h4><p>redisObject 结构包含一个 lru 属性，该属性记录了对象最后一次被命令程序访问的时间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObiect</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> lru:<span class="number">22</span>; </span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>OBJECT IDLETIME 命令可以打印出给定键的空转时长，该值就是通过将当前时间减去键的值对象的 lru 时间计算得出的，这个命令在访问键的值对象时，不会修改值对象的 lru 属性</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"><span class="comment"># 等待一分钟</span></span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(<span class="built_in">integer</span>) 70</span><br><span class="line"><span class="comment"># 访问 msg</span></span><br><span class="line">redis&gt; GET msg</span><br><span class="line"><span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="comment"># 键处于活跃状态，空转时长为 0</span></span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p>空转时长的作用：如果服务器开启 maxmemory 选项，并且回收内存的算法为 volatile-lru 或者 allkeys-lru，那么当服务器占用的内存数超过了 maxmemory 所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存（LRU 算法）</p>
<hr>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型，实质上是存一个字符串，string 类型是二进制安全的，可以包含任何数据，比如图片或者序列化的对象</p>
<p>存储数据的格式：一个存储空间保存一个数据，每一个空间中只能保存一个字符串信息</p>
<p>存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-string结构图.png" style="zoom:50%;">

<p>Redis 所有操作都是<strong>原子性</strong>的，采用<strong>单线程</strong>机制，命令是单个顺序执行，无需考虑并发带来影响，原子性就是有一个失败则都失败</p>
<p>字符串对象可以是 int、raw、embstr 三种实现方式</p>
<hr>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>指令操作：</p>
<ul>
<li><p>数据操作：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> key value			<span class="comment">#添加/修改数据添加/修改数据</span></span><br><span class="line">del key					<span class="comment">#删除数据</span></span><br><span class="line">setnx key value			<span class="comment">#判定性添加数据，键值为空则设添加</span></span><br><span class="line">mset k1 v1 k2 v2...		<span class="comment">#添加/修改多个数据，m：Multiple</span></span><br><span class="line">append key value		<span class="comment">#追加信息到原始信息后部（如果原始信息存在就追加，否则新建）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查询操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">get key					<span class="comment">#获取数据，如果不存在，返回空（nil）</span></span><br><span class="line">mget key1 key2...		<span class="comment">#获取多个数据</span></span><br><span class="line">strlen key				<span class="comment">#获取数据字符个数（字符串长度）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置数值数据增加&#x2F;减少指定范围的值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">incr key					<span class="comment">#key++</span></span><br><span class="line">incrby key increment		<span class="comment">#key+increment</span></span><br><span class="line">incrbyfloat key increment	<span class="comment">#对小数操作</span></span><br><span class="line">decr key					<span class="comment">#key--</span></span><br><span class="line">decrby key increment		<span class="comment">#key-increment</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置数据具有指定的生命周期</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">setex key seconds value  		<span class="comment">#设置key-value存活时间，seconds单位是秒</span></span><br><span class="line">psetex key milliseconds value	<span class="comment">#毫秒级</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意事项：</p>
<ol>
<li><p>数据操作不成功的反馈与数据正常操作之间的差异</p>
<ul>
<li><p>表示运行结果是否成功</p>
<ul>
<li><p>(integer) 0  → false ，失败</p>
</li>
<li><p>(integer) 1  → true，成功</p>
</li>
</ul>
</li>
<li><p>表示运行结果值</p>
<ul>
<li><p>(integer) 3  → 3 个</p>
</li>
<li><p>(integer) 1  → 1 个</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数据未获取到时，对应的数据为（nil），等同于null</p>
</li>
<li><p><strong>数据最大存储量</strong>：512MB</p>
</li>
<li><p>string 在 Redis 内部存储默认就是一个字符串，当遇到增减类操作 incr，decr 时<strong>会转成数值型</strong>进行计算</p>
</li>
<li><p>按数值进行操作的数据，如果原始数据不能转成数值，或超越了Redis 数值上限范围，将报错<br>9223372036854775807（java 中 Long 型数据最大值，Long.MAX_VALUE）</p>
</li>
<li><p>Redis 可用于控制数据库表主键 ID，为数据库表主键提供生成策略，保障数据库表的主键唯一性</p>
</li>
</ol>
<p>单数据和多数据的选择：</p>
<ul>
<li>单数据执行 3 条指令的过程：3 次发送 + 3 次处理 + 3 次返回</li>
<li>多数据执行 1 条指令的过程：1 次发送 + 3 次处理 + 1 次返回（发送和返回的事件略高于单数据）</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/string单数据与多数据操作.png" style="zoom: 33%;">





<hr>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>字符串对象的编码可以是 int、raw、embstr 三种</p>
<ul>
<li><p>int：字符串对象保存的是<strong>整数值</strong>，并且整数值可以用 long 类型来表示，那么对象会将整数值保存在字符串对象结构的 ptr 属性面（将 void * 转换成 long)，并将字符串对象的编码设置为 int（浮点数用另外两种方式）</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-字符串对象int编码.png" style="zoom:67%;">
</li>
<li><p>raw：字符串对象保存的是一个字符串值，并且值的长度大于 39 字节，那么对象将使用简单动态字符串（SDS）来保存该值，并将对象的编码设置为 raw</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1raw%E7%BC%96%E7%A0%81.png"></p>
</li>
<li><p>embstr：字符串对象保存的是一个字符串值，并且值的长度小于等于 39 字节，那么对象将使用 embstr 编码的方式来保存这个字符串值，并将对象的编码设置为 embstr</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1embstr%E7%BC%96%E7%A0%81.png"></p>
<p>上图所示，embstr 与 raw 都使用了 redisObject 和 sdshdr 来表示字符串对象，但是 raw 需要调用两次内存分配函数分别创建两种结构，embstr 只需要一次内存分配来分配一块<strong>连续的空间</strong></p>
</li>
</ul>
<p>embstr 是用于保存短字符串的一种编码方式，对比 raw 的优点：</p>
<ul>
<li>内存分配次数从两次降低为一次，同样释放内存的次数也从两次变为一次</li>
<li>embstr 编码的字符串对象的数据都保存在同一块连续内存，所以比 raw 编码能够更好地利用缓存优势（局部性原理）</li>
</ul>
<p>int 和 embstr 编码的字符串对象在条件满足的情况下，会被转换为 raw 编码的字符串对象：</p>
<ul>
<li>int 编码的整数值，执行 APPEND 命令追加一个字符串值，先将整数值转为字符串然后追加，最后得到一个 raw 编码的对象</li>
<li>Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序，所以 embstr 对象实际上<strong>是只读的</strong>，执行修改命令会将对象的编码从 embstr 转换成 raw，操作完成后得到一个 raw 编码的对象</li>
</ul>
<p>某些情况下，程序会将字符串对象里面的字符串值转换回浮点数值，执行某些操作后再将浮点数值转换回字符串值：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SET pi 3.14 </span><br><span class="line">OK </span><br><span class="line">redis&gt; OBJECT ENCODING pi</span><br><span class="line"><span class="string">&quot;embstr&quot;</span> </span><br><span class="line">redis&gt; INCRBYFLOAT pi 2.0 <span class="comment"># 转为浮点数执行增加的操作</span></span><br><span class="line"><span class="string">&quot;5. 14&quot;</span> </span><br><span class="line">redis&gt; OBJECT ENCODING pi </span><br><span class="line"><span class="string">&quot;embstr&quot;</span> </span><br></pre></td></tr></table></figure>







<hr>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>主页高频访问信息显示控制，例如新浪微博大 V 主页显示粉丝数与微博数量</p>
<ul>
<li><p>在 Redis 中为大 V 用户设定用户信息，以用户主键和属性值作为 key，后台设定定时刷新策略</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> user:<span class="built_in">id</span>:3506728370:fans 12210947</span><br><span class="line"><span class="built_in">set</span> user:<span class="built_in">id</span>:3506728370:blogs 6164</span><br><span class="line"><span class="built_in">set</span> user:<span class="built_in">id</span>:3506728370:focuses 83</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 JSON 格式保存数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user:<span class="built_in">id</span>:3506728370 → &#123;<span class="string">&quot;fans&quot;</span>:12210947,<span class="string">&quot;blogs&quot;</span>:6164,<span class="string">&quot;focuses&quot;</span>:83&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>key的设置约定：表名 : 主键名 : 主键值 : 字段名</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>主键名</th>
<th>主键值</th>
<th>字段名</th>
</tr>
</thead>
<tbody><tr>
<td>order</td>
<td>id</td>
<td>29437595</td>
<td>name</td>
</tr>
<tr>
<td>equip</td>
<td>id</td>
<td>390472345</td>
<td>type</td>
</tr>
<tr>
<td>news</td>
<td>id</td>
<td>202004150</td>
<td>title</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>数据存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</p>
<p>数据存储结构：一个存储空间保存多个键值对数据</p>
<p>hash 类型：底层使用<strong>哈希表</strong>结构实现数据存储</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/hash结构图.png" style="zoom: 33%;">

<p>Redis 中的 hash 类似于 Java 中的  <code>Map&lt;String, Map&lt;Object,object&gt;&gt;</code>，左边是 key，右边是值，中间叫 field 字段，本质上 <strong>hash 存了一个 key-value 的存储空间</strong></p>
<p>hash 是指的一个数据类型，并不是一个数据</p>
<ul>
<li>如果 field 数量较少，存储结构优化为<strong>压缩列表结构</strong>（有序）</li>
<li>如果 field 数量较多，存储结构使用 HashMap 结构（无序）</li>
</ul>
<hr>
<h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><p>指令操作：</p>
<ul>
<li><p>数据操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hset key field value		<span class="comment">#添加/修改数据</span></span><br><span class="line">hdel key field1 [field2]	<span class="comment">#删除数据，[]代表可选</span></span><br><span class="line">hsetnx key field value		<span class="comment">#设置field的值，如果该field存在则不做任何操作</span></span><br><span class="line">hmset key f1 v1 f2 v2...	<span class="comment">#添加/修改多个数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查询操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hget key field				<span class="comment">#获取指定field对应数据</span></span><br><span class="line">hgetall key					<span class="comment">#获取指定key所有数据</span></span><br><span class="line">hmget key field1 field2...	<span class="comment">#获取多个数据</span></span><br><span class="line">hexists key field			<span class="comment">#获取哈希表中是否存在指定的字段</span></span><br><span class="line">hlen key					<span class="comment">#获取哈希表中字段的数量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取哈希表中所有的字段名或字段值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hkeys key					<span class="comment">#获取所有的field	</span></span><br><span class="line">hvals key					<span class="comment">#获取所有的value</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置指定字段的数值数据增加指定范围的值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hincrby key field increment		<span class="comment">#指定字段的数值数据增加指定的值，increment为负数则减少</span></span><br><span class="line">hincrbyfloat key field increment<span class="comment">#操作小数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意事项</p>
<ol>
<li>hash 类型中 value 只能存储字符串，不允许存储其他数据类型，不存在嵌套现象，如果数据未获取到，对应的值为（nil）</li>
<li>每个 hash 可以存储 2^32 - 1 个键值对</li>
<li>hash 类型和对象的数据存储形式相似，并且可以灵活添加删除对象属性。但 hash 设计初衷不是为了存储大量对象而设计的，不可滥用，不可将 hash 作为对象列表使用</li>
<li>hgetall 操作可以获取全部属性，如果内部 field 过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈</li>
</ol>
<hr>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>哈希对象的内部编码有两种：ziplist（压缩列表）、hashtable（哈希表、字典）</p>
<ul>
<li><p>压缩列表实现哈希对象：同一键值对的节点总是挨在一起，保存键的节点在前，保存值的节点在后</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1ziplist.png"></p>
</li>
<li><p>字典实现哈希对象：字典的每一个键都是一个字符串对象，每个值也是</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-哈希对象dict.png" style="zoom:67%;"></li>
</ul>
<p>当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型，具体需要满足两个条件：</p>
<ul>
<li>当键值对数量小于 hash-max-ziplist-entries 配置（默认 512 个）</li>
<li>所有键和值的长度都小于 hash-max-ziplist-value 配置（默认 64 字节）</li>
</ul>
<p>以上两个条件的上限值是可以通过配置文件修改的，当两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行</p>
<p>ziplist 使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比 hashtable 更加优秀，当 ziplist 无法满足哈希类型时，Redis 会使用 hashtable 作为哈希的内部实现，因为此时 ziplist 的读写效率会下降，而 hashtable 的读写时间复杂度为 O(1)</p>
<hr>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user:<span class="built_in">id</span>:3506728370 → &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;春晚&quot;</span>,<span class="string">&quot;fans&quot;</span>:12210862,<span class="string">&quot;blogs&quot;</span>:83&#125;</span><br></pre></td></tr></table></figure>

<p>对于以上数据，使用单条去存的话，存的条数会很多。但如果用 json 格式，存一条数据就够了。</p>
<p>假如现在粉丝数量发生了变化，要把整个值都改变，但是用单条存就不存在这个问题，只需要改其中一个就可以</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/hash应用场景结构图.png" style="zoom: 33%;">

<p>可以实现购物车的功能，key 对应着每个用户，存储空间存储购物车的信息</p>
<hr>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</p>
<p>数据存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序，允许重复元素</p>
<p>list 类型：保存多个数据，底层使用<strong>双向链表</strong>存储结构实现，类似于 LinkedList</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/list结构图.png" style="zoom:33%;">

<p>如果两端都能存取数据的话，这就是双端队列，如果只能从一端进一端出，这个模型叫栈</p>
<hr>
<h4 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h4><p>指令操作：</p>
<ul>
<li><p>数据操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lpush key value1 [value2]...<span class="comment">#从左边添加/修改数据(表头)</span></span><br><span class="line">rpush key value1 [value2]...<span class="comment">#从右边添加/修改数据(表尾)</span></span><br><span class="line">lpop key					<span class="comment">#从左边获取并移除第一个数据，类似于出栈/出队</span></span><br><span class="line">rpop key					<span class="comment">#从右边获取并移除第一个数据</span></span><br><span class="line">lrem key count value		<span class="comment">#删除指定数据，count=2删除2个，该value可能有多个(重复数据)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查询操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lrange key start stop		<span class="comment">#从左边遍历数据并指定开始和结束索引，0是第一个索引，-1是终索引</span></span><br><span class="line">lindex key index			<span class="comment">#获取指定索引数据，没有则为nil，没有索引越界</span></span><br><span class="line">llen key					<span class="comment">#list中数据长度/个数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>规定时间内获取并移除数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">b							<span class="comment">#代表阻塞</span></span><br><span class="line">blpop key1 [key2] <span class="built_in">timeout</span>	<span class="comment">#在指定时间内获取指定key(可以多个)的数据，超时则为(nil)</span></span><br><span class="line">							<span class="comment">#可以从其他客户端写数据，当前客户端阻塞读取数据</span></span><br><span class="line">brpop key1 [key2] <span class="built_in">timeout</span>	<span class="comment">#从右边操作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>复制操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brpoplpush <span class="built_in">source</span> destination <span class="built_in">timeout</span>	<span class="comment">#从source获取数据放入destination，假如在指定时间内没有任何元素被弹出，则返回一个nil和等待时长。反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意事项</p>
<ol>
<li>list 中保存的数据都是 string 类型的，数据总容量是有限的，最多 2^32 - 1 个元素（4294967295）</li>
<li>list 具有索引的概念，但操作数据时通常以队列的形式进行入队出队，或以栈的形式进行入栈出栈</li>
<li>获取全部数据操作结束索引设置为 -1</li>
<li>list 可以对数据进行分页操作，通常第一页的信息来自于 list，第 2 页及更多的信息通过数据库的形式加载</li>
</ol>
<hr>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>在 Redis3.2 版本以前列表对象的内部编码有两种：ziplist（压缩列表）和 linkedlist（链表）</p>
<ul>
<li><p>压缩列表实现的列表对象：PUSH 1、three、5 三个元素</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1ziplist.png"></p>
</li>
<li><p>链表实现的列表对象：为了简化字符串对象的表示，使用了 StringObject 的结构，底层其实是 sdshdr 结构</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1linkedlist.png"></p>
</li>
</ul>
<p>列表中存储的数据量比较小的时候，列表就会使用一块连续的内存存储，采用压缩列表的方式实现的条件：</p>
<ul>
<li>列表对象保存的所有字符串元素的长度都小于 64 字节</li>
<li>列表对象保存的元素数量小于 512 个</li>
</ul>
<p>以上两个条件的上限值是可以通过配置文件修改的，当两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行</p>
<p>在 Redis3.2 版本 以后对列表数据结构进行了改造，使用 <strong>quicklist（快速列表）</strong>代替了 linkedlist，quicklist 实际上是 ziplist 和 linkedlist 的混合体，将 linkedlist 按段切分，每一段使用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针串接起来，既满足了快速的插入删除性能，又不会出现太大的空间冗余</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-快速列表数据结构.png" style="zoom: 50%;">



<hr>
<h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h4><p>企业运营过程中，系统将产生出大量的运营数据，如何保障多台服务器操作日志的统一顺序输出？</p>
<ul>
<li>依赖 list 的数据具有顺序的特征对信息进行管理，右进左查或者左近左查</li>
<li>使用队列模型解决多路信息汇总合并的问题</li>
<li>使用栈模型解决最新消息的问题</li>
</ul>
<p>微信文章订阅公众号：</p>
<ul>
<li>比如订阅了两个公众号，它们发布了两篇文章，文章 ID 分别为 666 和 888，可以通过执行 <code>LPUSH key 666 888</code> 命令推送给我</li>
</ul>
<hr>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>数据存储需求：存储大量的数据，在查询方面提供更高的效率</p>
<p>数据存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</p>
<p>set 类型：与 hash 存储结构哈希表完全相同，只是仅存储键不存储值（nil），所以添加，删除，查找的复杂度都是 O(1)，并且<strong>值是不允许重复且无序的</strong></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/set结构图.png" style="zoom: 33%;">



<hr>
<h4 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h4><p>指令操作：</p>
<ul>
<li><p>数据操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sadd key member1 [member2]	<span class="comment">#添加数据</span></span><br><span class="line">srem key member1 [member2]	<span class="comment">#删除数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查询操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">smembers key				<span class="comment">#获取全部数据</span></span><br><span class="line">scard key					<span class="comment">#获取集合数据总量</span></span><br><span class="line">sismember key member		<span class="comment">#判断集合中是否包含指定数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>随机操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">  spop key [count]			<span class="comment">#随机获取集中的某个数据并将该数据移除集合</span></span><br><span class="line">  srandmember key [count]		<span class="comment">#随机获取集合中指定(数量)的数据</span></span><br><span class="line"></span><br><span class="line">* 集合的交、并、差</span><br><span class="line"></span><br><span class="line">  ```sh</span><br><span class="line">  sinter key1 [key2...]  					<span class="comment">#两个集合的交集，不存在为(empty list or set)</span></span><br><span class="line">  sunion key1 [key2...]  					<span class="comment">#两个集合的并集</span></span><br><span class="line">  sdiff key1 [key2...]					<span class="comment">#两个集合的差集</span></span><br><span class="line">  </span><br><span class="line">  sinterstore destination key1 [key2...]	<span class="comment">#两个集合的交集并存储到指定集合中</span></span><br><span class="line">  sunionstore destination key1 [key2...]	<span class="comment">#两个集合的并集并存储到指定集合中</span></span><br><span class="line">  sdiffstore destination key1 [key2...]	<span class="comment">#两个集合的差集并存储到指定集合中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>复制</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">smove <span class="built_in">source</span> destination member			<span class="comment">#将指定数据从原始集合中移动到目标集合中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意事项</p>
<ol>
<li>set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份</li>
<li>set 虽然与 hash 的存储结构相同，但是无法启用 hash 中存储值的空间</li>
</ol>
<hr>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>集合对象的内部编码有两种：intset（整数集合）、hashtable（哈希表、字典）</p>
<ul>
<li><p>整数集合实现的集合对象：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-集合对象intset.png" style="zoom:67%;">
</li>
<li><p>字典实现的集合对象：键值对的值为 NULL</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-集合对象dict.png" style="zoom:80%;"></li>
</ul>
<p>当集合对象可以同时满足以下两个条件时，对象使用 intset 编码：</p>
<ul>
<li>集合中的元素都是整数值</li>
<li>集合中的元素数量小于 set-maxintset-entries配置（默认 512 个）</li>
</ul>
<p>以上两个条件的上限值是可以通过配置文件修改的</p>
<hr>
<h4 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h4><p>应用场景：</p>
<ol>
<li><p>黑名单：资讯类信息类网站追求高访问量，但是由于其信息的价值，往往容易被不法分子利用，通过爬虫技术，快速获取信息，个别特种行业网站信息通过爬虫获取分析后，可以转换成商业机密。</p>
<p>注意：爬虫不一定做摧毁性的工作，有些小型网站需要爬虫为其带来一些流量。</p>
</li>
<li><p>白名单：对于安全性更高的应用访问，仅仅靠黑名单是不能解决安全问题的，此时需要设定可访问的用户群体， 依赖白名单做更为苛刻的访问验证</p>
</li>
<li><p>随机操作可以实现抽奖功能</p>
</li>
<li><p>集合的交并补可以实现微博共同关注的查看，可以根据共同关注或者共同喜欢推荐相关内容</p>
</li>
</ol>
<hr>
<h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><p>数据存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式</p>
<p>数据存储结构：新的存储模型，可以保存可排序的数据</p>
<hr>
<h4 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a>操作</h4><p>指令操作：</p>
<ul>
<li><p>数据操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zadd key score1 member1 [score2 member2]	<span class="comment">#添加数据</span></span><br><span class="line">zrem key member [member ...]				<span class="comment">#删除数据</span></span><br><span class="line">zremrangebyrank key start stop 				<span class="comment">#删除指定索引范围的数据</span></span><br><span class="line">zremrangebyscore key min max				<span class="comment">#删除指定分数区间内的数据</span></span><br><span class="line">zscore key member							<span class="comment">#获取指定值的分数</span></span><br><span class="line">zincrby key increment member				<span class="comment">#指定值的分数增加increment</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查询操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zrange key start stop [WITHSCORES]		<span class="comment">#获取指定范围的数据，升序，WITHSCORES 代表显示分数</span></span><br><span class="line">zrevrange key start stop [WITHSCORES]	<span class="comment">#获取指定范围的数据，降序</span></span><br><span class="line"></span><br><span class="line">zrangebyscore key min max [WITHSCORES] [LIMIT offset count]	<span class="comment">#按条件获取数据，从小到大</span></span><br><span class="line">zrevrangebyscore key max min [WITHSCORES] [...]				<span class="comment">#从大到小</span></span><br><span class="line"></span><br><span class="line">zcard key										<span class="comment">#获取集合数据的总量</span></span><br><span class="line">zcount key min max								<span class="comment">#获取指定分数区间内的数据总量</span></span><br><span class="line">zrank key member								<span class="comment">#获取数据对应的索引（排名）升序</span></span><br><span class="line">zrevrank key member								<span class="comment">#获取数据对应的索引（排名）降序</span></span><br></pre></td></tr></table></figure>

<ul>
<li>min 与 max 用于限定搜索查询的条件</li>
<li>start 与 stop 用于限定查询范围，作用于索引，表示开始和结束索引</li>
<li>offset 与 count 用于限定查询范围，作用于查询结果，表示开始位置和数据总量</li>
</ul>
</li>
<li><p>集合的交、并操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zinterstore destination numkeys key [key ...]	<span class="comment">#两个集合的交集并存储到指定集合中</span></span><br><span class="line">zunionstore destination numkeys key [key ...]	<span class="comment">#两个集合的并集并存储到指定集合中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意事项：</p>
<ol>
<li>score 保存的数据存储空间是 64 位，如果是整数范围是 -9007199254740992~9007199254740992</li>
<li>score 保存的数据也可以是一个双精度的 double 值，基于双精度浮点数的特征可能会丢失精度，慎重使用</li>
<li>sorted_set 底层存储还是基于 set 结构的，因此数据不能重复，如果重复添加相同的数据，score 值将被反复覆盖，保留最后一次修改的结果</li>
</ol>
<hr>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>有序集合对象的内部编码有两种：ziplist（压缩列表）和 skiplist（跳跃表）</p>
<ul>
<li><p>压缩列表实现有序集合对象：ziplist 本身是有序、不可重复的，符合有序集合的特性</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1ziplist.png"></p>
</li>
<li><p>跳跃表实现有序集合对象：<strong>底层是 zset 结构，zset 同时包含字典和跳跃表的结构</strong>，图示字典和跳跃表中重复展示了各个元素的成员和分值，但实际上两者会<strong>通过指针来共享相同元素的成员和分值</strong>，不会产生空间浪费</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1zset.png"></p>
</li>
</ul>
<p>使用字典加跳跃表的优势：</p>
<ul>
<li>字典为有序集合创建了一个从成员到分值的映射，用 O(1) 复杂度查找给定成员的分值</li>
<li>排序操作使用跳跃表完成，节省每次重新排序带来的时间成本和空间成本</li>
</ul>
<p>使用 ziplist 格式存储需要满足以下两个条件：</p>
<ul>
<li>有序集合保存的元素个数要小于 128 个；</li>
<li>有序集合保存的所有元素大小都小于 64 字节</li>
</ul>
<p>当元素比较多时，此时 ziplist 的读写效率会下降，时间复杂度是 O(n)，跳表的时间复杂度是 O(logn)</p>
<hr>
<h4 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h4><ul>
<li>排行榜</li>
<li>对于基于时间线限定的任务处理，将处理时间记录为 score 值，利用排序功能区分处理的先后顺序</li>
<li>当任务或者消息待处理，形成了任务队列或消息队列时，对于高优先级的任务要保障对其优先处理，采用 score 记录权重</li>
</ul>
<hr>
<h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><h4 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h4><p>Bitmaps 是二进制位数组（bit array），底层使用 SDS 字符串表示，因为 SDS 是二进制安全的</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E4%BD%8D%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84.png"></p>
<p>buf 数组的每个字节用一行表示，buf[1] 是 <code>&#39;\0&#39;</code>，保存位数组的顺序和书写位数组的顺序是完全相反的，图示的位数组 0100 1101</p>
<p>数据结构的详解查看 Java → Algorithm → 位图</p>
<hr>
<h4 id="命令实现"><a href="#命令实现" class="headerlink" title="命令实现"></a>命令实现</h4><h5 id="GETBIT"><a href="#GETBIT" class="headerlink" title="GETBIT"></a>GETBIT</h5><p>GETBIT 命令获取位数组 bitarray 在 offset 偏移量上的二进制位的值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GETBIT &lt;bitarray&gt; &lt;offset&gt;</span><br></pre></td></tr></table></figure>

<p>执行过程：</p>
<ul>
<li>计算 <code>byte = offset/8</code>（向下取整）, byte 值记录数据保存在位数组中的索引</li>
<li>计算 <code>bit = (offset mod 8) + 1</code>，bit 值记录数据在位数组中的第几个二进制位</li>
<li>根据 byte 和 bit 值，在位数组 bitarray 中定位 offset 偏移量指定的二进制位，并返回这个位的值</li>
</ul>
<p>GETBIT 命令执行的所有操作都可以在常数时间内完成，所以时间复杂度为 O(1)</p>
<hr>
<h5 id="SETBIT"><a href="#SETBIT" class="headerlink" title="SETBIT"></a>SETBIT</h5><p>SETBIT 将位数组 bitarray 在 offset 偏移量上的二进制位的值设置为 value，并向客户端返回二进制位的旧值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SETBIT &lt;bitarray&gt; &lt;offset&gt; &lt;value&gt; </span><br></pre></td></tr></table></figure>

<p>执行过程：</p>
<ul>
<li>计算 <code>len = offset/8 + 1</code>，len 值记录了保存该数据至少需要多少个字节</li>
<li>检查 bitarray 键保存的位数组的长度是否小于 len，成立就会将 SDS 扩展为 len 字节（注意空间预分配机制），所有新扩展空间的二进制位的值置为 0</li>
<li>计算 <code>byte = offset/8</code>（向下取整）, byte 值记录数据保存在位数组中的索引</li>
<li>计算 <code>bit = (offset mod 8) + 1</code>，bit 值记录数据在位数组中的第几个二进制位</li>
<li>根据 byte 和 bit 值，在位数组 bitarray 中定位 offset 偏移量指定的二进制位，首先将指定位现存的值保存在 oldvalue 变量，然后将新值 value 设置为这个二进制位的值</li>
<li>向客户端返回 oldvalue 变量的值</li>
</ul>
<hr>
<h5 id="BITCOUNT"><a href="#BITCOUNT" class="headerlink" title="BITCOUNT"></a>BITCOUNT</h5><p>BITCOUNT 命令用于统计给定位数组中，值为 1 的二进制位的数量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">BITCOUNT &lt;bitarray&gt; [start end]</span><br></pre></td></tr></table></figure>

<p>二进制位统计算法：</p>
<ul>
<li>遍历法：遍历位数组中的每个二进制位</li>
<li>查表算法：读取每个字节（8 位）的数据，查表获取数值对应的二进制中有几个 1 </li>
<li>variable-precision SWAR算法：计算汉明距离</li>
<li>Redis 实现：<ul>
<li>如果二进制位的数量大于等于 128 位， 那么使用 variable-precision SWAR 算法来计算二进制位的汉明重量</li>
<li>如果二进制位的数量小于 128 位，那么使用查表算法来计算二进制位的汉明重量</li>
</ul>
</li>
</ul>
<hr>
<h5 id="BITOP"><a href="#BITOP" class="headerlink" title="BITOP"></a>BITOP</h5><p>BITOP 命令对指定 key 按位进行交、并、非、异或操作，并将结果保存到指定的键中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">BITOP OPTION destKey key1 [key2...]</span><br></pre></td></tr></table></figure>

<p>OPTION 有 AND（与）、OR（或）、 XOR（异或）和 NOT（非）四个选项</p>
<p>AND、OR、XOR 三个命令可以接受多个位数组作为输入，需要遍历输入的每个位数组的每个字节来进行计算，所以命令的复杂度为 O(n^2)；与此相反，NOT 命令只接受一个位数组输入，所以时间复杂度为 O(n)</p>
<hr>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><p><strong>解决 Redis 缓存穿透</strong>，判断给定数据是否存在， 防止缓存穿透</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-Bitmaps应用之缓存穿透.png" style="zoom: 67%;">
</li>
<li><p>垃圾邮件过滤，对每一个发送邮件的地址进行判断是否在布隆的黑名单中，如果在就判断为垃圾邮件</p>
</li>
<li><p>爬虫去重，爬给定网址的时候对已经爬取过的 URL 去重</p>
</li>
<li><p>信息状态统计</p>
</li>
</ul>
<hr>
<h3 id="Hyper"><a href="#Hyper" class="headerlink" title="Hyper"></a>Hyper</h3><p>基数是数据集去重后元素个数，HyperLogLog 是用来做基数统计的，运用了 LogLog 的算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>&#125; 	基数集： &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> ,<span class="number">7</span>, <span class="number">8</span>&#125; 	基数：<span class="number">5</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">1</span>&#125; 	基数集： &#123;<span class="number">1</span>,<span class="number">7</span>&#125; 				基数：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>相关指令：</p>
<ul>
<li><p>添加数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pfadd key element [element ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pfcount key [key ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pfmerge destkey sourcekey [sourcekey...]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>应用场景：</p>
<ul>
<li>用于进行基数统计，不是集合不保存数据，只记录数量而不是具体数据，比如网站的访问量</li>
<li>核心是基数估算算法，最终数值存在一定误差</li>
<li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li>
<li>耗空间极小，每个 hyperloglog key 占用了12K的内存用于标记基数</li>
<li>pfadd 命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大</li>
<li>Pfmerge 命令合并后占用的存储空间为12K，无论合并之前数据量多少</li>
</ul>
<hr>
<h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>GeoHash 是一种地址编码方法，把二维的空间经纬度数据编码成一个字符串</p>
<ul>
<li><p>添加坐标点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">geoadd key longitude latitude member [longitude latitude member ...]</span><br><span class="line">georadius key longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取坐标点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">geopos key member [member ...]</span><br><span class="line">georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算距离</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">geodist key member1 member2 [unit]	<span class="comment">#计算坐标点距离</span></span><br><span class="line">geohash key member [member ...]		<span class="comment">#计算经纬度</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>Redis 应用于地理位置计算</p>
<hr>
<h2 id="持久机制"><a href="#持久机制" class="headerlink" title="持久机制"></a>持久机制</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>持久化：利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化 </p>
<p>作用：持久化用于防止数据的意外丢失，确保数据安全性，因为 Redis 是内存级，所以需要持久化到磁盘</p>
<p>计算机中的数据全部都是二进制，保存一组数据有两种方式<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-持久化的两种方式.png" style="zoom: 33%;"></p>
<p>RDB：将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单</p>
<p>AOF：将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂</p>
<hr>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="文件创建"><a href="#文件创建" class="headerlink" title="文件创建"></a>文件创建</h4><p>RDB 持久化功能所生成的 RDB 文件 是一个经过压缩的紧凑二进制文件，通过该文件可以还原生成 RDB 文件时的数据库状态，有两个 Redis 命令可以生成 RDB 文件，一个是 SAVE，另一个是 BGSAVE</p>
<h5 id="SAVE"><a href="#SAVE" class="headerlink" title="SAVE"></a>SAVE</h5><p>SAVE 指令：手动执行一次保存操作，该指令的执行会阻塞当前 Redis 服务器，客户端发送的所有命令请求都会被拒绝，直到当前 RDB 过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用</p>
<p>工作原理：Redis 是个<strong>单线程的工作模式</strong>，会创建一个任务队列，所有的命令都会进到这个队列排队执行。当某个指令在执行的时候，队列后面的指令都要等待，所以这种执行方式会非常耗时</p>
<p>配置 redis.conf：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span> path				<span class="comment">#设置存储.rdb文件的路径，通常设置成存储空间较大的目录中，目录名称data</span></span><br><span class="line">dbfilename <span class="string">&quot;x.rdb&quot;</span>		<span class="comment">#设置本地数据库文件名，默认值为dump.rdb，通常设置为dump-端口号.rdb</span></span><br><span class="line">rdbcompression <span class="built_in">yes</span>|no	<span class="comment">#设置存储至本地数据库时是否压缩数据，默认yes，设置为no节省CPU运行时间</span></span><br><span class="line">rdbchecksum <span class="built_in">yes</span>|no		<span class="comment">#设置读写文件过程是否进行RDB格式校验，默认yes</span></span><br></pre></td></tr></table></figure>



<hr>
<h5 id="BGSAVE"><a href="#BGSAVE" class="headerlink" title="BGSAVE"></a>BGSAVE</h5><p>BGSAVE：bg 是 background，代表后台执行，命令的完成需要两个进程，<strong>进程之间不相互影响</strong>，所以持久化期间 Redis 正常工作</p>
<p>工作原理：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-bgsave工作原理.png" style="zoom:67%;">

<p>流程：客户端发出 BGSAVE 指令，Redis 服务器使用 fork 函数创建一个子进程，然后响应后台已经开始执行的信息给客户端。子进程会异步执行持久化的操作，持久化过程是先将数据写入到一个临时文件中，持久化操作结束再用这个临时文件<strong>替换</strong>上次持久化的文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建子进程</span></span><br><span class="line">pid = fork()</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 子进程负责创建 RDB 文件</span></span><br><span class="line">    rdbSave()</span><br><span class="line">    <span class="comment"># 完成之后向父进程发送信号</span></span><br><span class="line">    signal_parent()</span><br><span class="line"><span class="keyword">elif</span> pid &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 父进程继续处理命令请求，并通过轮询等待子进程的信号</span></span><br><span class="line">    handle_request_and_wait_signal()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 处理出错恃况</span></span><br><span class="line">    handle_fork_error() </span><br></pre></td></tr></table></figure>

<p>配置 redis.conf</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">stop-writes-on-bgsave-error <span class="built_in">yes</span>|no	<span class="comment">#后台存储过程中如果出现错误，是否停止保存操作，默认yes</span></span><br><span class="line">dbfilename filename  </span><br><span class="line"><span class="built_in">dir</span> path  </span><br><span class="line">rdbcompression <span class="built_in">yes</span>|no  </span><br><span class="line">rdbchecksum <span class="built_in">yes</span>|no</span><br></pre></td></tr></table></figure>

<p>注意：BGSAVE 命令是针对 SAVE 阻塞问题做的优化，Redis 内部所有涉及到 RDB 操作都采用 BGSAVE 的方式，SAVE 命令放弃使用</p>
<p>在 BGSAVE 命令执行期间，服务器处理 SAVE、BGSAVE、BGREWRITEAOF 三个命令的方式会和平时有所不同</p>
<ul>
<li>SAVE 命令会被服务器拒绝，服务器禁止 SAVE 和 BGSAVE 命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个 rdbSave 调用，产生竞争条件</li>
<li>BGSAVE 命令也会被服务器拒绝，也会产生竞争条件</li>
<li>BGREWRITEAOF 和 BGSAVE 两个命令不能同时执行<ul>
<li>如果 BGSAVE 命令正在执行，那么 BGREWRITEAOF 命令会被<strong>延迟</strong>到 BGSAVE 命令执行完毕之后执行</li>
<li>如果 BGREWRITEAOF 命令正在执行，那么 BGSAVE 命令会被服务器拒绝</li>
</ul>
</li>
</ul>
<hr>
<h5 id="特殊指令"><a href="#特殊指令" class="headerlink" title="特殊指令"></a>特殊指令</h5><p>RDB 特殊启动形式的指令（客户端输入）</p>
<ul>
<li><p>服务器运行过程中重启</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">debug reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭服务器时指定保存数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">shutdown save</span><br></pre></td></tr></table></figure>

<p>默认情况下执行 shutdown 命令时，自动执行 bgsave（如果没有开启 AOF 持久化功能）</p>
</li>
<li><p>全量复制：主从复制部分详解</p>
</li>
</ul>
<hr>
<h4 id="文件载入"><a href="#文件载入" class="headerlink" title="文件载入"></a>文件载入</h4><p>RDB 文件的载入工作是在服务器启动时自动执行，期间 Redis 会一直处于阻塞状态，直到载入完成</p>
<p>Redis 并没有专门用于载入 RDB 文件的命令，只要服务器在启动时检测到 RDB 文件存在，就会自动载入 RDB 文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[7379] 30 Aug 21:07:01.289 * DB loaded from disk: 0.018 seconds  <span class="comment"># 服务器在成功载入 RDB 文件之后打印</span></span><br></pre></td></tr></table></figure>

<p>AOF 文件的更新频率通常比 RDB 文件的更新频率高：</p>
<ul>
<li>如果服务器开启了 AOF 持久化功能，那么会优先使用 AOF 文件来还原数据库状态</li>
<li>只有在 AOF 持久化功能处于关闭状态时，服务器才会使用 RDB 文件来还原数据库状态</li>
</ul>
<hr>
<h4 id="自动保存"><a href="#自动保存" class="headerlink" title="自动保存"></a>自动保存</h4><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>Redis 支持通过配置服务器的 save 选项，让服务器每隔一段时间自动执行一次 BGSAVE 命令</p>
<p>配置 redis.conf：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">save second changes <span class="comment">#设置自动持久化条件，满足限定时间范围内key的变化数量就进行持久化(bgsave)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>second：监控时间范围</li>
<li>changes：监控 key 的变化量</li>
</ul>
<p>默认三个条件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">save 900 1		<span class="comment"># 900s内1个key发生变化就进行持久化</span></span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>判定 key 变化的依据：</p>
<ul>
<li>对数据产生了影响，不包括查询</li>
<li>不进行数据比对，比如 name 键存在，重新 set name seazean 也算一次变化</li>
</ul>
<p>save 配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的</p>
<hr>
<h5 id="自动原理"><a href="#自动原理" class="headerlink" title="自动原理"></a>自动原理</h5><p>服务器状态相关的属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录了保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改计数器</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dirty;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上一次执行保存的时间 </span></span><br><span class="line">    <span class="type">time_t</span> lastsave;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Redis 服务器启动时，可以通过指定配置文件或者传入启动参数的方式设置 save 选项， 如果没有自定义就设置为三个默认值（上节提及），设置服务器状态 redisServe.saveparams 属性，该数组每一项为一个 saveparam 结构，代表 save 的选项设置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> &#123;</span></span><br><span class="line">    <span class="comment">// 秒数</span></span><br><span class="line">    <span class="type">time_t</span> seconds</span><br><span class="line">    <span class="comment">// 修改数</span></span><br><span class="line">    <span class="type">int</span> changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>dirty 计数器记录距离上一次成功执行 SAVE 或者 BGSAVE 命令之后，服务器中的所有数据库进行了多少次修改（包括写入、删除、更新等操作），当服务器成功执行一个修改指令，该命令修改了多少次数据库， dirty 的值就增加多少</p>
</li>
<li><p>lastsave 属性是一个 UNIX 时间戳，记录了服务器上一次成功执行 SAVE 或者 BGSAVE 命令的时间</p>
</li>
</ul>
<p>Redis 的服务器周期性操作函数 serverCron 默认每隔 100 毫秒就会执行一次，该函数用于对正在运行的服务器进行维护</p>
<p>serverCron 函数的其中一项工作是检查 save 选项所设置的保存条件是否满足，会遍历 saveparams 数组中的<strong>所有保存条件</strong>，只要有任意一个条件被满足服务器就会执行 BGSAVE 命令</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-BGSAVE%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86.png"></p>
<hr>
<h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><p>RDB 的存储结构：图示全大写单词标示常量，用全小写单词标示变量和数据</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-RDB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png"></p>
<ul>
<li>REDIS：长度为 5 字节，保存着 <code>REDIS</code> 五个字符，是 RDB 文件的开头，在载入文件时可以快速检查所载入的文件是否 RDB 文件</li>
<li>db_version：长度为 4 字节，是一个用字符串表示的整数，记录 RDB 的版本号</li>
<li>database：包含着零个或任意多个数据库，以及各个数据库中的键值对数据</li>
<li>EOF：长度为 1 字节的常量，标志着 RDB 文件正文内容的结束，当读入遇到这个值时，代表所有数据库的键值对都已经载入完毕</li>
<li>check_sum：长度为 8 字节的无符号整数，保存着一个校验和，该值是通过 REDIS、db_version、databases、EOF 四个部分的内容进行计算得出。服务器在载入 RDB 文件时，会将载入数据所计算出的校验和与 check_sum 所记录的校验和进行对比，来检查 RDB 文件是否有出错或者损坏</li>
</ul>
<p>Redis 本身带有 RDB 文件检查工具 redis-check-dump</p>
<hr>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h4 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h4><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令（不记录读）来记录数据库状态，<strong>增量保存</strong>只许追加文件但不可以改写文件，<strong>与 RDB 相比可以理解为由记录数据改为记录数据的变化</strong></p>
<p>AOF 主要作用是解决了<strong>数据持久化的实时性</strong>，目前已经是 Redis 持久化的主流方式</p>
<p>AOF 写数据过程：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-AOF工作原理.png" style="zoom:67%;">

<p>Redis 只会将对数据库进行了修改的命令写入到 AOF 文件，并复制到各个从服务器，但是 PUBSUB 和 SCRIPT LOAD 命令例外：</p>
<ul>
<li>PUBSUB 命令虽然没有修改数据库，但 PUBSUB 命令向频道的所有订阅者发送消息这一行为带有副作用，接收到消息的所有客户端的状态都会因为这个命令而改变，所以服务器需要使用 REDIS_FORCE_AOF 标志强制将这个命令写入 AOF 文件。这样在将来载入 AOF 文件时，服务器就可以再次执行相同的 PUBSUB 命令，并产生相同的副作用</li>
<li>SCRIPT LOAD  命令虽然没有修改数据库，但它修改了服务器状态，所以也是一个带有副作用的命令，需要使用 REDIS_FORCE_AOF</li>
</ul>
<hr>
<h4 id="持久实现"><a href="#持久实现" class="headerlink" title="持久实现"></a>持久实现</h4><p>AOF 持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤</p>
<h5 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h5><p>启动 AOF 的基本配置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">appendonly <span class="built_in">yes</span>|no				<span class="comment">#开启AOF持久化功能，默认no，即不开启状态</span></span><br><span class="line">appendfilename filename			<span class="comment">#AOF持久化文件名，默认appendonly.aof，建议设置appendonly-端口号.aof</span></span><br><span class="line"><span class="built_in">dir</span>								<span class="comment">#AOF持久化文件保存路径，与RDB持久化文件路径保持一致即可</span></span><br></pre></td></tr></table></figure>

<p>当 AOF 持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令<strong>追加</strong>到服务器状态的 aof_buf 缓冲区的末尾</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// AOF 缓冲区</span></span><br><span class="line">    sds aof_buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h5><p>服务器在处理文件事件时会执行<strong>写命令，追加一些内容到 aof_buf 缓冲区</strong>里，所以服务器每次结束一个事件循环之前，就会执行 flushAppendOnlyFile 函数，判断是否需要<strong>将 aof_buf 缓冲区中的内容写入和保存到 AOF 文件</strong>里</p>
<p>flushAppendOnlyFile 函数的行为由服务器配置的 appendfsync 选项的值来决定</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">appendfsync always|everysec|no	<span class="comment">#AOF写数据策略：默认为everysec</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>always：每次写入操作都将 aof_buf 缓冲区中的所有内容<strong>写入并同步</strong>到 AOF 文件</p>
<p>特点：安全性最高，数据零误差，但是性能较低，不建议使用</p>
</li>
<li><p>everysec：先将 aof_buf 缓冲区中的内容写入到 AOF 文件，判断上次同步 AOF 文件的时间距离现在超过一秒钟，再次对 AOF 文件进行同步，这个同步操作是由一个（子）线程专门负责执行的</p>
<p>特点：在系统突然宕机的情况下丢失 1 秒内的数据，准确性较高，性能较高，建议使用，也是默认配置</p>
</li>
<li><p>no：将 aof_buf 缓冲区中的内容写入到 AOF 文件，但并不对 AOF 文件进行同步，何时同步由操作系统来决定</p>
<p>特点：<strong>整体不可控</strong>，服务器宕机会丢失上次同步 AOF 后的所有写指令</p>
</li>
</ul>
<hr>
<h5 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h5><p>在现代操作系统中，当用户调用 write 函数将数据写入文件时，操作系统通常会将写入数据暂时保存在一个内存缓冲区空间，等到缓冲区<strong>写满或者到达特定时间周期</strong>，才真正地将缓冲区中的数据写入到磁盘里面（刷脏）</p>
<ul>
<li>优点：提高文件的写入效率</li>
<li>缺点：为写入数据带来了安全问题，如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失</li>
</ul>
<p>系统提供了 fsync 和 fdatasync 两个同步函数做<strong>强制硬盘同步</strong>，可以让操作系统立即将缓冲区中的数据写入到硬盘里面，函数会阻塞到写入硬盘完成后返回，保证了数据持久化</p>
<p>异常恢复：AOF 文件损坏，通过 redis-check-aof–fix appendonly.aof 进行恢复，重启 Redis，然后重新加载</p>
<hr>
<h4 id="文件载入-1"><a href="#文件载入-1" class="headerlink" title="文件载入"></a>文件载入</h4><p>AOF 文件里包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍 AOF 文件里的命令，就还原服务器关闭之前的数据库状态，服务器在启动时，还原数据库状态打印的日志：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[8321] 05 Sep 11:58:50.449 * DB loaded from append only file: 0.000 seconds </span><br></pre></td></tr></table></figure>

<p>AOF 文件里面除了用于指定数据库的 SELECT 命令是服务器自动添加的，其他都是通过客户端发送的命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">* 2\r\n<span class="variable">$6</span>\r\nSELECT\r\n<span class="variable">$1</span>\r\n0\r\n	<span class="comment"># 服务器自动添加</span></span><br><span class="line">* 3\r\n<span class="variable">$3</span>\r\nSET\r\n<span class="variable">$3</span>\r\nmsg\r\n<span class="variable">$5</span>\r\nhello\r\n</span><br><span class="line">* 5\r\n<span class="variable">$4</span>\r\nSADD\r\n<span class="variable">$6</span>\r\nfruits\r\n<span class="variable">$5</span>\r\napple\r\n<span class="variable">$6</span>\r\nbanana\r\n<span class="variable">$6</span>\r\ncherry\r\n</span><br></pre></td></tr></table></figure>

<p>Redis 读取 AOF 文件并还原数据库状态的步骤：</p>
<ul>
<li>创建一个<strong>不带网络连接的伪客户端</strong>（fake client）执行命令，因为 Redis 的命令只能在客户端上下文中执行， 而载入 AOF 文件时所使用的命令来源于本地 AOF 文件而不是网络连接</li>
<li>从 AOF 文件分析并读取一条写命令</li>
<li>使用伪客户端执行被读出的写命令，然后重复上述步骤</li>
</ul>
<hr>
<h4 id="重写实现"><a href="#重写实现" class="headerlink" title="重写实现"></a>重写实现</h4><h5 id="重写策略"><a href="#重写策略" class="headerlink" title="重写策略"></a>重写策略</h5><p>AOF 重写：读取服务器当前的数据库状态，<strong>生成新 AOF 文件来替换旧 AOF 文件</strong>，不会对现有的 AOF 文件进行任何读取、分析或者写入操作，而是直接原子替换。新 AOF 文件不会包含任何浪费空间的冗余命令，所以体积通常会比旧 AOF 文件小得多</p>
<p>AOF 重写规则：</p>
<ul>
<li><p>进程内具有时效性的数据，并且数据已超时将不再写入文件 </p>
</li>
<li><p>对同一数据的多条写命令合并为一条命令，因为会读取当前的状态，所以直接将当前状态转换为一条命令即可。为防止数据量过大造成客户端缓冲区溢出，对 list、set、hash、zset 等集合类型，<strong>单条指令</strong>最多写入 64 个元素</p>
<p>如 lpushlist1 a、lpush list1 b、lpush list1 c 可以转化为：lpush list1 a b c</p>
</li>
<li><p>非写入类的无效指令将被忽略，只保留最终数据的写入命令，但是 select 指令虽然不更改数据，但是更改了数据的存储位置，此类命令同样需要记录</p>
</li>
</ul>
<p>AOF 重写作用：</p>
<ul>
<li>降低磁盘占用量，提高磁盘利用率</li>
<li>提高持久化效率，降低持久化写时间，提高 IO 性能</li>
<li>降低数据恢复的用时，提高数据恢复效率</li>
</ul>
<hr>
<h5 id="重写原理"><a href="#重写原理" class="headerlink" title="重写原理"></a>重写原理</h5><p>AOF 重写程序 aof_rewrite 函数可以创建一个新 AOF 文件， 但是该函数会进行大量的写入操作，调用这个函数的线程将被长时间阻塞，所以 Redis 将 AOF 重写程序放到 fork 的子进程里执行，不会阻塞父进程，重写命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bgrewriteaof</span><br></pre></td></tr></table></figure>

<ul>
<li><p>子进程进行 AOF 重写期间，服务器进程（父进程）可以继续处理命令请求</p>
</li>
<li><p>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下， 保证数据的安全性</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-AOF%E6%89%8B%E5%8A%A8%E9%87%8D%E5%86%99%E5%8E%9F%E7%90%86.png"></p>
</li>
</ul>
<p>子进程在进行 AOF 重写期间，服务器进程还需要继续处理命令请求，而新命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的 AOF 文件所保存的数据库状态不一致，所以 Redis 设置了 AOF 重写缓冲区</p>
<p>工作流程：</p>
<ul>
<li>Redis 服务器执行完一个写命令，会同时将该命令追加到 AOF 缓冲区和 AOF 重写缓冲区（从创建子进程后才开始写入）</li>
<li>当子进程完成 AOF 重写工作之后，会向父进程发送一个信号，父进程在接到该信号之后， 会调用一个信号处理函数，该函数执行时会<strong>对服务器进程（父进程）造成阻塞</strong>（影响很小，类似 JVM STW），主要工作：<ul>
<li>将 AOF 重写缓冲区中的所有内容写入到新 AOF 文件中， 这时新 AOF 文件所保存的状态将和服务器当前的数据库状态一致</li>
<li>对新的 AOF 文件进行改名，<strong>原子地（atomic）覆盖</strong>现有的 AOF 文件，完成新旧两个 AOF 文件的替换</li>
</ul>
</li>
</ul>
<hr>
<h5 id="自动重写"><a href="#自动重写" class="headerlink" title="自动重写"></a>自动重写</h5><p>触发时机：Redis 会记录上次重写时的 AOF 大小，默认配置是当 AOF 文件大小是上次重写后大小的一倍且文件大于 64M 时触发</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-min-size size		<span class="comment">#设置重写的基准值，最小文件 64MB，达到这个值开始重写</span></span><br><span class="line">auto-aof-rewrite-percentage percent	<span class="comment">#触发AOF文件执行重写的增长率，当前AOF文件大小超过上一次重写的AOF文件大小的百分之多少才会重写，比如文件达到 100% 时开始重写就是两倍时触发</span></span><br></pre></td></tr></table></figure>

<p>自动重写触发比对参数（ 运行指令 <code>info Persistence</code> 获取具体信息 ）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">aof_current_size					<span class="comment">#AOF文件当前尺寸大小（单位:字节）</span></span><br><span class="line">aof_base_size						<span class="comment">#AOF文件上次启动和重写时的尺寸大小（单位:字节）</span></span><br></pre></td></tr></table></figure>

<p>自动重写触发条件公式：</p>
<ul>
<li>aof_current_size &gt; auto-aof-rewrite-min-size</li>
<li>(aof_current_size - aof_base_size) &#x2F; aof_base_size &gt;&#x3D; auto-aof-rewrite-percentage</li>
</ul>
<hr>
<h3 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h3><p>RDB 的特点</p>
<ul>
<li><p>RDB 优点：</p>
<ul>
<li>RDB 是一个紧凑压缩的二进制文件，存储效率较高，但存储数据量较大时，存储效率较低</li>
<li>RDB 内部存储的是 Redis 在某个时间点的数据快照，非常<strong>适合用于数据备份，全量复制、灾难恢复</strong></li>
<li>RDB 恢复数据的速度要比 AOF 快很多，因为是快照，直接恢复</li>
</ul>
</li>
<li><p>RDB 缺点：</p>
<ul>
<li>BGSAVE 指令每次运行要执行 fork 操作创建子进程，会牺牲一些性能</li>
<li>RDB 方式无论是执行指令还是利用配置，无法做到实时持久化，具有丢失数据的可能性，最后一次持久化后的数据可能丢失</li>
<li>Redis 的众多版本中未进行 RDB 文件格式的版本统一，可能出现各版本之间数据格式无法兼容</li>
</ul>
</li>
</ul>
<p>AOF 特点：</p>
<ul>
<li>AOF 的优点：数据持久化有较好的实时性，通过 AOF 重写可以降低文件的体积</li>
<li>AOF 的缺点：文件较大时恢复较慢</li>
</ul>
<p>AOF 和 RDB 同时开启，系统默认取 AOF 的数据（数据不会存在丢失）</p>
<p>应用场景：</p>
<ul>
<li><p>对数据<strong>非常敏感</strong>，建议使用默认的 AOF 持久化方案，AOF 持久化策略使用 everysecond，每秒钟 fsync 一次，该策略 Redis 仍可以保持很好的处理性能</p>
<p>注意：AOF 文件存储体积较大，恢复速度较慢，因为要执行每条指令</p>
</li>
<li><p>数据呈现<strong>阶段有效性</strong>，建议使用 RDB 持久化方案，可以做到阶段内无丢失，且恢复速度较快</p>
<p>注意：利用 RDB 实现紧凑的数据持久化，存储数据量较大时，存储效率较低</p>
</li>
</ul>
<p>综合对比：</p>
<ul>
<li>RDB 与 AOF 的选择实际上是在做一种权衡，每种都有利有弊</li>
<li>灾难恢复选用 RDB</li>
<li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用 AOF；如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用 RDB</li>
<li>双保险策略，同时开启 RDB 和 AOF，重启后 Redis 优先使用 AOF 来恢复数据，降低丢失数据的量</li>
<li>不建议单独用 AOF，因为可能会出现 Bug，如果只是做纯内存缓存，可以都不用</li>
</ul>
<hr>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>fork() 函数创建一个子进程，子进程与父进程几乎是完全相同的进程，系统先给子进程分配资源，然后把父进程的所有数据都复制到子进程中，只有少数值与父进程的值不同，相当于克隆了一个进程</p>
<p>在完成对其调用之后，会产生 2 个进程，且每个进程都会<strong>从 fork() 的返回处开始执行</strong>，这两个进程将执行相同的程序段，但是拥有各自不同的堆段，栈段，数据段，每个子进程都可修改各自的数据段，堆段，和栈段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 父进程返回子进程的pid，子进程返回0，错误返回负值，根据返回值的不同进行对应的逻辑处理</span></span><br></pre></td></tr></table></figure>

<p>fork 调用一次，却能够<strong>返回两次</strong>，可能有三种不同的返回值：</p>
<ul>
<li>在父进程中，fork 返回新创建子进程的进程 ID</li>
<li>在子进程中，fork 返回 0</li>
<li>如果出现错误，fork 返回一个负值，错误原因：<ul>
<li>当前的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN</li>
<li>系统内存不足，这时 errno 的值被设置为 ENOMEM</li>
</ul>
</li>
</ul>
<p>fpid 的值在父子进程中不同：进程形成了链表，父进程的 fpid 指向子进程的进程 id，因为子进程没有子进程，所以其 fpid 为0</p>
<p>创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的调度策略</p>
<p>每个进程都有一个独特（互不相同）的进程标识符 process ID，可以通过 getpid() 函数获得；还有一个记录父进程 pid 的变量，可以通过 getppid() 函数获得变量的值</p>
<hr>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>基本使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>   </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>   </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">pid_t</span> fpid; <span class="comment">// fpid表示fork函数返回的值  </span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;  </span><br><span class="line">    fpid = fork();   </span><br><span class="line">    <span class="keyword">if</span> (fpid &lt; <span class="number">0</span>)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error in fork!&quot;</span>);   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am the child process, my process id is %d/n&quot;</span>, getpid());    </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am the parent process, my process id is %d/n&quot;</span>, getpid());   </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;count: %d/n&quot;</span>,count);<span class="comment">// 1  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/* 输出内容：</span></span><br><span class="line"><span class="comment">    i am the child process, my process id is 5574</span></span><br><span class="line"><span class="comment">    count: 1</span></span><br><span class="line"><span class="comment">    i am the parent process, my process id is 5573</span></span><br><span class="line"><span class="comment">    count: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>进阶使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line">   <span class="comment">// ppid 指当前进程的父进程pid  </span></span><br><span class="line">   <span class="comment">// pid 指当前进程的pid,  </span></span><br><span class="line">   <span class="comment">// fpid 指fork返回给当前进程的值，在这可以表示子进程</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;  </span><br><span class="line">       <span class="type">pid_t</span> fpid = fork();  </span><br><span class="line">       <span class="keyword">if</span>(fpid == <span class="number">0</span>)  </span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%d child  %4d %4d %4d/n&quot;</span>,i, getppid(), getpid(), fpid);  </span><br><span class="line">       <span class="keyword">else</span>  </span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%d parent %4d %4d %4d/n&quot;</span>,i, getppid(), getpid(),fpid);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*输出内容：</span></span><br><span class="line"><span class="comment">	i        父id  id  子id</span></span><br><span class="line"><span class="comment">	0 parent 2043 3224 3225</span></span><br><span class="line"><span class="comment">    0 child  3224 3225    0</span></span><br><span class="line"><span class="comment">    1 parent 2043 3224 3226</span></span><br><span class="line"><span class="comment">    1 parent 3224 3225 3227</span></span><br><span class="line"><span class="comment">    1 child     1 3227    0</span></span><br><span class="line"><span class="comment">    1 child     1 3226    0 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-fork函数使用演示.png" style="zoom: 80%;">

<p>在 p3224 和 p3225 执行完第二个循环后，main 函数退出，进程死亡。所以 p3226，p3227 就没有父进程了，成为孤儿进程，所以 p3226 和 p3227 的父进程就被置为 ID 为 1的 init 进程（笔记 Tool → Linux → 进程管理详解）</p>
<p>参考文章：<a href="https://blog.csdn.net/love_gaohz/article/details/41727415">https://blog.csdn.net/love_gaohz/article/details/41727415</a></p>
<hr>
<h4 id="内存-1"><a href="#内存-1" class="headerlink" title="内存"></a>内存</h4><p>fork() 调用之后父子进程的内存关系</p>
<p>早期 Linux 的 fork() 实现时，就是全部复制，这种方法效率太低，而且造成了很大的内存浪费，现在 Linux 实现采用了两种方法：</p>
<ul>
<li><p>父子进程的代码段是相同的，所以代码段是没必要复制的，只需内核将代码段标记为只读，父子进程就共享此代码段。fork() 之后在进程创建代码段时，子进程的进程级页表项都指向和父进程相同的物理页帧</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-fork以后内存关系1.png" style="zoom: 67%;">
</li>
<li><p>对于父进程的数据段，堆段，栈段中的各页，由于父子进程相互独立，采用<strong>写时复制 COW</strong> 的技术，来提高内存以及内核的利用率</p>
<p>在 fork 之后两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，<strong>两者的虚拟空间不同，但其对应的物理空间是同一个</strong>，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。如果两者的代码完全相同，代码段继续共享父进程的物理空间；而如果两者执行的代码不同，子进程的代码段也会分配单独的物理空间。   </p>
<p>fork 之后内核会将子进程放在队列的前面，让子进程先执行，以免父进程执行导致写时复制，而后子进程再执行，因无意义的复制而造成效率的下降</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-fork以后内存关系2.png" style="zoom:67%;"></li>
</ul>
<p>补充知识：</p>
<p>vfork（虚拟内存 fork virtual memory fork）：调用 vfork() 父进程被挂起，子进程使用父进程的地址空间。不采用写时复制，如果子进程修改父地址空间的任何页面，这些修改过的页面对于恢复的父进程是可见的</p>
<p>参考文章：<a href="https://blog.csdn.net/Shreck66/article/details/47039937">https://blog.csdn.net/Shreck66/article/details/47039937</a></p>
<hr>
<h2 id="事务机制-1"><a href="#事务机制-1" class="headerlink" title="事务机制"></a>事务机制</h2><h3 id="事务特征"><a href="#事务特征" class="headerlink" title="事务特征"></a>事务特征</h3><p>Redis 事务就是将多个命令请求打包，然后<strong>一次性、按顺序</strong>地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务去执行其他的命令请求，会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求，Redis 事务的特性：</p>
<ul>
<li>Redis 事务<strong>没有隔离级别</strong>的概念，队列中的命令在事务没有提交之前都不会实际被执行</li>
<li>Redis 单条命令式保存原子性的，但是事务<strong>不保证原子性</strong>，事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li>
</ul>
<hr>
<h3 id="工作流程-3"><a href="#工作流程-3" class="headerlink" title="工作流程"></a>工作流程</h3><p>事务的执行流程分为三个阶段：</p>
<ul>
<li><p>事务开始：MULTI 命令的执行标志着事务的开始，通过在客户端状态的 flags 属性中打开 REDIS_MULTI 标识，将执行该命令的客户端从非事务状态切换至事务状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MULTI	<span class="comment"># 设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>命令入队：事务队列以先进先出（FIFO）的方式保存入队的命令，每个 Redis 客户端都有事务状态，包含着事务队列：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">	<span class="comment">// 事务状态</span></span><br><span class="line">    multiState mstate;	<span class="comment">/* MULTI/EXEC state */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 事务队列，FIFO顺序</span></span><br><span class="line">    multiCmd *commands; </span><br><span class="line">    </span><br><span class="line">   	<span class="comment">// 已入队命令计数</span></span><br><span class="line">    <span class="type">int</span> count；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果命令为 EXEC、DISCARD、WATCH、MULTI 四个命中的一个，那么服务器立即执行这个命令</li>
<li>其他命令服务器不执行，而是将命令放入一个事务队列里面，然后向客户端返回 QUEUED 回复</li>
</ul>
</li>
<li><p>事务执行：EXEC 提交事务给服务器执行，服务器会遍历这个客户端的事务队列，执行队列中的命令并将执行结果返回</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">EXEC	<span class="comment"># Commit 提交，执行事务，与multi成对出现，成对使用</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>事务取消的方法：</p>
<ul>
<li><p>取消事务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">DISCARD	<span class="comment"># 终止当前事务的定义，发生在multi之后，exec之前</span></span><br></pre></td></tr></table></figure>

<p>一般用于事务执行过程中输入了错误的指令，直接取消这次事务，类似于回滚</p>
</li>
</ul>
<hr>
<h3 id="WATCH"><a href="#WATCH" class="headerlink" title="WATCH"></a>WATCH</h3><h4 id="监视机制"><a href="#监视机制" class="headerlink" title="监视机制"></a>监视机制</h4><p>WATCH 命令是一个乐观锁（optimistic locking），可以在 EXEC 命令执行之前，监视任意数量的数据库键，并在 EXEC 命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复</p>
<ul>
<li><p>添加监控锁</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">WATCH key1 [key2……]	<span class="comment">#可以监控一个或者多个key</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>取消对所有 key 的监视</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">UNWATCH</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><p>每个 Redis 数据库都保存着一个 watched_keys 字典，键是某个被 WATCH 监视的数据库键，值则是一个链表，记录了所有监视相应数据库键的客户端：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">	<span class="comment">// 正在被 WATCH 命令监视的键</span></span><br><span class="line">    dict *watched_keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有对数据库进行修改的命令，在执行后都会调用 <code>multi.c/touchWatchKey</code> 函数对 watched_keys 字典进行检查，是否有客户端正在监视刚被命令修改过的数据库键，如果有的话函数会将监视被修改键的客户端的 REDIS_DIRTY_CAS 标识打开，表示该客户端的事务安全性已经被破坏</p>
<p>服务器接收到个客户端 EXEC 命令时，会根据这个客户端是否打开了 REDIS_DIRTY_CAS 标识，如果打开了说明客户端提交事务不安全，服务器会拒绝执行</p>
<hr>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>事务具有原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</p>
<p>原子性指事务队列中的命令要么就全部都执行，要么一个都不执行，但是在命令执行出错时，不会保证原子性（下一节详解）</p>
<p>Redis 不支持事务回滚机制（rollback），即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止</p>
<p>回滚需要程序员在代码中实现，应该尽可能避免：</p>
<ul>
<li><p>事务操作之前记录数据的状态</p>
<ul>
<li><p>单数据：string</p>
</li>
<li><p>多数据：hash、list、set、zset</p>
</li>
</ul>
</li>
<li><p>设置指令恢复所有的被修改的项</p>
<ul>
<li><p>单数据：直接 set（注意周边属性，例如时效）</p>
</li>
<li><p>多数据：修改对应值或整体克隆复制</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>事务具有一致性指的是，数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的</p>
<p>一致是数据符合数据库的定义和要求，没有包含非法或者无效的错误数据，Redis 通过错误检测和简单的设计来保证事务的一致性：</p>
<ul>
<li><p>入队错误：命令格式输入错误，出现语法错误造成，<strong>整体事务中所有命令均不会执行</strong>，包括那些语法正确的命令</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-命令的语法错误.png" style="zoom:80%;">
</li>
<li><p>执行错误：命令执行出现错误，例如对字符串进行 incr 操作，事务中正确的命令会被执行，运行错误的命令不会被执行</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-事务中执行错误.png" style="zoom:80%;">
</li>
<li><p>服务器停机：</p>
<ul>
<li>如果服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据库是一致的</li>
<li>如果服务器运行在持久化模式下，重启之后将数据库还原到一致的状态</li>
</ul>
</li>
</ul>
<hr>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>Redis 是一个单线程的执行原理，所以对于隔离性，分以下两种情况：</p>
<ul>
<li>并发操作在 EXEC 命令前执行，隔离性的保证要使用 WATCH 机制来实现，否则隔离性无法保证</li>
<li>并发操作在 EXEC 命令后执行，隔离性可以保证</li>
</ul>
<hr>
<h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p>Redis 并没有为事务提供任何额外的持久化功能，事务的持久性由 Redis 所使用的持久化模式决定</p>
<p>配置选项 <code>no-appendfsync-on-rewrite</code> 可以配合 appendfsync 选项在 AOF 持久化模式使用：</p>
<ul>
<li>选项打开时在执行 BGSAVE 或者 BGREWRITEAOF 期间，服务器会暂时停止对 AOF 文件进行同步，从而尽可能地减少 I&#x2F;O 阻塞</li>
<li>选项打开时运行在 always 模式的 AOF 持久化，事务也不具有持久性，所以该选项默认关闭</li>
</ul>
<p>在一个事务的最后加上 SAVE 命令总可以保证事务的耐久性</p>
<hr>
<h2 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="Lua 脚本"></a>Lua 脚本</h2><h3 id="环境创建"><a href="#环境创建" class="headerlink" title="环境创建"></a>环境创建</h3><h4 id="基本介绍-16"><a href="#基本介绍-16" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Redis 对 Lua 脚本支持，通过在服务器中嵌入 Lua 环境，客户端可以使用 Lua 脚本直接在服务器端<strong>原子地执行</strong>多个命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">EVAL &lt;script&gt; &lt;numkeys&gt; [key ...] [arg ...]</span><br><span class="line">EVALSHA &lt;sha1&gt; &lt;numkeys&gt; [key ...] [arg ...]</span><br></pre></td></tr></table></figure>

<p>EVAL 命令可以直接对输入的脚本计算：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; EVAL <span class="string">&quot;return 1 + 1&quot;</span> 0	<span class="comment"># 0代表需要的参数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2 </span><br></pre></td></tr></table></figure>

<p>EVALSHA 命令根据脚本的 SHA1 校验和来对脚本计算：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; EVALSHA <span class="string">&quot;2f3lba2bb6d6a0f42ccl59d2e2dad55440778de3&quot;</span> 0</span><br><span class="line">(<span class="built_in">integer</span>) 2 </span><br></pre></td></tr></table></figure>

<p>应用场景：Redis 只保证单条命令的原子性，所以为了实现原子操作，将多条的对 Redis 的操作整合到一个脚本里，但是避免把不需要做并发控制的操作写入脚本中</p>
<p>Lua 语法特点：</p>
<ul>
<li>声明变量的时候无需指定数据类型，而是用 local 来声明变量为局部变量</li>
<li>数组下标是从 1 开始</li>
</ul>
<hr>
<h4 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h4><p>Redis 服务器创建并修改 Lua 环境的整个过程：</p>
<ul>
<li><p>创建一个基础的 Lua 环境，调用 Lua 的 API 函数 lua_open</p>
</li>
<li><p>载入多个函数库到 Lua 环境里面，让 Lua 脚本可以使用这些函数库来进行数据操作，包括基础核心函数</p>
</li>
<li><p>创建全局变量 redis 表格，表格包含以下函数：</p>
<ul>
<li>执行 Redis 命令的 redis.call 和 redis.pcall 函数</li>
<li>记录 Redis 日志的 redis.log 函数，以及相应的日志级别 (level) 常量 redis.LOG_DEBUG 等</li>
<li>计算 SHAl 校验和的 redis.shalhex 函数</li>
<li>返回错误信息的 redis.error_reply 函数和 redis.status_reply 函数</li>
</ul>
</li>
<li><p>使用 Redis 自制的随机函数来替换 Lua 原有的带有副作用的随机函数，从而避免在脚本中引入副作用</p>
<p>Redis 要求所有传入服务器的 Lua 脚本，以及 Lua 环境中的所有函数，都必须是无副作用（side effect）的纯函数（pure function），所以对有副作用的随机函数 <code>math.random</code> 和 <code>math.randornseed</code> 进行替换</p>
</li>
<li><p>创建排序辅助函数 <code> _redis_compare_helper</code>，使用辅助函数来对一部分 Redis 命令的结果进行排序，从而消除命令的不确定性</p>
<p>比如集合元素的排列是无序的， 所以即使两个集合的元素完全相同，输出结果也不一定相同，Redis 将 SMEMBERS 这类在相同数据集上产生不同输出的命令称为带有不确定性的命令</p>
</li>
<li><p>创建 redis.pcall 函数的错误报告辅助函数 <code>_redis_err_handler </code>，这个函数可以打印出错代码的来源和发生错误的行数</p>
</li>
<li><p>对 Lua 环境中的全局环境进行保护，确保传入服务器的脚本不会因忘记使用 local 关键字，而将额外的全局变量添加到 Lua 环境</p>
</li>
<li><p>将完成修改的 Lua 环境保存到服务器状态的 lua 属性中，等待执行服务器传来的 Lua 脚本</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    Lua *lua;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Redis 使用串行化的方式来执行 Redis 命令，所以在任何时间里最多都只会有一个脚本能够被放进 Lua 环境里面运行，因此整个 Redis 服务器只需要创建一个 Lua 环境即可</p>
<hr>
<h3 id="协作组件"><a href="#协作组件" class="headerlink" title="协作组件"></a>协作组件</h3><h4 id="伪客户端"><a href="#伪客户端" class="headerlink" title="伪客户端"></a>伪客户端</h4><p>Redis 服务器为 Lua 环境创建了一个伪客户端负责处理 Lua 脚本中包含的所有 Redis 命令，工作流程：</p>
<ul>
<li>Lua 环境将 redis.call 或者 redis.pcall 函数想要执行的命令传给伪客户端</li>
<li>伪客户端将命令传给命令执行器</li>
<li>命令执行器执行命令并将命令的执行结果返回给伪客户端</li>
<li>伪客户端接收命令执行器返回的命令结果，并将结果返回给 Lua 环境</li>
<li>Lua 将命令结果返回给 redis.call 函数或者 redis.pcall 函数</li>
<li>redis.call 函数或者 redis.pcall 函数会将命令结果作为返回值返回给脚本的调用者</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-Lua%E4%BC%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%89%A7%E8%A1%8C.png"></p>
<hr>
<h4 id="脚本字典"><a href="#脚本字典" class="headerlink" title="脚本字典"></a>脚本字典</h4><p>Redis 服务器为 Lua 环境创建 lua_scripts 字典，键为某个 Lua 脚本的 SHA1 校验和（checksum），值则是校验和对应的 Lua 脚本</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    dict *lua_scripts;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>服务器会将所有被 EVAL 命令执行过的 Lua 脚本，以及所有被 SCRIPT LOAD 命令载入过的 Lua 脚本都保存到 lua_scripts 字典</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SCRIPT LOAD <span class="string">&quot;return &#x27;hi&#x27;&quot;</span></span><br><span class="line"><span class="string">&quot;2f3lba2bb6d6a0f42ccl59d2e2dad55440778de3&quot;</span> <span class="comment"># 字典的键，SHA1 校验和</span></span><br></pre></td></tr></table></figure>





<hr>
<h3 id="命令实现-1"><a href="#命令实现-1" class="headerlink" title="命令实现"></a>命令实现</h3><h4 id="脚本函数"><a href="#脚本函数" class="headerlink" title="脚本函数"></a>脚本函数</h4><p>EVAL 命令的执行的第一步是为传入的脚本定义一个相对应的 Lua 函数，Lua 函数的名字由 f_ 前缀加上脚本的 SHA1 校验和（四十个字符长）组成，而函数的体（body）则是脚本本身</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">EVAL <span class="string">&quot;return &#x27;hello world&#x27;&quot;</span> 0 </span><br><span class="line"><span class="comment"># 命令将会定义以下的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f_533203lc6b470dc5a0dd9b4bf2030dea6d65de91</span></span>() &#123;</span><br><span class="line">	<span class="built_in">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用函数来保存客户端传入的脚本有以下优点：</p>
<ul>
<li>通过函数的局部性来让 Lua 环境保持清洁，减少了垃圾回收的工作最， 并且避免了使用全局变量</li>
<li>如果某个脚本在 Lua 环境中被定义过至少一次，那么只需要 SHA1 校验和，服务器就可以在不知道脚本本身的情况下，直接通过调用 Lua 函数来执行脚本</li>
</ul>
<p>EVAL 命令第二步是将客户端传入的脚本保存到服务器的 lua_scripts 字典里，在字典中新添加一个键值对</p>
<hr>
<h4 id="执行函数"><a href="#执行函数" class="headerlink" title="执行函数"></a>执行函数</h4><p>EVAL 命令第三步是执行脚本函数</p>
<ul>
<li><p>将 EVAL 命令中传入的<strong>键名参数和脚本参数</strong>分别保存到 KEYS 数组和 ARGV 数组，将这两个数组作为<strong>全局变量</strong>传入到 Lua 环境</p>
</li>
<li><p>为 Lua 环境装载超时处理钩子（hook），这个钩子可以在脚本出现超时运行情况时，让客户端通过 <code>SCRIPT KILL</code> 命令停止脚本，或者通过 SHUTDOWN 命令直接关闭服务器</p>
<p>因为 Redis 是单线程的执行命令，当 Lua 脚本阻塞时需要兜底策略，可以中断执行</p>
</li>
<li><p>执行脚本函数</p>
</li>
<li><p>移除之前装载的超时钩子</p>
</li>
<li><p>将执行脚本函数的结果保存到客户端状态的输出缓冲区里，等待服务器将结果返回给客户端</p>
</li>
</ul>
<hr>
<h4 id="EVALSHA"><a href="#EVALSHA" class="headerlink" title="EVALSHA"></a>EVALSHA</h4><p>EVALSHA 命令的实现原理就是根据脚本的 SHA1 校验和来调用<strong>脚本对应的函数</strong>，如果函数在 Lua 环境中不存在，找不到 f_ 开头的函数，就会返回 <code>SCRIPT NOT FOUND</code></p>
<hr>
<h3 id="管理命令"><a href="#管理命令" class="headerlink" title="管理命令"></a>管理命令</h3><p>Redis 中与 Lua 脚本有关的管理命令有四个：</p>
<ul>
<li><p>SCRIPT FLUSH：用于清除服务器中所有和 Lua 脚本有关的信息，会释放并重建 lua_scripts 字典，关闭现有的 Lua 环境并重新创建一个新的 Lua 环境</p>
</li>
<li><p>SCRIPT EXISTS：根据输入的 SHA1 校验和（允许一次传入多个校验和），检查校验和对应的脚本是否存在于服务器中，通过检查 lua_scripts 字典实现</p>
</li>
<li><p>SCRIPT LOAD：在 Lua 环境中为脚本创建相对应的函数，然后将脚本保存到 lua_scripts字典里</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SCRIPT LOAD <span class="string">&quot;return &#x27;hi&#x27;&quot;</span></span><br><span class="line"><span class="string">&quot;2f3lba2bb6d6a0f42ccl59d2e2dad55440778de3&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SCRIPT KILL：停止脚本</p>
</li>
</ul>
<p>如果服务器配置了 lua-time-li­mit 选项，那么在每次执行 Lua 脚本之前，都会设置一个超时处理的钩子。钩子会在脚本运行期间会定期检查运行时间是否超过配置时间，如果超时钩子将定期在脚本运行的间隙中，查看是否有 SCRIPT KILL 或者 SHUTDOWN 到达：</p>
<ul>
<li>如果超时运行的脚本没有执行过写入操作，客户端可以通过 SCRIPT KILL 来停止这个脚本</li>
<li>如果执行过写入操作，客户端只能用 SHUTDOWN nosave 命令来停止服务器，防止不合法的数据被写入数据库中</li>
</ul>
<hr>
<h3 id="脚本复制"><a href="#脚本复制" class="headerlink" title="脚本复制"></a>脚本复制</h3><h4 id="命令复制"><a href="#命令复制" class="headerlink" title="命令复制"></a>命令复制</h4><p>当服务器运行在复制模式时，具有写性质的脚本命令也会被复制到从服务器，包括 EVAL、EVALSHA、SCRIPT FLUSH，以及 SCRIPT LOAD 命令</p>
<p>Redis 复制 EVAL、SCRIPT FLUSH、SCRIPT LOAD 三个命令的方法和复制普通 Redis 命令的方法一样，当主服务器执行完以上三个命令的其中一个时，会直接将被执行的命令传播（propagate）给所有从服务器，在从服务器中产生相同的效果</p>
<hr>
<h4 id="EVALSHA-1"><a href="#EVALSHA-1" class="headerlink" title="EVALSHA"></a>EVALSHA</h4><p>EVALSHA 命令的复制操作相对复杂，因为多个从服务器之间载入 Lua 脚本的清况各有不同，一个在主服务器被成功执行的 EVALSHA 命令，在从服务器执行时可能会出现脚本未找到（not found）错误</p>
<p>Redis 要求主服务器在传播 EVALSHA 命令时，必须确保 EVALSHA 命令要执行的脚本已经被所有从服务器载入过，如果不能确保主服务器会<strong>将 EVALSHA 命令转换成一个等价的 EVAL 命令</strong>，然后通过传播 EVAL 命令来代替 EVALSHA 命令</p>
<p>主服务器使用服务器状态的 repl_scriptcache_dict 字典记录已经将哪些脚本传播给了<strong>所有从服务器</strong>，当一个校验和出现在字典时，说明校验和对应的 Lua 脚本已经传播给了所有从服务器，主服务器可以直接传播 EVALSHA 命令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键是一个个 Lua 脚本的 SHA1 校验和，值则全部都是 NULL</span></span><br><span class="line">    dict *repl_scriptcache_dict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：每当主服务器添加一个新的从服务器时，都会清空 repl_scriptcache_dict 字典，因为字典里面记录的脚本已经不再被所有从服务器载入过，所以服务器以清空字典的方式，强制重新向所有从服务器传播脚本</p>
<p>通过使用 EVALSHA 命令指定的 SHA1 校验和，以及 lua_scripts 字典保存的 Lua 脚本，可以将一个 EVALSHA 命令转化为 EVAL 命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">EVALSHA <span class="string">&quot;533203lc6b470dc5a0dd9b4bf2030dea6d65de91&quot;</span> 0 </span><br><span class="line"><span class="comment"># -&gt; 转换</span></span><br><span class="line">EVAL <span class="string">&quot;return&#x27;hello world&#x27;&quot;</span> 0 </span><br></pre></td></tr></table></figure>

<p>脚本内容 <code>&quot;return&#39;hello world&#39;&quot;</code> 来源于 lua_scripts 字典 533203lc6b470dc5a0dd9b4bf2030dea6d65de91 键的值</p>
<hr>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="基本操作-4"><a href="#基本操作-4" class="headerlink" title="基本操作"></a>基本操作</h3><p>在分布式场景下，锁变量需要由一个共享存储系统来维护，多个客户端才可以通过访问共享存储系统来访问锁变量，加锁和释放锁的操作就变成了读取、判断和设置共享存储系统中的锁变量值多步操作</p>
<p>Redis 分布式锁的基本使用，悲观锁</p>
<ul>
<li><p>使用 SETNX 设置一个公共锁</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SETNX lock-key value	<span class="comment"># value任意数，返回为1设置成功，返回为0设置失败</span></span><br></pre></td></tr></table></figure>

<p><code>NX</code>：只在键不存在时，才对键进行设置操作，<code>SET key value NX</code> 效果等同于 <code>SETNX key value</code></p>
<p><code>XX</code> ：只在键已经存在时，才对键进行设置操作</p>
<p><code>EX</code>：设置键 key 的过期时间，单位时秒</p>
<p><code>PX</code>：设置键 key 的过期时间，单位时毫秒</p>
<p>说明：由于 <code>SET</code> 命令加上选项已经可以完全取代 SETNX、SETEX、PSETEX 的功能，Redis 不推荐使用这几个命令</p>
</li>
<li><p>操作完毕通过 DEL 操作释放锁</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">DEL lock-key </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 EXPIRE 为锁 key 添加存活（持有）时间，过期自动删除（放弃）锁，防止线程出现异常，无法释放锁</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">EXPIRE lock-key second </span><br><span class="line">PEXPIRE lock-key milliseconds</span><br></pre></td></tr></table></figure>

<p>通过 EXPIRE 设置过期时间缺乏原子性，如果在 SETNX 和 EXPIRE 之间出现异常，锁也无法释放</p>
</li>
<li><p>在 SET 时指定过期时间，保证原子性</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">  SET key value NX [EX seconds | PX milliseconds]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">****</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 防误删</span></span><br><span class="line"></span><br><span class="line">场景描述：线程 A 正在执行，但是业务阻塞，在锁的过期时间内未执行完成，过期删除后线程 B 重新获取到锁，此时线程 A 执行完成，删除锁，导致线程 B 的锁被线程 A 误删</span><br><span class="line"></span><br><span class="line">SETNX 获取锁时，设置一个指定的唯一值（UUID），释放前获取这个值，判断是否自己的锁，防止出现线程之间误删了其他线程的锁</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">// 加锁, unique_value作为客户端唯一性的标识，</span><br><span class="line">// PX 10000 则表示 lock_key 会在 10s 后过期，以免客户端在这期间发生异常而无法释放锁</span><br><span class="line">SET lock_key unique_value NX PX 10000</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Lua 脚本（unlock.script）实现的释放锁操作的伪代码：key 类型参数会放入 KEYS 数组，其它参数会放入 ARGV 数组，在脚本中通过 KEYS 和 ARGV 传递参数，<strong>保证判断标识和释放锁这两个操作的原子性</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">EVAL <span class="string">&quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[1])&quot;</span> 1 lock_key unique_value <span class="comment"># 1 代表需要一个参数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放锁，KEYS[1] 就是锁的 key，ARGV[1] 就是标识值，避免误释放</span></span><br><span class="line"><span class="comment">// 获取标识值，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="优化锁-1"><a href="#优化锁-1" class="headerlink" title="优化锁"></a>优化锁</h3><h4 id="不可重入"><a href="#不可重入" class="headerlink" title="不可重入"></a>不可重入</h4><p>不可重入：同一个线程无法多次获取同一把锁</p>
<p>使用 hash 键，filed 是加锁的线程标识， value 是<strong>锁重入次数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">|</span>    key    <span class="operator">|</span>       <span class="keyword">value</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>           <span class="operator">|</span>  filed  <span class="operator">|</span>  <span class="keyword">value</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-------------------------------|</span></span><br><span class="line"><span class="operator">|</span>  lock_key <span class="operator">|</span> thread1 <span class="operator">|</span>    <span class="number">1</span>    <span class="operator">|</span></span><br></pre></td></tr></table></figure>

<p>锁重入：</p>
<ul>
<li>加锁时判断锁的 filed 属性是否是当前线程，如果是将 value 加 1</li>
<li>解锁时判断锁的 filed 属性是否是当前线程，首先将 value 减一，如果 value 为 0 直接释放锁</li>
</ul>
<p>使用 Lua 脚本保证多条命令的原子性</p>
<hr>
<h4 id="不可重试"><a href="#不可重试" class="headerlink" title="不可重试"></a>不可重试</h4><p>不可重试：获取锁只尝试一次就返回 false，没有重试机制</p>
<ul>
<li>利用 Lua 脚本尝试获取锁，获取失败获取锁的剩余超时时间 ttl，或者通过参数传入线程抢锁允许等待的时间</li>
<li>利用订阅功能订阅锁释放的信息，然后线程挂起等待 ttl 时间</li>
<li>利用 Lua 脚本在释放锁时，发布一条锁释放的消息</li>
</ul>
<hr>
<h4 id="超时释放"><a href="#超时释放" class="headerlink" title="超时释放"></a>超时释放</h4><p>超时释放：锁超时释放可以避免死锁，但如果是业务执行耗时较长，需要进行锁续时，防止业务未执行完提前释放锁</p>
<p>看门狗 Watch Dog 机制：</p>
<ul>
<li>获取锁成功后，提交周期任务，每隔一段时间（Redisson 中默认为过期时间 &#x2F; 3），重置一次超时时间</li>
<li>如果服务宕机，Watch Dog 机制线程就停止，就不会再延长 key 的过期时间</li>
<li>释放锁后，终止周期任务</li>
</ul>
<hr>
<h4 id="主从一致"><a href="#主从一致" class="headerlink" title="主从一致"></a>主从一致</h4><p>主从一致性：集群模式下，主从同步存在延迟，当加锁后主服务器宕机时，从服务器还没同步主服务器中的锁数据，此时从服务器升级为主服务器，其他线程又可以获取到锁</p>
<p>将服务器升级为多主多从，：</p>
<ul>
<li>获取锁需要从所有主服务器 SET 成功才算获取成功</li>
<li>某个 master 宕机，slave 还没有同步锁数据就升级为 master，其他线程尝试加锁会加锁失败，因为其他 master 上已经存在该锁</li>
</ul>
<hr>
<h2 id="主从复制-1"><a href="#主从复制-1" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="基本操作-5"><a href="#基本操作-5" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="主从介绍"><a href="#主从介绍" class="headerlink" title="主从介绍"></a>主从介绍</h4><p>主从复制：一个服务器去复制另一个服务器，被复制的服务器为主服务器 master，复制的服务器为从服务器 slave</p>
<ul>
<li>master 用来<strong>写数据</strong>，执行写操作时，将出现变化的数据自动同步到 slave，很少会进行读取操作</li>
<li>slave 用来读数据，禁止在 slave 服务器上进行读操作</li>
</ul>
<p>进行复制中的主从服务器双方的数据库将保存相同的数据，将这种现象称作<strong>数据库状态一致</strong></p>
<p>主从复制的特点：</p>
<ul>
<li><p><strong>薪火相传</strong>：一个 slave 可以是下一个 slave 的 master，slave 同样可以接收其他 slave 的连接和同步请求，那么该 slave 作为了链条中下一个的 master，可以有效减轻 master 的写压力，去中心化降低风险</p>
<p>注意：主机挂了，从机还是从机，无法写数据了</p>
</li>
<li><p><strong>反客为主</strong>：当一个 master 宕机后，后面的 slave 可以立刻升为 master，其后面的 slave 不做任何修改</p>
</li>
</ul>
<p>主从复制的作用：</p>
<ul>
<li><strong>读写分离</strong>：master 写、slave 读，提高服务器的读写负载能力</li>
<li><strong>负载均衡</strong>：基于主从结构，配合读写分离，由 slave 分担 master 负载，并根据需求的变化，改变 slave 的数量，通过多个从节点分担数据读取负载，大大提高 Redis 服务器并发量与数据吞吐量</li>
<li>故障恢复：当 master 出现问题时，由 slave 提供服务，实现快速的故障恢复</li>
<li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li>
<li>高可用基石：基于主从复制，构建哨兵模式与集群，实现 Redis 的高可用方案</li>
</ul>
<p><strong>三高</strong>架构：</p>
<ul>
<li><p>高并发：应用提供某一业务要能支持很多客户端同时访问的能力，称为并发</p>
</li>
<li><p>高性能：性能最直观的感受就是速度快，时间短</p>
</li>
<li><p>高可用：</p>
<ul>
<li>可用性：应用服务在全年宕机的时间加在一起就是全年应用服务不可用的时间</li>
<li>业界可用性目标 5 个 9，即 99.999%，即服务器年宕机时长低于 315 秒，约 5.25 分钟</li>
</ul>
</li>
</ul>
<hr>
<h4 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h4><p>系统状态指令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">INFO replication</span><br></pre></td></tr></table></figure>

<p>master 和 slave 互连：</p>
<ul>
<li><p>方式一：客户端发送命令，设置 slaveof 选项，产生主从结构</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slaveof masterip masterport</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：服务器带参启动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server --slaveof masterip masterport</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式三：服务器配置（主流方式）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slaveof masterip masterport</span><br></pre></td></tr></table></figure></li>
</ul>
<p>主从断开连接：</p>
<ul>
<li><p>slave 断开连接后，不会删除已有数据，只是不再接受 master 发送的数据，可以作<strong>为从服务器升级为主服务器的指令</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slaveof no one	</span><br></pre></td></tr></table></figure></li>
</ul>
<p>授权访问：master 有服务端和客户端，slave 也有服务端和客户端，不仅服务端之间可以发命令，客户端也可以</p>
<ul>
<li><p>master 客户端发送命令设置密码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">requirepass password</span><br></pre></td></tr></table></figure>

<p>master 配置文件设置密码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">config <span class="built_in">set</span> requirepass password</span><br><span class="line">config get requirepass</span><br></pre></td></tr></table></figure>
</li>
<li><p>slave 客户端发送命令设置密码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">auth password</span><br></pre></td></tr></table></figure>

<p>slave 配置文件设置密码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">masterauth password</span><br></pre></td></tr></table></figure>

<p>slave 启动服务器设置密码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server –a password</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="复制流程"><a href="#复制流程" class="headerlink" title="复制流程"></a>复制流程</h3><h4 id="旧版复制"><a href="#旧版复制" class="headerlink" title="旧版复制"></a>旧版复制</h4><p>Redis 的复制功能分为同步（sync）和命令传播（command propagate）两个操作，主从库间的复制是<strong>异步进行的</strong></p>
<p>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态，该过程又叫全量复制：</p>
<ul>
<li>从服务器向主服务器发送 SYNC 命令来进行同步</li>
<li>收到 SYNC 的主服务器执行 BGSAVE 命令，在后台生成一个 RDB 文件，并使用一个<strong>缓冲区</strong>记录从现在开始执行的所有<strong>写命令</strong></li>
<li>当 BGSAVE 命令执行完毕时，主服务器会将 RDB 文件发送给从服务器</li>
<li>从服务接收并载入 RDB 文件（从服务器会<strong>清空原有数据</strong>）</li>
<li>缓冲区记录了 RDB 文件所在状态后的所有写命令，主服务器将在缓冲区的所有命令发送给从服务器，从服务器执行这些写命令</li>
<li>至此从服务器的数据库状态和主服务器一致</li>
</ul>
<p>命令传播用于在主服务器的数据库状态被修改，导致主从数据库状态出现不一致时， 让主从服务器的数据库重新回到一致状态</p>
<ul>
<li>主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器</li>
<li>从服务器接受命令并执行，主从服务器将再次回到一致状态</li>
</ul>
<hr>
<h4 id="功能缺陷"><a href="#功能缺陷" class="headerlink" title="功能缺陷"></a>功能缺陷</h4><p>SYNC 本身就是一个非常消耗资源的操作，每次执行 SYNC 命令，都需要执行以下动作：</p>
<ul>
<li>生成 RDB 文件，耗费主服务器大量 CPU 、内存和磁盘 I&#x2F;O 资源</li>
<li>RDB 文件发送给从服务器，耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响</li>
<li>从服务器载入 RDB 文件，期间会因为阻塞而没办法处理命令请求</li>
</ul>
<p>SYNC 命令下的从服务器对主服务器的复制分为两种情况：</p>
<ul>
<li>初次复制：从服务器没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同</li>
<li>断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，自动重连后并继续复制主服务器</li>
</ul>
<p>旧版复制在断线后重复制时，也会创建 RDB 文件进行<strong>全量复制</strong>，但是从服务器只需要断线时间内的这部分数据，所以旧版复制的实现方式非常浪费资源</p>
<hr>
<h4 id="新版复制"><a href="#新版复制" class="headerlink" title="新版复制"></a>新版复制</h4><p>Redis 从 2.8 版本开始，使用 PSYNC 命令代替 SYNC 命令来执行复制时的<strong>同步操作</strong>（命令传播阶段相同），解决了旧版复制在处理断线重复制情况的低效问题</p>
<p>PSYNC 命令具有完整重同步（full resynchronization）和<strong>部分重同步</strong>（partial resynchronization）两种模式：</p>
<ul>
<li>完整重同步：处理初次复制情况，执行步骤和 SYNC命令基本一样</li>
<li>部分重同步：处理断线后重复制情况，主服务器可以将主从连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态，该过程又叫<strong>部分复制</strong></li>
</ul>
<hr>
<h3 id="部分同步"><a href="#部分同步" class="headerlink" title="部分同步"></a>部分同步</h3><p>部分重同步功能由以下三个部分构成：</p>
<ul>
<li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量</li>
<li>主服务器的复制积压缓冲区（replication backlog）</li>
<li>服务器的运行 ID (run ID)</li>
</ul>
<h4 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h4><p>主服务器和从服务器会分别维护一个复制偏移量：</p>
<ul>
<li><p>主服务器每次向从服务器传播 N 个字节的数据时，就将自己的复制偏移量的值加上 N</p>
</li>
<li><p>从服务器每次收到主服务器传播来的 N 个字节的数据时，就将自己的复制偏移量的值加上 N</p>
</li>
</ul>
<p>通过对比主从服务器的复制偏移量，可以判断主从服务器是否处于一致状态</p>
<ul>
<li>主从服务器的偏移量是相同的，说明主从服务器处于一致状态</li>
<li>主从服务器的偏移量是不同的，说明主从服务器处于不一致状态</li>
</ul>
<hr>
<h4 id="缓冲区-1"><a href="#缓冲区-1" class="headerlink" title="缓冲区"></a>缓冲区</h4><p>复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为 1MB</p>
<ul>
<li>出队规则跟普通的先进先出队列一样</li>
<li>入队规则是当入队元素的数量大于队列长度时，最先入队的元素会被弹出，然后新元素才会被放入队列</li>
</ul>
<p>当主服务器进行<strong>命令传播时，不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区</strong>，缓冲区会保存着一部分最近传播的写命令，并且缓冲区会为队列中的每个字节记录相应的复制偏移量</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%A4%8D%E5%88%B6%E7%A7%AF%E5%8E%8B%E7%BC%93%E5%86%B2%E5%8C%BA.png"></p>
<p>从服务器会通过 PSYNC 命令将自己的复制偏移量 offset 发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：</p>
<ul>
<li>offset 之后的数据（即 offset+1）仍然存在于复制积压缓冲区里，那么主服务器将对从服务器执行部分重同步操作</li>
<li>offset 之后的数据已经不在复制积压缓冲区，说明部分数据已经丢失，那么主服务器将对从服务器执行完整重同步操作</li>
</ul>
<p>复制缓冲区大小设定不合理，会导致<strong>数据溢出</strong>。比如主服务器需要执行大量写命令，又或者主从服务器断线后重连接所需的时间较长，导致缓冲区中的数据已经丢失，则必须进行完整重同步</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">repl-backlog-size ?mb</span><br></pre></td></tr></table></figure>

<p>建议设置如下，这样可以保证绝大部分断线情况都能用部分重同步来处理：</p>
<ul>
<li>从服务器断线后重新连接上主服务器所需的平均时间 second</li>
<li>获取 master 平均每秒产生写命令数据总量 write_size_per_second</li>
<li>最优复制缓冲区空间 &#x3D; 2 * second * write_size_per_second</li>
</ul>
<hr>
<h4 id="运行ID"><a href="#运行ID" class="headerlink" title="运行ID"></a>运行ID</h4><p>服务器运行 ID（run ID）：是每一台服务器每次运行的身份识别码，在服务器启动时自动生成，由 40 位随机的十六进制字符组成，一台服务器多次运行可以生成多个运行 ID</p>
<p>作用：服务器间进行传输识别身份，如果想两次操作均对同一台服务器进行，<strong>每次必须操作携带对应的运行 ID</strong>，用于对方识别</p>
<p>从服务器对主服务器进行初次复制时，主服务器将自己的运行 ID 传送给从服务器，然后从服务器会将该运行 ID 保存。当从服务器断线并重新连上一个主服务器时，会向当前连接的主服务器发送之前保存的运行 ID：</p>
<ul>
<li>如果运行 ID 和当前连接的主服务器的运行 ID 相同，说明从服务器断线之前复制的就是当前连接的这个主服务器，执行部分重同步</li>
<li>如果不同，需要执行完整重同步操作</li>
</ul>
<hr>
<h4 id="PSYNC"><a href="#PSYNC" class="headerlink" title="PSYNC"></a>PSYNC</h4><p>PSYNC 命令的调用方法有两种</p>
<ul>
<li>如果从服务器之前没有复制过任何主服务器，或者执行了 <code>SLAVEOF no one</code>，开始一次新的复制时将向主服务器发送 <code>PSYNC ? -1</code> 命令，主动请求主服务器进行完整重同步</li>
<li>如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code> 命令，runid 是上一次复制的主服务器的运行 ID，offset 是复制的偏移量</li>
</ul>
<p>接收到 PSYNC 命令的主服务器会向从服务器返回以下三种回复的其中一种：</p>
<ul>
<li>执行完整重同步操作：返回 <code>+FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code>，runid 是主服务器的运行 ID，offset 是主服务器的复制偏移量</li>
<li>执行部分重同步操作：返回 <code>+CONTINUE</code>，从服务器收到该回复说明只需要等待主服务器发送缺失的部分数据即可</li>
<li>主服务器的版本低于 Redis2.8：返回 <code>-ERR</code>，版本过低识别不了 PSYNC，从服务器将向主服务器发送 SYNC 命令</li>
</ul>
<hr>
<h3 id="复制实现"><a href="#复制实现" class="headerlink" title="复制实现"></a>复制实现</h3><h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><p>通过向从服务器发送 SLAVEOF 命令，可以让从服务器去复制一个主服务器</p>
<ul>
<li><p>设置主服务器的地址和端口：将 SLAVEOF 命令指定的 ip 和 port 保存到服务器状态 redisServer</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	<span class="comment">// 主服务器的地址 </span></span><br><span class="line">    <span class="type">char</span> *masterhost; </span><br><span class="line">	 <span class="comment">//主服务器的端口 </span></span><br><span class="line">    <span class="type">int</span> masterport; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SLAVEOF 命令是一个<strong>异步命令</strong>，在完成属性的设置后服务器直接返回 OK，而实际的复制工作将在 OK 返回之后才真正开始执行</p>
</li>
<li><p>建立套接字连接：</p>
<ul>
<li>从服务器 connect 主服务器建立套接字连接，成功后从服务器将为这个套接字关联一个用于复制工作的文件事件处理器，负责执行后续的复制工作，如接收 RDB 文件、接收主服务器传播来的写命令等</li>
<li>主服务器在接受 accept 从务器的套接字连接后，将为该套接字创建相应的客户端状态，将从服务器看作一个客户端，从服务器将同时具有 server 和 client（可以发命令）两个身份</li>
</ul>
</li>
<li><p>发送 PING 命令：从服务器向主服务器发送一个 PING 命令，检查主从之间的通信是否正常、主服务器处理命令的能力是否正常</p>
<ul>
<li>返回错误，表示主服务器无法处理从服务器的命令请求（忙碌），从服务器断开并重新创建连向主服务器的套接字</li>
<li>返回命令回复，但从服务器不能在规定的时间内读取出命令回复的内容，表示主从之间的网络状态不佳，需要断开重连</li>
<li>读取到 PONG，表示一切状态正常，可以执行复制</li>
</ul>
</li>
<li><p>身份验证：如果从服务器设置了 masterauth 选项就进行身份验证，将向主服务器发送一条 AUTH 命令，命令参数为从服务器 masterauth 选项的值，如果主从设置的密码不相同，那么主将返回一个 invalid password 错误</p>
</li>
<li><p>发送端口信息：身份验证后</p>
<ul>
<li>从服务器执行命令 <code>REPLCONF listening-port &lt;port­number&gt;</code>， 向主服务器发送从服务器的监听端口号</li>
<li>主服务器在接收到这个命令后，会将端口号记录在对应的客户端状态 redisClient.slave_listening_port 属性中：</li>
</ul>
</li>
<li><p>同步：从服务器将向主服务器发送 PSYNC 命令，在同步操作执行之后，<strong>主从服务器双方都是对方的客户端</strong>，可以相互发送命令</p>
<ul>
<li><p>完整重同步：主服务器需要成为从服务器的客户端，才能将保存在缓冲区里面的写命令发送给从服务器执行</p>
</li>
<li><p>部分重同步：主服务器需要成为从服务器的客户端，才能向从服务器发送保存在复制积压缓冲区里面的写命令</p>
</li>
</ul>
</li>
<li><p>命令传播：主服务器将写命令发送给从服务器，保持数据库的状态一致</p>
</li>
</ul>
<hr>
<h4 id="复制图示"><a href="#复制图示" class="headerlink" title="复制图示"></a>复制图示</h4><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B%E6%9B%B4%E6%96%B0.png"></p>
<hr>
<h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><h4 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h4><p>心跳机制：进入命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：<code>REPLCONF ACK &lt;replication_offset&gt;</code>，re_offset 是从服务器当前的复制偏移量</p>
<p>心跳的作用：</p>
<ul>
<li>检测主从服务器的网络连接状态</li>
<li>辅助实现 min-slaves 选项</li>
<li>检测命令丢失</li>
</ul>
<hr>
<h4 id="网络状态"><a href="#网络状态" class="headerlink" title="网络状态"></a>网络状态</h4><p>如果主服务器超过一秒钟没有收到从服务器发来的 REPLCONF ACK 命令，主服务就认为主从服务器之间的连接出现问题</p>
<p>向主服务器发送 <code>INFO replication</code> 命令，lag 一栏表示从服务器最后一次向主服务器发送 ACK 命令距离现在多少秒：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INFO replication </span><br><span class="line"><span class="comment"># Replication </span></span><br><span class="line">role:master </span><br><span class="line">connected_slaves:2 </span><br><span class="line">slave0: ip=127.0.0.1,port=11111,state=online,offset=123,lag=0 <span class="comment"># 刚刚发送过 REPLCONF ACK </span></span><br><span class="line">slavel: ip=127.0.0.1,port=22222,state=online,offset=456,lag=3 <span class="comment"># 3秒之前发送过REPLCONF ACK </span></span><br></pre></td></tr></table></figure>

<p>在一般情况下，lag 的值应该在 0 或者 1 秒之间跳动，如果超过 1 秒说明主从服务器之间的连接出现了故障</p>
<hr>
<h4 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h4><p>Redis 的 min-slaves-to-write 和 min-slaves-max-lag 两个选项可以防止主服务器在<strong>不安全的情况下</strong>执行写命令</p>
<p>比如向主服务器设置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">min-slaves-to-write 5</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>

<p>那么在从服务器的数少于 5 个，或者 5 个从服务器的延迟（lag）值都大于或等于10 秒时，主服务器将拒绝执行写命令</p>
<hr>
<h4 id="命令丢失"><a href="#命令丢失" class="headerlink" title="命令丢失"></a>命令丢失</h4><p>检测命令丢失：由于网络或者其他原因，主服务器传播给从服务器的写命令丢失，那么当从服务器向主服务器发送 REPLCONF ACK 命令时，主服务器会检查从服务器的复制偏移量是否小于自己的，然后在复制积压缓冲区里找到从服务器缺少的数据，并将这些数据重新发送给从服务器</p>
<p>说明：REPLCONF ACK 命令和复制积压缓冲区都是 Redis 2.8 版本新增的，在 Redis 2.8 版本以前，即使命令在传播过程中丢失，主从服务器都不会注意到，也不会向从服务器补发丢失的数据，所以为了保证<strong>主从复制的数据一致性</strong>，最好使用 2.8 或以上版本的 Redis</p>
<hr>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="重启恢复"><a href="#重启恢复" class="headerlink" title="重启恢复"></a>重启恢复</h4><p>系统不断运行，master 的数据量会越来越大，一旦 <strong>master 重启</strong>，runid 将发生变化，会导致全部 slave 的全量复制操作</p>
<p>解决方法：本机保存上次 runid，重启后恢复该值，使所有 slave 认为还是之前的 master</p>
<p>优化方案：</p>
<ul>
<li><p>master 内部创建 master_replid 变量，使用 runid 相同的策略生成，并发送给所有 slave</p>
</li>
<li><p>在 master 关闭时执行命令 <code>shutdown save</code>，进行 RDB 持久化，将 runid 与 offset 保存到 RDB 文件中</p>
<p><code>redis-check-rdb dump.rdb</code> 命令可以查看该信息，保存为 repl-id 和 repl-offset</p>
</li>
<li><p>master 重启后加载 RDB 文件，恢复数据，将 RDB 文件中保存的 repl-id 与 repl-offset 加载到内存中，master_repl_id &#x3D; repl-id，master_repl_offset &#x3D; repl-offset</p>
</li>
<li><p>通过 info 命令可以查看该信息</p>
</li>
</ul>
<hr>
<h4 id="网络中断"><a href="#网络中断" class="headerlink" title="网络中断"></a>网络中断</h4><p>master 的 CPU 占用过高或 slave 频繁断开连接</p>
<ul>
<li><p>出现的原因：</p>
<ul>
<li>slave 每 1 秒发送 REPLCONF ACK 命令到 master</li>
<li>当 slave 接到了慢查询时（keys * ，hgetall等），会大量占用 CPU 性能</li>
<li>master 每 1 秒调用复制定时函数 replicationCron()，比对 slave 发现长时间没有进行响应</li>
</ul>
<p>最终导致 master 各种资源（输出缓冲区、带宽、连接等）被严重占用</p>
</li>
<li><p>解决方法：通过设置合理的超时时间，确认是否释放 slave</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">repl-timeout	<span class="comment"># 该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>slave 与 master 连接断开</p>
<ul>
<li><p>出现的原因：</p>
<ul>
<li>master 发送 ping 指令频度较低</li>
<li>master 设定超时时间较短</li>
<li>ping 指令在网络中存在丢包</li>
</ul>
</li>
<li><p>解决方法：提高 ping 指令发送的频度</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">repl-ping-slave-period	</span><br></pre></td></tr></table></figure>

<p>超时时间 repl-time 的时间至少是 ping 指令频度的5到10倍，否则 slave 很容易判定超时</p>
</li>
</ul>
<hr>
<h4 id="一致性-1"><a href="#一致性-1" class="headerlink" title="一致性"></a>一致性</h4><p>网络信息不同步，数据发送有延迟，导致多个 slave 获取相同数据不同步</p>
<p>解决方案：</p>
<ul>
<li><p><strong>优化主从间的网络环境</strong>，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象</p>
</li>
<li><p>监控主从节点延迟（通过offset）判断，如果 slave 延迟过大，<strong>暂时屏蔽程序对该 slave 的数据访问</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slave-serve-stale-data <span class="built_in">yes</span>|no</span><br></pre></td></tr></table></figure>

<p>开启后仅响应 info、slaveof 等少数命令（慎用，除非对数据一致性要求很高）</p>
</li>
<li><p>多个 slave 同时对 master 请求数据同步，master 发送的 RDB 文件增多，会对带宽造成巨大冲击，造成 master 带宽不足，因此数据同步需要根据业务需求，适量错峰</p>
</li>
</ul>
<hr>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><h3 id="哨兵概述"><a href="#哨兵概述" class="headerlink" title="哨兵概述"></a>哨兵概述</h3><p>Sentinel（哨兵）是 Redis 的高可用性（high availability）解决方案，由一个或多个 Sentinel 实例 instance 组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器，并在被监视的主服务器下线时进行故障转移</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-哨兵系统.png" style="zoom:67%;">

<ul>
<li>双环图案表示主服务器</li>
<li>单环图案表示三个从服务器</li>
</ul>
<p>哨兵的作用：</p>
<ul>
<li><p>监控：监控 master 和 slave，不断的检查 master 和 slave 是否正常运行，master 存活检测、master 与 slave 运行情况检测</p>
</li>
<li><p>通知：当被监控的服务器出现问题时，向其他哨兵发送通知</p>
</li>
<li><p>自动故障转移：断开 master 与 slave 连接，选取一个 slave 作为 master，将其他 slave 连接新的 master，并告知客户端新的服务器地址</p>
</li>
</ul>
<hr>
<h3 id="启用哨兵"><a href="#启用哨兵" class="headerlink" title="启用哨兵"></a>启用哨兵</h3><h4 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h4><p>配置三个哨兵 sentinel.conf：一般多个哨兵配置相同、端口不同，特殊需求可以配置不同的属性</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">port 26401</span><br><span class="line"><span class="built_in">dir</span> <span class="string">&quot;/redis/data&quot;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6401 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 20000</span><br><span class="line">sentinel parallel-sync mymaster 1</span><br><span class="line">sentinel deny-scripts-reconfig <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>配置说明：</p>
<ul>
<li><p>设置哨兵监听的主服务器信息，判断主观下线所需要的票数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;master_ip&gt; &lt;master_port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定哨兵在监控 Redis 服务时，设置判定服务器宕机的时长，该设置控制是否进行主从切换</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sentinel down-after-milliseconds &lt;master-name&gt; &lt;million_seconds&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>出现故障后，故障切换的最大超时时间，超过该值，认定切换失败，默认 3 分钟</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sentinel failover-timeout &lt;master_name&gt; &lt;million_seconds&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>故障转移时，同时进行主从同步的 slave 数量，数值越大，要求网络资源越高</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sentinel parallel-syncs &lt;master_name&gt; &lt;sync_slave_number&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>启动哨兵：服务端命令（Linux 命令）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-sentinel filename</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>Sentinel 本质上只是一个运行在特殊模式下的 Redis 服务器，当一个 Sentinel 启动时，首先初始化 Redis 服务器，但是初始化过程和普通 Redis 服务器的初始化过程并不完全相同，哨兵<strong>不提供数据相关服务</strong>，所以不会载入 RDB、AOF 文件</p>
<p>整体流程：</p>
<ul>
<li><p>初始化服务器</p>
</li>
<li><p>将普通 Redis 服务器使用的代码替换成 Sentinel 专用代码</p>
</li>
<li><p>初始化 Sentinel 状态</p>
</li>
<li><p>根据给定的配置文件，初始化 Sentinel 的监视主服务器列表</p>
</li>
<li><p>创建连向主服务器的网络连接</p>
</li>
</ul>
<hr>
<h4 id="代码替换"><a href="#代码替换" class="headerlink" title="代码替换"></a>代码替换</h4><p>将一部分普通 Redis服务器使用的代码替换成 Sentinel 专用代码</p>
<p>Redis 服务器端口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> REDIS_SERVERPORT 6379 		<span class="comment">// 普通服务器端口</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REDIS_SENTINEL_PORT 26379 	<span class="comment">// 哨兵端口</span></span></span><br></pre></td></tr></table></figure>

<p>服务器的命令表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通 Redis 服务器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">redisCommandTable</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;get&quot;</span>, getCommand, <span class="number">2</span>, <span class="string">&quot;r&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;set&quot;</span>, setCommand, <span class="number">-3</span>, <span class="string">&quot;wm&quot;</span>, <span class="number">0</span>, noPreloadGetKeys, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 哨兵</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">sentinelcmds</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;ping&quot;</span>, pingCommand, <span class="number">1</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;sentinel&quot;</span>, sentinelCommand, <span class="number">-2</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;subscribe&quot;</span>,...&#125;, &#123;<span class="string">&quot;unsubscribe&quot;</span>,...O&#125;, &#123;<span class="string">&quot;psubscribe&quot;</span>,...&#125;, &#123;<span class="string">&quot;punsubscribe&quot;</span>,...&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;info&quot;</span>,...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述表是哨兵模式下客户端可以执行的命令，所以对于 GET、SET 等命令，服务器根本就没有载入</p>
<hr>
<h4 id="哨兵状态"><a href="#哨兵状态" class="headerlink" title="哨兵状态"></a>哨兵状态</h4><p>服务器会初始化一个 sentinelState 结构，又叫 Sentinel 状态，结构保存了服务器中所有和 Sentinel 功能有关的状态（服务器的一般状态仍然由 redisServer 结构保存）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sentinelState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前纪元，用于实现故障转移</span></span><br><span class="line">    <span class="type">uint64_t</span> current_epoch; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存了所有被这个sentinel监视的主服务器</span></span><br><span class="line">    dict *masters;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否进入了 TILT 模式</span></span><br><span class="line">    <span class="type">int</span> tilt;</span><br><span class="line">    <span class="comment">// 进入 TILT 模式的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> tilt_start_time;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后一次执行时间处理的事件</span></span><br><span class="line">    <span class="type">mstime_t</span> previous_time;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 目前正在执行的脚本数量</span></span><br><span class="line">    <span class="type">int</span> running_scripts;</span><br><span class="line">    <span class="comment">// 一个FIFO队列，包含了所有需要执行的用户脚本</span></span><br><span class="line">    <span class="built_in">list</span> *scripts_queue;</span><br><span class="line">    </span><br><span class="line">&#125; sentinel;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="监控列表"><a href="#监控列表" class="headerlink" title="监控列表"></a>监控列表</h4><p>Sentinel 状态的初始化将 masters 字典的初始化，根据被载入的 Sentinel 配置文件 conf 来进行属性赋值</p>
<p>Sentinel 状态中的 masters 字典记录了所有被 Sentinel 监视的<strong>主服务器的相关信息</strong>，字典的键是被监视主服务器的名字，值是主服务器对应的实例结构</p>
<p>实例结构是一个 sentinelRedisinstance 数据类型，代表被 Sentinel 监视的实例，这个实例可以是主、从服务器，或者其他 Sentinel</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisinstance</span> &#123;</span></span><br><span class="line">    <span class="comment">// 标识值，记录了实例的类型，以及该实例的当前状态</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例的名字，主服务器的名字由用户在配置文件中设置，</span></span><br><span class="line">    <span class="comment">// 从服务器和哨兵的名字由 Sentinel 自动设置，格式为 ip:port，例如 127.0.0.1:6379</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例运行的 ID</span></span><br><span class="line">    <span class="type">char</span> *runid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="type">uint64_t</span> config_epoch;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例地址</span></span><br><span class="line">    sentinelAddr *addr; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前实例时主服务器，该字段保存从服务器信息，键是名字格式为 ip:port，值是实例结构</span></span><br><span class="line">    dict *slaves;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所有监视当前服务器的 Sentinel 实例，键是名字格式为 ip:port，值是实例结构</span></span><br><span class="line">    dict *sentinels;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sentinel down-after-milliseconds 的值，表示实例无响应多少毫秒后会被判断为主观下线(subjectively down) </span></span><br><span class="line">    <span class="type">mstime_t</span> down_after_period;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sentinel monitor 选项中的quorum参数，判断这个实例为客观下线(objectively down)所需的支持投票数量</span></span><br><span class="line">    <span class="type">int</span> quorum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sentinel parallel-syncs 的值，在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量</span></span><br><span class="line">    <span class="type">int</span> parallel-syncs;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sentinel failover-timeout的值，刷新故障迁移状态的最大时限</span></span><br><span class="line">    <span class="type">mstime_t</span> failover_timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addr 属性是一个指向 sentinelAddr 的指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelAddr</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *ip;</span><br><span class="line">    <span class="type">int</span> port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h4><p>初始化 Sentinel 的最后一步是创建连向被监视主服务器的网络连接，Sentinel 将成为主服务器的客户端，可以向主服务器发送命令，并从命令回复中获取相关的信息</p>
<p>每个被 Sentinel 监视的主服务器，Sentinel 会创建两个连向主服务器的<strong>异步网络连接</strong>：</p>
<ul>
<li>命令连接：用于向主服务器发送命令，并接收命令回复</li>
<li>订阅连接：用于订阅主服务器的 <code>_sentinel_:hello</code> 频道</li>
</ul>
<p>建立两个连接的原因：</p>
<ul>
<li><p>在 Redis 目前的发布与订阅功能中，被发送的信息都不会保存在 Redis 服务器里， 如果在信息发送时接收信息的客户端离线或断线，那么这个客户端就会丢失这条信息，为了不丢失 hello 频道的任何信息，Sentinel 必须用一个订阅连接来接收该频道的信息</p>
</li>
<li><p>Sentinel 还必须向主服务器发送命令，以此来与主服务器进行通信，所以 Sentinel 还必须向主服务器创建命令连接</p>
</li>
</ul>
<p>说明：断线的意思就是网络连接断开</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%93%A8%E5%85%B5%E7%B3%BB%E7%BB%9F%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png"></p>
<hr>
<h3 id="信息交互"><a href="#信息交互" class="headerlink" title="信息交互"></a>信息交互</h3><h4 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h4><h5 id="主服务器"><a href="#主服务器" class="headerlink" title="主服务器"></a>主服务器</h5><p>Sentinel 默认会以每十秒一次的频率，通过命令连接向被监视的主服务器发送 INFO 命令，来获取主服务器的当前信息</p>
<ul>
<li>一部分是主服务器本身的信息，包括 runid 域记录的服务器运行 ID，以及 role 域记录的服务器角色</li>
<li>另一部分是服务器属下所有从服务器的信息，每个从服务器都由一个 slave 字符串开头的行记录，根据这些 IP 地址和端口号，Sentinel 无须用户提供从服务器的地址信息，就可以自动发现从服务器</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Server </span></span><br><span class="line">run_id:76llc59dc3a29aa6fa0609f84lbb6al019008a9c</span><br><span class="line">...</span><br><span class="line"><span class="comment"># Replication </span></span><br><span class="line">role:master </span><br><span class="line">...</span><br><span class="line">slave0: ip=l27.0.0.1, port=11111, state=online, offset=22, lag=0</span><br><span class="line">slave1: ip=l27.0.0.1, port=22222, state=online, offset=22, lag=0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>根据 run_id 和 role 记录的信息 Sentinel 将对主服务器的实例结构进行更新，比如主服务器重启之后，运行 ID 就会和实例结构之前保存的运行 ID 不同，哨兵检测到这一情况之后就会对实例结构的运行 ID 进行更新</p>
<p>对于主服务器返回的从服务器信息，用实例结构的 slaves 字典记录了从服务器的信息：</p>
<ul>
<li>如果从服务器对应的实例结构已经存在，那么 Sentinel 对从服务器的实例结构进行更新</li>
<li>如果不存在，为这个从服务器新创建一个实例结构加入字典，字典键为 <code>ip:port</code></li>
</ul>
<hr>
<h5 id="从服务器"><a href="#从服务器" class="headerlink" title="从服务器"></a>从服务器</h5><p>当 Sentinel 发现主服务器有新的从服务器出现时，会为这个新的从服务器创建相应的实例结构，还会创建到从服务器的命令连接和订阅连接，所以 Sentinel 对所有的从服务器之间都可以进行命令操作</p>
<p>Sentinel 默认会以每十秒一次的频率，向从服务器发送 INFO 命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Server </span></span><br><span class="line">run_id:76llc59dc3a29aa6fa0609f84lbb6al019008a9c	<span class="comment">#从服务器的运行 id</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># Replication </span></span><br><span class="line">role:slave 				<span class="comment"># 从服务器角色</span></span><br><span class="line">...</span><br><span class="line">master_host:127.0.0.1 	<span class="comment"># 主服务器的 ip</span></span><br><span class="line">master_port:6379 		<span class="comment"># 主服务器的 port</span></span><br><span class="line">master_link_status:up 	<span class="comment"># 主从服务器的连接状态</span></span><br><span class="line">slave_repl_offset:11111	<span class="comment"># 从服务器的复制偏移蜇</span></span><br><span class="line">slave_priority:100 		<span class="comment"># 从服务器的优先级</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优先级属性</strong>在故障转移时会用到</li>
</ul>
<p>根据这些信息，Sentinel 会对从服务器的实例结构进行更新</p>
<hr>
<h4 id="发送信息"><a href="#发送信息" class="headerlink" title="发送信息"></a>发送信息</h4><p>Sentinel 在默认情况下，会以每两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送以下格式的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUBLISH _sentinel_:hello <span class="string">&quot;&lt;s_ip&gt;, &lt;s_port&gt;, &lt;s_runid&gt;, &lt;s_epoch&gt;, &lt;m_name&gt;, &lt;m_ip&gt;, &lt;m_port&gt;, &lt;m_epoch&gt;</span></span><br></pre></td></tr></table></figure>

<p>这条命令向服务器的 <code>_sentinel_:hello</code> 频道发送了一条信息，信息的内容由多个参数组成：</p>
<ul>
<li>以 s_ 开头的参数记录的是 Sentinel 本身的信息</li>
<li>以 m_ 开头的参数记录的则是主服务器的信息</li>
</ul>
<p>说明：<strong>通过命令连接发送的频道信息</strong></p>
<hr>
<h4 id="接受信息"><a href="#接受信息" class="headerlink" title="接受信息"></a>接受信息</h4><h5 id="订阅频道"><a href="#订阅频道" class="headerlink" title="订阅频道"></a>订阅频道</h5><p>Sentinel 与一个主或从服务器建立起订阅连接之后，就会通过订阅连接向服务器发送订阅命令，频道的订阅会一直持续到 Sentinel 与服务器的连接断开为止</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SUBSCRIBE _sentinel_:hello</span><br></pre></td></tr></table></figure>

<p>订阅成功后，Sentinel 就可以通过订阅连接从服务器的 <code>_sentinel_:hello</code> 频道接收信息，对消息分析：</p>
<ul>
<li>如果信息中记录的 Sentinel 运行 ID 与自己的相同，不做进一步处理</li>
<li>如果不同，将根据信息中的各个参数，对相应主服务器的实例结构进行更新</li>
</ul>
<p>对于监视同一个服务器的多个 Sentinel 来说，<strong>一个 Sentinel 发送的信息会被其他 Sentinel 接收到</strong>，这些信息会被用于更新其他 Sentinel 对发送信息 Sentinel 的认知，也会被用于更新其他 Sentinel 对被监视的服务器的认知</p>
<p>哨兵实例之间可以相互发现，要归功于 Redis 提供发布订阅机制</p>
<hr>
<h5 id="更新字典"><a href="#更新字典" class="headerlink" title="更新字典"></a>更新字典</h5><p>Sentinel 为主服务器创建的实例结构的 sentinels 字典保存所有同样监视这个<strong>主服务器的 Sentinel 信息</strong>（包括 Sentinel 自己），字典的键是 Sentinel 的名字，格式为 <code>ip:port</code>，值是键所对应 Sentinel 的实例结构</p>
<p>当 Sentinel 接收到其他 Sentinel 发来的信息时（发送信息的为源 Sentinel，接收信息的为目标 Sentinel），目标 Sentinel 会分析提取参数，在自己的 Sentinel 状态 sentinelState.masters 中查找相应的主服务器实例结构，检查主服务器实例结构的 sentinels 字典中，源 Sentinel 的实例结构是否存在</p>
<ul>
<li>如果源 Sentinel 的实例结构存在，那么对源 Sentinel 的实例结构进行更新</li>
<li>如果源 Sentinel 的实例结构不存在，说明源 Sentinel 是刚开始监视主服务器，目标 Sentinel 会为源 Sentinel 创建一个新的实例结构，并将这个结构添加到 sentinels 字典里面</li>
</ul>
<p>因为 Sentinel 可以接收到的频道信息来获知其他 Sentinel 的存在，并通过发送频道信息来让其他 Sentinel 知道自己的存在，所以用户在使用 Sentinel 时并不需要提供各个 Sentinel 的地址信息，<strong>监视同一个主服务器的多个 Sentinel 可以自动发现对方</strong></p>
<hr>
<h5 id="命令连接"><a href="#命令连接" class="headerlink" title="命令连接"></a>命令连接</h5><p>Sentinel 通过频道信息发现新的 Sentinel，除了创建实例结构，还会创建一个连向新 Sentinel 的命令连接，而新 Sentinel 也同样会创建连向这个 Sentinel 的命令连接，最终监视同一主服务器的多个 Sentinel 将形成相互连接的网络</p>
<p>作用：<strong>通过命令连接相连的各个 Sentinel</strong> 可以向其他 Sentinel 发送命令请求来进行信息交换</p>
<p>Sentinel 之间不会创建订阅连接：</p>
<ul>
<li>Sentinel 需要通过接收主服务器或者从服务器发来的频道信息来发现未知的新 Sentinel，所以才创建订阅连接</li>
<li>相互已知的 Sentinel 只要使用命令连接来进行通信就足够了</li>
</ul>
<hr>
<h3 id="下线检测"><a href="#下线检测" class="headerlink" title="下线检测"></a>下线检测</h3><h4 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h4><p>Sentinel 在默认情况下会以每秒一次的频率向所有与它创建了命令连接的实例（包括主从服务器、其他 Sentinel）发送 PING 命令，通过实例返回的 PING 命令回复来判断实例是否在线</p>
<ul>
<li>有效回复：实例返回 +PONG、-LOADING、-MASTERDOWN 三种回复的其中一种</li>
<li>无效回复：实例返回除上述三种以外的任何数据</li>
</ul>
<p>Sentinel 配置文件中 down-after-milliseconds 选项指定了判断实例进入主观下线所需的时长，如果主服务器在该时间内一直向 Sentinel 返回无效回复，Sentinel 就会在该服务器对应实例结构的 flags 属性打开 SRI_S_DOWN 标识，表示该主服务器进入主观下线状态</p>
<p>配置的 down-after-milliseconds 值不仅适用于主服务器，还会被用于当前 Sentinel 判断主服务器属下的所有从服务器，以及所有同样监视这个主服务器的其他 Sentinel 的主观下线状态</p>
<p>注意：对于监视同一个主服务器的多个 Sentinel 来说，设置的 down-after-milliseconds 选项的值可能不同，所以当一个 Sentinel 将主服务器判断为主观下线时，其他 Sentinel 可能仍然会认为主服务器处于在线状态</p>
<hr>
<h4 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h4><p>当 Sentinel 将一个主服务器判断为主观下线之后，会向同样监视这一主服务器的其他 Sentinel 进行询问</p>
<p>Sentinel 使用命令询问其他 Sentinel 是否同意主服务器已下线：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>ip：被 Sentinel 判断为主观下线的主服务器的 IP 地址</li>
<li>port：被 Sentinel 判断为主观下线的主服务器的端口号</li>
<li>current_epoch：Sentinel 当前的配置纪元，用于选举领头 Sentinel</li>
<li>runid：取值为 * 符号代表命令仅仅用于检测主服务器的客观下线状态；取值为 Sentinel 的运行 ID 则用于选举领头 Sentinel</li>
</ul>
<p>目标 Sentinel 接收到源 Sentinel 的命令时，会根据参数的 lP 和端口号，检查主服务器是否已下线，然后返回一条包含三个参数的 Multi Bulk 回复：</p>
<ul>
<li>down_state：返回目标 Sentinel 对服务器的检查结果，1 代表主服务器已下线，0 代表未下线</li>
<li>leader_runid：取值为 * 符号代表命令仅用于检测服务器的下线状态；而局部领头 Sentinel 的运行 ID 则用于选举领头 Sentinel</li>
<li>leader_epoch：目标 Sentinel 的局部领头 Sentinel 的配置纪元</li>
</ul>
<p>源 Sentinel 将统计其他 Sentinel 同意主服务器已下线的数量，当这一数量达到配置指定的判断客观下线所需的数量（quorum）时，Sentinel 会将主服务器对应实例结构 flags 属性的 SRI_O_DOWN 标识打开，代表客观下线，并对主服务器执行故障转移操作</p>
<p>注意：不同 Sentinel 判断客观下线的条件可能不同，因为载入的配置文件中的属性（quorum）可能不同</p>
<hr>
<h3 id="领头选举"><a href="#领头选举" class="headerlink" title="领头选举"></a>领头选举</h3><p>主服务器被判断为客观下线时，监视这个主服务器的各个 Sentinel 会进行协商，选举出一个领头 Sentinel 对下线服务器执行故障转移</p>
<p>Redis 选举领头 Sentinel 的规则：</p>
<ul>
<li><p>所有在线的 Sentinel 都有被选为领头 Sentinel 的资格</p>
</li>
<li><p>每个发现主服务器进入客观下线的 Sentinel 都会要求其他 Sentinel 将自己设置为局部领头 Sentinel</p>
</li>
<li><p>在一个配置纪元里，所有 Sentinel 都只有一次将某个 Sentinel 设置为局部领头 Sentinel 的机会，并且局部领头一旦设置，在这个配置纪元里就不能再更改</p>
</li>
<li><p>Sentinel 设置局部领头 Sentinel 的规则是先到先得，最先向目标 Sentinel 发送设置要求的源 Sentinel 将成为目标 Sentinel 的局部领头 Sentinel，之后接收到的所有设置要求都会被目标 Sentinel 拒绝</p>
</li>
<li><p>领头 Sentinel 的产生需要半数以上 Sentinel 的支持，并且每个 Sentinel 只有一票，所以一个配置纪元只会出现一个领头 Sentinel，比如 10 个 Sentinel 的系统中，至少需要 <code>10/2 + 1 = 6</code> 票</p>
</li>
</ul>
<p>选举过程：</p>
<ul>
<li>一个 Sentinel 向目标 Sentinel 发送 <code>SENTINEL is-master-down-by-addr</code> 命令，命令中的 runid 参数不是＊符号而是源 Sentinel 的运行 ID，表示源 Sentinel 要求目标 Sentinel 将自己设置为它的局部领头 Sentinel</li>
<li>目标 Sentinel 接受命令处理完成后，将返回一条命令回复，回复中的 leader_runid 和 leader_epoch 参数分别记录了目标 Sentinel 的局部领头 Sentinel 的运行 ID 和配置纪元</li>
<li>源 Sentinel 接收目标 Sentinel 命令回复之后，会判断 leader_epoch 是否和自己的相同，相同就继续判断 leader_runid 是否和自己的运行 ID 一致，成立表示目标 Sentinel 将源 Sentinel 设置成了局部领头 Sentinel，即获得一票</li>
<li>如果某个 Sentinel 被半数以上的 Sentinel 设置成了局部领头 Sentinel，那么这个 Sentinel 成为领头 Sentinel</li>
<li>如果在给定时限内，没有一个 Sentinel 被选举为领头 Sentinel，那么各个 Sentinel 将在一段时间后再次选举，直到选出领头</li>
<li>每次进行领头 Sentinel 选举之后，不论选举是否成功，所有 Sentinel 的配置纪元（configuration epoch）都要自增一次</li>
</ul>
<p>Sentinel 集群至少 3 个节点的原因：</p>
<ul>
<li>如果 Sentinel 集群只有 2 个 Sentinel 节点，则领头选举需要 <code>2/2 + 1 = 2</code> 票，如果一个节点挂了，那就永远选不出领头</li>
<li>Sentinel 集群允许 1 个 Sentinel 节点故障则需要 3 个节点的集群，允许 2 个节点故障则需要 5 个节点集群</li>
</ul>
<hr>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><h4 id="执行流程-2"><a href="#执行流程-2" class="headerlink" title="执行流程"></a>执行流程</h4><p>领头 Sentinel 将对已下线的主服务器执行故障转移操作，该操作包含以下三个步骤</p>
<ul>
<li><p>从下线主服务器属下的所有从服务器里面，挑选出一个从服务器，执行 <code>SLAVEOF no one</code>，将从服务器升级为主服务器</p>
<p>在发送 SLAVEOF no one 命令后，领头 Sentinel 会以<strong>每秒一次的频率</strong>（一般是 10s&#x2F;次）向被升级的从服务器发送 INFO 命令，观察命令回复中的角色信息，当被升级服务器的 role 从 slave 变为 master 时，说明从服务器已经顺利升级为主服务器</p>
</li>
<li><p>将已下线的主服务器的所有从服务器改为复制新的主服务器，通过向从服务器发送 SLAVEOF 命令实现</p>
</li>
<li><p>将已经下线的主服务器设置为新的主服务器的从服务器，设置是保存在服务器对应的实例结构中，当旧的主服务器重新上线时，Sentinel 就会向它发送 SLAVEOF 命令，成为新的主服务器的从服务器</p>
</li>
</ul>
<p>示例：sever1 是主，sever2、sever3、sever4 是从服务器，sever1 故障后选中 sever2 升级</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%93%A8%E5%85%B5%E6%89%A7%E8%A1%8C%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB.png"></p>
<hr>
<h4 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h4><p>领头 Sentinel 会将已下线主服务器的所有从服务器保存到一个列表里，然后按照以下规则对列表进行过滤，最后挑选出一个<strong>状态良好、数据完整</strong>的从服务器</p>
<ul>
<li><p>删除列表中所有处于下线或者断线状态的从服务器，保证列表中的从服务器都是正常在线的</p>
</li>
<li><p>删除列表中所有最近五秒内没有回复过领头 Sentinel 的 INFO 命令的从服务器，保证列表中的从服务器最近成功进行过通信</p>
</li>
<li><p>删除所有与已下线主服务器连接断开超过 <code>down-after-milliseconds * 10</code> 毫秒的从服务器，保证列表中剩余的从服务器都没有过早地与主服务器断开连接，保存的数据都是比较新的</p>
<p>down-after-milliseconds 时间用来判断是否主观下线，其余的时间完全可以完成客观下线和领头选举</p>
</li>
<li><p>根据从服务器的优先级，对列表中剩余的从服务器进行排序，并选出其中<strong>优先级最高</strong>的从服务器</p>
</li>
<li><p>如果有多个具有相同最高优先级的从服务器，领头 Sentinel 将对这些相同优先级的服务器按照复制偏移量进行排序，选出其中偏移量最大的从服务器，也就是保存着最新数据的从服务器</p>
</li>
<li><p>如果还没选出来，就按照运行 ID 对这些从服务器进行排序，并选出其中运行 ID 最小的从服务器</p>
</li>
</ul>
<hr>
<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><h3 id="集群节点"><a href="#集群节点" class="headerlink" title="集群节点"></a>集群节点</h3><h4 id="节点概述"><a href="#节点概述" class="headerlink" title="节点概述"></a>节点概述</h4><p>Redis 集群是 Redis 提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享， 并提供复制和故障转移功能，一个 Redis 集群通常由多个节点（node）组成，将各个独立的节点连接起来，构成一个包含多节点的集群</p>
<p>一个节点就是一个<strong>运行在集群模式下的 Redis 服务器</strong>，Redis 在启动时会根据配置文件中的 <code>cluster-enabled</code> 配置选项是否为 yes 来决定是否开启服务器的集群模式</p>
<p>节点会继续使用所有在单机模式中使用的服务器组件，使用 redisServer 结构来保存服务器的状态，使用 redisClient 结构来保存客户端的状态，也有集群特有的数据结构</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F.png"></p>
<hr>
<h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><p>每个节点都保存着一个集群状态 clusterState 结构，这个结构记录了在当前节点的视角下，集群目前所处的状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 指向当前节点的指针</span></span><br><span class="line">	clusterNode *myself;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 集群当前的配置纪元，用于实现故障转移</span></span><br><span class="line">	<span class="type">uint64_t</span> currentEpoch;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 集群当前的状态，是在线还是下线</span></span><br><span class="line">	<span class="type">int</span> state;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 集群中至少处理着一个槽的节点的数量，为0表示集群目前没有任何节点在处理槽</span></span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群节点名单（包括 myself 节点），字典的键为节点的名字，字典的值为节点对应的clusterNode结构 </span></span><br><span class="line">    dict *nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个节点都会使用 clusterNode 结构记录当前状态，并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的 clusterNode 结构，以此来记录其他节点的状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 创建节点的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> ctime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点的名字，由 40 个十六进制字符组成</span></span><br><span class="line">    <span class="type">char</span> name[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点标识，使用各种不同的标识值记录节点的角色（比如主节点或者从节点）以及节点目前所处的状态（比如在线或者下线）</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="type">uint64_t</span> configEpoch;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点的IP地址</span></span><br><span class="line">    <span class="type">char</span> ip[REDIS_IP_STR_LEN];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点的端口号</span></span><br><span class="line">    <span class="type">int</span> port;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存连接节点所需的有关信息</span></span><br><span class="line">    clusterLink *link;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clusterNode 结构的 link 属性是一个 clusterLink 结构，该结构保存了连接节点所需的有关信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterLink</span> &#123;</span></span><br><span class="line">    <span class="comment">// 连接的创建时间 </span></span><br><span class="line">    <span class="type">mstime_t</span> ctime;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// TCP套接字描述符</span></span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 输出缓冲区，保存着等待发送给其他节点的消息(message)。 </span></span><br><span class="line">    sds sndbuf;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 输入缓冲区，保存着从其他节点接收到的消息。</span></span><br><span class="line">	sds rcvbuf;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 与这个连接相关联的节点，如果没有的话就为NULL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>redisClient 结构中的套接宇和缓冲区是用于连接客户端的</li>
<li>clusterLink 结构中的套接宇和缓冲区则是用于连接节点的</li>
</ul>
<hr>
<h4 id="MEET"><a href="#MEET" class="headerlink" title="MEET"></a>MEET</h4><p>CLUSTER MEET 命令用来将 ip 和 port 所指定的节点添加到接受命令的节点所在的集群中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CLUSTER MEET &lt;ip&gt; &lt;port&gt; </span><br></pre></td></tr></table></figure>

<p>假设向节点 A 发送 CLUSTER MEET 命令，让节点 A 将另一个节点 B 添加到节点 A 当前所在的集群里，收到命令的节点 A 将与根据 ip 和 port 向节点 B 进行握手（handshake）：</p>
<ul>
<li>节点 A 会为节点 B 创建一个 clusterNode 结构，并将该结构添加到自己的 clusterState.nodes 字典里，然后节点 A 向节点 B <strong>发送 MEET 消息</strong>（message）</li>
<li>节点 B 收到 MEET 消息后，节点 B 会为节点 A 创建一个 clusterNode 结构，并将该结构添加到自己的 clusterState.nodes 字典里，之后节点 B 将向节点 A <strong>返回一条 PONG 消息</strong></li>
<li>节点 A 收到 PONG 消息后，代表节点 A 可以知道节点 B 已经成功地接收到了自已发送的 MEET 消息，此时节点 A 将向节点 B <strong>返回一条 PING 消息</strong></li>
<li>节点 B 收到 PING 消息后， 代表节点 B 可以知道节点 A 已经成功地接收到了自己返回的 PONG 消息，握手完成</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E6%8F%A1%E6%89%8B.png"></p>
<p>节点 A 会将节点 B 的信息通过 Gossip 协议传播给集群中的其他节点，让其他节点也与节点 B 进行握手，最终经过一段时间之后，节点 B 会被集群中的所有节点认识</p>
<hr>
<h3 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h3><h4 id="基本操作-6"><a href="#基本操作-6" class="headerlink" title="基本操作"></a>基本操作</h4><p>Redis 集群通过分片的方式来保存数据库中的键值对，集群的整个数据库被分为16384 个槽（slot），数据库中的每个键都属于 16384 个槽中的一个，集群中的每个节点可以处理 0 个或最多 16384 个槽（<strong>每个主节点存储的数据并不一样</strong>）</p>
<ul>
<li>当数据库中的 16384 个槽都有节点在处理时，集群处于上线状态（ok）</li>
<li>如果数据库中有任何一个槽得到处理，那么集群处于下线状态（fail）</li>
</ul>
<p>通过向节点发送 CLUSTER ADDSLOTS 命令，可以将一个或多个槽指派（assign）给节点负责</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CLUSTER ADDSLOTS &lt;slot&gt; [slot ... ] </span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:7000&gt; CLUSTER ADDSLOTS 0 1 2 3 4 ... 5000 <span class="comment"># 将槽0至槽5000指派给节点7000负责</span></span><br><span class="line">OK </span><br></pre></td></tr></table></figure>

<p>命令执行细节：</p>
<ul>
<li>如果命令参数中有一个槽已经被指派给了某个节点，那么会向客户端返回错误，并终止命令执行</li>
<li>将 slots 数组中的索引 i 上的二进制位设置为 1，就代表指派成功</li>
</ul>
<hr>
<h4 id="节点指派"><a href="#节点指派" class="headerlink" title="节点指派"></a>节点指派</h4><p>clusterNode 结构的 slots 属性和 numslot 属性记录了节点负责处理哪些槽：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 处理信息，一字节等于 8 位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> slots[l6384/<span class="number">8</span>];</span><br><span class="line">    <span class="comment">// 记录节点负责处理的槽的数量，就是 slots 数组中值为 1 的二进制位数量</span></span><br><span class="line">    <span class="type">int</span> numslots;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>slots 是一个二进制位数组（bit array），长度为 <code>16384/8 = 2048</code> 个字节，包含 16384 个二进制位，Redis 以 0 为起始索引，16383 为终止索引，对 slots 数组的 16384 个二进制位进行编号，并根据索引 i 上的二进制位的值来判断节点是否负责处理槽 i：</p>
<ul>
<li>在索引 i 上的二进制位的值为 1，那么表示节点负责处理槽 i</li>
<li>在索引 i 上的二进制位的值为 0，那么表示节点不负责处理槽 i</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E9%9B%86%E7%BE%A4%E6%A7%BD%E6%8C%87%E6%B4%BE%E4%BF%A1%E6%81%AF.png"></p>
<p>取出和设置 slots 数组中的任意一个二进制位的值的**复杂度仅为 O(1)**，所以对于一个给定节点的 slots 数组来说，检查节点是否负责处理某个槽或者将某个槽指派给节点负责，这两个动作的复杂度都是 O(1)</p>
<p><strong>传播节点的槽指派信息</strong>：一个节点除了会将自己负责处理的槽记录在 clusterNode 中，还会将自己的 slots 数组通过消息发送给集群中的其他节点，每个接收到 slots 数组的节点都会将数组保存到相应节点的 clusterNode 结构里面，因此集群中的<strong>每个节点</strong>都会知道数据库中的 16384 个槽分别被指派给了集群中的哪些节点</p>
<hr>
<h4 id="集群指派"><a href="#集群指派" class="headerlink" title="集群指派"></a>集群指派</h4><p>集群状态 clusterState 结构中的 slots 数组记录了集群中所有 16384 个槽的指派信息，数组每一项都是一个指向 clusterNode 的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    clusterNode *slots[<span class="number">16384</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 slots[i] 指针指向 NULL，那么表示槽 i 尚未指派给任何节点</li>
<li>如果 slots[i] 指针指向一个 clusterNode 结构，那么表示槽 i 已经指派给该节点所代表的节点</li>
</ul>
<p>通过该节点，程序检查槽 i 是否已经被指派或者取得负责处理槽 i 的节点，只需要访问 clusterState. slots[i] 即可，时间复杂度仅为 O(1)</p>
<hr>
<h4 id="集群数据"><a href="#集群数据" class="headerlink" title="集群数据"></a>集群数据</h4><p>集群节点保存键值对以及键值对过期时间的方式，与单机 Redis 服务器保存键值对以及键值对过期时间的方式完全相同，但是集群节点只能使用 0 号数据库，单机服务器可以任意使用</p>
<p>除了将键值对保存在数据库里面之外，节点还会用 clusterState 结构中的 slots_to_keys 跳跃表来<strong>保存槽和键之间的关系</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    zskiplist *slots_to_keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>slots_to_keys 跳跃表每个节点的分值（score）都是一个槽号，而每个节点的成员（member）都是一个数据库键（按槽号升序）</p>
<ul>
<li>当节点往数据库中添加一个新的键值对时，节点就会将这个键以及键的槽号关联到 slots_to_keys 跳跃表</li>
<li>当节点删除数据库中的某个键值对时，节点就会在 slots_to_keys 跳跃表解除被删除键与槽号的关联</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%A7%BD%E5%92%8C%E9%94%AE%E8%B7%B3%E8%B7%83%E8%A1%A8.png"></p>
<p>通过在 slots_to_keys 跳跃表中记录各个数据库键所属的槽，可以很方便地对属于某个或某些槽的所有数据库键进行批量操作，比如 <code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code> 命令返回最多 count 个属于槽 slot 的数据库键，就是通过该跳表实现</p>
<hr>
<h3 id="集群命令"><a href="#集群命令" class="headerlink" title="集群命令"></a>集群命令</h3><h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><p>集群处于上线状态，客户端就可以向集群中的节点发送命令（16384 个槽全部指派就进入上线状态）</p>
<p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令该键属于哪个槽，并检查这个槽是否指派给了自己</p>
<ul>
<li>如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令</li>
<li>反之，节点会向客户端返回一个 MOVED 错误，指引客户端转向（redirect）至正确的节点，再次发送该命令</li>
</ul>
<p>计算键归属哪个槽的<strong>寻址算法</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">slot_number</span><span class="params">(key)</span>: 			<span class="comment">// CRC16(key) 语句计算键 key 的 CRC-16 校验和</span></span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">CRC16</span><span class="params">(key)</span> &amp; 16383;	<span class="comment">// 取模，十进制对16384的取余</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>CLUSTER KEYSLOT &lt;key&gt;</code> 命令可以查看一个给定键属于哪个槽，底层实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">CLUSTER_KEYSLOT</span><span class="params">(key)</span>:</span><br><span class="line">	<span class="comment">// 计算槽号</span></span><br><span class="line">	slot = slot_number(key);</span><br><span class="line">	<span class="comment">// 将槽号返回给客户端</span></span><br><span class="line">	reply_client(slot);</span><br></pre></td></tr></table></figure>

<p>判断槽是否由当前节点负责处理：如果 clusterState.slots[i] 不等于 clusterState.myself，那么说明槽 i 并非由当前节点负责，节点会根据 clusterState.slots[i] 指向的 clusterNode 结构所记录的节点 IP 和端口号，向客户端返回 MOVED 错误</p>
<hr>
<h4 id="MOVED"><a href="#MOVED" class="headerlink" title="MOVED"></a>MOVED</h4><p>MOVED 错误的格式为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port＞</span><br></pre></td></tr></table></figure>

<p>参数 slot 为键所在的槽，ip 和 port 是负责处理槽 slot 的节点的 ip 地址和端口号</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MOVED 12345 127.0.0.1:6380 <span class="comment"># 表示槽 12345 正由 IP地址为 127.0.0.1, 端口号为 6380 的节点负责</span></span><br></pre></td></tr></table></figure>

<p>当客户端接收到节点返回的 MOVED 错误时，客户端会根据 MOVED 错误中提供的 IP 地址和端口号，转至负责处理槽 slot 的节点重新发送执行的命令</p>
<ul>
<li><p>一个集群客户端通常会与集群中的多个节点创建套接字连接，节点转向实际上就是换一个套接字来发送命令</p>
</li>
<li><p>如果客户端尚未与转向的节点创建套接字连接，那么客户端会先根据 IP 地址和端口号来连接节点，然后再进行转向</p>
</li>
</ul>
<p>集群模式的 redis-cli 在接收到 MOVED 错误时，并不会打印出 MOVED 错误，而是根据错误<strong>自动进行节点转向</strong>，并打印出转向信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ redis-cli -c -p 6379 	<span class="comment">#集群模式</span></span><br><span class="line">127.0.0.1:6379&gt; SET msg <span class="string">&quot;happy&quot;</span> </span><br><span class="line">-&gt; Redirected to slot [6257] located at 127.0.0.1:6380</span><br><span class="line">OK </span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<p>使用单机（stand alone）模式的 redis-cli 会打印错误，因为单机模式客户端不清楚 MOVED 错误的作用，不会进行自动转向：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ redis-cli -c -p 6379 	<span class="comment">#集群模式</span></span><br><span class="line">127.0.0.1:6379&gt; SET msg <span class="string">&quot;happy&quot;</span> </span><br><span class="line">(error) MOVED 6257 127.0.0.1:6380</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><p>Redis 集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽的键值对也会从源节点被移动到目标节点，该操作是可以在线（online）进行，在重新分片的过程中源节点和目标节点都可以处理命令请求</p>
<p>Redis 的集群管理软件 redis-trib 负责执行重新分片操作，redis-trib 通过向源节点和目标节点发送命令来进行重新分片操作</p>
<ul>
<li>向目标节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code> 命令，准备好从源节点导入属于槽 slot 的键值对</li>
<li>向源节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code> 命令，让源节点准备好将属于槽 slot 的键值对迁移</li>
<li>redis-trib 向源节点发送 <code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code> 命令，获得最多 count 个属于槽 slot 的键值对的键名</li>
<li>对于每个 key，redis-trib 都向源节点发送一个 <code>MIGRATE &lt;target_ip&gt; &lt;target_port&gt; &lt;key_name&gt; 0 &lt;timeout＞</code> 命令，将被选中的键<strong>原子地</strong>从源节点迁移至目标节点</li>
<li>重复上述步骤，直到源节点保存的所有槽 slot 的键值对都被迁移至目标节点为止</li>
<li>redis-trib 向集群中的任意一个节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target _id&gt;</code> 命令，将槽 slot 指派给目标节点，这一指派信息会通过消息传播至整个集群，最终集群中的所有节点都直到槽 slot 已经指派给了目标节点</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E9%9B%86%E7%BE%A4%E9%87%8D%E6%96%B0%E5%88%86%E7%89%87.png"></p>
<p>如果重新分片涉及多个槽，那么 redis-trib 将对每个给定的槽分别执行上面给出的步骤</p>
<hr>
<h4 id="命令原理"><a href="#命令原理" class="headerlink" title="命令原理"></a>命令原理</h4><p>clusterState 结构的 importing_slots_from 数组记录了当前节点正在从其他节点导入的槽，migrating_slots_to 数组记录了当前节点正在迁移至其他节点的槽：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 如果 importing_slots_from[i] 的值不为 NULL，而是指向一个 clusterNode 结构，</span></span><br><span class="line">    <span class="comment">// 那么表示当前节点正在从 clusterNode 所代表的节点导入槽 i</span></span><br><span class="line">    clusterNode *importing_slots_from[<span class="number">16384</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表示当前节点正在将槽 i 迁移至 clusterNode 所代表的节点</span></span><br><span class="line">    clusterNode *migrating_slots_to[<span class="number">16384</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code> 命令：将目标节点 <code>clusterState.importing_slots_from[slot]</code> 的值设置为  source_id 所代表节点的 clusterNode 结构</p>
<p><code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code> 命令：将源节点 <code>clusterState.migrating_slots_to[slot]</code> 的值设置为target_id 所代表节点的 clusterNode 结构</p>
<hr>
<h4 id="ASK-错误"><a href="#ASK-错误" class="headerlink" title="ASK 错误"></a>ASK 错误</h4><p>重新分片期间，源节点向目标节点迁移一个槽的过程中，可能出现被迁移槽的一部分键值对保存在源节点，另一部分保存在目标节点</p>
<p>客户端向源节点发送命令请求，并且命令要处理的数据库键属于被迁移的槽：</p>
<ul>
<li><p>源节点会先在数据库里面查找指定键，如果找到的话，就直接执行客户端发送的命令</p>
</li>
<li><p>未找到会检查 clusterState.migrating_slots_to[slot]，看键 key 所属的槽 slot 是否正在进行迁移</p>
</li>
<li><p>槽 slot 正在迁移则源节点将向客户端返回一个 ASK 错误，指引客户端转向正在导入槽的目标节点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ASK &lt;slot&gt; &lt;ip:port&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接到 ASK 错误的客户端，会根据错误提供的 IP 地址和端口号转向目标节点，首先向目标节点发送一个 ASKING 命令，再重新发送原本想要执行的命令</p>
</li>
</ul>
<p>和 MOVED 错误情况类似，集群模式的 redis-cli 在接到 ASK 错误时不会打印错误进行自动转向；单机模式的 redis-cli 会打印错误</p>
<p>对比 MOVED 错误：</p>
<ul>
<li><p>MOVED 错误代表槽的负责权已经从一个节点转移到了另一个节点，转向是一种持久性的转向</p>
</li>
<li><p>ASK 错误只是两个节点在迁移槽的过程中使用的一种临时措施，ASK 的转向不会对客户端今后发送关于槽 slot 的命令请求产生任何影响，客户端仍然会将槽 slot 的命令请求发送至目前负责处理槽 slot 的节点，除非 ASK 错误再次出现</p>
</li>
</ul>
<hr>
<h4 id="ASKING"><a href="#ASKING" class="headerlink" title="ASKING"></a>ASKING</h4><p>客户端不发送 ASKING 命令，而是直接发送执行的命令，那么客户端发送的命令将被节点拒绝执行，并返回 MOVED 错误</p>
<p>ASKING 命令作用是打开发送该命令的客户端的 REDIS_ASKING 标识，该命令的伪代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">ASKING</span> <span class="params">()</span>:</span><br><span class="line">    <span class="comment">// 打开标识</span></span><br><span class="line">    client.flags |= REDIS_ASKING </span><br><span class="line">    <span class="comment">// 向客户端返回OK回复</span></span><br><span class="line">    reply(<span class="string">&quot;OK&quot;</span>) </span><br></pre></td></tr></table></figure>

<p>当前节点正在导入槽 slot，并且发送命令的客户端带有 REDIS_ASKING 标识，那么节点将破例执行这个关于槽 slot 的命令一次</p>
<p>客户端的 REDIS_ASKING 标识是一次性标识，当节点执行了一个带有 REDIS_ASKING 标识的客户端发送的命令之后，该客户端的 REDIS_ASKING 标识就会被移除</p>
<hr>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><h4 id="节点复制"><a href="#节点复制" class="headerlink" title="节点复制"></a>节点复制</h4><p>Redis 集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CLUSTER REPLICATE &lt;node_id&gt; </span><br></pre></td></tr></table></figure>

<p>向一个节点发送命令可以让接收命令的节点成为 node_id 所指定节点的从节点，并开始对主节点进行复制</p>
<ul>
<li><p>接受命令的节点首先会在的 clusterState.nodes 字典中找到 node_id 所对应节点的 clusterNode 结构，并将自己的节点中的 clusterState.myself.slaveof 指针指向这个结构，记录这个节点正在复制的主节点</p>
</li>
<li><p>节点会修改 clusterState.myself.flags 中的属性，关闭 REDIS_NODE_MASTER 标识，打开 REDIS_NODE_SLAVE 标识</p>
</li>
<li><p>节点会调用复制代码，对主节点进行复制（节点的复制功能和单机 Redis 服务器的使用了相同的代码）</p>
</li>
</ul>
<p>一个节点成为从节点，并开始复制某个主节点这一信息会通过消息发送给集群中的其他节点，最终集群中的所有节点都会知道某个从节点正在复制某个主节点</p>
<p>主节点的 clusterNode 结构的 slaves 属性和 numslaves 属性中记录正在复制这个主节点的从节点名单：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 正在复制这个主节点的从节点数量</span></span><br><span class="line">    <span class="type">int</span> numslaves;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组项指向一个正在复制这个主节点的从节点的clusterNode结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> **<span class="title">slaves</span>;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><p>集群中的每个节点都会定期地向集群中的其他节点发送 PING 消息，来检测对方是否在线，如果接收 PING 的节点没有在规定的时间内返回 PONG 消息，那么发送消息节点就会将接收节点标记为<strong>疑似下线</strong>（probable fail, PFAIL）</p>
<p>集群中的节点会互相发送消息，来<strong>交换集群中各个节点的状态信息</strong>，当一个主节点 A 通过消息得知主节点 B 认为主节点 C 进入了疑似下线状态时，主节点 A 会在 clusterState.nodes 字典中找到主节点 C 所对应的节点，并将主节点 B 的下线报告（failure report）添加到 clusterNode.fail_reports 链表里面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 一个链表，记录了所有其他节点对该节点的下线报告 </span></span><br><span class="line">    <span class="built_in">list</span> *fail_reports;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每个下线报告由一个 clusterNodeFailReport 结构表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNodeFailReport</span> &#123;</span></span><br><span class="line">    <span class="comment">// 报告目标节点巳经下线的节点 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后一次从node节点收到下线报告的时间</span></span><br><span class="line">    <span class="comment">// 程序使用这个时间戳来检查下线报告是否过期，与当前时间相差太久的下线报告会被删除 </span></span><br><span class="line">    <span class="type">mstime_t</span> time; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>集群里<strong>半数以上</strong>负责处理槽的主节点都将某个主节点 X 报告为疑似下线，那么 X 将被标记为<strong>已下线</strong>（FAIL），将 X 标记为已下线的节点会向集群广播一条关于主节点 X 的 FAIL 消息，所有收到消息的节点都会将 X 标记为已下线</p>
<hr>
<h4 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h4><p>当一个从节点发现所属的主节点进入了已下线状态，从节点将开始对下线主节点进行故障转移，执行步骤：</p>
<ul>
<li>下属的从节点通过选举产生一个节点</li>
<li>被选中的从节点会执行 <code>SLAVEOF no one</code> 命令，成为新的主节点</li>
<li>新的主节点会<strong>撤销所有对已下线主节点的槽指派</strong>，并将这些槽全部指派给自己</li>
<li>新的主节点向集群广播一条 PONG 消息，让集群中的其他节点知道当前节点变成了主节点，并且接管了下线节点负责处理的槽</li>
<li>新的主节点开始接收有关的命令请求，故障转移完成</li>
</ul>
<hr>
<h4 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h4><p>集群选举新的主节点的规则：</p>
<ul>
<li>集群的配置纪元是一个自增的计数器，初始值为 0</li>
<li>当集群里某个节点开始一次故障转移，集群的配置纪元就是增加一</li>
<li>每个配置纪元里，集群中每个主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得该主节点的投票</li>
<li>具有投票权的主节点是必须具有正在处理的槽</li>
<li>集群里有 N 个具有投票权的主节点，那么当一个从节点收集到大于等于 <code>N/2+1</code> 张支持票时，从节点就会当选</li>
<li>每个配置纪元里，具有投票权的主节点只能投一次票，所以获得一半以上票的节点只会有一个</li>
</ul>
<p>选举流程：</p>
<ul>
<li>当某个从节点发现正在复制的主节点进入已下线状态时，会向集群广播一条 <code>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</code> 消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票</li>
<li>如果主节点尚未投票给其他从节点，将向要求投票的从节点返回一条 <code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code> 消息，表示这个主节点支持从节点成为新的主节点</li>
<li>如果从节点获取到了半数以上的选票，则会当选新的主节点</li>
<li>如果一个配置纪元里没有从节点能收集到足够多的支待票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点</li>
</ul>
<p>选举新主节点的方法和选举领头 Sentinel 的方法非常相似，两者都是基于 Raft 算法的领头选举（eader election）方法实现的</p>
<hr>
<h3 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h3><h4 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h4><p>集群中的各个节点通过发送和接收消息（message）来进行通信，将发送消息的节点称为发送者（sender），接收消息的节点称为接收者（receiver）</p>
<p>节点发送的消息主要有：</p>
<ul>
<li><p>MEET 消息：当发送者接到客户端发送的 CLUSTER MEET 命令时，会向接收者发送 MEET 消息，请求接收者加入到发送者当前所处的集群里</p>
</li>
<li><p>PING 消息：集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个，然后对这五个节点中最长时间没有发送过 PING 消息的节点发送 PING，以此来<strong>随机检测</strong>被选中的节点是否在线</p>
<p>如果节点 A 最后一次收到节点 B 发送的 PONG 消息的时间，距离当前已经超过了节点 A 的 cluster-node­-timeout 设置时长的一半，那么 A 也会向 B 发送 PING 消息，防止 A 因为长时间没有随机选中 B 发送 PING，而导致对节点 B 的信息更新滞后</p>
</li>
<li><p>PONG 消息：当接收者收到 MEET 消息或者 PING 消息时，为了让发送者确认已经成功接收消息，会向发送者返回一条 PONG；节点也可以通过向集群广播 PONG 消息来让集群中的其他节点立即刷新关于这个节点的认识（从升级为主）</p>
</li>
<li><p>FAIL 消息：当一个主节点 A 判断另一个主节点 B 已经进入 FAIL 状态时，节点 A 会向集群广播一条 B 节点的 FAIL 信息</p>
</li>
<li><p>PUBLISH 消息：当节点接收到一个 PUBLISH 命令时，节点会执行这个命令并向集群广播一条 PUBLISH 消息，接收到 PUBLISH 消息的节点都会执行相同的 PUBLISH 命令</p>
</li>
</ul>
<hr>
<h4 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h4><p>节点发送的所有消息都由一个消息头包裹，消息头除了包含消息正文之外，还记录了消息发送者自身的一些信息</p>
<p>消息头：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterMsg</span> &#123;</span></span><br><span class="line">    <span class="comment">// 消息的长度（包括这个消息头的长度和消息正文的长度）</span></span><br><span class="line">	<span class="type">uint32_t</span> totlen;</span><br><span class="line">	<span class="comment">// 消息的类型</span></span><br><span class="line">	<span class="type">uint16_t</span> type;</span><br><span class="line">    <span class="comment">// 消息正文包含的节点信息数量，只在发送MEET、PING、PONG这三种Gossip协议消息时使用 </span></span><br><span class="line">    <span class="type">uint16_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送者所处的配置纪元</span></span><br><span class="line">    <span class="type">uint64_t</span> currentEpoch;</span><br><span class="line">    <span class="comment">// 如果发送者是一个主节点，那么这里记录的是发送者的配置纪元</span></span><br><span class="line">    <span class="comment">// 如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的配置纪元</span></span><br><span class="line">    <span class="type">uint64_t</span> configEpoch;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送者的名字(ID)</span></span><br><span class="line">	<span class="type">char</span> sender[REDIS CLUSTER NAMELEN];</span><br><span class="line">	<span class="comment">// 发送者目前的槽指派信息</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> myslots[REDIS_CLUSTER_SLOTS/<span class="number">8</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的名字</span></span><br><span class="line">    <span class="comment">// 如果发送者是一个主节点，那么这里记录的是 REDIS_NODE_NULL_NAME，一个 40 宇节长值全为 0 的字节数组</span></span><br><span class="line">    <span class="type">char</span> slaveof[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 发送者的端口号</span></span><br><span class="line">	<span class="type">uint16_t</span> port;</span><br><span class="line">	<span class="comment">// 发送者的标识值</span></span><br><span class="line">    <span class="type">uint16_t</span> flags; </span><br><span class="line">	<span class="comment">//发送者所处集群的状态</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> state;</span><br><span class="line">	<span class="comment">// 消息的正文（或者说， 内容） </span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">clusterMsgData</span> <span class="title">data</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clusterMsg 结构的 currentEpoch、sender、myslots 等属性记录了发送者的节点信息，接收者会根据这些信息在 clusterState.nodes 字典里找到发送者对应的 clusterNode 结构，并对结构进行更新，比如<strong>传播节点的槽指派信息</strong></p>
<p>消息正文：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">clusterMsgData</span> &#123;</span></span><br><span class="line">    <span class="comment">// MEET、PING、PONG 消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">// 每条 MEET、PING、PONG 消息都包含两个 clusterMsgDataGossip 结构</span></span><br><span class="line">        clusterMsgDataGossip gossip[<span class="number">1</span>];</span><br><span class="line">    &#125; ping;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// FAIL 消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">		clusterMsgDataFail about;</span><br><span class="line">    &#125; fail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// PUBLISH 消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    	clusterMsgDataPublish msg;</span><br><span class="line">    &#125; publish;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他消息正文...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a>Gossip</h4><p>Redis 集群中的各个节点通过 Gossip 协议来交换各自关于不同节点的状态信息，其中 Gossip 协议由 MEET、PING、PONG 消息实现，三种消息使用相同的消息正文，所以节点通过消息头的 type 属性来判断消息的具体类型</p>
<p>发送者发送这三种消息时，会从已知节点列表中<strong>随机选出两个节点</strong>（主从都可以），将两个被选中节点信息保存到两个 Gossip 结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterMsgDataGossip</span> &#123;</span></span><br><span class="line">    <span class="comment">// 节点的名字</span></span><br><span class="line">	<span class="type">char</span> nodename[REDIS CLUSTER NAMELEN];</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 最后一次向该节点发送PING消息的时间戳</span></span><br><span class="line">    <span class="type">uint32_t</span> ping_sent;</span><br><span class="line">	<span class="comment">// 最后一次从该节点接收到PONG消息的时间戳</span></span><br><span class="line">    <span class="type">uint32_t</span> pong_received;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 节点的IP地址</span></span><br><span class="line">	<span class="type">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="comment">// 节点的端口号</span></span><br><span class="line">    <span class="type">uint16_t</span> port;</span><br><span class="line">	<span class="comment">// 节点的标识值</span></span><br><span class="line">    <span class="type">uint16_t</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当接收者收到消息时，会访问消息正文中的两个数据结构，来进行相关操作</p>
<ul>
<li>如果被选中节点不存在于接收者的已知节点列表，接收者将根据结构中记录的 IP 地址和端口号，与节点进行握手</li>
<li>如果存在，根据 Gossip 结构记录的信息对节点所对应的 clusterNode 结构进行更新</li>
</ul>
<hr>
<h4 id="FAIL"><a href="#FAIL" class="headerlink" title="FAIL"></a>FAIL</h4><p>在集群的节点数量比较大的情况下，使用 Gossip 协议来传播节点的已下线信息会带来一定延迟，因为 Gossip 协议消息通常需要一段时间才能传播至整个集群，所以通过发送 FAIL消息可以让集群里的所有节点立即知道某个主节点已下线，从而尽快进行其他操作</p>
<p>FAIL 消息的正文由 clusterMsgDataFail 结构表示，该结构只有一个属性，记录了已下线节点的名字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterMsgDataFail</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> nodename[REDIS_CLUSTER_NAMELEN)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为传播下线信息不需要其他属性，所以节省了传播的资源</p>
<hr>
<h4 id="PUBLISH"><a href="#PUBLISH" class="headerlink" title="PUBLISH"></a>PUBLISH</h4><p>当客户端向集群中的某个节点发送命令，接收到 PUBLISH 命令的节点不仅会向 channel 频道发送消息 message，还会向集群广播一条 PUBLISH 消息，所有接收到这条 PUBLISH 消息的节点都会向 channel 频道发送 message 消息，最终集群中所有节点都发了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUBLISH &lt;channel&gt; &lt;message&gt; </span><br></pre></td></tr></table></figure>

<p>PUBLISH 消息的正文由 clusterMsgDataPublish 结构表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterMsgDataPublish</span> &#123;</span></span><br><span class="line">    <span class="comment">// channel参数的长度</span></span><br><span class="line">    <span class="type">uint32_t</span> channel_len;</span><br><span class="line">    <span class="comment">// message参数的长度</span></span><br><span class="line">    <span class="type">uint32_t</span> message_len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义为8字节只是为了对齐其他消息结构，实际的长度由保存的内容决定</span></span><br><span class="line">    <span class="comment">// bulk_data 的 0 至 channel_len-1 字节保存的是channel参数</span></span><br><span class="line">    <span class="comment">// bulk_data的 channel_len 字节至 channel_len + message_len-1 字节保存的则是message参数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> bulk_data[<span class="number">8</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让集群的所有节点执行相同的 PUBLISH 命令，最简单的方法就是向所有节点广播相同的 PUBLISH 命令，这也是 Redis 复制 PUBLISH 命令时所使用的，但是这种做法并不符合 Redis 集群的各<strong>个节点通过发送和接收消息来进行通信</strong>的规则</p>
<hr>
<h3 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a>脑裂问题</h3><p>脑裂指在主从集群中，同时有两个相同的主节点能接收写请求，导致客户端不知道应该往哪个主节点写入数据，导致不同客户端往不同的主节点上写入数据</p>
<ul>
<li>原主节点并没有真的发生故障，由于某些原因无法处理请求（CPU 利用率很高、自身阻塞），无法按时响应心跳请求，被哨兵&#x2F;集群主节点错误的判断为下线</li>
<li>在被判断下线之后，原主库又重新开始处理请求了，哨兵&#x2F;集群主节点还没有完成主从切换，客户端仍然可以和原主库通信，客户端发送的写操作就会在原主库上写入数据，造成脑裂问题</li>
</ul>
<p>数据丢失问题：从库一旦升级为新主库，哨兵就会让原主库执行 slave of 命令，和新主库重新进行全量同步，原主库需要清空本地的数据，加载新主库发送的 RDB 文件，所以原主库在主从切换期间保存的新写数据就丢失了</p>
<p>预防脑裂：在主从集群部署时，合理地配置参数 min-slaves-to-write 和 min-slaves-max-lag</p>
<ul>
<li>假设从库有 K 个，可以将 min-slaves-to-write 设置为 K&#x2F;2+1（如果 K 等于 1，就设为 1）</li>
<li>将 min-slaves-max-lag 设置为十几秒（例如 10～20s）</li>
</ul>
<hr>
<h3 id="结构搭建"><a href="#结构搭建" class="headerlink" title="结构搭建"></a>结构搭建</h3><p>整体框架：</p>
<ul>
<li>配置服务器（3 主 3 从）</li>
<li>建立通信（Meet）</li>
<li>分槽（Slot）</li>
<li>搭建主从（master-slave）</li>
</ul>
<p>创建集群 conf 配置文件：</p>
<ul>
<li><p>redis-6501.conf</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">port 6501</span><br><span class="line"><span class="built_in">dir</span> <span class="string">&quot;/redis/data&quot;</span></span><br><span class="line">dbfilename <span class="string">&quot;dump-6501.rdb&quot;</span></span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line">cluster-config-file <span class="string">&quot;cluster-6501.conf&quot;</span></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"></span><br><span class="line"><span class="comment">#其他配置文件参照上面的修改端口即可，内容完全一样</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端启动：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server config_file_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端启动：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli -p 6504 -c</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>cluster 配置：</strong></p>
<ul>
<li><p>是否启用 cluster，加入 cluster 节点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster-enabled <span class="built_in">yes</span>|no</span><br></pre></td></tr></table></figure>
</li>
<li><p>cluster 配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster-config-file filename</span><br></pre></td></tr></table></figure>
</li>
<li><p>节点服务响应超时时间，用于判定该节点是否下线或切换为从节点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster-node-timeout milliseconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>master 连接的 slave 最小数量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster-migration-barrier min_slave_number</span><br></pre></td></tr></table></figure></li>
</ul>
<p>客户端启动命令：</p>
<p><strong>cluster 节点操作命令（客户端命令）：</strong></p>
<ul>
<li><p>查看集群节点信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改 slave 指向新的 master</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster replicate master-id</span><br></pre></td></tr></table></figure>
</li>
<li><p>发现一个新节点，新增 master</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster meet ip:port</span><br></pre></td></tr></table></figure>
</li>
<li><p>忽略一个没有 solt 的节点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster forget server_id</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动故障转移</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster failover</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>集群操作命令（Linux）：</strong></p>
<ul>
<li><p>创建集群</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli –-cluster create masterhost1:masterport1 masterhost2:masterport2  masterhost3:masterport3 [masterhostn:masterportn …] slavehost1:slaveport1  slavehost2:slaveport2 slavehost3:slaveport3 -–cluster-replicas n</span><br></pre></td></tr></table></figure>

<p>注意：master 与 slave 的数量要匹配，一个 master 对应 n 个 slave，由最后的参数 n 决定。master 与 slave 的匹配顺序为第一个 master 与前 n 个 slave 分为一组，形成主从结构</p>
</li>
<li><p>添加 master 到当前集群中，连接时可以指定任意现有节点地址与端口</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node new-master-host:new-master-port now-host:now-port</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加 slave</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node new-slave-host:new-slave-port master-host:master-port --cluster-slave --cluster-master-id masterid</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除节点，如果删除的节点是 master，必须保障其中没有槽 slot</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster del-node del-slave-host:del-slave-port del-slave-id</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新分槽，分槽是从具有槽的 master 中划分一部分给其他 master，过程中不创建新的槽</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster reshard new-master-host:new-master:port --cluster-from src-  master-id1, src-master-id2, src-master-idn --cluster-to target-master-id --  cluster-slots slots</span><br></pre></td></tr></table></figure>

<p>注意：将需要参与分槽的所有 masterid 不分先后顺序添加到参数中，使用 <code>,</code> 分隔，指定目标得到的槽的数量，所有的槽将平均从每个来源的 master 处获取</p>
</li>
<li><p>重新分配槽，从具有槽的 master 中分配指定数量的槽到另一个 master 中，常用于清空指定 master 中的槽</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster reshard src-master-host:src-master-port --cluster-from src-  master-id --cluster-to target-master-id --cluster-slots slots --cluster-yes</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><h4 id="基本指令-1"><a href="#基本指令-1" class="headerlink" title="基本指令"></a>基本指令</h4><p>Redis 发布订阅（pub&#x2F;sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息</p>
<p>Redis 客户端可以订阅任意数量的频道，每当有客户端向被订阅的频道发送消息（message）时，频道的<strong>所有订阅者都会收到消息</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85.png"></p>
<p>操作过程：</p>
<ul>
<li><p>打开一个客户端订阅 channel1：<code>SUBSCRIBE channel1</code></p>
</li>
<li><p>打开另一个客户端，给 channel1 发布消息 hello：<code>PUBLISH channel1 hello</code></p>
</li>
<li><p>第一个客户端可以看到发送的消息</p>
</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-发布订阅指令操作.png" style="zoom:67%;">

<p>客户端还可以通过 PSUBSCRIBE 命令订阅一个或多个模式，每当有其他客户端向某个频道发送消息时，消息不仅会被发送给这个频道的所有订阅者，还会被<strong>发送给所有与这个频道相匹配的模式的订阅者</strong>，比如 <code>PSUBSCRIBE channel*</code> 订阅模式，与 channel1 匹配</p>
<p>注意：发布的消息没有持久化，所以订阅的客户端只能收到订阅后发布的消息</p>
<hr>
<h4 id="频道操作"><a href="#频道操作" class="headerlink" title="频道操作"></a>频道操作</h4><p>Redis 将所有频道的订阅关系都保存在服务器状态的 pubsub_channels 字典里，键是某个被订阅的频道，值是一个记录所有订阅这个频道的客户端链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	<span class="comment">// 保存所有频道的订阅关系，</span></span><br><span class="line">	dict *pubsub_channels;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端执行 SUBSCRIBE 命令订阅某个或某些频道，服务器会将客户端与频道进行关联：</p>
<ul>
<li>频道已经存在，直接将客户端添加到链表末尾</li>
<li>频道还未有任何订阅者，在字典中为频道创建一个键值对，再将客户端添加到链表</li>
</ul>
<p>UNSUBSCRIBE 命令用来退订某个频道，服务器将从 pubsub_channels 中解除客户端与被退订频道之间的关联</p>
<hr>
<h4 id="模式操作"><a href="#模式操作" class="headerlink" title="模式操作"></a>模式操作</h4><p>Redis 服务器将所有模式的订阅关系都保存在服务器状态的 pubsub_patterns 属性里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	<span class="comment">// 保存所有模式订阅关系，链表中每个节点是一个 pubsubPattern</span></span><br><span class="line">	<span class="built_in">list</span> *pubsub_patterns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span> &#123;</span></span><br><span class="line">    <span class="comment">// 订阅的客户端</span></span><br><span class="line">    redisClient *client;</span><br><span class="line">	<span class="comment">// 被订阅的模式，比如  channel*</span></span><br><span class="line">    robj *pattern; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端执行 PSUBSCRIBE 命令订阅某个模式，服务器会新建一个 pubsubPattern 结构并赋值，放入 pubsub_patterns 链表结尾</p>
<p>模式的退订命令 PUNSUBSCRIBE 是订阅命令的反操作，服务器在 pubsub_patterns 链表中查找并删除对应的结构</p>
<hr>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>Redis 客户端执行 <code>PUBLISH &lt;channel&gt; &lt;message&gt;</code> 命令将消息 message发送给频道 channel，服务器会执行：</p>
<ul>
<li>在 pubsub_channels 字典里找到频道 channel 的订阅者名单，将消息 message 发送给所有订阅者</li>
<li>遍历整个 pubsub_patterns 链表，查找与 channel 频道相<strong>匹配的模式</strong>，并将消息发送给所有订阅了这些模式的客户端</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果频道和模式相匹配</span></span><br><span class="line"><span class="keyword">if</span> <span class="title function_">match</span><span class="params">(channel, pubsubPattern.pattern)</span> &#123;</span><br><span class="line">    <span class="comment">// 将消息发送给订阅该模式的客户端</span></span><br><span class="line">    send_message(pubsubPattern.client, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h4><p>PUBSUB 命令用来查看频道或者模式的相关信息</p>
<p><code>PUBSUB CHANNELS [pattern]</code> 返回服务器当前被订阅的频道，其中 pattern 参数是可选的</p>
<ul>
<li>如果不给定 pattern  参数，那么命令返回服务器当前被订阅的所有频道</li>
<li>如果给定 pattern 参数，那么命令返回服务器当前被订阅的频道中与 pattern 模式相匹配的频道</li>
</ul>
<p><code>PUBSUB NUMSUB [channel-1 channel-2 ... channel-n]</code>  命令接受任意多个频道作为输入参数，并返回这些频道的订阅者数量</p>
<p><code>PUBSUB NUMPAT</code> 命令用于返回服务器当前被订阅模式的数量</p>
<hr>
<h3 id="ACL-指令"><a href="#ACL-指令" class="headerlink" title="ACL 指令"></a>ACL 指令</h3><p>Redis ACL 是 Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-ACL%E6%8C%87%E4%BB%A4.png"></p>
<ul>
<li><p>acl cat：查看添加权限指令类别</p>
</li>
<li><p>acl whoami：查看当前用户</p>
</li>
<li><p>acl setuser username on &gt;password ~cached:* +get：设置有用户名、密码、ACL 权限（只能 get）</p>
</li>
</ul>
<hr>
<h3 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h3><p>MONITOR 命令，可以将客户端变为一个监视器，实时地接收并打印出服务器当前处理的命令请求的相关信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现原理</span></span><br><span class="line">def <span class="title function_">MONITOR</span><span class="params">()</span>:</span><br><span class="line">	<span class="comment">// 打开客户端的监视器标志</span></span><br><span class="line">	client.flags |= REDIS_MONITOR</span><br><span class="line">        </span><br><span class="line">  	<span class="comment">// 将客户端添加到服务器状态的 redisServer.monitors链表的末尾</span></span><br><span class="line">   	server.monitors.append(client)</span><br><span class="line">  	<span class="comment">// 向客户端返回 ok</span></span><br><span class="line">	send_reply(<span class="string">&quot;OK&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>服务器每次处理命令请求都会调用 replicationFeedMonitors 函数，函数将被处理的命令请求的相关信息<strong>发送给各个监视器</strong></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-监视器.png" style="zoom:50%;">

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; MONITOR </span><br><span class="line">OK </span><br><span class="line">1378822099.421623 [0 127.0.0.1:56604] <span class="string">&quot;PING&quot;</span> </span><br><span class="line">1378822105.089572 [0 127.0.0.1:56604] <span class="string">&quot;SET&quot;</span> <span class="string">&quot;msg&quot;</span> <span class="string">&quot;hello world&quot;</span> </span><br><span class="line">1378822109.036925 [0 127.0.0.1:56604] <span class="string">&quot;SET&quot;</span> <span class="string">&quot;number&quot;</span> <span class="string">&quot;123&quot;</span> </span><br><span class="line">1378822140.649496 (0 127.0.0.1:56604] <span class="string">&quot;SADD&quot;</span> <span class="string">&quot;fruits&quot;</span> <span class="string">&quot;Apple&quot;</span> <span class="string">&quot;Banana&quot;</span> <span class="string">&quot;Cherry&quot;</span> </span><br><span class="line">1378822154.117160 [0 127.0.0.1:56604] <span class="string">&quot;EXPIRE&quot;</span> <span class="string">&quot;msg&quot;</span> <span class="string">&quot;10086&quot;</span> </span><br><span class="line">1378822257.329412 [0 127.0.0.1:56604] <span class="string">&quot;KEYS&quot;</span> <span class="string">&quot;*&quot;</span> </span><br><span class="line">1378822258.690131 [0 127.0.0.1:56604] <span class="string">&quot;DBSIZE&quot;</span> </span><br></pre></td></tr></table></figure>





<hr>
<h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>Redis 的管道 Pipeline 机制可以一次处理多条指令</p>
<ul>
<li>Pipeline 中的多条命令非原子性，因为在向管道内添加命令时，其他客户端的发送的命令仍然在执行</li>
<li>原生批命令（mset 等）是服务端实现，而 pipeline 需要服务端与客户端共同完成</li>
</ul>
<p>使用 Pipeline 封装的命令数量不能太多，数据量过大会增加客户端的等待时间，造成网络阻塞，Jedis 中的 Pipeline 使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建管道</span></span><br><span class="line"><span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 放入命令到管道</span></span><br><span class="line">    pipeline.set(<span class="string">&quot;key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 每放入1000条命令，批量执行</span></span><br><span class="line">        pipeline.sync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集群下模式下，批处理命令的多个 key 必须落在一个插槽中，否则就会导致执行失败，N 条批处理命令的优化方式：</p>
<ul>
<li>串行命令：for 循环遍历，依次执行每个命令</li>
<li>串行 slot：在客户端计算每个 key 的 slot，将 slot 一致的分为一组，每组都利用 Pipeline 批处理，串行执行各组命令</li>
<li>并行 slot：在客户端计算每个 key 的 slot，将 slot 一致的分为一组，每组都利用 Pipeline 批处理，<strong>并行执行各组命令</strong></li>
<li>hash_tag：将所有 key 设置相同的 hash_tag，则所有 key 的 slot 一定相同</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>耗时</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>串行命令</td>
<td>N 次网络耗时 + N 次命令耗时</td>
<td>实现简单</td>
<td>耗时久</td>
</tr>
<tr>
<td>串行 slot</td>
<td>m 次网络耗时 + N 次命令耗时，m &#x3D; key 的 slot 个数</td>
<td>耗时较短</td>
<td>实现稍复杂</td>
</tr>
<tr>
<td>并行 slot</td>
<td>1 次网络耗时 + N 次命令耗时</td>
<td>耗时非常短</td>
<td>实现复杂</td>
</tr>
<tr>
<td>hash_tag</td>
<td>1 次网络耗时 + N 次命令耗时</td>
<td>耗时非常短、实现简单</td>
<td>容易出现<strong>数据倾斜</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="缓存方案"><a href="#缓存方案" class="headerlink" title="缓存方案"></a>缓存方案</h3><h4 id="缓存模式"><a href="#缓存模式" class="headerlink" title="缓存模式"></a>缓存模式</h4><h5 id="旁路缓存"><a href="#旁路缓存" class="headerlink" title="旁路缓存"></a>旁路缓存</h5><p>缓存本质：弥补 CPU 的高算力和 IO 的慢读写之间巨大的鸿沟</p>
<p>旁路缓存模式 Cache Aside Pattern 是平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景</p>
<p>Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准</p>
<ul>
<li>写操作：先更新 DB，然后直接删除 cache</li>
<li>读操作：从 cache 中读取数据，读取到就直接返回；读取不到就从 DB 中读取数据返回，并放到 cache</li>
</ul>
<p>时序导致的不一致问题：</p>
<ul>
<li><p>在写数据的过程中，不能先删除 cache 再更新 DB，因为会造成缓存的不一致。比如请求 1 先写数据 A，请求 2 随后读数据 A，当请求 1 删除 cache 后，请求 2 直接读取了 DB，此时请求 1 还没写入 DB（延迟双删）</p>
</li>
<li><p>在写数据的过程中，先更新 DB 再删除 cache 也会出现问题，但是概率很小，因为缓存的写入速度非常快</p>
</li>
</ul>
<p>旁路缓存的缺点：</p>
<ul>
<li>首次请求数据一定不在 cache 的问题，一般采用缓存预热的方法，将热点数据可以提前放入 cache 中</li>
<li>写操作比较频繁的话导致 cache 中的数据会被频繁被删除，影响缓存命中率</li>
</ul>
<p><strong>删除缓存而不是更新缓存的原因</strong>：每次更新数据库都更新缓存，造成无效写操作较多（懒惰加载，需要的时候再放入缓存）</p>
<hr>
<h5 id="读写穿透"><a href="#读写穿透" class="headerlink" title="读写穿透"></a>读写穿透</h5><p>读写穿透模式 Read&#x2F;Write Through Pattern：服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中，cache 负责将此数据同步写入 DB，从而减轻了应用程序的职责</p>
<ul>
<li><p>写操作：先查 cache，cache 中不存在，直接更新 DB；cache 中存在则先更新 cache，然后 cache 服务更新 DB（同步更新 cache 和 DB）</p>
</li>
<li><p>读操作：从 cache 中读取数据，读取到就直接返回 ；读取不到先从 DB 加载，写入到 cache 后返回响应</p>
<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，对客户端是透明的</p>
</li>
</ul>
<p>Read-Through Pattern 也存在首次不命中的问题，采用缓存预热解决</p>
<hr>
<h5 id="异步缓存"><a href="#异步缓存" class="headerlink" title="异步缓存"></a>异步缓存</h5><p>异步缓存写入 Write Behind Pattern 由 cache 服务来负责 cache 和 DB 的读写，对比读写穿透不同的是 Write Behind Caching 是只更新缓存，不直接更新 DB，改为<strong>异步批量</strong>的方式来更新 DB，可以减小写的成本</p>
<p>缺点：这种模式对数据一致性没有高要求，可能出现 cache 还没异步更新 DB，服务就挂掉了</p>
<p>应用：</p>
<ul>
<li><p>DB 的写性能非常高，适合一些数据经常变化又对数据一致性要求不高的场景，比如浏览量、点赞量</p>
</li>
<li><p>MySQL 的 InnoDB Buffer Pool 机制用到了这种策略</p>
</li>
</ul>
<hr>
<h4 id="缓存一致"><a href="#缓存一致" class="headerlink" title="缓存一致"></a>缓存一致</h4><p>使用缓存代表不需要强一致性，只需要最终一致性</p>
<p>缓存不一致的方法：</p>
<ul>
<li><p>数据库和缓存数据强一致场景：</p>
<ul>
<li><p>同步双写：更新 DB 时同样更新 cache，保证在一个事务中，通过加锁来保证更新 cache 时不存在线程安全问题</p>
</li>
<li><p>延迟双删：先淘汰缓存再写数据库，休眠 1 秒再次淘汰缓存，可以将 1 秒内造成的缓存脏数据再次删除</p>
</li>
<li><p>异步通知：</p>
<ul>
<li>基于 MQ 的异步通知：对数据的修改后，代码需要发送一条消息到 MQ 中，缓存服务监听 MQ 消息</li>
<li>Canal 订阅 MySQL binlog 的变更上报给 Kafka，系统监听 Kafka 消息触发缓存失效，或者直接将变更发送到处理服务，<strong>没有任何代码侵入</strong></li>
</ul>
<p>低耦合，可以同时通知多个缓存服务，但是时效性一般，可能存在中间不一致状态</p>
</li>
</ul>
</li>
<li><p>低一致性场景：</p>
<ul>
<li>更新 DB 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样就可以保证即使数据不一致影响也比较小</li>
<li>使用 Redis 自带的内存淘汰机制</li>
</ul>
</li>
</ul>
<hr>
<h4 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h4><h5 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h5><p>场景：宕机，服务器启动后迅速宕机</p>
<p>问题排查：</p>
<ol>
<li><p>请求数量较高，大量的请求过来之后都需要去从缓存中获取数据，但是缓存中又没有，此时从数据库中查找数据然后将数据再存入缓存，造成了短期内对 redis 的高强度操作从而导致问题</p>
</li>
<li><p>主从之间数据吞吐量较大，数据同步操作频度较高</p>
</li>
</ol>
<p>解决方案：</p>
<ul>
<li><p>前置准备工作：</p>
<ol>
<li><p>日常例行统计数据访问记录，统计访问频度较高的热点数据</p>
</li>
<li><p>利用 LRU 数据删除策略，构建数据留存队列例如：storm 与 kafka 配合</p>
</li>
</ol>
</li>
<li><p>准备工作：</p>
<ol>
<li><p>将统计结果中的数据分类，根据级别，redis 优先加载级别较高的热点数据</p>
</li>
<li><p>利用分布式多服务器同时进行数据读取，提速数据加载过程</p>
</li>
<li><p>热点数据主从同时预热</p>
</li>
</ol>
</li>
<li><p>实施：</p>
<ol start="4">
<li><p>使用脚本程序固定触发数据预热过程</p>
</li>
<li><p>如果条件允许，使用了 CDN（内容分发网络），效果会更好</p>
</li>
</ol>
</li>
</ul>
<p>总的来说：缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据</p>
<hr>
<h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><p>场景：数据库服务器崩溃，一连串的问题会随之而来</p>
<p>问题排查：在一个较短的时间内，<strong>缓存中较多的 key 集中过期</strong>，此周期内请求访问过期的数据 Redis 未命中，Redis 向数据库获取数据，数据库同时收到大量的请求无法及时处理。</p>
<p>解决方案：</p>
<ol>
<li>加锁，慎用</li>
<li>设置热点数据永远不过期，如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中</li>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生</li>
<li>构建<strong>多级缓存</strong>架构，Nginx 缓存 + Redis 缓存 + ehcache 缓存</li>
<li>灾难预警机制，监控 Redis 服务器性能指标，CPU 使用率、内存容量、平均响应时间、线程数</li>
<li><strong>限流、降级</strong>：短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li>
</ol>
<p>总的来说：缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现（约 40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p>
<hr>
<h5 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h5><p>缓存击穿也叫热点 Key 问题</p>
<ol>
<li><p><strong>Redis 中某个 key 过期，该 key 访问量巨大</strong></p>
</li>
<li><p>多个数据请求从服务器直接压到 Redis 后，均未命中</p>
</li>
<li><p>Redis 在短时间内发起了大量对数据库中同一数据的访问</p>
</li>
</ol>
<p>解决方案：</p>
<ol>
<li><p>预先设定：以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息 key 的过期时长 注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</p>
</li>
<li><p>现场调整：监控访问量，对自然流量激增的数据<strong>延长过期时间或设置为永久性 key</strong></p>
</li>
<li><p>后台刷新数据：启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</p>
</li>
<li><p><strong>二级缓存</strong>：设置不同的失效时间，保障不会被同时淘汰就行</p>
</li>
<li><p>加锁：分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重</p>
</li>
</ol>
<p>总的来说：缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中 Redis 后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个 key 的过期监控难度较高，配合雪崩处理策略即可</p>
<hr>
<h5 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h5><p>场景：系统平稳运行过程中，应用服务器流量随时间增量较大，Redis 服务器命中率随时间逐步降低，Redis 内存平稳，内存无压力，Redis 服务器 CPU 占用激增，数据库服务器压力激增，数据库崩溃</p>
<p>问题排查：</p>
<ol>
<li><p>Redis 中大面积出现未命中</p>
</li>
<li><p>出现非正常 URL 访问</p>
</li>
</ol>
<p>问题分析：</p>
<ul>
<li>访问了不存在的数据，跳过了 Redis 缓存，数据库页查询不到对应数据</li>
<li>Redis 获取到 null 数据未进行持久化，直接返回</li>
<li>出现黑客攻击服务器</li>
</ul>
<p>解决方案：</p>
<ol>
<li><p>缓存 null：对查询结果为 null 的数据进行缓存，设定短时限，例如 30-60 秒，最高 5 分钟</p>
</li>
<li><p>白名单策略：提前预热各种分类<strong>数据 id 对应的 bitmaps</strong>，id 作为 bitmaps 的 offset，相当于设置了数据白名单。当加载正常数据时放行，加载异常数据时直接拦截（效率偏低），也可以使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）</p>
</li>
<li><p>实时监控：实时监控 Redis 命中率（业务正常范围时，通常会有一个波动值）与 null 数据的占比</p>
<ul>
<li>非活动时段波动：通常检测 3-5 倍，超过 5 倍纳入重点排查对象</li>
<li>活动时段波动：通常检测10-50 倍，超过 50 倍纳入重点排查对象</li>
</ul>
<p>根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控</p>
</li>
<li><p>key 加密：临时启动防灾业务 key，对 key 进行业务层传输加密服务，设定校验程序，过来的 key 校验；例如每天随机分配 60 个加密串，挑选 2 到 3 个，混淆到页面数据 id 中，发现访问 key 不满足规则，驳回数据访问</p>
</li>
</ol>
<p>总的来说：缓存击穿是指访问了不存在的数据，跳过了合法数据的 Redis 数据缓存阶段，<strong>每次访问数据库</strong>，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除</p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV15y4y1r7X3">https://www.bilibili.com/video/BV15y4y1r7X3</a></p>
<hr>
<h3 id="Key-设计"><a href="#Key-设计" class="headerlink" title="Key 设计"></a>Key 设计</h3><p>大 Key：通常以 Key 的大小和 Key 中成员的数量来综合判定，引发的问题：</p>
<ul>
<li>客户端执行命令的时长变慢</li>
<li>Redis 内存达到 maxmemory 定义的上限引发操作阻塞或重要的 Key 被逐出，甚至引发内存溢出（OOM）</li>
<li>集群架构下，某个数据分片的内存使用率远超其他数据分片，使<strong>数据分片的内存资源不均衡</strong></li>
<li>对大 Key 执行读请求，会使 Redis 实例的带宽使用率被占满，导致自身服务变慢，同时易波及相关的服务</li>
<li>对大 Key 执行删除操作，会造成主库较长时间的阻塞，进而可能引发同步中断或主从切换</li>
</ul>
<p>热 Key：通常以其接收到的 Key 被请求频率来判定，引发的问题：</p>
<ul>
<li>占用大量的 CPU 资源，影响其他请求并导致整体性能降低</li>
<li>分布式集群架构下，产生<strong>访问倾斜</strong>，即某个数据分片被大量访问，而其他数据分片处于空闲状态，可能引起该数据分片的连接数被耗尽，新的连接建立请求被拒绝等问题</li>
<li>在抢购或秒杀场景下，可能因商品对应库存 Key 的请求量过大，超出 Redis 处理能力造成超卖</li>
<li>热 Key 的请求压力数量超出 Redis 的承受能力易造成缓存击穿，即大量请求将被直接指向后端的存储层，导致存储访问量激增甚至宕机，从而影响其他业务</li>
</ul>
<p>参考文档：<a href="https://help.aliyun.com/document_detail/353223.html">https://help.aliyun.com/document_detail/353223.html</a></p>
<hr>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p>Redis 中的监控指标如下：</p>
<ul>
<li><p>性能指标：Performance</p>
<p>响应请求的平均时间：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">latency</span><br></pre></td></tr></table></figure>

<p>平均每秒处理请求总数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">instantaneous_ops_per_sec</span><br></pre></td></tr></table></figure>

<p>缓存查询命中率（通过查询总次数与查询得到非nil数据总次数计算而来）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hit_rate(calculated)</span><br></pre></td></tr></table></figure>
</li>
<li><p>内存指标：Memory</p>
<p>当前内存使用量：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">used_memory</span><br></pre></td></tr></table></figure>

<p>内存碎片率（关系到是否进行碎片整理）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mem_fragmentation_ratio</span><br></pre></td></tr></table></figure>

<p>为避免内存溢出删除的key的总数量：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">evicted_keys</span><br></pre></td></tr></table></figure>

<p>基于阻塞操作（BLPOP等）影响的客户端数量：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">blocked_clients</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本活动指标：Basic_activity</p>
<p>当前客户端连接总数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">connected_clients</span><br></pre></td></tr></table></figure>

<p>当前连接 slave 总数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">connected_slaves</span><br></pre></td></tr></table></figure>

<p>最后一次主从信息交换距现在的秒：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">master_last_io_seconds_ago</span><br></pre></td></tr></table></figure>

<p>key 的总数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">keyspace</span><br></pre></td></tr></table></figure>
</li>
<li><p>持久性指标：Persistence</p>
<p>当前服务器其最后一次 RDB 持久化的时间：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rdb_last_save_time</span><br></pre></td></tr></table></figure>

<p>当前服务器最后一次 RDB 持久化后数据变化总量：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rdb_changes_since_last_save</span><br></pre></td></tr></table></figure>
</li>
<li><p>错误指标：Error</p>
<p>被拒绝连接的客户端总数（基于达到最大连接值的因素）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rejected_connections</span><br></pre></td></tr></table></figure>

<p>key未命中的总次数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">keyspace_misses</span><br></pre></td></tr></table></figure>

<p>主从断开的秒数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">master_link_down_since_seconds</span><br></pre></td></tr></table></figure></li>
</ul>
<p>要对 Redis 的相关指标进行监控，我们可以采用一些用具：</p>
<ul>
<li>CloudInsight Redis</li>
<li>Prometheus</li>
<li>Redis-stat</li>
<li>Redis-faina</li>
<li>RedisLive</li>
<li>zabbix</li>
</ul>
<p>命令工具：</p>
<ul>
<li><p>benchmark</p>
<p>测试当前服务器的并发性能：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-benchmark [-h ] [-p ] [-c ] [-n &lt;requests]&gt; [-k ]</span><br></pre></td></tr></table></figure>

<p>范例：100 个连接，5000 次请求对应的性能</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-benchmark -c 100 -n 5000</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-redis-benchmark%E6%8C%87%E4%BB%A4.png"></p>
</li>
<li><p>redis-cli</p>
<p>monitor：启动服务器调试信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">monitor</span><br></pre></td></tr></table></figure>

<p>slowlog：慢日志</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slowlog [operator]    <span class="comment">#获取慢查询日志</span></span><br></pre></td></tr></table></figure>

<ul>
<li>get ：获取慢查询日志信息</li>
<li>len ：获取慢查询日志条目数</li>
<li>reset ：重置慢查询日志</li>
</ul>
<p>相关配置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slowlog-log-slower-than 1000 <span class="comment">#设置慢查询的时间下线，单位：微妙</span></span><br><span class="line">slowlog-max-len 100	<span class="comment">#设置慢查询命令对应的日志显示长度，单位：命令数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>JDBC（Java DataBase Connectivity，Java 数据库连接）是一种用于执行 SQL 语句的 Java API，可以为多种关系型数据库提供统一访问，是由一组用 Java 语言编写的类和接口组成的。</p>
<p>JDBC 是 Java 官方提供的一套规范（接口），用于帮助开发人员快速实现不同关系型数据库的连接</p>
<hr>
<h3 id="功能类"><a href="#功能类" class="headerlink" title="功能类"></a>功能类</h3><h4 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h4><p>DriverManager：驱动管理对象</p>
<ul>
<li><p>注册驱动：</p>
<ul>
<li><p>注册给定的驱动：<code>public static void registerDriver(Driver driver)</code></p>
</li>
<li><p>代码实现语法：<code>Class.forName(&quot;com.mysql.jdbc.Driver)</code></p>
</li>
<li><p>com.mysql.jdbc.Driver 中存在静态代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不需要通过 DriverManager 调用静态方法 registerDriver，因为 Driver 类被使用，则自动执行静态代码块完成注册驱动</p>
</li>
<li><p>jar 包中 META-INF 目录下存在一个 java.sql.Driver 配置文件，文件中指定了 com.mysql.jdbc.Driver</p>
</li>
</ul>
</li>
<li><p>获取数据库连接并返回连接对象：</p>
<p>方法：<code>public static Connection getConnection(String url, String user, String password)</code></p>
<ul>
<li>url：指定连接的路径，语法为 <code>jdbc:mysql://ip地址(域名):端口号/数据库名称</code></li>
<li>user：用户名</li>
<li>password：密码</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>Connection：数据库连接对象</p>
<ul>
<li>获取执行者对象<ul>
<li>获取普通执行者对象：<code>Statement createStatement()</code></li>
<li>获取预编译执行者对象：<code>PreparedStatement prepareStatement(String sql)</code></li>
</ul>
</li>
<li>管理事务<ul>
<li>开启事务：<code>setAutoCommit(boolean autoCommit)</code>，false 开启事务，true 自动提交模式（默认）</li>
<li>提交事务：<code>void commit()</code></li>
<li>回滚事务：<code>void rollback()</code></li>
</ul>
</li>
<li>释放资源<ul>
<li>释放此 Connection 对象的数据库和 JDBC 资源：<code>void close()</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h4><p>Statement：执行 sql 语句的对象</p>
<ul>
<li>执行 DML 语句：<code>int executeUpdate(String sql)</code><ul>
<li>返回值 int：返回影响的行数</li>
<li>参数 sql：可以执行 insert、update、delete 语句</li>
</ul>
</li>
<li>执行 DQL 语句：<code>ResultSet executeQuery(String sql)</code><ul>
<li>返回值 ResultSet：封装查询的结果</li>
<li>参数 sql：可以执行 select 语句</li>
</ul>
</li>
<li>释放资源<ul>
<li>释放此 Statement 对象的数据库和 JDBC 资源：<code>void close()</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h4><p>ResultSet：结果集对象，ResultSet 对象维护了一个游标，指向当前的数据行，初始在第一行</p>
<ul>
<li>判断结果集中是否有数据：<code>boolean next()</code><ul>
<li>有数据返回 true，并将索引<strong>向下移动一行</strong></li>
<li>没有数据返回 false</li>
</ul>
</li>
<li>获取结果集中<strong>当前行</strong>的数据：<code>XXX getXxx(&quot;列名&quot;)</code><ul>
<li>XXX 代表数据类型（要获取某列数据，这一列的数据类型）</li>
<li>例如：String getString(“name”);   int getInt(“age”);</li>
</ul>
</li>
<li>释放资源<ul>
<li>释放 ResultSet 对象的数据库和 JDBC 资源：<code>void close()</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>数据准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建db14数据库</span><br><span class="line">CREATE DATABASE db14;</span><br><span class="line"></span><br><span class="line">-- 使用db14数据库</span><br><span class="line">USE db14;</span><br><span class="line"></span><br><span class="line">-- 创建student表</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">	sid INT PRIMARY KEY AUTO_INCREMENT,	-- 学生id</span><br><span class="line">	NAME VARCHAR(20),					-- 学生姓名</span><br><span class="line">	age INT,							-- 学生年龄</span><br><span class="line">	birthday DATE,						-- 学生生日</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO student VALUES (NULL,&#x27;张三&#x27;,23,&#x27;1999-09-23&#x27;),(NULL,&#x27;李四&#x27;,24,&#x27;1998-08-10&#x27;),</span><br><span class="line">(NULL,&#x27;王五&#x27;,25,&#x27;1996-06-06&#x27;),(NULL,&#x27;赵六&#x27;,26,&#x27;1994-10-20&#x27;);</span><br></pre></td></tr></table></figure>

<p>JDBC 连接代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.导入jar包</span></span><br><span class="line">        <span class="comment">//2.注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://192.168.2.184:3306/db2&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取执行者对象</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stat</span> <span class="operator">=</span> con.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.执行sql语句，并且接收结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user&quot;</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stat.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.处理结果</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            System.out.println(rs.getInt(<span class="string">&quot;id&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.释放资源</span></span><br><span class="line">        con.close();</span><br><span class="line">        stat.close();</span><br><span class="line">        con.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<hr>
<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul>
<li><p>配置文件（在 src 下创建 config.properties）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://192.168.2.184:3306/db14</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtils</span> &#123;</span><br><span class="line">    <span class="comment">//1.私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">JDBCUtils</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明配置信息变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driverClass;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection con;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.静态代码块中实现加载配置文件和注册驱动</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//通过类加载器返回配置文件的字节流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> JDBCUtils.class.getClassLoader().</span><br><span class="line">                	getResourceAsStream(<span class="string">&quot;config.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建Properties集合，加载流对象的信息</span></span><br><span class="line">            <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            prop.load(is);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取信息为变量赋值</span></span><br><span class="line">            driverClass = prop.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line">            url = prop.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            username = prop.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">            password = prop.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//注册驱动</span></span><br><span class="line">            Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.获取数据库连接的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con = DriverManager.getConnection(url,username,password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.释放资源的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection con, Statement stat, ResultSet rs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(con != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stat != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stat.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//方法重载，可能没有返回值对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection con, Statement stat)</span> &#123;</span><br><span class="line">        close(con,stat,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p>从数据库读取数据并封装成 Student 对象，需要：</p>
<ul>
<li><p>Student 类成员变量对应表中的列</p>
</li>
<li><p>所有的基本数据类型需要使用包装类，<strong>以防 null 值无法赋值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer sid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    ........</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建db14数据库</span><br><span class="line">CREATE DATABASE db14;</span><br><span class="line"></span><br><span class="line">-- 使用db14数据库</span><br><span class="line">USE db14;</span><br><span class="line"></span><br><span class="line">-- 创建student表</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">	sid INT PRIMARY KEY AUTO_INCREMENT,	-- 学生id</span><br><span class="line">	NAME VARCHAR(20),					-- 学生姓名</span><br><span class="line">	age INT,							-- 学生年龄</span><br><span class="line">	birthday DATE						-- 学生生日</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO student VALUES (NULL,&#x27;张三&#x27;,23,&#x27;1999-09-23&#x27;),(NULL,&#x27;李四&#x27;,24,&#x27;1998-08-10&#x27;),(NULL,&#x27;王五&#x27;,25,&#x27;1996-06-06&#x27;),(NULL,&#x27;赵六&#x27;,26,&#x27;1994-10-20&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作数据库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDaoImpl</span>&#123;</span><br><span class="line">	<span class="comment">//查询所有学生信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Student&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. </span></span><br><span class="line">        ArrayList&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//2.获取数据库连接</span></span><br><span class="line">			con = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">           	<span class="comment">//3.获取执行者对象</span></span><br><span class="line">           	stat = con.createStatement();</span><br><span class="line"></span><br><span class="line">           	<span class="comment">//4.执行sql语句，并且接收返回的结果集</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM student&quot;</span>;</span><br><span class="line">           	rs = stat.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">          	<span class="comment">//5.处理结果集</span></span><br><span class="line">           	<span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">sid</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;sid&quot;</span>);</span><br><span class="line">               	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">               	<span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">               	<span class="type">Date</span> <span class="variable">birthday</span> <span class="operator">=</span> rs.getDate(<span class="string">&quot;birthday&quot;</span>);</span><br><span class="line"></span><br><span class="line">               	<span class="comment">//封装Student对象</span></span><br><span class="line">               	<span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(sid,name,age,birthday);</span><br><span class="line">               	<span class="comment">//将student对象保存到集合中</span></span><br><span class="line">               	list.add(stu);</span><br><span class="line">           	&#125;</span><br><span class="line">       	&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">           	e.printStackTrace();</span><br><span class="line">       	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           	<span class="comment">//6.释放资源</span></span><br><span class="line">           	JDBCUtils.close(con,stat,rs);</span><br><span class="line">       	&#125;</span><br><span class="line">		<span class="comment">//将集合对象返回</span></span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加学生信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            con = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.获取执行者对象</span></span><br><span class="line">            stat = con.createStatement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.执行sql语句，并且接收返回的结果集</span></span><br><span class="line">            <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> stu.getBirthday();</span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">birthday</span> <span class="operator">=</span> sdf.format(d);</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO student VALUES (&#x27;&quot;</span>+stu.getSid()+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+stu.getName()+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+stu.getAge()+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+birthday+<span class="string">&quot;&#x27;)&quot;</span>;</span><br><span class="line">            result = stat.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//6.释放资源</span></span><br><span class="line">            JDBCUtils.close(con,stat);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将结果返回</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="注入攻击"><a href="#注入攻击" class="headerlink" title="注入攻击"></a>注入攻击</h3><h4 id="攻击演示"><a href="#攻击演示" class="headerlink" title="攻击演示"></a>攻击演示</h4><p>SQL 注入攻击演示</p>
<ul>
<li><p>在登录界面，输入一个错误的用户名或密码，也可以登录成功 </p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E6%BC%94%E7%A4%BA.png"></p>
</li>
<li><p>原理：我们在密码处输入的所有内容，都应该认为是密码的组成，但是 Statement 对象在执行 SQL 语句时，将一部分内容当做查询条件来执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user WHERE loginname=&#x27;aaa&#x27; AND password=&#x27;aaa&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="攻击解决"><a href="#攻击解决" class="headerlink" title="攻击解决"></a>攻击解决</h4><p>PreparedStatement：预编译 sql 语句的执行者对象，继承 <code>PreparedStatement extends Statement</code></p>
<ul>
<li>在执行 sql 语句之前，将 sql 语句进行提前编译，<strong>明确 sql 语句的格式</strong>，剩余的内容都会认为是参数</li>
<li>sql 语句中的参数使用 ? 作为<strong>占位符</strong></li>
</ul>
<p>为 ? 占位符赋值的方法：<code>setXxx(int parameterIndex, xxx data)</code></p>
<ul>
<li><p>参数1：? 的位置编号（编号从 1 开始）</p>
</li>
<li><p>参数2：? 的实际参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user WHERE loginname=? AND password=?&quot;</span>;</span><br><span class="line">pst = con.prepareStatement(sql);</span><br><span class="line">pst.setString(<span class="number">1</span>,loginName);</span><br><span class="line">pst.setString(<span class="number">2</span>,password);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>执行 sql 语句的方法</p>
<ul>
<li>执行 insert、update、delete 语句：<code>int executeUpdate()</code></li>
<li>执行 select 语句：<code>ResultSet executeQuery()</code></li>
</ul>
<hr>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>数据库连接背景：数据库连接是一种关键的、有限的、昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。</p>
<p>数据库连接池：<strong>数据库连接池负责分配、管理和释放数据库连接</strong>，它允许应用程序<strong>重复使用</strong>一个现有的数据库连接，而不是再重新建立一个，这项技术能明显提高对数据库操作的性能。</p>
<p>数据库连接池原理</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3.png"></p>
<hr>
<h4 id="自定义池"><a href="#自定义池" class="headerlink" title="自定义池"></a>自定义池</h4><p>DataSource 接口概述：</p>
<ul>
<li>java.sql.DataSource 接口：数据源（数据库连接池）</li>
<li>Java 中 DataSource 是一个标准的数据源接口，官方提供的数据库连接池规范，连接池类实现该接口</li>
<li>获取数据库连接对象：<code>Connection getConnection()</code></li>
</ul>
<p>自定义连接池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDataSource</span> <span class="keyword">implements</span> <span class="title class_">DataSource</span>&#123;</span><br><span class="line">    <span class="comment">//1.定义集合容器，用于保存多个数据库连接对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Connection&gt; pool = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Connection&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.静态代码块，生成10个数据库连接保存到集合中</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line">            pool.add(con);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.返回连接池的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pool.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.从池中返回一个数据库连接</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pool.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//从池中获取数据库连接</span></span><br><span class="line">            <span class="keyword">return</span> pool.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;连接数量已用尽&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试连接池功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDataSourceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建数据库连接池对象</span></span><br><span class="line">        <span class="type">MyDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDataSource</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用之前连接池数量：&quot;</span> + dataSource.getSize());<span class="comment">//10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取数据库连接对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(con.getClass());<span class="comment">// JDBC4Connection</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询学生表全部信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM student&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pst.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            System.out.println(rs.getInt(<span class="string">&quot;sid&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getString(<span class="string">&quot;name&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getInt(<span class="string">&quot;age&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getDate(<span class="string">&quot;birthday&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        rs.close();</span><br><span class="line">        pst.close();</span><br><span class="line">		<span class="comment">//目前的连接对象close方法，是直接关闭连接，而不是将连接归还池中</span></span><br><span class="line">        con.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用之后连接池数量：&quot;</span> + dataSource.getSize());<span class="comment">//9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：释放资源并没有把连接归还给连接池</p>
<hr>
<h4 id="归还连接"><a href="#归还连接" class="headerlink" title="归还连接"></a>归还连接</h4><p>归还数据库连接的方式：继承方式、装饰者设计者模式、适配器设计模式、动态代理方式</p>
<h5 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h5><p>继承（无法解决）</p>
<ul>
<li>通过打印连接对象，发现 DriverManager 获取的连接实现类是 JDBC4Connection</li>
<li>自定义一个类，继承 JDBC4Connection 这个类，重写 close() 方法</li>
<li>查看 JDBC 工具类获取连接的方法发现：虽然自定义了一个子类，完成了归还连接的操作。但是 DriverManager 获取的还是 JDBC4Connection 这个对象，并不是我们的子类对象</li>
</ul>
<p>代码实现</p>
<ul>
<li><p>自定义继承连接类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义一个类，继承JDBC4Connection</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConnection1</span> <span class="keyword">extends</span> <span class="title class_">JDBC4Connection</span>&#123;</span><br><span class="line">    <span class="comment">//2.定义Connection连接对象和容器对象的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> Connection con;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Connection&gt; pool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通过有参构造方法为成员变量赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyConnection1</span><span class="params">(String hostToConnectTo, <span class="type">int</span> portToConnectTo, Properties info, String databaseToConnectTo, String url,Connection con,List&lt;Connection&gt; pool)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="built_in">super</span>(hostToConnectTo, portToConnectTo, info, databaseToConnectTo, url);</span><br><span class="line">        <span class="built_in">this</span>.con = con;</span><br><span class="line">        <span class="built_in">this</span>.pool = pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.重写close方法，完成归还连接</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        pool.add(con);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义连接池类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将之前的连接对象换成自定义的子类对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> MyConnection1 con;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.获取数据库连接的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//等效于：MyConnection1 con = new JDBC4Connection();  语法错误！</span></span><br><span class="line">        con = DriverManager.getConnection(url,username,password);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="装饰者"><a href="#装饰者" class="headerlink" title="装饰者"></a>装饰者</h5><p>自定义类实现 Connection 接口，通过装饰设计模式，实现和 mysql 驱动包中的 Connection 实现类相同的功能</p>
<p>在实现类对每个获取的 Connection 进行装饰：把连接和连接池参数传递进行包装</p>
<p>特点：通过装饰设计模式连接类我们发现，有很多需要重写的方法，代码太繁琐</p>
<ul>
<li><p>装饰设计模式类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义一个类，实现Connection接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConnection2</span> <span class="keyword">implements</span> <span class="title class_">Connection</span> &#123;</span><br><span class="line">    <span class="comment">//2.定义Connection连接对象和连接池容器对象的变量</span></span><br><span class="line">    <span class="keyword">private</span> Connection con;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Connection&gt; pool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyConnection2</span><span class="params">(Connection con,List&lt;Connection&gt; pool)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.con = con;</span><br><span class="line">        <span class="built_in">this</span>.pool = pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.在close()方法中，完成连接的归还</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        pool.add(con);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.剩余方法，只需要调用mysql驱动包的连接对象完成即可</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Statement <span class="title function_">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> con.createStatement();</span><br><span class="line">    &#125;</span><br><span class="line">    ..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义连接池类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(pool.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//从池中获取数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> pool.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//通过自定义连接对象进行包装</span></span><br><span class="line">        <span class="type">MyConnection2</span> <span class="variable">mycon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyConnection2</span>(con,pool);</span><br><span class="line">        <span class="comment">//返回包装后的连接对象</span></span><br><span class="line">        <span class="keyword">return</span> mycon;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;连接数量已用尽&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h5><p>使用适配器设计模式改进，提供一个适配器类，实现 Connection 接口，将所有功能进行实现（除了 close 方法），自定义连接类只需要继承这个适配器类，重写需要改进的 close() 方法即可。</p>
<p>特点：自定义连接类中很简洁。剩余所有的方法抽取到了适配器类中，但是适配器这个类还是我们自己编写。</p>
<ul>
<li><p>适配器类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MyAdapter</span> <span class="keyword">implements</span> <span class="title class_">Connection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义数据库连接对象的变量</span></span><br><span class="line">    <span class="keyword">private</span> Connection con;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造方法赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAdapter</span><span class="params">(Connection con)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.con = con;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的方法，均调用mysql的连接对象实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Statement <span class="title function_">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> con.createStatement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义连接类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConnection3</span> <span class="keyword">extends</span> <span class="title class_">MyAdapter</span> &#123;</span><br><span class="line">    <span class="comment">//2.定义Connection连接对象和连接池容器对象的变量</span></span><br><span class="line">    <span class="keyword">private</span> Connection con;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Connection&gt; pool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyConnection3</span><span class="params">(Connection con,List&lt;Connection&gt; pool)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(con);    <span class="comment">// 将接收的数据库连接对象给适配器父类传递</span></span><br><span class="line">        <span class="built_in">this</span>.con = con;</span><br><span class="line">        <span class="built_in">this</span>.pool = pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.在close()方法中，完成连接的归还</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        pool.add(con);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义连接池类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从池中返回一个数据库连接</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(pool.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//从池中获取数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> pool.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//通过自定义连接对象进行包装</span></span><br><span class="line">        <span class="type">MyConnection3</span> <span class="variable">mycon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyConnection3</span>(con,pool);</span><br><span class="line">        <span class="comment">//返回包装后的连接对象</span></span><br><span class="line">        <span class="keyword">return</span> mycon;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;连接数量已用尽&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>使用动态代理的方式来改进</p>
<p>自定义数据库连接池类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDataSource</span> <span class="keyword">implements</span> <span class="title class_">DataSource</span> &#123;</span><br><span class="line">    <span class="comment">//1.准备一个容器。用于保存多个数据库连接对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Connection&gt; pool = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.定义静态代码块,获取多个连接对象保存到容器中</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line">            pool.add(con);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.提供一个获取连接池大小的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pool.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//动态代理方式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">if</span>(pool.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> pool.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">proxyCon</span> <span class="operator">=</span> (Connection) Proxy.newProxyInstance(</span><br><span class="line">                con.getClass().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Connection.class&#125;, </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    执行Connection实现类连接对象所有的方法都会经过invoke</span></span><br><span class="line"><span class="comment">                    如果是close方法，归还连接</span></span><br><span class="line"><span class="comment">                    如果不是，直接执行连接对象原有的功能即可</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;close&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">//归还连接</span></span><br><span class="line">                        pool.add(con);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> method.invoke(con,args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> proxyCon;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;连接数量已用尽&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h4><h5 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h5><p>使用 C3P0 连接池：</p>
<ul>
<li><p>配置文件名称：c3p0-config.xml，必须放在 src 目录下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用默认的配置读取连接池对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!--  连接参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://192.168.2.184:3306/db14<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 连接池参数 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--初始化数量--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--最大连接数量--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--超时时间 3000ms--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;checkoutTimeout&quot;</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;otherc3p0&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--  连接参数 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池参数 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C3P0Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.创建c3p0的数据库连接池对象</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.通过连接池对象获取数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.执行操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM student&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.执行sql语句，接收结果集</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pst.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.处理结果集</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            System.out.println(rs.getInt(<span class="string">&quot;sid&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getString(<span class="string">&quot;name&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getInt(<span class="string">&quot;age&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getDate(<span class="string">&quot;birthday&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.释放资源</span></span><br><span class="line">        rs.close();   pst.close();   con.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h5><p>Druid 连接池：</p>
<ul>
<li><p>配置文件：druid.properties，必须放在 src 目录下</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://192.168.2.184:3306/db14</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取配置文件的流对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> DruidTest1.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.通过Properties集合，加载配置文件</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        prop.load(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.通过Druid连接池工厂类获取数据库连接池对象</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过连接池对象获取数据库连接进行使用</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//4.执行sql语句，接收结果集</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM student&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pst.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.处理结果集</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            System.out.println(rs.getInt(<span class="string">&quot;sid&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getString(<span class="string">&quot;name&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getInt(<span class="string">&quot;age&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getDate(<span class="string">&quot;birthday&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.释放资源</span></span><br><span class="line">        rs.close();   pst.close();   con.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="工具类-1"><a href="#工具类-1" class="headerlink" title="工具类"></a>工具类</h4><p>数据库连接池的工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceUtils</span> &#123;</span><br><span class="line">    <span class="comment">//1.私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DataSourceUtils</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明数据源变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供静态代码块，完成配置文件的加载和获取数据库连接池对象</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//完成配置文件的加载</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> DataSourceUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            prop.load(is);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取数据库连接池对象</span></span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.提供一个获取数据库连接的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con = dataSource.getConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.提供一个获取数据库连接池对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.释放资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection con, Statement stat, ResultSet rs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(con != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stat != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stat.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//方法重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection con, Statement stat)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(con != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stat != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stat.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Jedis 用于 Java 语言连接 Redis 服务，并提供对应的操作 API</p>
<ul>
<li><p>jar 包导入</p>
<p>下载地址：<a href="https://mvnrepository.com/artifact/redis.clients/jedis">https://mvnrepository.com/artifact/redis.clients/jedis</a></p>
<p>基于 maven：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端连接 Redis：API 文档 <a href="http://xetorthio.github.io/jedis/">http://xetorthio.github.io/jedis/</a></p>
<p>连接 redis：<code>Jedis jedis = new Jedis(&quot;192.168.0.185&quot;, 6379)</code></p>
<p>操作 redis：<code>jedis.set(&quot;name&quot;, &quot;seazean&quot;);  jedis.get(&quot;name&quot;)</code></p>
<p>关闭 redis：<code>jedis.close()</code></p>
</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取连接对象</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.2.185&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//2.执行操作</span></span><br><span class="line">        jedis.set(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;39&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(hello);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;list1&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list1 = jedis.lrange(<span class="string">&quot;list1&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s:list1 ) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.sadd(<span class="string">&quot;set1&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;poi&quot;</span>,<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">len</span> <span class="operator">=</span> jedis.scard(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line">        System.out.println(len);</span><br><span class="line">        <span class="comment">//3.关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="工具类-2"><a href="#工具类-2" class="headerlink" title="工具类"></a>工具类</h3><p>连接池对象：</p>
<ul>
<li>JedisPool：Jedis 提供的连接池技术</li>
<li>poolConfig：连接池配置对象 </li>
<li>host：Redis 服务地址</li>
<li>port：Redis 服务端口号</li>
</ul>
<p>JedisPool 的构造器如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">JedisPool</span><span class="params">(GenericObjectPoolConfig poolConfig, String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(poolConfig, host, port, <span class="number">2000</span>, (String)<span class="literal">null</span>, <span class="number">0</span>, (String)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建配置文件 redis.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">redis.maxTotal</span>=<span class="string">50</span></span><br><span class="line"><span class="attr">redis.maxIdel</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">redis.host</span>=<span class="string">192.168.2.185</span></span><br><span class="line"><span class="attr">redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> maxTotal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> maxIdel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPoolConfig jpc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        <span class="comment">//最大连接数</span></span><br><span class="line">        maxTotal = Integer.parseInt(bundle.getString(<span class="string">&quot;redis.maxTotal&quot;</span>));</span><br><span class="line">        <span class="comment">//活动连接数</span></span><br><span class="line">        maxIdel = Integer.parseInt(bundle.getString(<span class="string">&quot;redis.maxIdel&quot;</span>));</span><br><span class="line">        host = bundle.getString(<span class="string">&quot;redis.host&quot;</span>);</span><br><span class="line">        port = Integer.parseInt(bundle.getString(<span class="string">&quot;redis.port&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Jedis连接配置</span></span><br><span class="line">        jpc = <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        jpc.setMaxTotal(maxTotal);</span><br><span class="line">        jpc.setMaxIdle(maxIdel);</span><br><span class="line">        <span class="comment">//连接池对象</span></span><br><span class="line">        jp = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jpc, host, port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外访问接口，提供jedis连接对象，连接从连接池获取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jp.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/08/02/Tool/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: Tool</span><br><span class="line">date: 2022-01-01 00:00:00</span><br><span class="line">tags: Tool</span><br><span class="line">categories: Tool</span><br><span class="line">comment</span><br></pre></td></tr></table></figure>



<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Git概述"><a href="#Git概述" class="headerlink" title="Git概述"></a>Git概述</h2><h3 id="版本系统"><a href="#版本系统" class="headerlink" title="版本系统"></a>版本系统</h3><p>SVN 是集中式版本控制系统，版本库是集中放在中央服务器的，而开发人员工作的时候，用的都是自己的电脑，所以首先要从中央服务器下载最新的版本，然后开发，开发完后，需要把自己开发的代码提交到中央服务器。</p>
<p>集中式版本控制工具缺点：服务器单点故障、容错性差</p>
<p>Git 是分布式版本控制系统（Distributed Version Control System，简称 DVCS） ，分为两种类型的仓库：</p>
<p>本地仓库和远程仓库：</p>
<ul>
<li>本地仓库：是在开发人员自己电脑上的 Git 仓库		</li>
<li>远程仓库：是在远程服务器上的 Git 仓库</li>
</ul>
<hr>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>1．从远程仓库中克隆代码到本地仓库</p>
<p>2．从本地仓库中 checkout 代码然后进行代码修改</p>
<p>3．在提交前先将代码提交到<strong>暂存区</strong></p>
<p>4．提交到本地仓库。本地仓库中保存修改的各个历史版本</p>
<p>5．修改完成后，需要和团队成员共享代码时，将代码push到远程仓库</p>
<h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><p>下载地址： <a href="https://git-scm.com/download">https://git-scm.com/download</a></p>
<h3 id="代码托管"><a href="#代码托管" class="headerlink" title="代码托管"></a>代码托管</h3><p>Git 中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建Git远程仓库呢？我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有 GitHub、码云、GitLab 等。</p>
<p>GitHub（地址：<a href="https://github.com/%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9D%A2%E5%90%91%E5%BC%80%E6%BA%90%E5%8F%8A%E7%A7%81%E6%9C%89%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%8F%AA%E6%94%AF%E6%8C%81">https://github.com/）是一个面向开源及私有软件项目的托管平台，因为只支持</a> Git 作为唯一的版本库格式进行托管，故名 GitHub</p>
<p>码云（地址： <a href="https://gitee.com/%EF%BC%89%E6%98%AF%E5%9B%BD%E5%86%85%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0%EF%BC%8C%E7%94%B1%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8%E5%9B%BD%E5%86%85%EF%BC%8C%E6%89%80%E4%BB%A5%E7%9B%B8%E6%AF%94%E4%BA%8E">https://gitee.com/）是国内的一个代码托管平台，由于服务器在国内，所以相比于</a> GitHub，码云速度会更快</p>
<p>GitLab（地址： <a href="https://about.gitlab.com/">https://about.gitlab.com/</a> ）是一个用于仓库管理系统的开源项目，使用 Git 作为代码管理工具，并在此基础上搭建起来的 web 服务</p>
<hr>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>安装 Git 后首先要设置用户名称和 email 地址，因为每次 Git 提交都会使用该用户信息，此信息和注册的代码托管平台的信息无关</p>
<p>设置用户信息：</p>
<ul>
<li>git config –global user.name “Seazean”</li>
<li>git config –global user.email “<a href="mailto:&#x7a;&#104;&#121;&#122;&#x68;&#x79;&#x61;&#110;&#103;&#64;&#115;&#105;&#x6e;&#x61;&#x2e;&#99;&#x6f;&#109;">&#x7a;&#104;&#121;&#122;&#x68;&#x79;&#x61;&#110;&#103;&#64;&#115;&#105;&#x6e;&#x61;&#x2e;&#99;&#x6f;&#109;</a>”  &#x2F;&#x2F;用户名和邮箱可以随意填写，不会校对</li>
</ul>
<p>查看配置信息：</p>
<ul>
<li>git config –list</li>
<li>git config user.name</li>
</ul>
<p>通过上面的命令设置的信息会保存在用户目录下 &#x2F;.gitconfig 文件中</p>
<hr>
<h2 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h2><h3 id="获取仓库"><a href="#获取仓库" class="headerlink" title="获取仓库"></a>获取仓库</h3><ul>
<li><p><strong>本地仓库初始化</strong></p>
<ol>
<li><p>在电脑的任意位置创建一个空目录（例如 repo1）作为本地 Git 仓库</p>
</li>
<li><p>进入这个目录中，点击右键打开 Git bash 窗口</p>
</li>
<li><p>执行命令 <strong>git init</strong></p>
<p>如果在当前目录中看到 .git 文件夹（此文件夹为隐藏文件夹）则说明 Git 仓库创建成功</p>
</li>
</ol>
</li>
<li><p><strong>远程仓库克隆</strong><br>通过 Git 提供的命令从远程仓库进行克隆，将远程仓库克隆到本地</p>
<p>命令：git clone 远程 Git 仓库地址（HTTPS 或者 SSH）</p>
</li>
<li><p>生成 SSH 公钥步骤</p>
<ul>
<li>设置账户</li>
<li>cd ~&#x2F;.ssh（查看是否生成过 SSH 公钥）user 目录下</li>
<li>生成 SSH 公钥：<code>ssh-keygen -t rsa -C &quot;email&quot;</code><ul>
<li>-t 指定密钥类型，默认是 rsa ，可以省略</li>
<li>-C 设置注释文字，比如邮箱</li>
<li>-f 指定密钥文件存储文件名</li>
</ul>
</li>
<li>查看命令: cat ~&#x2F;.ssh&#x2F;id_rsa.pub</li>
<li>公钥测试命令: ssh -T <a href="mailto:&#x67;&#105;&#116;&#x40;&#x67;&#x69;&#x74;&#104;&#117;&#x62;&#46;&#99;&#111;&#109;">&#x67;&#105;&#116;&#x40;&#x67;&#x69;&#x74;&#104;&#117;&#x62;&#46;&#99;&#111;&#109;</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/Git%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p>
<p>版本库：.git 隐藏文件夹就是版本库，版本库中存储了很多配置信息、日志信息和文件版本信息等</p>
<p>工作目录（工作区）：包含 .git 文件夹的目录就是工作目录，主要用于存放开发的代码</p>
<p>暂存区：.git 文件夹中有很多文件，其中有一个 index 文件就是暂存区，也可以叫做 stage，暂存区是一个临时保存修改文件的地方</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E6%96%87%E4%BB%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<hr>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git status</td>
<td>查看 git 状态 （文件是否进行了添加、提交操作）</td>
</tr>
<tr>
<td>git add filename</td>
<td>添加，将指定文件添加到暂存区</td>
</tr>
<tr>
<td>git commit -m ‘message’</td>
<td>提交，将暂存区文件提交到本地仓库，删除暂存区的该文件</td>
</tr>
<tr>
<td>git commit –amend</td>
<td>修改 commit 的 message</td>
</tr>
<tr>
<td>git rm filename</td>
<td>删除，删除工作区的文件，不是仓库，需要提交</td>
</tr>
<tr>
<td>git mv filename</td>
<td>移动或重命名工作区文件</td>
</tr>
<tr>
<td>git reset filename</td>
<td>使用当前分支上的修改覆盖暂存区，<strong>将暂存区的文件取消暂存</strong></td>
</tr>
<tr>
<td>git checkout filename</td>
<td>使用暂存区的修改覆盖工作目录，用来撤销本次修改(危险)</td>
</tr>
<tr>
<td>git log</td>
<td>查看日志（ git 提交的历史日志）</td>
</tr>
<tr>
<td>git reflog</td>
<td>可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录的操作）</td>
</tr>
</tbody></table>
<p><strong>其他指令</strong>：可以跳过暂存区域直接从分支中取出修改，或者直接提交修改到分支中</p>
<ul>
<li>git commit -a 直接把所有文件的修改添加到暂存区然后执行提交</li>
<li>git checkout HEAD – files 取出最后一次修改，可以用来进行回滚操作</li>
</ul>
<hr>
<h4 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h4><ul>
<li><p>Git 工作目录下的文件存在两种状态：</p>
<ul>
<li>untracked 未跟踪（未被纳入版本控制）</li>
<li>tracked 已跟踪（被纳入版本控制）<ul>
<li>Unmodified 未修改状态</li>
<li>Modified 已修改状态</li>
<li>Staged 已暂存状态</li>
</ul>
</li>
</ul>
</li>
<li><p>查看文件状态：文件的状态会随着我们执行 Git 的命令发生变化</p>
<ul>
<li>git status 查看文件状态</li>
<li>git status –s 查看更简洁的文件状态</li>
</ul>
</li>
</ul>
<hr>
<h4 id="文件忽略"><a href="#文件忽略" class="headerlink" title="文件忽略"></a>文件忽略</h4><p>一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为 .gitignore 的文件（文件名称固定），列出要忽略的文件模式。下面是一个示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># no .a files</span></span><br><span class="line">*.a</span><br><span class="line"><span class="comment"># but do track lib.a, even though you&#x27;re ignoring .a files above</span></span><br><span class="line">!lib.a</span><br><span class="line"><span class="comment"># only ignore the TODO file in the current directory, not subdir/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"><span class="comment"># ignore all files in the build/ directory</span></span><br><span class="line">build/</span><br><span class="line"><span class="comment"># ignore doc/notes.txt, but not doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"><span class="comment"># ignore all .pdf files in the doc/ directory</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><p>Git 有四个工作空间的概念，分别为 工作空间、暂存区、本地仓库、远程仓库。</p>
<p>pull &#x3D; fetch + merge</p>
<p>fetch 是从远程仓库更新到本地仓库，pull是从远程仓库直接更新到工作空间中</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E5%9B%BE%E8%A7%A3%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p>
<hr>
<h3 id="查看仓库"><a href="#查看仓库" class="headerlink" title="查看仓库"></a>查看仓库</h3><p>git remote：显示所有远程仓库的简写  </p>
<p>git remote -v：显示所有远程仓库  </p>
<p>git remote show <shortname>：显示某个远程仓库的详细信息</shortname></p>
<h3 id="添加仓库"><a href="#添加仓库" class="headerlink" title="添加仓库"></a>添加仓库</h3><p>git remote add <shortname><url>：添加一个新的远程仓库，并指定一个可以引用的简写</url></shortname></p>
<h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><p>git clone <url>(HTTPS or SSH)：克隆远程仓库</url></p>
<p>Git 克隆的是该 Git 仓库服务器上的几乎所有数据（包括日志信息、历史记录等），而不仅仅是复制工作所需要的文件，当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。</p>
<h3 id="删除仓库"><a href="#删除仓库" class="headerlink" title="删除仓库"></a>删除仓库</h3><p>git remote rm <shortname>：移除远程仓库，从本地移除远程仓库的记录，并不会影响到远程仓库</shortname></p>
<h3 id="拉取仓库"><a href="#拉取仓库" class="headerlink" title="拉取仓库"></a>拉取仓库</h3><p>git fetch  <shortname>：从远程仓库获取最新版本到本地仓库，不会自动 merge  </shortname></p>
<p>git pull <shortname> <branchname>：从远程仓库获取最新版本并 merge 到本地仓库</branchname></shortname></p>
<p>注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且<strong>仓库中存在文件</strong>，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ），解决此问题可以在 git pull 命令后加入参数 –allow-unrelated-histories</p>
<h3 id="推送仓库"><a href="#推送仓库" class="headerlink" title="推送仓库"></a>推送仓库</h3><p>git push <shortname><branchname>：上传本地指定分支到远程仓库</branchname></shortname></p>
<hr>
<h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2.png"></p>
<p>命令：git reset –hard 版本唯一索引值</p>
<hr>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><p>git branch：列出所有本地分支  </p>
<p>git branch -r：列出所有远程分支  </p>
<p>git branch -a：列出所有本地分支和远程分支</p>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>git branch  branch-name：新建一个分支，但依然停留在当前分支</p>
<p>git checkout -b branch-name：新建一个分支，并切换到该分支</p>
<h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>git push origin branch-name：推送到远程仓库，origin 是引用名</p>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>git checkout branch-name：切换到 branch-name 分支</p>
<h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>git merge branch-name：合并指定分支到当前分支</p>
<p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没办法合并它们，同时会提示文件冲突。此时需要我们打开冲突的文件并修复冲突内容，最后执行 git add 命令来标识冲突已解决</p>
<p>​	<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF%E5%86%B2%E7%AA%81.png"></p>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>git branch -d branch-name：删除分支</p>
<p>git push origin –d branch-name：删除远程仓库中的分支   （origin 是引用名）</p>
<p>如果要删除的分支中进行了开发动作，此时执行删除命令并不会删除分支，如果坚持要删除此分支，可以将命令中的 -d 参数改为 -D：git branch -D branch-name</p>
<hr>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><h3 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h3><p>git tag：列出所有 tag</p>
<p>git show tag-name：查看 tag 详细信息</p>
<p>标签作用：在开发的一些关键时期，使用标签来记录这些关键时刻，保存快照，例如发布版本、有重大修改、升级的时候、会使用标签记录这些时刻，来永久标记项目中的关键历史时刻</p>
<h3 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h3><p>git tag tag-name：新建标签，如（git tag v1.0.1）</p>
<h3 id="推送标签"><a href="#推送标签" class="headerlink" title="推送标签"></a>推送标签</h3><p>git push [remotename] [tagname]：推送到远程仓库</p>
<p>git push [remotename] –tags：推送所有的标签</p>
<h3 id="切换标签"><a href="#切换标签" class="headerlink" title="切换标签"></a>切换标签</h3><p>git checkout tag-name：切换标签</p>
<h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><p>git tag -d tag-name：删除本地标签</p>
<p>git push origin :refs&#x2F;tags&#x2F; tag-name：删除远程标签</p>
<hr>
<h2 id="IDEA操作"><a href="#IDEA操作" class="headerlink" title="IDEA操作"></a>IDEA操作</h2><h3 id="环境配置-1"><a href="#环境配置-1" class="headerlink" title="环境配置"></a>环境配置</h3><p>File → Settings 打开设置窗口，找到 Version Control 下的 git 选项</p>
<p>选择 git 的安装目录后可以点击 Test 按钮测试是否正确配置：D:\Program Files\Git\cmd\git.exe</p>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>1、VCS → Import into Version Control → Create Git Repository</p>
<p>2、选择工程所在的目录,这样就创建好本地仓库了</p>
<p>3、点击git后边的对勾,将当前项目代码提交到本地仓库</p>
<p>​	注意: 项目中的配置文件不需要提交到本地仓库中,提交时,忽略掉即可</p>
<h3 id="文件操作-1"><a href="#文件操作-1" class="headerlink" title="文件操作"></a>文件操作</h3><p>右键项目名打开菜单 Git → Add → commit</p>
<h3 id="版本管理-1"><a href="#版本管理-1" class="headerlink" title="版本管理"></a>版本管理</h3><ul>
<li><p>版本对比<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94.png"></p>
</li>
<li><p>版本切换方式一：控制台 Version Control → Log → 右键 Reset Current Branch → Reset，这种切换会抛弃原来的提交记录<br>       <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F%E4%B8%80.png"></p>
</li>
<li><p>版本切换方式二：控制台 Version Control → Log → Revert Commit → Merge → 处理代码 → commit，这种切换会当成一个新的提交记录，之前的提交记录也都保留<br> <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F%E4%BA%8C.png"></p>
</li>
</ul>
<p>​           <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F%E4%BA%8C(1).png"></p>
<hr>
<h3 id="分支管理-1"><a href="#分支管理-1" class="headerlink" title="分支管理"></a>分支管理</h3><ul>
<li>创建分支：VCS → Git → Branches → New Branch → 给分支起名字 → ok</li>
<li>切换分支：idea 右下角 Git → 选择要切换的分支 → checkout</li>
<li>合并分支：VCS → Git → Merge changes → 选择要合并的分支 → merge</li>
<li>删除分支：idea 右下角 → 选中要删除的分支 → Delete</li>
</ul>
<hr>
<h3 id="推送仓库-1"><a href="#推送仓库-1" class="headerlink" title="推送仓库"></a>推送仓库</h3><ol>
<li>VCS → Git → Push → 点击 master Define remote</li>
<li>将远程仓库的 url 路径复制过来 → Push<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E6%8E%A8%E9%80%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93.png"></li>
</ol>
<hr>
<h3 id="克隆仓库-1"><a href="#克隆仓库-1" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><p>File → Close Project → Checkout from Version Control → Git → 指定远程仓库的路径 → 指定本地存放的路径 → clone</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%85%8B%E9%9A%86%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png"></p>
<hr>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>操作系统（Operation System），是管理计算机硬件与软件资源的计算机程序，同时也是计算机系统的内核与基石。操作系统需要处理管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务，操作系统也提供一个让用户与系统交互的操作界面</p>
<p>操作系统作为接口的示意图：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/操作系统.png" style="zoom:80%;">

<p>移动设备操作系统：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png"></p>
<hr>
<h2 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h2><h3 id="系统介绍"><a href="#系统介绍" class="headerlink" title="系统介绍"></a>系统介绍</h3><p>从内到位依次是硬件 → 内核层 → Shell 层 → 应用层 → 用户<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/Linux%E7%B3%BB%E7%BB%9F.png" alt="Linux"></p>
<p>内核层：核心和基础，附着在硬件平台上，控制和管理系统内的各种资源，有效的组织进程的运行，扩展硬件的功能，提高资源利用效率，为用户提供安全可靠的应用环境。</p>
<p>Shell 层：与用户直接交互的界面。用户可以在提示符下输入命令行，由 Shell 解释执行并输出相应结果或者有关信息，所以我们也把  Shell 称作命令解释器，利用系统提供的丰富命令可以快捷而简便地完成许多工作。</p>
<hr>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>Linux 文件系统目录结构和熟知的 windows 系统有较大区别，没有各种盘符的概念。根目录只有一个&#x2F;，采用层级式的树状目录结构。</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png" alt="Linux文件系统"></p>
<hr>
<h2 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h2><h3 id="设置IP"><a href="#设置IP" class="headerlink" title="设置IP"></a>设置IP</h3><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>首先设置虚拟机中 NAT 模式的选项，打开 VMware，点击编辑下的虚拟网络编辑器，设置 NAT 参数<br>    <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E9%85%8D%E7%BD%AENAT.jpg"></p>
<p><strong>注意</strong>：VMware Network Adapter VMnet8 保证是启用状态</p>
<p>​	<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E6%9C%AC%E5%9C%B0%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5.jpg"></p>
<h4 id="静态IP"><a href="#静态IP" class="headerlink" title="静态IP"></a>静态IP</h4><p>在普通用户下不能修改网卡的配置信息；所以我们要切换到 root 用户进行 ip 配置：su root&#x2F;su</p>
<ul>
<li><p>修改网卡配置文件：<code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>
</li>
<li><p>修改文件内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=10.2.111.62</span><br><span class="line">NETMASK=255.255.252.0</span><br><span class="line">GATEWAY=10.2.111.254</span><br><span class="line">DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=<span class="built_in">yes</span></span><br><span class="line">IPV6_AUTOCONF=<span class="built_in">yes</span></span><br><span class="line">IPV6_DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=2c2371f1-ef29-4514-a568-c4904bd11c82</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=<span class="literal">true</span></span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line">BOOTPROTO设置为静态static</span><br><span class="line">IPADDR设置ip地址</span><br><span class="line">NETMASK设置子网掩码</span><br><span class="line">GATEWAY设置网关</span><br><span class="line">ONBOOT设置为<span class="literal">true</span>在系统启动时是否激活网卡</span><br><span class="line">执行保存 :wq!</span><br></pre></td></tr></table></figure>

</li>
<li><p>重启网络：systemctl restart network</p>
</li>
<li><p>查看IP：ifconfig</p>
</li>
<li><p>宿主机 ping 虚拟机，虚拟机 ping 宿主机</p>
</li>
<li><p>在虚拟机中访问网络，需要增加一块 NAT 网卡</p>
<ul>
<li>【虚拟机】–【设置】–【添加】</li>
<li><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/两块NAT网卡.jpg" style="zoom:80%;"></li>
</ul>
</li>
</ul>
<hr>
<h3 id="远程登陆"><a href="#远程登陆" class="headerlink" title="远程登陆"></a>远程登陆</h3><p><strong>服务器维护工作</strong> 都是在 远程 通过 SSH 客户端 来完成的， 并没有图形界面， 所有的维护工作都需要通过命令来完成，Linux 服务器需要安装 SSH 相关服务</p>
<p>首先执行 sudo apt-get install openssh-server 指令，接下来用 xshell 连接</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Linux.png"></p>
<p>先用普通用户登录，然后转成 root</p>
<hr>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>Linux 系统是一个多用户、多任务的操作系统。多用户是指在 Linux 操作系统中可以创建多个用户，而这些多用户又可以同时执行各自不同的任务，而互不影响</p>
<p>在 Linux 系统中，会存在着以下几个概念：</p>
<ul>
<li>用户名：用户的名称</li>
<li>用户所属的组：当前用户所属的组</li>
<li>用户的家目录：当前账号登录成功之后的目录，就叫做该用户的家目录</li>
</ul>
<h3 id="用户管理-1"><a href="#用户管理-1" class="headerlink" title="用户管理"></a>用户管理</h3><h4 id="当前用户"><a href="#当前用户" class="headerlink" title="当前用户"></a>当前用户</h4><p>logname：用于显示目前用户的名称</p>
<ul>
<li><p>–help：在线帮助</p>
</li>
<li><p>–vesion：显示版本信息</p>
</li>
</ul>
<h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h4><p>su UserName：切换用户</p>
<p>su -c comman root：切换用户为 root 并在执行 comman 指令后退出返回原使用者</p>
<p>su：切换到 root 用户</p>
<h4 id="用户添加"><a href="#用户添加" class="headerlink" title="用户添加"></a>用户添加</h4><p>命令：useradd  [options]  用户名</p>
<p>参数说明：</p>
<ul>
<li>-c comment 指定一段注释性描述</li>
<li>-d 指定用户主目录，如果此目录不存在，则同时使用 -m 选项，可以创建主目录</li>
<li>-m 创建用户的主目录</li>
<li>-g 用户组，指定用户所属的用户组</li>
<li>-G 用户组，用户组 指定用户所属的附加组</li>
<li>-s Shell 文件 指定用户的登录 Shell</li>
<li>-u 用户号，指定用户的用户号，如果同时有 -o 选项，则可以重复使用其他用户的标识号。</li>
</ul>
<p>如何知道添加用户成功呢？ 通过指令 cat &#x2F;etc&#x2F;passwd 查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seazean:x:  1000:1000:Seazean:/home/seazean:/bin/bash</span><br><span class="line">用户名 密码  用户ID 组ID   注释    家目录        shell程序</span><br></pre></td></tr></table></figure>

<p>useradd -m Username 新建用户成功之后，会建立 home 目录，但是此时有问题没有指定 shell 的版本，不是我们熟知的 bash，功能上有很多限制，进行 <strong>sudo useradd -m -s &#x2F;bin&#x2F;bash Username</strong></p>
<h4 id="用户密码"><a href="#用户密码" class="headerlink" title="用户密码"></a>用户密码</h4><p>系统安装好默认的 root 用户是没有密码的，需要给 root 设置一个密码 <strong>sudo passwd root</strong>.</p>
<ul>
<li><p>普通用户：<strong>sudo passwd UserName</strong></p>
</li>
<li><p>管理员用户：passwd [options] UserName</p>
<ul>
<li>-l：锁定密码，即禁用账号</li>
<li>-u：密码解锁</li>
<li>-d：使账号无密码</li>
<li>-f：强迫用户下次登录时修改密码</li>
</ul>
</li>
</ul>
<h4 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h4><p>usermod 命令通过修改系统帐户文件来修改用户账户信息</p>
<p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录 Shell 等</p>
<ul>
<li><p>普通用户：sudo usermod [options] Username</p>
</li>
<li><p>管理员用户：usermod [options] Username</p>
<ul>
<li>usermod <strong>-l</strong> newName Username</li>
<li>-l 新的登录名称</li>
</ul>
</li>
</ul>
<h4 id="用户删除"><a href="#用户删除" class="headerlink" title="用户删除"></a>用户删除</h4><p>删除用户账号就是要将 &#x2F;etc&#x2F;passwd 等系统文件中的该用户记录删除，必要时还删除用户的主目录</p>
<ul>
<li><p>普通用户：sudo userdel [options] Username</p>
</li>
<li><p>管理员用户：userdel [options] Username</p>
<ul>
<li>-f：强制删除用户，即使用户当前已登录</li>
<li>-r：删除用户的同时，删除与用户相关的所有文件</li>
</ul>
</li>
</ul>
<hr>
<h3 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h3><h4 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h4><p>添加组：<strong>groupadd 组名</strong></p>
<p>创建用户的时加入组：useradd -m  -g 组名 用户名<br>​</p>
<h4 id="添加用户组"><a href="#添加用户组" class="headerlink" title="添加用户组"></a>添加用户组</h4><p>新增一个用户组（组名可见名知意，符合规范即可），然后将用户添加到组中，需要使用管理员权限</p>
<p>命令：groupadd  [options] Groupname</p>
<ul>
<li>-g GID 指定新用户组的组标识号（GID）</li>
<li>-o 一般与 -g 选项同时使用，表示新用户组的 GID 可以与系统已有用户组的 GID 相同</li>
</ul>
<p>新增用户组 Seazean：groupadd Seazean</p>
<h4 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h4><p>需要使用管理员权限</p>
<p>命令：groupmod [options] Groupname</p>
<ul>
<li>-g GID 为用户组指定新的组标识号。</li>
<li>-o 与 -g 选项同时使用，用户组的新 GID 可以与系统已有用户组的 GID 相同</li>
<li>-n 新用户组 将用户组的名字改为新名字</li>
</ul>
<p>修改 Seazean 组名为 zhy：groupmod -n zhy Seazean</p>
<h4 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h4><ul>
<li><p>普通用户：sudo groupdel Groupname </p>
</li>
<li><p>管理员用户：groupdel Groupname </p>
<ul>
<li>-f  用户的主组也继续删除</li>
<li>-h  显示帮助信息</li>
</ul>
</li>
</ul>
<h4 id="用户所属组"><a href="#用户所属组" class="headerlink" title="用户所属组"></a>用户所属组</h4><p>查询用户所属组：groups Username</p>
<p>查看用户及组信息：id Username</p>
<p>创建用户的时加入组：useradd -m  -g Groupname Username</p>
<p>修改用户所属组：usermod -g Groupname Username</p>
<p>usermod常用选项：</p>
<ul>
<li>-d 用户的新主目录</li>
<li>-l  新的登录名称</li>
</ul>
<h4 id="gpasswd"><a href="#gpasswd" class="headerlink" title="gpasswd"></a>gpasswd</h4><p>gpasswd 是 Linux 工作组文件 &#x2F;etc&#x2F;group 和 &#x2F;etc&#x2F;gshadow 管理工具，用于将一个用户添加到组或从组中删除</p>
<p>命令：gpasswd  选项  Username  Groupname</p>
<ul>
<li>-a 向组 GROUP 中添加用户 USER</li>
<li>-d 从组 GROUP 中添加或删除用户</li>
</ul>
<p><strong>查看用户组下所有用户（所有用户）</strong>：grep ‘Groupname’ &#x2F;etc&#x2F;group</p>
<hr>
<h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>在控制台输入：命令名 -h&#x2F;  -help&#x2F;   –h  &#x2F;空</p>
<p>可以看到命令的帮助文档</p>
<p><strong>man</strong> [指令名称]：查看帮助文档，比如 man ls，退出方式 q</p>
<hr>
<h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>date 可以用来显示或设定系统的日期与时间</p>
<p>命令：date [options]</p>
<ul>
<li><p>-d&lt;字符串&gt;：显示字符串所指的日期与时间，字符串前后必须加上双引号；</p>
</li>
<li><p>-s&lt;字符串&gt;：根据字符串来设置日期与时间，字符串前后必须加上双引号</p>
</li>
<li><p>-u：显示 GMT</p>
</li>
<li><p>–version：显示版本信息</p>
</li>
</ul>
<p>查看时间：date → 2020年 11月 30日 星期一 17:10:54 CST</p>
<p>查看指定格式时间：date “+%Y-%m-%d %H:%M:%S” → 2020-11-30 17:11:44</p>
<p>设置日期指令：date -s “2019-12-23 19:21:00”</p>
<hr>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>id 会显示用户以及所属群组的实际与有效 ID，若两个 ID 相同则仅显示实际 ID；若仅指定用户名称，则显示目前用户的 ID</p>
<p>命令：id [-gGnru] [–help] [–version] [用户名称] &#x2F;&#x2F;参数的顺序</p>
<ul>
<li>-g 或–group：显示用户所属群组的 ID</li>
<li>-G 或–groups：显示用户所属附加群组的 ID</li>
<li>-n 或–name：显示用户，所属群组或附加群组的名称。</li>
<li>-r 或–real：显示实际 ID</li>
<li>-u 或–user：显示用户 ID</li>
</ul>
<blockquote>
<p>id 命令参数虽然很多，但是常用的是不带参数的 id 命令，主要看 uid 和组信息</p>
</blockquote>
<hr>
<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>sudo：控制用户对系统命令的使用权限，通过 sudo 可以提高普通用户的操作权限</p>
<ul>
<li>-V 显示版本编号</li>
<li>-h 会显示版本编号及指令的使用方式说明</li>
<li>-l  显示出自己（执行 sudo 的使用者）的权限</li>
<li>-command 要以系统管理者身份（或以 -u 更改为其他人）执行的指令</li>
</ul>
<p> <strong>sudo -u root command  -l</strong>：指定 root 用户执行指令 command  </p>
<hr>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>top：用于实时显示 process 的动态</p>
<ul>
<li><p>-c：command 属性进行了命令补全</p>
</li>
<li><p>-p 进程号：显示指定 pid 的进程信息</p>
</li>
<li><p>-d 秒数：表示进程界面更新时间（每几秒刷新一次）</p>
</li>
<li><p>-H 表示线程模式</p>
</li>
</ul>
<p><code>top -Hp 进程 id</code>：分析该进程内各线程的 CPU 使用情况</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/top%E5%91%BD%E4%BB%A4.png"></p>
<p><strong>各进程（任务）的状态监控属性解释说明：</strong></p>
<ul>
<li>PID — 进程 id</li>
<li>TID — 线程 id</li>
<li>USER — 进程所有者</li>
<li>PR — 进程优先级</li>
<li>NI — nice 值，负值表示高优先级，正值表示低优先级</li>
<li>VIRT — 进程使用的虚拟内存总量，单位 kb，VIRT&#x3D;SWAP+RES</li>
<li>RES — 进程使用的、未被换出的物理内存大小，单位 kb，RES&#x3D;CODE+DATA</li>
<li>SHR — 共享内存大小，单位 kb</li>
<li>S — 进程状态，D&#x3D;不可中断的睡眠状态 R&#x3D;运行 S&#x3D;睡眠 T&#x3D;跟踪&#x2F;停止 Z&#x3D;僵尸进程</li>
<li>%CPU — 上次更新到现在的 CPU 时间占用百分比</li>
<li>%MEM — 进程使用的物理内存百分比</li>
<li>TIME+ — 进程使用的 CPU 时间总计，单位 1&#x2F;100 秒</li>
<li>COMMAND — 进程名称（命令名&#x2F;命令行）</li>
</ul>
<hr>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>Linux 系统中查看进程使用情况的命令是 ps 指令</p>
<p>命令：ps</p>
<ul>
<li>-e:  显示所有进程</li>
<li>-f:  全格式</li>
<li>a:  显示终端上的所有进程</li>
<li>u:  以用户的格式来显示进程信息</li>
<li>x:  显示后台运行的进程</li>
<li>-T：开启线程查看</li>
<li>-p：指定线程号</li>
</ul>
<p> 一般常用格式为 ps -ef 或者 ps aux 两种。显示的信息大体一致，略有区别：</p>
<ul>
<li>如果想查看进程的 CPU 占用率和内存占用率，可以使用 aux</li>
<li>如果想查看进程的父进程 ID 和完整的 COMMAND 命令，可以使用 ef</li>
</ul>
<p><code>ps -T -p &lt;pid&gt;</code>：显示某个进程的线程</p>
<p><strong>ps 和 top 区别：</strong></p>
<ul>
<li><p>ps 命令：可以查看进程的瞬间信息，是系统在过去执行的进程的静态快照</p>
</li>
<li><p>top 命令：可以持续的监视进程的动态信息</p>
</li>
</ul>
<hr>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>Linux kill 命令用于删除执行中的程序或工作，并不是让进程直接停止，而是给进程发一个信号，可以进入终止逻辑</p>
<p>命令：kill [-s &lt;信息名称或编号&gt;] [程序]　或　kill [-l &lt;信息编号&gt;]</p>
<ul>
<li>-l &lt;信息编号&gt;：若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称</li>
<li>-s &lt;信息名称或编号&gt;：指定要送出的信息</li>
<li>-KILL：强制杀死进程</li>
<li><strong>-9：彻底杀死进程（常用）</strong></li>
<li>[程序]  程序的 PID、PGID、工作编号</li>
</ul>
<p><code>kill 15642 </code>.   <code>kill -KILL 15642</code>.    <code>kill -9 15642</code></p>
<p>杀死指定用户所有进程：</p>
<ol>
<li><p>过滤出 user 用户进程 ：<code>kill -9 $(ps -ef | grep user) </code></p>
</li>
<li><p>直接杀死：<code>kill -u user</code></p>
</li>
</ol>
<hr>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>shutdown 命令可以用来进行关闭系统，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机</p>
<p>普通用户：sudo shutdown [-t seconds] [-rkhncfF] time [message]</p>
<p>管理员用户：shutdown [-t seconds] [-rkhncfF] time [message]</p>
<ul>
<li>-t seconds：设定在几秒钟之后进行关机程序</li>
<li>-k：并不会真的关机，只是将警告讯息传送给所有使用者</li>
<li>-r：关机后重新开机</li>
<li>-h：关机后停机</li>
<li>-n：不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机</li>
<li>-c：取消目前已经进行中的关机动作</li>
<li>-f：关机时，不做 fcsk 动作（检查 Linux 档系统）</li>
<li>-F：关机时，强迫进行 fsck 动作</li>
<li>time：设定关机的时间</li>
<li>message：传送给所有使用者的警告讯息</li>
</ul>
<p>立即关机：<code>shutdown -h now</code>   或者   <code>shudown now</code></p>
<p>指定 1 分钟后关机并显示警告信息：<code>shutdown +1 &quot;System will shutdown after 1 minutes&quot; </code></p>
<p>指定 1 分钟后重启并发出警告信息：<code>shutdown –r +1 &quot;1分钟后关机重启&quot;</code></p>
<hr>
<h3 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h3><p>reboot 命令用于用来重新启动计算机</p>
<p>命令：reboot [-n] [-w] [-d] [-f] [-i]</p>
<ul>
<li>-n：在重开机前不做将记忆体资料写回硬盘的动作</li>
<li>-w：并不会真的重开机，只是把记录写到 &#x2F;var&#x2F;log&#x2F;wtmp 档案里</li>
<li>-d：不把记录写到 &#x2F;var&#x2F;log&#x2F;wtmp 档案里（-n 这个参数包含了 -d）</li>
<li>-f：强迫重开机，不呼叫 shutdown 这个指令</li>
<li>-i：在重开机之前先把所有网络相关的装置先停止</li>
</ul>
<hr>
<h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>who 命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、上线时间、CPU 使用量、动作等等</p>
<p>命令：who - [husfV] [user]</p>
<ul>
<li>-H 或 –heading：显示各栏位的标题信息列（常用 <code>who -H</code>）</li>
<li>-i 或 -u 或 –idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成 <code>.</code> 号，如果该用户已超过 24 小时没有任何动作，则标示出 <code>old</code> 字符串</li>
<li>-m：此参数的效果和指定 <code>am i</code> 字符串相同</li>
<li>-q 或–count：只显示登入系统的帐号名称和总人数</li>
<li>-s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题</li>
<li>-w 或-T或–mesg或–message或–writable：显示用户的信息状态栏</li>
<li>–help：在线帮助</li>
<li>–version：显示版本信息</li>
</ul>
<hr>
<h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><p>命令：systemctl [command] [unit]</p>
<ul>
<li><p>–version  查看版本号</p>
</li>
<li><p>start：立刻启动后面接的 unit</p>
</li>
<li><p>stop：立刻关闭后面接的 unit</p>
</li>
<li><p>restart：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思</p>
</li>
<li><p>reload：不关闭 unit 的情况下，重新载入配置文件，让设置生效</p>
</li>
<li><p>status：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机时是否启动等信息</p>
</li>
<li><p>enable：设置下次开机时，后面接的 unit 会被启动</p>
</li>
<li><p>disable：设置下次开机时，后面接的 unit 不会被启动</p>
</li>
<li><p>is-active：目前有没有正在运行中</p>
</li>
<li><p>is-enable：开机时有没有默认要启用这个 unit</p>
</li>
<li><p>kill ：不要被 kill 这个名字吓着了，它其实是向运行 unit 的进程发送信号</p>
</li>
<li><p>show：列出 unit 的配置</p>
</li>
<li><p>mask：注销 unit，注销后你就无法启动这个 unit 了</p>
</li>
<li><p>unmask：取消对 unit 的注销</p>
</li>
</ul>
<hr>
<h3 id="timedatectl"><a href="#timedatectl" class="headerlink" title="timedatectl"></a>timedatectl</h3><p>timedatectl用于控制系统时间和日期。可以查询和更改系统时钟于设定，同时可以设定和修改时区信息。在实际开发过程中，系统时间的显示会和实际出现不同步；我们为了校正服务器时间、时区会使用timedatectl命令</p>
<p>timedatectl：显示系统的时间信息</p>
<p>timedatectl status：显示系统的当前时间和日期</p>
<p>timedatectl | grep Time：查看当前时区</p>
<p>timedatectl list-timezones：查看所有可用的时区</p>
<p>timedatectl set-timezone “Asia&#x2F;Shanghai”：设置本地时区为上海</p>
<p>timedatectl set-ntp true&#x2F;false：启用&#x2F;禁用时间同步</p>
<p>timedatectl set-time “2020-12-20 20:45:00”：时间同步关闭后可以设定时间</p>
<p>NTP 即 Network Time Protocol（网络时间协议），是一个互联网协议，用于同步计算机之间的系统时钟，timedatectl 实用程序可以自动同步你的Linux系统时钟到使用NTP的远程服务器</p>
<hr>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>clear 命令用于清除屏幕</p>
<p>通过执行 clear 命令，就可以把缓冲区的命令全部清理干净</p>
<hr>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p>exit 命令用于退出目前的 shell</p>
<p>执行 exit 可使 shell 以指定的状态值退出。若不设置状态值参数，则 shell 以预设值退出。状态值 0 代表执行成功，其他值代表执行失败；exit 也可用在 script，离开正在执行的 script，回到 shell</p>
<p>命令：exit [状态值]</p>
<ul>
<li><p>0 表示成功（Zero - Success）</p>
</li>
<li><p>非 0 表示失败（Non-Zero  - Failure）</p>
</li>
<li><p>2 表示用法不当（Incorrect Usage）</p>
</li>
<li><p>127 表示命令没有找到（Command Not Found）</p>
</li>
<li><p>126 表示不是可执行的（Not an executable）</p>
</li>
<li><p>大于等于 128 信号产生</p>
</li>
</ul>
<hr>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>ls命令相当于我们在Windows系统中打开磁盘、或者打开文件夹看到的目录以及文件的明细。</p>
<p>命令：ls [options]  目录名称</p>
<ul>
<li>-a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)</li>
<li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li>
<li>-l  ：显示不隐藏的文件与文件夹的详细信息；(常用)</li>
<li><strong>ls -al &#x3D; ll 命令</strong>：显示所有文件与文件夹的详细信息</li>
</ul>
<h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>pwd 是 Print Working Directory 的缩写，也就是显示目前所在当前目录的命令</p>
<p>命令：pwd 选项</p>
<ul>
<li>-L	打印 $PWD 变量的值，如果它包含了当前的工作目录</li>
<li>-P	打印当前的物理路径，不带有任何的符号链接</li>
</ul>
<h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>cd 是 Change Directory 的缩写，这是用来变换工作目录的命令</p>
<p>命令：cd [相对路径或绝对路径] </p>
<ul>
<li>cd ~ ：表示回到根目录</li>
<li>cd .. ：返回上级目录</li>
</ul>
<ul>
<li><strong>相对路径</strong> 在输入路径时, 最前面不是以 <code>/</code> 开始的 , 表示相对<strong>当前目录</strong>所在的目录位置<ul>
<li>例如： &#x2F;usr&#x2F;share&#x2F;doc</li>
</ul>
</li>
<li><strong>绝对路径</strong> 在输入路径时, 最前面是以 <code>/</code>  开始的, 表示从<strong>根目录</strong>开始的具体目录位置<ul>
<li>由 &#x2F;usr&#x2F;share&#x2F;doc 到 &#x2F;usr&#x2F;share&#x2F;man 时，可以写成： cd ..&#x2F;man</li>
<li>优点：定位准确, 不会因为 工作目录变化 而变化</li>
</ul>
</li>
</ul>
<h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>mkdir命令用于建立名称为 dirName 之子目录</p>
<p>命令：mkdir [-p] dirName</p>
<ul>
<li>-p 确保目录名称存在，不存在的就建一个，用来创建多级目录。</li>
</ul>
<p><code>mkdir -p aaa/bbb</code>：在 aaa 目录下，创建一个 bbb 的子目录。 若 aaa 目录原本不存在，则建立一个</p>
<h4 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h4><p>rmdir命令删除空的目录</p>
<p>命令：rmdir [-p] dirName</p>
<ul>
<li>-p 是当子目录被删除后使它也成为空目录的话，则顺便一并删除</li>
</ul>
<p><code>rmdir  -p aaa/bbb</code>：在 aaa 目录中，删除名为 bbb 的子目录。若 bbb 删除后，aaa 目录成为空目录，则 aaa 同时也会被删除</p>
<h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>cp 命令主要用于复制文件或目录</p>
<p>命令：cp  [options]  source… directory</p>
<ul>
<li>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合</li>
<li>-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式</li>
<li>-f：覆盖已经存在的目标文件而不给出提示</li>
<li>-i：与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 y 时目标文件将被覆盖</li>
<li>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</li>
<li>-r&#x2F;R：若给出的源文件是一个目录文件，此时将复制该目录下所有的<strong>子目录</strong>和文件</li>
<li>-l：不复制文件，只是生成链接文件</li>
</ul>
<p><code>cp –r aaa/*  ccc</code>：复制 aaa 下的所有文件到 ccc，不加参数 -r 或者 -R，只复制文件，而略过目录</p>
<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>rm命令用于删除一个文件或者目录。</p>
<p>命令：rm [options] name…</p>
<ul>
<li>-i 删除前逐一询问确认。</li>
<li>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认</li>
<li>-r 将目录及以下之档案亦逐一删除，递归删除</li>
</ul>
<p>注：文件一旦通过 rm 命令删除，则无法恢复，所以必须格外小心地使用该命令</p>
<h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>mv 命令用来为文件或目录改名、或将文件或目录移入其它位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv [options] source dest</span><br><span class="line">mv [options] source... directory</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-i：若指定目录已有同名文件，则先询问是否覆盖旧文件</p>
</li>
<li><p>-f：在 mv 操作要覆盖某已有的目标文件时不给任何指示</p>
<table>
<thead>
<tr>
<th>命令格式</th>
<th>运行结果</th>
</tr>
</thead>
<tbody><tr>
<td>mv  文件名  文件名</td>
<td>将源文件名改为目标文件名</td>
</tr>
<tr>
<td>mv  文件名  目录名</td>
<td>将文件移动到目标目录</td>
</tr>
<tr>
<td>mv  目录名  目录名</td>
<td>目标目录已存在，将源目录移动到目标目录。目标目录不存在则改名</td>
</tr>
<tr>
<td>mv  目录名  文件名</td>
<td>出错</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E7%94%A8%E6%88%B7%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6.png"></p>
<p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。</p>
<ul>
<li>当为 d 则是目录</li>
<li>当为 - 则是文件</li>
<li>若是 l 则表示为链接文档 link file</li>
<li>若是 b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)</li>
<li>若是 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)</li>
</ul>
<p>接下来的字符，以三个为一组，均为[rwx] 的三个参数组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现[ - ]。</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/文件权限.png" style="zoom: 50%;">

<p>从左至右用 0-9 这些数字来表示：</p>
<ul>
<li>第 0 位确定文件类型</li>
<li>第 1-3 位确定属主拥有该文件的权限</li>
<li>第 4-6 位确定属组拥有该文件的权限</li>
<li>第 7-9 位确定其他用户拥有该文件的权限</li>
</ul>
<hr>
<h4 id="文件信息"><a href="#文件信息" class="headerlink" title="文件信息"></a>文件信息</h4><p>对于一个文件，都有一个特定的所有者，也就是对该文件具有所有权的用户（属主）；还有这个文件是属于哪个组的（属组）</p>
<ul>
<li>文件的【属主】有一套【读写执行权限rwx】</li>
<li>文件的【属组】有一套【读写执行权限rwx】</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E5%88%97%E5%87%BA%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6.png"></p>
<p><code>ls -l</code> 可以查看文件夹下文件的详细信息, 从左到右 依次是:</p>
<ul>
<li>权限（A 区域）： 第一个字符如果是 <code>d</code> 表示目录</li>
<li>硬链接数（B 区域）：通俗的讲就是有多少种方式, 可以访问当前目录和文件</li>
<li>属主（C 区域）：文件是所有者、或是叫做属主</li>
<li>属组（D 区域）： 文件属于哪个组</li>
<li>大小（E 区域）：文件大小</li>
<li>时间（F 区域）：最后一次访问时间</li>
<li>名称（G 区域）：文件的名称</li>
</ul>
<hr>
<h4 id="更改权限"><a href="#更改权限" class="headerlink" title="更改权限"></a>更改权限</h4><h5 id="权限概述"><a href="#权限概述" class="headerlink" title="权限概述"></a>权限概述</h5><p>Linux 文件属性有两种设置方法，一种是数字，一种是符号</p>
<p>Linux 的文件调用权限分为三级 : 文件属主、属组、其他，利用 chmod 可以控制文件如何被他人所调用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [-cfvR] [--help] [--version] mode file...</span><br><span class="line">mode : 权限设定字串,格式: [ugoa...][[+-=][rwxX]...][,...]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>u 表示档案的拥有者，g 表示与该档案拥有者属于同一个 group 者，o 表示其他的人，a 表示这三者皆是</p>
</li>
<li><p>+表示增加权限、- 表示取消权限、&#x3D; 表示唯一设定权限</p>
</li>
<li><p>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有该档案是个子目录或者该档案已经被设定过为可执行</p>
</li>
</ul>
<h5 id="数字权限"><a href="#数字权限" class="headerlink" title="数字权限"></a>数字权限</h5><p>命令：chmod [-R] xyz 文件或目录</p>
<ul>
<li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加</li>
<li>-R : 进行递归（recursive）的持续变更，亦即连同次目录下的所有文件都会变更</li>
</ul>
<p>文件的权限字符为：[-rwxrwxrwx]， 这九个权限是三三一组的，我们使用数字来代表各个权限</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/权限数字表.png" style="zoom: 67%;">

<p>各权限的数字对照表：[r]:4、[w]:2、[x]:1、[-]:0</p>
<p>每种身份（owner&#x2F;group&#x2F;others）的三个权限（r&#x2F;w&#x2F;x）分数是需要累加的，例如权限为：[-rwxrwx—] 分数是</p>
<ul>
<li>owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li>
<li>group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li>
<li>others&#x3D; — &#x3D; 0+0+0 &#x3D; 0</li>
</ul>
<p>表示为：<code>chmod -R 770 文件名</code></p>
<h5 id="符号权限"><a href="#符号权限" class="headerlink" title="符号权限"></a>符号权限</h5><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E6%9D%83%E9%99%90%E7%AC%A6%E5%8F%B7%E8%A1%A8.png"></p>
<ul>
<li>user     属主权限</li>
<li>group  属组权限</li>
<li>others  其他权限</li>
<li>all  全部的身份</li>
</ul>
<p>我们就可以使用 <strong>u g o a</strong> 来代表身份的权限，读写的权限可以写成 <strong>r w x</strong></p>
<p><code>chmod u=rwx,g=rx,o=r  a.txt</code>：将as.txt的权限设置为 <strong>-rwxr-xr–</strong></p>
<p><code> chmod a-r a.txt</code>：将文件的所有权限去除 <strong>r</strong></p>
<hr>
<h4 id="更改属组"><a href="#更改属组" class="headerlink" title="更改属组"></a>更改属组</h4><p>chgrp 命令用于变更文件或目录的所属群组</p>
<p>文件或目录权限的的拥有者由所属群组来管理，可以使用 chgrp 指令去变更文件与目录的所属群组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chgrp [-cfhRv][--help][--version][所属群组][文件或目录...]</span><br><span class="line">chgrp [-cfhRv][--help][--reference=&lt;参考文件或目录&gt;][--version][文件或目录...]</span><br></pre></td></tr></table></figure>

<p>chgrp -v root aaa：将文件 aaa 的属组更改成 root（其他也可以）</p>
<hr>
<h4 id="更改属主"><a href="#更改属主" class="headerlink" title="更改属主"></a>更改属主</h4><p>利用 chown 可以将档案的拥有者加以改变。</p>
<p>使用权限 : 管理员账户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown [–R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名:属组名 文件名</span><br></pre></td></tr></table></figure>

<p>chown root aaa：将文件aaa的属主更改成root</p>
<p>chown seazean:seazean aaa：将文件aaa的属主和属组更改为seazean</p>
<hr>
<h3 id="文件操作-2"><a href="#文件操作-2" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>touch 命令用于创建文件、修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…]</span><br></pre></td></tr></table></figure>

<ul>
<li>-a  改变档案的读取时间记录</li>
<li>-m 改变档案的修改时间记录</li>
<li>-c  假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样</li>
<li>-f  不使用，是为了与其他 unix 系统的相容性而保留</li>
<li>-r  使用参考档的时间记录，与 –file 的效果一样</li>
<li>-d 设定时间与日期，可以使用各种不同的格式</li>
<li>-t  设定档案的时间记录，格式与 date 指令相同</li>
<li>–no-create 不会建立新档案</li>
<li>–help 列出指令格式</li>
<li>–version 列出版本讯息</li>
</ul>
<p><code>touch t.txt</code>：创建 t.txt 文件</p>
<p><code>touch t&#123;1..10&#125;.txt</code>：创建10 个名为 t1.txt 到 t10.txt 的空文件</p>
<p><code>touch t.txt</code>：更改 t.txt 的访问时间为现在</p>
<h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><p>stat 命令用于显示 inode 内容</p>
<p>命令：stat [文件或目录]</p>
<h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>cat 是一个文本文件查看和连接工具，<strong>用于小文件</strong></p>
<p>命令：cat [-AbeEnstTuv] [–help] [–version] Filename</p>
<ul>
<li>-n  显示文件加上行号</li>
<li>-b  和 -n 相似，只不过对于空白行不编号</li>
</ul>
<h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>less 用于查看文件，但是 less 在查看之前不会加载整个文件，<strong>用于大文件</strong></p>
<p>命令：less [options] Filename</p>
<ul>
<li>-N  显示每行行号</li>
</ul>
<h4 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h4><p>tail 命令可用于查看文件的内容，有一个常用的参数 <strong>-f</strong> 常用于查阅正在改变的日志文件</p>
<p>命令：tail  [options]  Filename</p>
<ul>
<li>-f  循环读取,动态显示文档的最后内容</li>
<li>-n  显示文件的尾部 n 行内容</li>
<li>-c 显示字节数</li>
<li>-nf 查看最后几行日志信息</li>
</ul>
<p><code>tail -f filename</code>：动态显示最尾部的内容</p>
<p><code>tail -n +2  txtfile.txt</code>：显示文件 txtfile.txt 的内容，从第 2 行至文件末尾</p>
<p><code>tail -n 2  txtfile.txt</code>：显示文件 txtfile.txt 的内容，最后 2 行</p>
<h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p>head 命令可用于查看文件的开头部分的内容，有一个常用的参数 <strong>-n</strong> 用于显示行数，默认为 10</p>
<ul>
<li>-q 隐藏文件名</li>
<li>-v 显示文件名</li>
<li>-c 显示的字节数</li>
<li>-n 显示的行数</li>
</ul>
<p><code>head -n Filename</code>：查看文件的前一部分</p>
<p><code>head -n 20 Filename</code>：查看文件的前 20 行</p>
<h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>grep 指令用于查找内容包含指定的范本样式的文件，若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]</span><br></pre></td></tr></table></figure>

<ul>
<li>-c 只输出匹配行的计数</li>
<li>-i 不区分大小写</li>
<li>-h 查询多文件时不显示文件名</li>
<li>-l 查询多文件时只输出包含匹配字符的文件名</li>
<li>-n 显示匹配行及行号</li>
<li>-s 不显示不存在或无匹配文本的错误信息</li>
<li>-v 显示不包含匹配文本的所有行</li>
<li>–color&#x3D;auto 可以将找到的关键词部分加上颜色的显示</li>
</ul>
<p>**管道符 |**：表示将前一个命令处理的结果传递给后面的命令处理</p>
<ul>
<li><code>grep aaaa Filename </code>：显示存在关键字 aaaa 的行</li>
<li><code>grep -n aaaa Filename</code>：显示存在关键字 aaaa 的行，且显示行号</li>
<li><code>grep -i aaaa Filename</code>：忽略大小写，显示存在关键字 aaaa 的行</li>
<li><code>grep -v aaaa Filename</code>：显示存在关键字 aaaa 的所有行</li>
<li><code>ps -ef | grep  sshd</code>：查找包含 sshd 进程的进程信息</li>
<li><code> ps -ef | grep -c sshd</code>：查找 sshd 相关的进程个数</li>
</ul>
<h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><p>将字符串输出到控制台 ,  通常和重定向联合使用</p>
<p>命令：echo string，如果字符串有空格, 为了避免歧义 请增加 双引号 或者 单引号</p>
<ul>
<li>通过 <code>命令 &gt; 文件</code>  将命令的成功结果覆盖指定文件内容</li>
<li>通过 <code>命令 &gt;&gt; 文件</code>   将命令的成功结果追加指定文件的后面</li>
<li>通过 <code>命令 &amp;&gt;&gt; 文件</code> 将 命令的失败结果追加指定文件的后面</li>
</ul>
<p><code>echo &quot;程序员&quot; &gt;&gt; a.txt</code>：将程序员追加到 a.txt 后面</p>
<p><code>cat 不存在的目录 &amp;&gt;&gt; error.log</code>：将错误信息追加到 error.log 文件</p>
<h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><p>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk [options] &#x27;script&#x27; var=value file(s)</span><br><span class="line">awk [options] -f scriptfile var=value file(s)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-F fs：指定输入文件折分隔符，fs 是一个字符串或者是一个正则表达式</p>
</li>
<li><p>-v：var&#x3D;value 赋值一个用户定义变量</p>
</li>
<li><p>-f：从脚本文件中读取 awk 命令</p>
</li>
<li><p>$n：获取<strong>第几段</strong>内容</p>
</li>
<li><p>$0：获取<strong>当前行</strong> 内容</p>
</li>
<li><p>NF：表示当前行共有多少个字段</p>
</li>
<li><p>$NF：代表最后一个字段</p>
</li>
<li><p>$(NF-1)：代表倒数第二个字段</p>
</li>
<li><p>NR：代表处理的是第几行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">命令：awk <span class="string">&#x27;BEGIN&#123;初始化操作&#125;&#123;每行都执行&#125; END&#123;结束时操作&#125;&#x27;</span>   </span><br><span class="line">文件名BEGIN&#123; 这里面放的是执行前的语句 &#125;&#123;这里面放的是处理每一行时要执行的语句&#125;</span><br><span class="line">END &#123;这里面放的是处理完所有的行后要执行的语句 &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//准备数据</span><br><span class="line">zhangsan 68 99 26</span><br><span class="line">lisi 98 66 96</span><br><span class="line">wangwu 38 33 86</span><br><span class="line">zhaoliu 78 44 36</span><br><span class="line">maq 88 22 66</span><br><span class="line">zhouba 98 44 46</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>cat a.txt | awk  &#39;/zhang|li/&#39;</code>：搜索含有 zhang  和 li 的学生成绩</p>
</li>
<li><p><code>awk &quot;/zhang|li/&quot; a.txt </code>：同上一个命令，效果一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zhangsan 68 99 26</span><br><span class="line">lisi 98 66 96</span><br><span class="line">zhaoliu 78 44 36</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>cat a.txt | awk -F &#39; &#39; &#39;&#123;print $1,$2,$3&#125;&#39;</code>：按照空格分割，打印 一二三列内容</p>
</li>
<li><p><code>awk -F &#39; &#39; &#39;&#123;OFS=&quot;\t&quot;&#125;&#123;print $1,$2,$3&#125;&#39;</code>：按照制表符 tab 进行分割，打印一二三列<br>\b：退格      \f：换页      \n：换行      \r：回车      \t：制表符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zhangsan	68	99</span><br><span class="line">lisi	98	66</span><br><span class="line">wangwu	38	33</span><br><span class="line">zhaoliu	78	44</span><br><span class="line">maq	88	22</span><br><span class="line">zhouba	98	44</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>awk -F &#39;,&#39; &#39;&#123;print  toupper($1)&#125;&#39; a.txt</code>：根据逗号分割，打印内容，第一段大写</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>含义</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>toupper()</td>
<td>upper</td>
<td>字符 转成 大写</td>
</tr>
<tr>
<td>tolower()</td>
<td>lower</td>
<td>字符 转成小写</td>
</tr>
<tr>
<td>length()</td>
<td>length</td>
<td>返回 字符长度</td>
</tr>
</tbody></table>
</li>
<li><p><code>awk -F &#39; &#39; &#39;BEGIN&#123;&#125;&#123;total=total+$4&#125; END&#123;print total&#125;&#39; a.txt</code>：计算的是第4列的总分</p>
</li>
<li><p><code>awk -F &#39; &#39; &#39;BEGIN&#123;&#125;&#123;total=total+$4&#125; END&#123;print total, NR&#125;&#39; a.txt</code> ：查看总分, 总人数</p>
</li>
<li><p><code>awk -F &#39; &#39; &#39;BEGIN&#123;&#125;&#123;total=total+$4&#125; END&#123;print total, NR, (total/NR)&#125;&#39; a.txt</code>：查看总分, 总人数，平均数</p>
</li>
<li><p><code>cat a.txt | awk -F &#39; &#39; &#39;BEGIN&#123;&#125;&#123;total=total+$4&#125; END&#123;print total&#125;&#39; </code>：可以这样写</p>
</li>
</ul>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find 命令用来在指定目录下查找文件，如果使用该命令不设置任何参数，将在当前目录下查找子目录与文件，并且将查找到的子目录和文件全部进行显示</p>
<p>命令：find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定内容&gt;</p>
<ul>
<li><code>find . -name &quot;*.gz&quot;</code>：将目前目录及其子目录下所有延伸档名是 gz 的文件查询出来</li>
<li><code>find . -ctime -1</code>：将目前目录及其子目录下所有最近 1 天内更新过的文件查询出来</li>
<li><code> find / -name  &#39;seazean&#39;</code>：全局搜索 seazean</li>
</ul>
<h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p>read 命令用于从标准输入读取数值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]</span><br></pre></td></tr></table></figure>



<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>Linux sort 命令用于将文本文件内容加以排序</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span> [-bcdfimMnr][文件]</span><br></pre></td></tr></table></figure>

<ul>
<li>-n 依照数值的大小排序</li>
<li>-r 以相反的顺序来排序（sort 默认的排序方式是<strong>升序</strong>，改成降序，加 -r）</li>
<li>-u 去掉重复</li>
</ul>
<p>面试题：一列数字，输出最大的 4 个不重复的数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span> -ur a.txt | <span class="built_in">head</span> -n 4</span><br><span class="line"><span class="built_in">sort</span> -r a.txt | <span class="built_in">uniq</span> |  <span class="built_in">head</span> -n 4</span><br></pre></td></tr></table></figure>



<h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p>uniq 用于重复数据处理，使用前先 sort 排序</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uniq</span> [OPTION]... [INPUT [OUTPUT]]</span><br></pre></td></tr></table></figure>

<ul>
<li>-c 在数据行前出现的次数</li>
<li>-d 只打印重复的行，重复的行只显示一次</li>
<li>-D 只打印重复的行，重复的行出现多少次就显示多少次</li>
<li>-f 忽略行首的几个字段</li>
<li>-i 忽略大小写</li>
<li>-s 忽略行首的几个字母</li>
<li>-u 只打印唯一的行</li>
<li>-w 比较不超过 n 个字母</li>
</ul>
<hr>
<h3 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h3><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>tar 的主要功能是打包、压缩和解压文件，tar 本身不具有压缩功能，是调用压缩功能实现的。</p>
<p>命令：tar  [必要参数]   [选择参数]   [文件] </p>
<ul>
<li>-c   产生 .tar 文件</li>
<li>-v   显示详细信息	</li>
<li>-z   打包同时压缩</li>
<li>-f   指定压缩后的文件名</li>
<li>-x   解压 .tar 文件</li>
<li>-t   列出 tar 文件中包含的文件的信息</li>
<li>-r   附加新的文件到tar文件中</li>
</ul>
<p><code>tar -cvf txt.tar txtfile.txt </code>：将 txtfile.txt 文件打包（仅打包，不压缩）</p>
<p><code>tar -zcvf combine.tar.gz 1.txt 2.txt 3.txt</code>：将 123.txt 文件打包压缩（gzip）</p>
<p><code>tar -ztvf txt.tar.gz</code>：查看 tar 中有哪些文件</p>
<p><code>tar -zxvf Filename -C 目标路径</code>：解压</p>
<h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4><p>gzip命令用于压缩文件。</p>
<p>gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名</p>
<ul>
<li>gzip * ：压缩目录下的所有文件，删除源文件。不支持直接压缩目录</li>
<li>gzip -rv 目录名：递归压缩目录</li>
<li>gzip -dv *：解压文件并列出详细信息</li>
</ul>
<h4 id="gunzip"><a href="#gunzip" class="headerlink" title="gunzip"></a>gunzip</h4><p>gunzip命令用于解压文件。用于解开被gzip压缩过的文件</p>
<p>命令：gunzip  [options]  [文件或者目录]</p>
<p>gunzip 001.gz ：解压001.gz文件</p>
<h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><p>zip 命令用于压缩文件。</p>
<p>zip 是个使用广泛的压缩程序，文件经它压缩后会另外产生具有 <code>.zip</code> 扩展名的压缩文件</p>
<p>命令：zip  [必要参数]  [选择参数]  [文件] </p>
<ul>
<li>-q 不显示指令执行过程</li>
<li>-r 递归处理，将指定目录下的所有文件和子目录一并处理</li>
</ul>
<p><code>zip -q -r z.zip *</code>：将该目录的文件全部压缩</p>
<h4 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h4><p>unzip 命令用于解压缩 zip 文件，unzip 为 <code>.zip</code> 压缩文件的解压缩程序</p>
<p>命令：unzip  [必要参数]  [选择参数]  [文件] </p>
<ul>
<li><p>-l  查看压缩文件内所包含的文件</p>
</li>
<li><p>-d&lt;目录&gt; 指定文件解压缩后所要存储的目录。</p>
</li>
</ul>
<p><code>unzip -l z.zip</code> ：查看压缩文件中包含的文件</p>
<p><code>unzip -d ./unFiles z.zip</code>：把文件解压到指定的目录下</p>
<h4 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h4><p>bzip2 命令是 <code>.bz2</code> 文件的压缩程序。</p>
<p>bzip2 采用新的压缩演算法，压缩效果比传统的 LZ77&#x2F;LZ78 压缩演算法好，若不加任何参数，bzip2 压缩完文件后会产生 .bz2 的压缩文件，并删除原始的文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bzip2 [-cdfhkLstvVz][--repetitive-best][--repetitive-fast][- 压缩等级][要压缩的文件]</span><br></pre></td></tr></table></figure>

<p>压缩：bzip2 a.txt</p>
<h4 id="bunzip2"><a href="#bunzip2" class="headerlink" title="bunzip2"></a>bunzip2</h4><p>bunzip2 命令是 <code>.bz2</code> 文件的解压缩程序。</p>
<p>命令：bunzip2  [-fkLsvV]  [.bz2压缩文件]</p>
<ul>
<li>-v　解压缩文件时，显示详细的信息。</li>
</ul>
<p>解压：bunzip2 -v a.bz2 </p>
<hr>
<h3 id="文件编辑"><a href="#文件编辑" class="headerlink" title="文件编辑"></a>文件编辑</h3><h4 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h4><p>vim：是从 vi 发展出来的一个文本编辑器</p>
<ul>
<li>命令模式：在 Linux 终端中输入<code>vim 文件名</code> 就进入了命令模式，但不能输入文字</li>
<li>编辑模式：在命令模式下按 <code>i</code> 就会进入编辑模式，此时可以写入程式，按 Esc 可回到命令模式</li>
<li>末行模式：在命令模式下按 <code>:</code> 进入末行模式，左下角会有一个冒号，可以敲入命令并执行</li>
</ul>
<h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>Ubuntu 默认没有安装 vim，需要先安装 vim，安装命令：<strong>sudo apt-get install vim</strong></p>
<p>Vim 有三种模式：命令模式（Command mode）、插入模式（Insert mode）、末行模式（Last Line mode）</p>
<table>
<thead>
<tr>
<th align="center">Vim 使用的选项</th>
<th align="center">说明</th>
<th align="center">常用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">vim filename</td>
<td align="center">打开或新建一个文件，将光标置于第一行首部</td>
<td align="center">常用</td>
</tr>
<tr>
<td align="center">vim -r filename</td>
<td align="center">恢复上次vim打开时崩溃的文件</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">vim -R filename</td>
<td align="center">把指定的文件以只读的方式放入Vim编辑器</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">vim + filename</td>
<td align="center">打开文件，将光标置于最后一行的首部</td>
<td align="center">常用</td>
</tr>
<tr>
<td align="center">vim +n filename</td>
<td align="center">打开文件，将光标置于n行的首部</td>
<td align="center">常用</td>
</tr>
<tr>
<td align="center">vim +&#x2F;pattern filename</td>
<td align="center">打开文件，将光标置于第一个与pattern匹配的位置</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">vim -c command filename</td>
<td align="center">对文件编辑前，先执行指定的命令</td>
<td align="center"></td>
</tr>
</tbody></table>
<hr>
<h4 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h4><p>在命令模式下，通过按下 i、I、a、A、o、O 这 6 个字母进入插入模式</p>
<table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td align="center">在光标所在位置插入文本，光标后的文本向右移动</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">在光标所在行的行首插入文本，行首是该行的第一个非空白字符</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">在光标所在行的下面插入新的一行，光标停在空行首</td>
</tr>
<tr>
<td align="center">O</td>
<td align="center">在光标所在行的上面插入新的一行，光标停在空行首</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">在光标所在位置之后插入文本</td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">在光标所在行的行尾插入文本</td>
</tr>
</tbody></table>
<p>按下 ESC 键，离开插入模式，进入命令模式</p>
<p>因为我们是一个空文件，所以使用【I】或者【i】都可以</p>
<p>如果里面的文本很多，要使用【A】进入编辑模式，即在行末添加文本</p>
<hr>
<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>Vim 打开一个文件（文件可以存在，也可以不存在），默认进入命令模式。在该模式下， 输入的字符会被当做指令，而不会被当做要输入的文字</p>
<h5 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h5><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">w</td>
<td align="center">光标移动至下一个单词的单词首</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">光标移动至上一个单词的单词首</td>
</tr>
<tr>
<td align="center">e</td>
<td align="center">光标移动至下一个单词的单词尾</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">光标移动至当前行的行首</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">行首, 第一个不是空白字符的位置</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">光标移动至当前行的行尾</td>
</tr>
<tr>
<td align="center">gg</td>
<td align="center">光标移动至文件开头</td>
</tr>
<tr>
<td align="center">G</td>
<td align="center">光标移动至文件末尾</td>
</tr>
<tr>
<td align="center">ngg</td>
<td align="center">光标移动至第n行</td>
</tr>
<tr>
<td align="center">nG</td>
<td align="center">光标移动至第n行</td>
</tr>
<tr>
<td align="center">:n</td>
<td align="center">光标移动至第n行</td>
</tr>
</tbody></table>
<hr>
<h5 id="选中文本"><a href="#选中文本" class="headerlink" title="选中文本"></a>选中文本</h5><p>在 vi&#x2F;vim 中要选择文本，需要显示 visual 命令切换到<strong>可视模式</strong></p>
<p>vi&#x2F;vim 中提供了三种可视模式，方便程序员的选择<strong>选中文本的方式</strong></p>
<p>按 ESC 可以放弃选中, 返回到<strong>命令模式</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>模式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>v</td>
<td>可视模式</td>
<td>从光标位置开始按照正常模式选择文本</td>
</tr>
<tr>
<td>V</td>
<td>可视化模式</td>
<td>选中光标经过的完整行</td>
</tr>
<tr>
<td>Ctrl + v</td>
<td>可是块模式</td>
<td>垂直方向选中文本</td>
</tr>
</tbody></table>
<h5 id="撤销删除"><a href="#撤销删除" class="headerlink" title="撤销删除"></a>撤销删除</h5><p>在学习编辑命令之前,先要知道怎样撤销之前一次错误的编辑操作</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>undo</td>
<td>撤销上次的命令(ctrl + z)</td>
</tr>
<tr>
<td>Ctrl + r</td>
<td>uredo</td>
<td>恢复撤销的命令</td>
</tr>
</tbody></table>
<p>删除的内容此时并没有真正的被删除，在剪切板中，按下 p 键，可以将删除的内容粘贴回来</p>
<table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x</td>
<td align="center">删除光标所在位置的字符</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">删除移动命令对应的内容</td>
</tr>
<tr>
<td align="center">dd</td>
<td align="center">删除光标所在行的内容</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">删除光标位置到行尾的内容</td>
</tr>
<tr>
<td align="center">:n1,n2</td>
<td align="center">删除从 a1 到 a2 行的文本内容</td>
</tr>
</tbody></table>
<p><strong>删除命令可以和移动命令连用, 以下是常见的组合命令(扩展):</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>dw</td>
<td>删除从光标位置到单词末尾</td>
</tr>
<tr>
<td>d}</td>
<td>删除从光标位置到段落末尾</td>
</tr>
<tr>
<td>dG</td>
<td>删除光标所行到文件末尾的所有内容</td>
</tr>
<tr>
<td>ndd</td>
<td>删除当前行（包括此行）到后 n 行内容</td>
</tr>
</tbody></table>
<hr>
<h5 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h5><p>vim 中提供有一个 被复制文本的缓冲区</p>
<ul>
<li>复制命令会将选中的文字保存在缓冲区</li>
<li>删除命令删除的文字会被保存在缓冲区</li>
<li>在需要的位置，使用粘贴命令可以将缓冲对的文字插入到光标所在的位置</li>
<li>vim 中的文本缓冲区只有一个，如果后续做过复制、剪切操作，之前缓冲区中的内容会被替换</li>
</ul>
<table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">y</td>
<td align="center">复制已选中的文本到剪切板</td>
</tr>
<tr>
<td align="center">yy</td>
<td align="center">将光标所在行复制到剪切板</td>
</tr>
<tr>
<td align="center">nyy</td>
<td align="center">复制从光标所在行到向下n行</td>
</tr>
<tr>
<td align="center">p</td>
<td align="center">将剪切板中的内容粘贴到光标后</td>
</tr>
<tr>
<td align="center">P</td>
<td align="center">将剪切板中的内容粘贴到光标前</td>
</tr>
</tbody></table>
<p>注意：<strong>vim 中的文本缓冲区和系统的剪切板不是同一个</strong>，在其他软件中使用 Ctrl + C 复制的内容，不能在 vim 中通过 <code>p</code> 命令粘贴，可以在编辑模式下使用鼠标右键粘贴</p>
<hr>
<h5 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h5><p>查找</p>
<table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x2F;abc</td>
<td align="center">从光标所在位置向后查找字符串 abc</td>
</tr>
<tr>
<td align="center">&#x2F;^abc</td>
<td align="center">查找以 abc 为行首的行</td>
</tr>
<tr>
<td align="center">&#x2F;abc$</td>
<td align="center">查找以 abc 为行尾的行</td>
</tr>
<tr>
<td align="center">?abc</td>
<td align="center">从光标所在位置向前查找字符串 abc</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">向后查找当前光标所在单词</td>
</tr>
<tr>
<td align="center">#</td>
<td align="center">向前查找当前光标所在单词</td>
</tr>
<tr>
<td align="center">n</td>
<td align="center">查找下一个，向同一方向重复上次的查找指令</td>
</tr>
<tr>
<td align="center">N</td>
<td align="center">查找上一个，向相反方向重复上次的查找指令</td>
</tr>
</tbody></table>
<p>替换：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>工作模式</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>替换当前字符</td>
<td>命令模式</td>
</tr>
<tr>
<td>R</td>
<td>替换当前行光标后的字符</td>
<td>替换模式</td>
</tr>
</tbody></table>
<ul>
<li>光标选中要替换的字符</li>
<li><code>R</code> 命令可以进入替换模式，替换完成后，按下 ESC 可以回到命令模式</li>
<li>替换命令的作用就是不用进入编辑模式，对文件进行轻量级的修改</li>
</ul>
<hr>
<h4 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h4><p>在命令模式下，按下 <code>:</code> 键进入末行模式</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:wq</td>
<td align="center">保存并退出 Vim 编辑器</td>
</tr>
<tr>
<td align="center">:wq!</td>
<td align="center">保存并强制退出 Vim 编辑器</td>
</tr>
<tr>
<td align="center">:q</td>
<td align="center">不保存且退出 Vim 编辑器</td>
</tr>
<tr>
<td align="center">:q!</td>
<td align="center">不保存且强制退出 Vim 编辑器</td>
</tr>
<tr>
<td align="center">:w</td>
<td align="center">保存但是不退出 Vim 编辑器</td>
</tr>
<tr>
<td align="center">:w!</td>
<td align="center">强制保存但是不退出 Vim 编辑器</td>
</tr>
<tr>
<td align="center">:w filename</td>
<td align="center">另存到 filename 文件</td>
</tr>
<tr>
<td align="center">x!</td>
<td align="center">保存文本，退出保存但是不退出 Vim 编辑器，更通用的命令</td>
</tr>
<tr>
<td align="center">ZZ</td>
<td align="center">直接退出保存但是不退出 Vim 编辑器</td>
</tr>
<tr>
<td align="center">:n</td>
<td align="center">光标移动至第 n 行行首</td>
</tr>
</tbody></table>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul>
<li><p>如果 vim 异常退出, 在磁盘上可能会保存有 交换文件</p>
</li>
<li><p>下次再使用 vim 编辑文件时，会看到以下屏幕信息：</p>
<p>  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/vim%E5%BC%82%E5%B8%B8.png"></p>
</li>
<li><p>ls -a 一下，会看到隐藏的 .swp 文件，删除了此文件即可</p>
</li>
</ul>
<hr>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> [-sf] source_filename dist_filename</span><br></pre></td></tr></table></figure>

<ul>
<li>-s：默认是实体链接，加 -s 为符号链接</li>
<li>-f：如果目标文件存在时，先删除目标文件</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/文件链接.png" style="zoom: 80%;">

<p><strong>实体链接</strong>：</p>
<ul>
<li>在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode</li>
<li>删除任意一个条目，文件还是存在，只要引用数量不为 0</li>
<li>不能跨越文件系统、不能对目录进行链接</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> /etc/crontab .</span><br><span class="line">ll</span><br><span class="line">34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab</span><br><span class="line">34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab</span><br></pre></td></tr></table></figure>

<p><strong>符号链接</strong>：</p>
<ul>
<li><p>符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式</p>
</li>
<li><p>当源文件被删除了，链接文件就打不开了</p>
</li>
<li><p>记录的是路径，所以可以为目录建立符号链接</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab</span><br><span class="line">53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>ps 指令：查看某个时间点的进程信息</p>
<p>top 指令：实时显示进程信息</p>
<p>pstree：查看进程树</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pstree -A	<span class="comment">#查看所有进程树</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="进程-ID"><a href="#进程-ID" class="headerlink" title="进程 ID"></a>进程 ID</h3><p>进程号：</p>
<ul>
<li><p>进程号为 0 的进程通常是调度进程，常常被称为交换进程（swapper），该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程</p>
</li>
<li><p>进程号为 1 是 init 进程，是一个守护进程，在自举过程结束时由内核调用，init 进程绝不会终止，是一个普通的用户进程，但是它以超级用户特权运行</p>
</li>
</ul>
<p>父进程 ID 为 0 的进程通常是内核进程，作为系统<strong>自举过程</strong>的一部分而启动，init 进程是个例外，它的父进程是 0，但它是用户进程</p>
<ul>
<li>主存 &#x3D; RAM + BIOS 部分的 ROM</li>
<li>DISK：存放 OS 和 Bootloader</li>
<li>BIOS：基于 I&#x2F;O 处理系统</li>
<li>Bootloader：加载 OS，将 OS 放入内存</li>
</ul>
<p>自举程序存储在内存中 ROM，<strong>用来加载操作系统</strong>，初始化 CPU、寄存器、内存等。CPU 的程序计数器指自举程序第一条指令，当计算机<strong>通电</strong>，CPU 开始读取并执行自举程序，将操作系统（不是全部，只是启动计算机的那部分程序）装入 RAM 中，这个过程是自举过程。装入完成后程序计数器设置为 RAM 中操作系统的<strong>第一条指令</strong>，接下来 CPU 将开始执行（启动）操作系统的指令</p>
<p>存储在 ROM 中保留很小的自举装入程序，完整功能的自举程序保存在磁盘的启动块上，启动块位于磁盘的固定位，拥有启动分区的磁盘称为启动磁盘或系统磁盘（C 盘）</p>
<hr>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>running or runnable (on run queue) 正在执行或者可执行，此时进程位于执行队列中</td>
</tr>
<tr>
<td>D</td>
<td>uninterruptible sleep (usually I&#x2F;O) 不可中断阻塞，通常为 IO 阻塞</td>
</tr>
<tr>
<td>S</td>
<td>interruptible sleep (waiting for an event to complete) 可中断阻塞，此时进程正在等待某个事件完成</td>
</tr>
<tr>
<td>Z</td>
<td>zombie (terminated but not reaped by its parent) 僵死，进程已经终止但是尚未被其父进程获取信息</td>
</tr>
<tr>
<td>T</td>
<td>stopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪</td>
</tr>
</tbody></table>
<p>孤儿进程：</p>
<ul>
<li>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程</li>
<li>孤儿进程将被 init 进程所收养，并由 init 进程对它们完成状态收集工作，所以孤儿进程不会对系统造成危害</li>
</ul>
<p>僵尸进程：</p>
<ul>
<li>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程</li>
<li>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）</li>
<li>系统所能使用的进程号是有限的，产生大量僵尸进程，会导致系统没有可用的进程号而不能产生新的进程</li>
<li>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程</li>
</ul>
<p>补充：</p>
<ul>
<li>守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。</li>
<li>守护进程是<strong>脱离于终端</strong>并且在后台运行的进程，脱离终端是为了避免在执行的过程中的信息在终端上显示，并且进程也不会被任何终端所产生的终端信息所打断</li>
<li>很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭；另一些只在需要的时候才启动，完成任务后就自动结束</li>
</ul>
<hr>
<h3 id="状态改变"><a href="#状态改变" class="headerlink" title="状态改变"></a>状态改变</h3><h4 id="SIGCHLD"><a href="#SIGCHLD" class="headerlink" title="SIGCHLD"></a>SIGCHLD</h4><p>当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：</p>
<ul>
<li>得到 SIGCHLD 信号</li>
<li>waitpid() 或者 wait() 调用会返回</li>
</ul>
<p>子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等；在子进程退出时进程描述符不会立即释放，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息，释放子进程的 PCB</p>
<hr>
<h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span></span><br></pre></td></tr></table></figure>

<p>参数：status 用来保存被收集的子进程退出时的状态，如果不关心子进程<strong>如何</strong>销毁，可以设置这个参数为 NULL</p>
<p>父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，wait() 函数就会销毁子进程并返回</p>
<ul>
<li>成功，返回被收集的子进程的进程 ID</li>
<li>失败，返回 -1，同时 errno 被置为 ECHILD（如果调用进程没有子进程，调用就会失败）</li>
</ul>
<hr>
<h4 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span></span><br></pre></td></tr></table></figure>

<p>作用和 wait() 完全相同，只是多了两个可控制的参数 pid 和 options</p>
<ul>
<li>pid：指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号；如果 pid&#x3D;-1 时，那么和 wait() 作用相同，都是关注所有子进程退出的 SIGCHLD 信号</li>
<li>options：主要有 WNOHANG 和 WUNTRACED 两个，WNOHANG 可以使 waitpid() 调用变成非阻塞的，就是会立即返回，父进程可以继续执行其它任务</li>
</ul>
<hr>
<h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><ul>
<li><p>启动：service network start</p>
</li>
<li><p>停止：service network stop</p>
</li>
<li><p>重启：service network restart</p>
</li>
</ul>
<hr>
<h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>ifconfig 是 Linux 中用于显示或配置网络设备的命令，英文全称是 network interfaces configuring</p>
<p>ifconfig 命令用于显示或设置网络设备。ifconfig 可设置网络设备的状态，或是显示目前的设置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ifconfig [网络设备][down up -allmulti -arp -promisc][add&lt;地址&gt;][del&lt;地址&gt;][&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;][io_addr&lt;I/O地址&gt;][irq&lt;IRQ地址&gt;][media&lt;网络媒介类型&gt;][mem_start&lt;内存地址&gt;][metric&lt;数目&gt;][mtu&lt;字节&gt;][netmask&lt;子网掩码&gt;][tunnel&lt;地址&gt;][-broadcast&lt;地址&gt;][-pointopoint&lt;地址&gt;][IP地址]</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ifconfig</code>：显示激活的网卡信息  ens</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/网卡信息.png">

<p>ens33（或 eth0）表示第一块网卡，IP地址是 192.168.0.137，广播地址 broadcast 192.168.0.255，掩码地址netmask 255.255.255.0 ，inet6 对应的是 ipv6</p>
<p>lo 是表示主机的<strong>回坏地址</strong>，用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口 </p>
</li>
<li><p>ifconfig ens33 down：关闭网卡</p>
</li>
<li><p>ifconfig ens33 up：启用网卡</p>
</li>
</ul>
<hr>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>ping 命令用于检测主机</p>
<p>执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping [-dfnqrRv][-c&lt;完成次数&gt;][-i&lt;间隔秒数&gt;][-I&lt;网络界面&gt;][-l&lt;前置载入&gt;][-p&lt;范本样式&gt;][-s&lt;数据包大小&gt;][-t&lt;存活数值&gt;][主机名称或IP地址]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-c&lt;完成次数&gt;：设置完成要求回应的次数；</p>
</li>
<li><p><code>ping -c 2 www.baidu.com</code><br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/ping%E7%99%BE%E5%BA%A6.png"></p>
<p>icmp_seq：ping 序列，从1开始</p>
<p>ttl：IP 生存时间值</p>
<p>time：响应时间,数值越小，联通速度越快</p>
</li>
</ul>
<hr>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>netstat 命令用于显示网络状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip]</span><br></pre></td></tr></table></figure>

<ul>
<li>-a   显示所有连线中的 Socket，显示详细的连接状况</li>
<li>-i    显示网络界面信息表单，显示网卡列表</li>
<li>-p  显示正在使用 Socket 的程序识别码和程序名称</li>
<li>-n  显示使用 IP 地址，而不通过域名服务器</li>
<li>-t   显示 TCP 传输协议的连线状况。</li>
<li>-u  显示 UDP 传输协议的连线状况</li>
<li><strong>-aptn：查看所有 TCP 开启端口</strong></li>
<li><strong>-apun：查看所有 UDP 开启端口</strong></li>
</ul>
<p>补充：</p>
<ul>
<li>netstat -apn | grep port：查看指定端口号</li>
<li>lsof -i:port ：查看指定端口号</li>
</ul>
<hr>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="挂载概念"><a href="#挂载概念" class="headerlink" title="挂载概念"></a>挂载概念</h3><p>在安装 Linux 系统时设立的各个分区，如根分区、&#x2F;boot 分区等都是自动挂载的，也就是说不需要人为操作，开机就会自动挂载。但是光盘、U 盘等存储设备如果需要使用，就必须人为的进行挂载</p>
<p>在 Windows 下插入 U 盘也是需要挂载（分配盘符）的，只不过 Windows 下分配盘符是自动的。其实挂载可以理解为 Windows 当中的分配盘符，只不过 Windows 当中是以英文字母 ABCD 等作为盘符，而 Linux 是拿系统目录作为盘符，当然 Linux 当中也不叫盘符，而是称为挂载点，而把为分区或者光盘等存储设备分配一个挂载点的过程称为挂载</p>
<p>Linux 中的根目录以外的文件要想被访问，需要将其关联到根目录下的某个目录来实现，这种关联操作就是挂载，这个目录就是挂载点，解除次关联关系的过程称之为卸载</p>
<p>挂载点的目录需要以下几个要求：</p>
<ul>
<li>目录要先存在，可以用 mkdir 命令新建目录</li>
<li>挂载点目录不可被其他进程使用到</li>
<li>挂载点下原有文件将被隐藏</li>
</ul>
<hr>
<h3 id="lsblk"><a href="#lsblk" class="headerlink" title="lsblk"></a>lsblk</h3><p>lsblk 命令的英文是 list block，即用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是不会列出 RAM 盘的信息</p>
<p>命令：lsblk [参数]</p>
<ul>
<li><p><code>lsblk</code>：以树状列出所有块设备<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E5%8F%AF%E7%94%A8%E5%9D%97%E8%AE%BE%E5%A4%87.png"></p>
<p>NAME：这是块设备名</p>
<p>MAJ：MIN : 本栏显示主要和次要设备号</p>
<p>RM：本栏显示设备是否可移动设备，在上面设备 sr0 的 RM 值等于 1，这说明他们是可移动设备</p>
<p>SIZE：本栏列出设备的容量大小信息</p>
<p>RO：该项表明设备是否为只读，在本案例中，所有设备的 RO 值为 0，表明他们不是只读的</p>
<p>TYPE：本栏显示块设备是否是磁盘或磁盘上的一个分区。在本例中，sda 和 sdb 是磁盘，而 sr0 是只读存储（rom）。</p>
<p>MOUNTPOINT：本栏指出设备挂载的挂载点。</p>
</li>
<li><p><code>lsblk -f</code>：不会列出所有空设备<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E4%B8%8D%E5%8C%85%E5%90%AB%E7%A9%BA%E8%AE%BE%E5%A4%87.png"></p>
<p>NAME表示设备名称</p>
<p>FSTYPE表示文件类型</p>
<p>LABEL表示设备标签</p>
<p>UUID设备编号</p>
<p>MOUNTPOINT表示设备的挂载点</p>
</li>
</ul>
<hr>
<h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p> df 命令用于显示目前在 Linux 系统上的文件系统的磁盘使用情况统计。</p>
<p>命令：df [options]… [FILE]…</p>
<ul>
<li>-h 使用人类可读的格式(预设值是不加这个选项的…)</li>
<li>–total 计算所有的数据之和</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86.png"></p>
<p>第一列指定文件系统的名称；第二列指定一个特定的文件系统，1K 是 1024 字节为单位的总容量；已用和可用列分别指定的容量；最后一个已用列指定使用的容量的百分比；最后一栏指定的文件系统的挂载点</p>
<hr>
<h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><p>mount 命令是经常会使用到的命令，它用于挂载 Linux 系统外的文件</p>
<p>使用者权限：所有用户，设置级别的需要管理员</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mount [-hV]</span><br><span class="line">mount -a [-fFnrsvw] [-t vfstype]</span><br><span class="line">mount [-fnrsvw] [-o options [,...]] device | <span class="built_in">dir</span></span><br><span class="line">mount [-fnrsvw] [-t vfstype] [-o options] device <span class="built_in">dir</span></span><br></pre></td></tr></table></figure>

<ul>
<li>-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。</li>
</ul>
<p>通过挂载的方式查看 Linux CD&#x2F;DVD 光驱，查看 ubuntu-20.04.1-desktop-amd64.iso 的文件</p>
<ul>
<li><p>进入【虚拟机】–【设置】，设置 CD&#x2F;DVD 的内容，ubuntu-20.04.1-desktop-amd64.iso</p>
</li>
<li><p>创建挂载点（注意：一般用户无法挂载 cdrom，只有 root 用户才可以操作）</p>
<p><code>mkdir -p /mnt/cdrom </code>：切换到 root 下创建一个挂载点（其实就是创建一个目录）</p>
</li>
<li><p>开始挂载<br><code>mount -t auto /dev/cdrom /mnt/cdrom</code>：通过挂载点的方式查看上面的【ISO文件内容】<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/%E6%8C%82%E8%BD%BD%E6%88%90%E5%8A%9F.png" alt="挂载成功"></p>
</li>
<li><p>查看挂载内容：<code>ls -l -a ./mnt/cdrom/</code></p>
</li>
<li><p>卸载 cdrom：<code>umount /mnt/cdrom/</code></p>
</li>
</ul>
<hr>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>防火墙技术是通过有机结合各类用于安全管理与筛选的软件和硬件设备，帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障，以保护用户资料与信息安全性的一种技术。在默认情况下，Linux 系统的防火墙状态是打开的</p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>启动语法：service  name status</p>
<ul>
<li><p>查看防火墙状态：<code>service iptables status</code></p>
</li>
<li><p>临时开启：<code>service iptables start</code></p>
</li>
<li><p>临时关闭：<code>service iptables stop</code></p>
</li>
<li><p>开机启动：<code>chkconfig iptables on</code></p>
</li>
<li><p>开机关闭：<code>chkconfig iptables off</code></p>
</li>
</ul>
<h3 id="放行"><a href="#放行" class="headerlink" title="放行"></a>放行</h3><p>设置端口防火墙放行</p>
<ul>
<li>修改配置文件：<code>vim /etc/sysconfig/iptables</code></li>
<li>添加放行端口：<code>-A INPUT -m state --state NEW -m tcp -p tcp --dport 端口号 -j ACCEPT</code></li>
<li>重新加载防火墙规则：<code>service iptables reload</code></li>
</ul>
<p>备注：默认情况下 22 端口号是放行的</p>
<hr>
<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序，又称 Shell 命令稿、程序化脚本，是一种计算机程序使用的文本文件，内容由一连串的 shell 命令组成，经由 Unix Shell 直译其内容后运作</p>
<p>Shell 被当成是一种脚本语言来设计，其运作方式与解释型语言相当，由 Unix shell 扮演命令行解释器的角色，在读取 shell 脚本之后，依序运行其中的 shell 命令，之后输出结果</p>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p>
<p><code>cat /etc/shells</code>：查看解释器<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/shell%E7%8E%AF%E5%A2%83.png"></p>
<p>Linux 的 Shell 种类众多，常见的有：</p>
<ul>
<li><p>Bourne Shell（&#x2F;usr&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;sh）</p>
</li>
<li><p>Bourne Again Shell（&#x2F;bin&#x2F;bash）：Bash 是大多数Linux 系统默认的 Shell</p>
</li>
<li><p>C Shell（&#x2F;usr&#x2F;bin&#x2F;csh）</p>
</li>
<li><p>K Shell（&#x2F;usr&#x2F;bin&#x2F;ksh）</p>
</li>
<li><p>Shell for Root（&#x2F;sbin&#x2F;sh）</p>
</li>
<li><p>等等……</p>
</li>
</ul>
<h4 id="第一个shell"><a href="#第一个shell" class="headerlink" title="第一个shell"></a>第一个shell</h4><ul>
<li><p>新建 s.sh 文件：touch s.sh</p>
</li>
<li><p>编辑 s.sh 文件：vim s.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash  --- 指定脚本解释器</span></span><br><span class="line">echo &quot;你好，shell !&quot;   ---向窗口输入文本</span><br><span class="line"></span><br><span class="line">:&lt;&lt;!</span><br><span class="line">写shell的习惯 第一行指定解释器</span><br><span class="line">文件是sh为后缀名</span><br><span class="line">括号成对书写</span><br><span class="line">注释的时候尽量不用中文注释。不友好。</span><br><span class="line">[] 括号两端要要有空格。  [ neirong ]</span><br><span class="line">习惯代码索引，增加阅读性</span><br><span class="line">写语句的时候，尽量写全了，比如if。。。</span><br><span class="line">!</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 s.sh文件：ls -l    s.sh文件权限是【-rw-rw-r–】</p>
</li>
<li><p>chmod a+x s.sh         s.sh文件权限是【-rwxrwxr-x】</p>
</li>
<li><p>执行文件：.&#x2F;s.sh</p>
</li>
<li><p>或者直接  <code>bash s.sh</code></p>
</li>
</ul>
<p><strong>注意：</strong></p>
<p><strong>#!</strong> 是一个约定的标记，告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell</p>
<p>echo 命令用于向窗口输出文本</p>
<hr>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li><p>单行注释：以 <strong>#</strong> 开头的行就是注释，会被解释器忽略</p>
</li>
<li><p>多行注释：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;!      -----这里的符号要和结尾处的一样</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">!        </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><p>变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p>
<ul>
<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li>
<li>中间不能有空格，可以使用下划线（_）。</li>
<li>不能使用标点符号。</li>
<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>
</ul>
<h4 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h4><p> 使用一个定义过的变量，只要在变量名前面加美元符号$即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=&quot;seazean&quot;</span><br><span class="line">echo $name</span><br><span class="line">echo $&#123;name&#125;</span><br><span class="line">name=&quot;zhy&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>已定义的变量，可以被重新定义变量名</p>
</li>
<li><p>外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界。推荐加！！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">比如：<span class="built_in">echo</span> <span class="string">&quot;I am good at <span class="variable">$&#123;shell-t&#125;</span>Script&quot;</span></span><br><span class="line">通过上面的脚本我们发现，如果不给shell-t变量加花括号，写成<span class="built_in">echo</span> <span class="string">&quot;I am good at <span class="variable">$shell</span>-tScript&quot;</span>，解释器shell就会把<span class="variable">$shell</span>-tScript当成一个变量，由于我们前面没有定义shell-t变量，那么解释器执行执行的结果自然就为空了。</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h4><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。(类似于final)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">myUrl=&quot;https://www.baidu.com&quot;</span><br><span class="line">readonly myUrl</span><br><span class="line">myUrl=&quot;https://cn.bing.com/&quot;  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">报错 myUrl <span class="built_in">readonly</span></span></span><br></pre></td></tr></table></figure>



<h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><p>使用 unset 命令可以删除变量，变量被删除后不能再次使用。</p>
<p>语法：<code>unset variable_name</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">myUrl=&quot;https://www.baidu.com&quot;</span><br><span class="line">unset myUrl</span><br><span class="line">echo $myUrl</span><br></pre></td></tr></table></figure>

<p>定义myUrl变量，通过unset删除变量，然后通过echo进行输出，<strong>结果是为空</strong>，没有任何的结果输出。</p>
<h4 id="字符变量"><a href="#字符变量" class="headerlink" title="字符变量"></a>字符变量</h4><blockquote>
<p>字符串是shell编程中最常用也是最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号，在Java SE中我们定义一个字符串通过Stirng  s&#x3D;“abc” 双引号的形式进行定义，而在shell中也是可以的。</p>
</blockquote>
<h5 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h5><ul>
<li><p><strong>单引号</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">str=<span class="string">&#x27;this is a string variable&#x27;</span></span><br></pre></td></tr></table></figure>

<p>单引号字符串的限制：</p>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的<strong>变量是无效的</strong>；</li>
<li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li>
</ul>
</li>
<li><p>双引号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">your_name=&#x27;frank&#x27;</span><br><span class="line">str=&quot;Hello,\&quot;$your_name\&quot;! \n&quot;</span><br><span class="line">echo -e $str     #Hello, &quot;frank&quot;!</span><br></pre></td></tr></table></figure>

<p>双引号的优点：</p>
<ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
</li>
</ul>
<h5 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">your_name=&quot;frank&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用双引号拼接</span></span><br><span class="line">greeting=&quot;hello, &quot;$your_name&quot; !&quot;</span><br><span class="line">greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;</span><br><span class="line">echo $greeting  $greeting_1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hello,frank! hello,frank</span></span><br></pre></td></tr></table></figure>



<h5 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h5><p>命令：&#96;$</p>
]]></content>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Tools</title>
    <url>/2022/01/01/Frame/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="Mvn介绍"><a href="#Mvn介绍" class="headerlink" title="Mvn介绍"></a>Mvn介绍</h3><p>Maven：本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目对象模型（POM）</p>
<p>POM：Project Object Model 项目对象模型。Maven 是用 Java 语言编写的，管理的东西以面向对象的形式进行设计，最终把一个项目看成一个对象，这个对象叫做 POM</p>
<span id="more"></span>

<p>pom.xml：Maven 需要一个  pom.xml 文件，Maven 通过加载这个配置文件可以知道项目的相关信息，这个文件代表就一个项目。如果做 8 个项目，对应的是 8 个 pom.xml 文件</p>
<p>依赖管理：Maven 对项目所有依赖资源的一种管理，它和项目之间是一种双向关系，即做项目时可以管理所需要的其他资源，当其他项目需要依赖我们项目时，Maven 也会把我们的项目当作一种资源去进行管理。</p>
<p>管理资源的存储位置：本地仓库，私服，中央仓库</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Maven%E4%BB%8B%E7%BB%8D.png"></p>
<p>基本作用：</p>
<ul>
<li><p>项目构建：提供标准的，跨平台的自动化构建项目的方式</p>
</li>
<li><p>依赖管理：方便快捷的管理项目依赖的资源（jar 包），避免资源间的版本冲突等问题</p>
</li>
<li><p>统一开发结构：提供标准的，统一的项目开发结构</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Maven%E6%A0%87%E5%87%86%E7%BB%93%E6%9E%84.png"></p>
</li>
</ul>
<p>各目录存放资源类型说明：</p>
<ul>
<li><p>src&#x2F;main&#x2F;java：项目 java 源码</p>
</li>
<li><p>src&#x2F;main&#x2F;resources：项目的相关配置文件（比如 mybatis 配置，xml 映射配置，自定义配置文件等）</p>
</li>
<li><p>src&#x2F;main&#x2F;webapp：web 资源（比如 html、css、js 等）</p>
</li>
<li><p>src&#x2F;test&#x2F;java：测试代码</p>
</li>
<li><p>src&#x2F;test&#x2F;resources：测试相关配置文件</p>
</li>
<li><p>src&#x2F;pom.xml：项目 pom 文件</p>
</li>
</ul>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1Ah411S7ZE">https://www.bilibili.com/video/BV1Ah411S7ZE</a></p>
<hr>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>仓库：用于存储资源，主要是各种 jar 包。有本地仓库，私服，中央仓库，私服和中央仓库都是远程仓库</p>
<ul>
<li><p>中央仓库：Maven 团队自身维护的仓库，属于开源的</p>
</li>
<li><p>私服：各公司&#x2F;部门等小范围内存储资源的仓库，私服也可以从中央仓库获取资源，作用：</p>
<ul>
<li>保存具有版权的资源，包含购买或自主研发的 jar</li>
<li>一定范围内共享资源，能做到仅对内不对外开放</li>
</ul>
</li>
<li><p>本地仓库：开发者自己电脑上存储资源的仓库，也可从远程仓库获取资源</p>
</li>
</ul>
<p>坐标：Maven 中的坐标用于描述仓库中资源的位置</p>
<ul>
<li><p>作用：使用唯一标识，唯一性定义资源位置，通过该标识可以将资源的识别与下载工作交由机器完成</p>
<ul>
<li><a href="https://mvnrepository.com：查询">https://mvnrepository.com：查询</a> maven 某一个资源的坐标，输入资源名称进行检索</li>
</ul>
</li>
<li><p>依赖设置：</p>
<ul>
<li>groupId：定义当前资源隶属组织名称（通常是域名反写，如：org.mybatis）</li>
</ul>
</li>
<li><p>artifactId：定义当前资源的名称（通常是项目或模块名称，如：crm、sms）</p>
<ul>
<li>version：定义当前资源的版本号</li>
</ul>
</li>
<li><p>packaging：定义资源的打包方式，取值一般有如下三种</p>
<ul>
<li><p>jar：该资源打成 jar 包，默认是 jar</p>
</li>
<li><p>war：该资源打成 war 包</p>
</li>
<li><p>pom：该资源是一个父资源（表明使用 Maven 分模块管理），打包时只生成一个 pom.xml 不生成 jar 或其他包结构</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>Maven 的官网：<a href="http://maven.apache.org/">http://maven.apache.org/</a></p>
<p>下载安装：Maven 是一个绿色软件，解压即安装</p>
<p>目录结构：</p>
<ul>
<li>bin：可执行程序目录</li>
<li>boot：Maven 自身的启动加载器</li>
<li>conf：Maven 配置文件的存放目录</li>
<li>lib：Maven运行所需库的存放目录</li>
</ul>
<p>配置 MAVEN_HOME：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Maven%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png"></p>
<p>Path 下配置：<code>%MAVEN_HOME%\bin</code></p>
<p>环境变量配置好之后需要测试环境配置结果，在 DOS 命令窗口下输入以下命令查看输出：<code>mvn -v</code></p>
<hr>
<h3 id="仓库配置"><a href="#仓库配置" class="headerlink" title="仓库配置"></a>仓库配置</h3><p>默认情况 Maven 本地仓库在系统用户目录下的 <code>.m2/repository</code>，修改 Maven 的配置文件 <code>conf/settings.xml</code> 来修改仓库位置</p>
<ul>
<li><p>修改本地仓库位置：找到 <localRepository> 标签，修改默认值</localRepository></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">| The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">| Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>E:\Workspace\Java\Project\.m2\repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：在仓库的同级目录即 <code>.m2</code> 也应该包含一个 <code>settings.xml</code> 配置文件，局部用户配置优先与全局配置</p>
<ul>
<li>全局 setting 定义了 Maven 的公共配置</li>
<li>用户 setting 定义了当前用户的配置</li>
</ul>
</li>
<li><p>修改远程仓库：在配置文件中找到 <code>&lt;mirrors&gt;</code> 标签，在这组标签下添加国内镜像</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>  <span class="comment">&lt;!--必须是central--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改默认 JDK：在配置文件中找到 <code>&lt;profiles&gt;</code> 标签，添加配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-10<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>10<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>10<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>10<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><h3 id="手动搭建"><a href="#手动搭建" class="headerlink" title="手动搭建"></a>手动搭建</h3><ol>
<li><p>在 E 盘下创建目录 mvnproject 进入该目录，作为我们的操作目录</p>
</li>
<li><p>创建我们的 Maven 项目，创建一个目录 <code>project-java</code> 作为我们的项目文件夹，并进入到该目录</p>
</li>
<li><p>创建 Java 代码（源代码）所在目录，即创建 <code>src/main/java</code></p>
</li>
<li><p>创建配置文件所在目录，即创建 <code>src/main/resources</code></p>
</li>
<li><p>创建测试源代码所在目录，即创建 <code>src/test/java</code></p>
</li>
<li><p>创建测试存放配置文件存放目录，即 <code>src/test/resources</code></p>
</li>
<li><p>在 <code>src/main/java</code> 中创建一个包（注意在 Windos 文件夹下就是创建目录）<code>demo</code>，在该目录下创建 <code>Demo.java</code> 文件，作为演示所需 Java 程序，内容如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">say</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello &quot;</span>+name);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;hello &quot;</span>+name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>src/test/java</code> 中创建一个测试包（目录）<code>demo</code>，在该包下创建测试程序 <code>DemoTest.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoTest</span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSay</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> d.say(<span class="string">&quot;maven&quot;</span>);</span><br><span class="line">		Assert.assertEquals(<span class="string">&quot;hello maven&quot;</span>,ret);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 <code>project-java/src</code> 下创建 <code>pom.xml</code> 文件，格式如下：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 	</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--指定pom的模型版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--打包方式，web工程打包为war，java工程打包为jar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--组织id--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--项目id--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--版本号:release,snapshot--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--设置当前工程的所有依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--具体的依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>搭建完成 Maven 的项目结构，通过 Maven 来构建项目。Maven 的构建命令以 <code>mvn</code> 开头，后面添加功能参数，可以一次性执行多个命令，用空格分离</p>
<ul>
<li><code>mvn compile</code>：编译</li>
<li><code>mvn clean</code>：清理</li>
<li><code>mvn test</code>：测试</li>
<li><code>mvn package</code>：打包</li>
<li><code>mvn install</code>：安装到本地仓库</li>
</ul>
<p>注意：执行某一条命令，则会把前面所有的都执行一遍</p>
</li>
</ol>
<hr>
<h3 id="IDEA搭建"><a href="#IDEA搭建" class="headerlink" title="IDEA搭建"></a>IDEA搭建</h3><h4 id="不用原型"><a href="#不用原型" class="headerlink" title="不用原型"></a>不用原型</h4><ol>
<li><p>在 IDEA 中配置 Maven，选择 maven3.6.1 防止依赖问题</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/IDEA配置Maven.png" alt="IDEA配置Maven" style="zoom:67%;">
</li>
<li><p>创建 Maven，New Module → Maven → 不选中 Create from archetype</p>
</li>
<li><p>填写项目的坐标</p>
<ul>
<li>GroupId：demo</li>
<li>ArtifactId：project-java</li>
</ul>
</li>
<li><p>查看各目录颜色标记是否正确</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/IDEA%E5%88%9B%E5%BB%BAMaven%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png"></p>
</li>
<li><p>IDEA 右侧侧栏有 Maven Project，打开后有 Lifecycle 生命周期</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/IDEA-Maven%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p>
</li>
<li><p>自定义 Maven 命令：Run → Edit Configurations → 左上角 +  → Maven</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/IDEA%E9%85%8D%E7%BD%AEMaven%E5%91%BD%E4%BB%A4.png"></p>
</li>
</ol>
<hr>
<h4 id="使用原型"><a href="#使用原型" class="headerlink" title="使用原型"></a>使用原型</h4><p>普通工程：</p>
<ol>
<li><p>创建 Maven 项目的时候选择使用原型骨架</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/IDEA%E5%88%9B%E5%BB%BAMaven-quickstart.png"></p>
</li>
<li><p>创建完成后发现通过这种方式缺少一些目录，需要手动去补全目录，并且要对补全的目录进行标记</p>
</li>
</ol>
<p>Web 工程：</p>
<ol>
<li><p>选择 Web 对应的原型骨架（选择 Maven 开头的是简化的）</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/IDEA%E5%88%9B%E5%BB%BAMaven-webapp.png"></p>
</li>
<li><p>通过原型创建 Web 项目得到的目录结构是不全的，因此需要我们自行补全，同时要标记正确</p>
</li>
<li><p>Web 工程创建之后需要启动运行，使用 tomcat 插件来运行项目，在 <code>pom.xml</code> 中添加插件的坐标：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> 		</span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 </span></span></span><br><span class="line"><span class="string"><span class="tag">                             http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>web01<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>web01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--构建--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--具体的插件配置--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--https://mvnrepository.com/  搜索--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span> <span class="comment">&lt;!--80端口默认不显示--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>插件配置以后，在 IDEA 右侧 <code>maven-project</code> 操作面板看到该插件，并且可以利用该插件启动项目，web01 → Plugins → tomcat7 → tomcat7:run</p>
</li>
</ol>
<hr>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h3><p>依赖是指在当前项目中运行所需的 jar，依赖配置的格式如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置当前项目所依赖的所有jar--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置具体的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖所属群组id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖所属项目id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖版本号--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p>依赖具有传递性，分两种：</p>
<ul>
<li><p>直接依赖：在当前项目中通过依赖配置建立的依赖关系</p>
</li>
<li><p>间接依赖：被依赖的资源如果依赖其他资源，则表明当前项目间接依赖其他资源</p>
<p>注意：直接依赖和间接依赖其实也是一个相对关系</p>
</li>
</ul>
<p>依赖传递的冲突问题：在依赖传递过程中产生了冲突，有三种优先法则</p>
<ul>
<li><p>路径优先：当依赖中出现相同资源时，层级越深，优先级越低，反之则越高</p>
</li>
<li><p>声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖靠后的</p>
</li>
<li><p>特殊优先：当同级配置了相同资源的不同版本时，后配置的覆盖先配置的</p>
</li>
</ul>
<p><strong>可选依赖</strong>：对外隐藏当前所依赖的资源，不透明</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--默认是false，true以后就变得不透明--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>排除依赖</strong>：主动断开依赖的资源，被排除的资源无需指定版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="comment">&lt;!--排除这个资源--&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>依赖的 jar 默认情况可以在任何地方可用，可以通过 <code>scope</code> 标签设定其作用范围，有三种：</p>
<ul>
<li><p>主程序范围有效（src&#x2F;main 目录范围内）</p>
</li>
<li><p>测试程序范围内有效（src&#x2F;test 目录范围内）</p>
</li>
<li><p>是否参与打包（package 指令范围内）</p>
</li>
</ul>
<p><code>scope</code> 标签的取值有四种：<code>compile,test,provided,runtime</code></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Maven%E4%BE%9D%E8%B5%96%E8%8C%83%E5%9B%B4.png"></p>
<p><strong>依赖范围的传递性：</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Maven%E4%BE%9D%E8%B5%96%E8%8C%83%E5%9B%B4%E7%9A%84%E4%BC%A0%E9%80%92%E6%80%A7.png"></p>
<hr>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="相关事件"><a href="#相关事件" class="headerlink" title="相关事件"></a>相关事件</h3><p>Maven 的构建生命周期描述的是一次构建过程经历了多少个事件</p>
<p>最常用的一套流程：compile → test-compile → test → package → install</p>
<ul>
<li><p>clean：清理工作</p>
<ul>
<li>pre-clean：执行一些在 clean 之前的工作</li>
<li>clean：移除上一次构建产生的所有文件</li>
<li>post-clean：执行一些在 clean 之后立刻完成的工作</li>
</ul>
</li>
<li><p>default：核心工作，例如编译，测试，打包，部署等，每个事件在执行之前都会<strong>将之前的所有事件依次执行一遍</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Maven-default%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p>
</li>
<li><p>site：产生报告，发布站点等</p>
<ul>
<li>pre-site：执行一些在生成站点文档之前的工作</li>
<li>site：生成项目的站点文档</li>
<li>post-site：执行一些在生成站点文档之后完成的工作，并为部署做准备</li>
<li>site-deploy：将生成的站点文档部署到特定的服务器上</li>
</ul>
</li>
</ul>
<hr>
<h3 id="执行事件"><a href="#执行事件" class="headerlink" title="执行事件"></a>执行事件</h3><p>Maven 的插件用来执行生命周期中的相关事件</p>
<ul>
<li><p>插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件</p>
</li>
<li><p>Maven 默认在各个生命周期上都绑定了预先设定的插件来完成相应功能</p>
</li>
<li><p>插件还可以完成一些自定义功能</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>           </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>           </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>           </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>           </span><br><span class="line">            <span class="comment">&lt;!--执行--&gt;</span>          </span><br><span class="line">            <span class="tag">&lt;<span class="name">excutions</span>&gt;</span>               </span><br><span class="line">                <span class="comment">&lt;!--具体执行位置--&gt;</span>              </span><br><span class="line">                <span class="tag">&lt;<span class="name">excution</span>&gt;</span>                   </span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span>                      </span><br><span class="line">                        <span class="comment">&lt;!--对源码进行打包，打包放在target目录--&gt;</span>                    	</span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>                      </span><br><span class="line">                        <span class="comment">&lt;!--对测试代码进行打包--&gt;</span>                       </span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>test-jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>                 </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>                  </span><br><span class="line">                    <span class="comment">&lt;!--执行的生命周期--&gt;</span>                 </span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-test-resources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>                 </span><br><span class="line">                <span class="tag">&lt;/<span class="name">excution</span>&gt;</span>         </span><br><span class="line">            <span class="tag">&lt;/<span class="name">excutions</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="模块开发"><a href="#模块开发" class="headerlink" title="模块开发"></a>模块开发</h2><h3 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h3><p>工程模块与模块划分：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Maven%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86.png"></p>
<ul>
<li><p>ssm_pojo 拆分</p>
<ul>
<li>新建模块，拷贝原始项目中对应的相关内容到 ssm_pojo 模块中</li>
<li>实体类（User）</li>
<li>配置文件（无）</li>
</ul>
</li>
<li><p>ssm_dao 拆分</p>
<ul>
<li><p>新建模块</p>
</li>
<li><p>拷贝原始项目中对应的相关内容到 ssm_dao 模块中</p>
<ul>
<li><p>数据层接口（UserDao）</p>
</li>
<li><p>配置文件：保留与数据层相关配置文件(3 个）</p>
</li>
<li><p>注意：分页插件在配置中与 SqlSessionFactoryBean 绑定，需要保留</p>
</li>
<li><p>pom.xml：引入数据层相关坐标即可，删除 SpringMVC 相关坐标</p>
<ul>
<li>Spring</li>
<li>MyBatis</li>
<li>Spring 整合 MyBatis</li>
<li>MySQL</li>
<li>druid</li>
<li>pagehelper</li>
<li>直接依赖 ssm_pojo（对 ssm_pojo 模块执行 install 指令，将其安装到本地仓库）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>    <span class="comment">&lt;!--导入资源文件pojo--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--spring环境--&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--mybatis环境--&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--mysql环境--&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--spring整合jdbc--&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--spring整合mybatis--&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--druid连接池--&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--分页插件坐标--&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>ssm_service 拆分</p>
<ul>
<li><p>新建模块</p>
</li>
<li><p>拷贝原始项目中对应的相关内容到 ssm_service 模块中</p>
<ul>
<li><p>业务层接口与实现类（UserService、UserServiceImpl）</p>
</li>
<li><p>配置文件：保留与数据层相关配置文件(1 个）</p>
</li>
<li><p>pom.xml：引入数据层相关坐标即可，删除 SpringMVC 相关坐标</p>
<ul>
<li><p>spring</p>
</li>
<li><p>junit</p>
</li>
<li><p>spring 整合 junit</p>
</li>
<li><p>直接依赖 ssm_dao（对 ssm_dao 模块执行 install 指令，将其安装到本地仓库）</p>
</li>
<li><p>间接依赖 ssm_pojo（由 ssm_dao 模块负责依赖关系的建立）</p>
</li>
</ul>
</li>
<li><p>修改 service 模块 Spring 核心配置文件名，添加模块名称，格式：applicationContext-service.xml</p>
</li>
<li><p>修改 dao 模块 Spring 核心配置文件名，添加模块名称，格式：applicationContext-dao.xml</p>
</li>
<li><p>修改单元测试引入的配置文件名称，由单个文件修改为多个文件</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ssm_control 拆分</p>
<ul>
<li><p>新建模块（使用 webapp 模板）</p>
</li>
<li><p>拷贝原始项目中对应的相关内容到 ssm_controller 模块中</p>
<ul>
<li><p>现层控制器类与相关设置类（UserController、异常相关……）</p>
</li>
<li><p>配置文件：保留与表现层相关配置文件(1 个）、服务器相关配置文件（1 个）</p>
</li>
<li><p>pom.xml：引入数据层相关坐标即可，删除 SpringMVC 相关坐标</p>
<ul>
<li><p>spring</p>
</li>
<li><p>springmvc</p>
</li>
<li><p>jackson</p>
</li>
<li><p>servlet</p>
</li>
<li><p>tomcat 服务器插件</p>
</li>
<li><p>直接依赖 ssm_service（对 ssm_service 模块执行 install 指令，将其安装到本地仓库）</p>
</li>
<li><p>间接依赖 ssm_dao、ssm_pojo</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--导入资源文件service--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>         </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm_service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--springmvc环境--&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--jackson相关坐标3个--&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--servlet环境--&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--设置插件--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>    </span><br><span class="line">        <span class="comment">&lt;!--具体的插件配置--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 web.xml 配置文件中加载 Spring 环境的配置文件名称，使用*通配，加载所有 applicationContext- 开始的配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:applicationContext-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>spring-mvc</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;controller&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>作用：聚合用于快速构建 Maven 工程，一次性构建多个项目&#x2F;模块</p>
<p>制作方式：</p>
<ul>
<li><p>创建一个空模块，打包类型定义为 pom</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义当前模块进行构建操作时关联的其他模块名称</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;............&quot;</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义该工程用于构建管理--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--管理的工程列表--&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span>       </span><br><span class="line">        <span class="comment">&lt;!--具体的工程名称--&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../ssm_pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../ssm_dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../ssm_service<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../ssm_controller<span class="tag">&lt;/<span class="name">module</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意事项：参与聚合操作的模块最终执行顺序与模块间的依赖关系有关，与配置顺序无关</p>
<hr>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>作用：通过继承可以实现在子工程中沿用父工程中的配置</p>
<ul>
<li>Maven 中的继承与 Java 中的继承相似，在子工程中配置继承关系</li>
</ul>
<p>制作方式：</p>
<ul>
<li><p>在子工程中声明其父工程坐标与对应的位置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义该工程的父工程--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.seazean<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--填写父工程的pom文件--&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../ssm/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>继承依赖的定义：在父工程中定义依赖管理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--声明此处进行依赖管理，版本锁定--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--具体的依赖--&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>      </span><br><span class="line">        <span class="comment">&lt;!--spring环境--&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>       </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>   </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>     </span><br><span class="line">        <span class="comment">&lt;!--等等所有--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>继承依赖的使用：在子工程中定义依赖关系，<strong>无需声明依赖版本</strong>，版本参照父工程中依赖的版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--spring环境--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>继承的资源：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">groupId：项目组ID，项目坐标的核心元素</span><br><span class="line">version：项目版本，项目坐标的核心因素</span><br><span class="line">description：项目的描述信息</span><br><span class="line">organization：项目的组织信息</span><br><span class="line">inceptionYear：项目的创始年份</span><br><span class="line">url：项目的URL地址</span><br><span class="line">developers：项目的开发者信息</span><br><span class="line">contributors：项目的贡献者信息</span><br><span class="line">distributionManagement：项目的部署配置</span><br><span class="line">issueManagement：项目的缺陷跟踪系统信息</span><br><span class="line">ciManagement：项目的持续集成系统信息</span><br><span class="line">scm：项目的版本控制系统信息</span><br><span class="line">malilingLists：项目的邮件列表信息</span><br><span class="line">properties：自定义的Maven属性</span><br><span class="line">dependencies：项目的依赖配置</span><br><span class="line">dependencyManagement：项目的依赖管理配置</span><br><span class="line">repositories：项目的仓库配置</span><br><span class="line">build：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等</span><br><span class="line">reporting：包括项目的报告输出目录配置、报告插件配置等</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承与聚合：</p>
<p>作用：</p>
<ul>
<li><p>聚合用于快速构建项目</p>
</li>
<li><p>继承用于快速配置</p>
</li>
</ul>
<p>相同点：</p>
<ul>
<li><p>聚合与继承的 pom.xml 文件打包方式均为 pom，可以将两种关系制作到同一个 pom 文件中</p>
</li>
<li><p>聚合与继承均属于设计型模块，并无实际的模块内容</p>
</li>
</ul>
<p>不同点：</p>
<ul>
<li><p>聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些</p>
</li>
<li><p>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><p>版本统一的重要性： </p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Maven%E7%89%88%E6%9C%AC%E7%BB%9F%E4%B8%80%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7.png"></p>
</li>
<li><p>属性类别：</p>
<ol>
<li>自定义属性  </li>
<li>内置属性</li>
<li>setting 属性</li>
<li>Java 系统属性</li>
<li>环境变量属性</li>
</ol>
</li>
<li><p>自定义属性：</p>
<p>作用：等同于定义变量，方便统一维护</p>
<p>定义格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义自定义属性，放在dependencyManagement上方--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>聚合与继承的 pom.xml 文件打包方式均为 pom，可以将两种关系制作到同一个 pom 文件中</p>
</li>
<li><p>聚合与继承均属于设计型模块，并无实际的模块内容</p>
</li>
</ul>
<p>调用格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内置属性：</p>
<p>作用：使用 Maven 内置属性，快速配置</p>
<p>调用格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;project.basedir&#125; or $&#123;project.basedir&#125;  <span class="comment">&lt;!--../ssm根目录--&gt;</span>$&#123;version&#125; or $&#123;project.version&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>vresion 是 1.0-SNAPSHOT</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>setting 属性</p>
<ul>
<li>使用 Maven 配置文件 setting.xml 中的标签属性，用于动态配置</li>
</ul>
<p>调用格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;settings.localRepository&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 系统属性：</p>
<p>作用：读取 Java 系统属性</p>
<p>调用格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;user.home&#125;</span><br></pre></td></tr></table></figure>

<p>系统属性查询方式 cmd 命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:system </span><br></pre></td></tr></table></figure>
</li>
<li><p>环境变量属性</p>
<p>作用：使用 Maven 配置文件 setting.xml 中的标签属性，用于动态配置</p>
<p>调用格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;env.JAVA_HOME&#125; </span><br></pre></td></tr></table></figure>

<p>环境变量属性查询方式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:system </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="工程版本"><a href="#工程版本" class="headerlink" title="工程版本"></a>工程版本</h3><p>SNAPSHOT（快照版本）</p>
<ul>
<li><p>项目开发过程中，为方便团队成员合作，解决模块间相互依赖和时时更新的问题，开发者对每个模块进行构建的时候，输出的临时性版本叫快照版本（测试阶段版本）</p>
</li>
<li><p>快照版本会随着开发的进展不断更新</p>
</li>
</ul>
<p>RELEASE（发布版本）</p>
<ul>
<li>项目开发到进入阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的，即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本</li>
</ul>
<p>约定规范：</p>
<ul>
<li><p>&lt;主版本&gt;.&lt;次版本&gt;.&lt;增量版本&gt;.&lt;里程碑版本&gt;</p>
</li>
<li><p>主版本：表示项目重大架构的变更，如：Spring5 相较于 Spring4 的迭代</p>
</li>
<li><p>次版本：表示有较大的功能增加和变化，或者全面系统地修复漏洞</p>
</li>
<li><p>增量版本：表示有重大漏洞的修复</p>
</li>
<li><p>里程碑版本：表明一个版本的里程碑（版本内部）。这样的版本同下一个正式版本相比，相对来说不是很稳定，有待更多的测试</p>
</li>
</ul>
<hr>
<h3 id="资源配置"><a href="#资源配置" class="headerlink" title="资源配置"></a>资源配置</h3><p>作用：在任意配置文件中加载 pom 文件中定义的属性</p>
<ul>
<li><p>父文件 pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://192.168.0.137:3306/ssm_db?useSSL=false<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>开启配置文件加载 pom 属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置资源文件对应的信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span>   </span><br><span class="line">        <span class="comment">&lt;!--设定配置文件对应的位置目录，支持使用属性动态设定路径--&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!--开启对配置文件的资源加载过滤--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>properties 文件中调用格式：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driverjdbc.url=$&#123;jdbc.url&#125;</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">rootjdbc.password=123456</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h3><ul>
<li><p>环境配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建多环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--定义具体的环境：生产环境--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span>     </span><br><span class="line">        <span class="comment">&lt;!--定义环境对应的唯一名称--&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>pro_env<span class="tag">&lt;/<span class="name">id</span>&gt;</span>    </span><br><span class="line">        <span class="comment">&lt;!--定义环境中专用的属性值--&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span>           </span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.1.1.1:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>     </span><br><span class="line">        <span class="comment">&lt;!--设置默认启动--&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span>      </span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--定义具体的环境：开发环境--&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev_env<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        ……  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>加载指定环境</p>
<p>作用：加载指定环境配置</p>
<p>调用格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn 指令 –P 环境定义<span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<p>范例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn install –P pro_env</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h2><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn 指令 –D skipTests</span><br></pre></td></tr></table></figure>

<p>注意事项：执行的指令生命周期必须包含测试环节</p>
<p>IEDA 界面：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/IDEA%E4%BD%BF%E7%94%A8%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C%E8%B7%B3%E8%BF%87%E6%B5%8B%E8%AF%95.png"></p>
<p>配置跳过：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--&lt;groupId&gt;org.apache.maven&lt;/groupId&gt;--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span><span class="comment">&lt;!--设置跳过测试--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span> <span class="comment">&lt;!--包含指定的测试用例--&gt;</span>      </span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/User*Test.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span><span class="comment">&lt;!--排除指定的测试用例--&gt;</span>      </span><br><span class="line">            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/User*TestCase.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><h3 id="Nexus"><a href="#Nexus" class="headerlink" title="Nexus"></a>Nexus</h3><p>Nexus 是 Sonatype 公司的一款 Maven 私服产品</p>
<p>下载地址：<a href="https://help.sonatype.com/repomanager3/download">https://help.sonatype.com/repomanager3/download</a> </p>
<p>启动服务器（命令行启动）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nexus.exe /run nexus</span><br></pre></td></tr></table></figure>

<p>访问服务器（默认端口：8081）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">http://localhost:8081</span><br></pre></td></tr></table></figure>

<p>修改基础配置信息</p>
<ul>
<li>安装路径下 etc 目录中 nexus-default.properties 文件保存有 nexus 基础配置信息，例如默认访问端口</li>
</ul>
<p>修改服务器运行配置信息</p>
<ul>
<li>安装路径下 bin 目录中 nexus.vmoptions 文件保存有 nexus 服务器启动的配置信息，例如默认占用内存空间</li>
</ul>
<hr>
<h3 id="资源操作"><a href="#资源操作" class="headerlink" title="资源操作"></a>资源操作</h3><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Maven%E7%A7%81%E6%9C%8D%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96.png"></p>
<p>仓库分类：</p>
<ul>
<li><p>宿主仓库 hosted </p>
<ul>
<li>保存无法从中央仓库获取的资源<ul>
<li>自主研发</li>
<li>第三方非开源项目</li>
</ul>
</li>
</ul>
</li>
<li><p>代理仓库 proxy </p>
<ul>
<li>代理远程仓库，通过 nexus 访问其他公共仓库，例如中央仓库</li>
</ul>
</li>
<li><p>仓库组 group </p>
<ul>
<li>将若干个仓库组成一个群组，简化配置</li>
<li>仓库组不能保存资源，属于设计型仓库</li>
</ul>
</li>
</ul>
<p>资源上传，上传资源时提供对应的信息</p>
<ul>
<li><p>保存的位置（宿主仓库）</p>
</li>
<li><p>资源文件</p>
</li>
<li><p>对应坐标</p>
</li>
</ul>
<hr>
<h3 id="IDEA操作"><a href="#IDEA操作" class="headerlink" title="IDEA操作"></a>IDEA操作</h3><h4 id="上传下载"><a href="#上传下载" class="headerlink" title="上传下载"></a>上传下载</h4><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/IDEA%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%B5%84%E6%BA%90%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD.png"></p>
<hr>
<h4 id="访问私服"><a href="#访问私服" class="headerlink" title="访问私服"></a>访问私服</h4><h5 id="本地访问"><a href="#本地访问" class="headerlink" title="本地访问"></a>本地访问</h5><p>配置本地仓库访问私服的权限（setting.xml）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>heima-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>heima-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">password</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置本地仓库资源来源（setting.xml）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-heima<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h5 id="工程访问"><a href="#工程访问" class="headerlink" title="工程访问"></a>工程访问</h5><p>配置当前项目访问私服上传资源的保存位置（pom.xml）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>heima-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/heima-release/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>heima-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/heima-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>发布资源到私服命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mvn deploy</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h3><p>程序中的日志可以用来记录程序在运行时候的详情，并可以进行永久存储。</p>
<table>
<thead>
<tr>
<th></th>
<th>输出语句</th>
<th>日志技术</th>
</tr>
</thead>
<tbody><tr>
<td>取消日志</td>
<td>需要修改代码，灵活性比较差</td>
<td>不需要修改代码，灵活性比较好</td>
</tr>
<tr>
<td>输出位置</td>
<td>只能是控制台</td>
<td>可以将日志信息写入到文件或者数据库中</td>
</tr>
<tr>
<td>多线程</td>
<td>和业务代码处于一个线程中</td>
<td>多线程方式记录日志，不影响业务代码的性能</td>
</tr>
</tbody></table>
<p>Log4j 是 Apache 的一个开源项目。使用 Log4j，通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。我们可以控制日志信息输送的目的地是控制台、文件等位置，也可以控制每一条日志的输出格式。</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/日志体系结构.png" style="zoom:50%;">



<hr>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件的三个核心：</p>
<ul>
<li><p>配置根 Logger</p>
<ul>
<li><p>格式：log4j.rootLogger&#x3D;日志级别，appenderName1，appenderName2，…</p>
</li>
<li><p>日志级别：常见的五个级别：<strong>DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</strong>（可以自定义）<br>Log4j 规则：只输出级别不低于设定级别的日志信息</p>
</li>
<li><p>appenderName1：指定日志信息要输出地址。可以同时指定多个输出目的地，用逗号隔开：</p>
<p>例如：log4j.rootLogger＝INFO，ca，fa</p>
</li>
</ul>
</li>
<li><p>Appenders（输出源）：日志要输出的地方，如控制台（Console）、文件（Files）等</p>
<ul>
<li><p>Appenders 取值：</p>
<ul>
<li>org.apache.log4j.ConsoleAppender（控制台）</li>
<li>org.apache.log4j.FileAppender（文件）</li>
</ul>
</li>
<li><p>ConsoleAppender 常用参数</p>
<ul>
<li><code>ImmediateFlush=true</code>：表示所有消息都会被立即输出，设为 false 则不输出，默认值是 true</li>
<li><code>Target=System.err</code>：默认值是 System.out</li>
</ul>
</li>
<li><p>FileAppender常用的选项</p>
<ul>
<li><p><code>ImmediateFlush=true</code>：表示所有消息都会被立即输出。设为 false 则不输出，默认值是 true</p>
</li>
<li><p><code>Append=false</code>：true 表示将消息添加到指定文件中，原来的消息不覆盖。默认值是 true</p>
</li>
<li><p><code>File=E:/logs/logging.log4j</code>：指定消息输出到 logging.log4j 文件中</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Layouts (布局)：日志输出的格式，常用的布局管理器：</p>
<ul>
<li>org.apache.log4j.PatternLayout（可以灵活地指定布局模式）</li>
</ul>
</li>
<li><p>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）</p>
</li>
<li><p>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）</p>
</li>
<li><p>PatternLayout 常用的选项</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/日志-PatternLayout常用的选项.png" style="zoom:80%;"></li>
</ul>
<hr>
<h3 id="日志应用"><a href="#日志应用" class="headerlink" title="日志应用"></a>日志应用</h3><ul>
<li><p>log4j 的配置文件,名字为 log4j.properties, 放在 src 根目录下</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">log4j.rootLogger</span>=<span class="string">I</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### direct log messages to my ###</span></span><br><span class="line"><span class="attr">log4j.appender.my</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="attr">log4j.appender.my.ImmediateFlush</span> = <span class="string">true</span></span><br><span class="line"><span class="attr">log4j.appender.my.Target</span>=<span class="string">System.out</span></span><br><span class="line"><span class="attr">log4j.appender.my.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.my.layout.ConversionPattern</span>=<span class="string">%d %t %5p %c&#123;1&#125;:%L - %m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># fileAppender演示</span></span><br><span class="line"><span class="attr">log4j.appender.fileAppender</span>=<span class="string">org.apache.log4j.FileAppender</span></span><br><span class="line"><span class="attr">log4j.appender.fileAppender.ImmediateFlush</span> = <span class="string">true</span></span><br><span class="line"><span class="attr">log4j.appender.fileAppender.Append</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">log4j.appender.fileAppender.File</span>=<span class="string">E:/log4j-log.log</span></span><br><span class="line"><span class="attr">log4j.appender.fileAppender.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.fileAppender.layout.ConversionPattern</span>=<span class="string">%d %5p %c&#123;1&#125;:%L - %m%n</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Log4JTest01</span> &#123;    </span><br><span class="line">    <span class="comment">//使用log4j的api来获取日志的对象   </span></span><br><span class="line">    <span class="comment">//弊端：如果以后我们更换日志的实现类，那么下面的代码就需要跟着改   </span></span><br><span class="line">    <span class="comment">//不推荐使用   </span></span><br><span class="line">    <span class="comment">//private static final Logger LOGGER = Logger.getLogger(Log4JTest01.class);    </span></span><br><span class="line">    <span class="comment">//使用slf4j里面的api来获取日志的对象 </span></span><br><span class="line">    <span class="comment">//好处：如果以后我们更换日志的实现类，那么下面的代码不需要跟着修改   </span></span><br><span class="line">    <span class="comment">//推荐使用    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(Log4JTest01.class);  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">        <span class="comment">//1.导入jar包        </span></span><br><span class="line">        <span class="comment">//2.编写配置文件        </span></span><br><span class="line">        <span class="comment">//3.在代码中获取日志的对象        </span></span><br><span class="line">        <span class="comment">//4.按照日志级别设置日志信息        </span></span><br><span class="line">        LOGGER.debug(<span class="string">&quot;debug级别的日志&quot;</span>);        </span><br><span class="line">        LOGGER.info(<span class="string">&quot;info级别的日志&quot;</span>);        </span><br><span class="line">        LOGGER.warn(<span class="string">&quot;warn级别的日志&quot;</span>);        </span><br><span class="line">        LOGGER.error(<span class="string">&quot;error级别的日志&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Netty 是一个异步事件驱动的网络应用程序框架，用于快速开发可维护、高性能的网络服务器和客户端</p>
<p>Netty 官网：<a href="https://netty.io/">https://netty.io/</a></p>
<p>Netty 的对 JDK 自带的 NIO 的 API 进行封装，解决上述问题，主要特点有：</p>
<ul>
<li>设计优雅，适用于各种传输类型的统一 API， 阻塞和非阻塞 Socket 基于灵活且可扩展的事件模型</li>
<li>使用方便，详细记录的 Javadoc、用户指南和示例，没有其他依赖项</li>
<li>高性能，吞吐量更高，延迟更低，减少资源消耗，最小化不必要的内存复制</li>
<li>安全，完整的 SSL&#x2F;TLS 和 StartTLS 支持</li>
</ul>
<p>Netty 的功能特性：</p>
<ul>
<li>传输服务：支持 BIO 和 NIO</li>
<li>容器集成：支持 OSGI、JBossMC、Spring、Guice 容器</li>
<li>协议支持：HTTP、Protobuf、二进制、文本、WebSocket 等一系列协议都支持，也支持通过实行编码解码逻辑来实现自定义协议</li>
<li>Core 核心：可扩展事件模型、通用通信 API、支持零拷贝的 ByteBuf 缓冲对象</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-功能特性.png" style="zoom:50%;">





<hr>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="阻塞模型"><a href="#阻塞模型" class="headerlink" title="阻塞模型"></a>阻塞模型</h3><p>传统阻塞型 I&#x2F;O 模式，每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-传统阻塞IO服务模型.png" style="zoom:50%;">

<p>模型缺点：</p>
<ul>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 read 操作上，造成线程资源浪费</li>
</ul>
<p>参考文章：<a href="https://www.jianshu.com/p/2965fca6bb8f">https://www.jianshu.com/p/2965fca6bb8f</a></p>
<hr>
<h3 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h3><h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4><p>Reactor 模式，通过一个或多个输入同时传递给服务处理器的<strong>事件驱动处理模式</strong>。 服务端程序处理传入的多路请求，并将它们同步分派给对应的处理线程，Reactor 模式也叫 Dispatcher 模式，即 I&#x2F;O 多路复用统一监听事件，收到事件后分发（Dispatch 给某线程）</p>
<p><strong>I&#x2F;O 复用结合线程池</strong>，就是 Reactor 模式基本设计思想：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-Reactor模型.png" style="zoom: 50%;">

<p>Reactor 模式关键组成：</p>
<ul>
<li>Reactor：在一个单独的线程中运行，负责<strong>监听和分发事件</strong>，分发给适当的处理程序来对 I&#x2F;O 事件做出反应</li>
<li>Handler：处理程序执行 I&#x2F;O 要完成的实际事件，Reactor 通过调度适当的处理程序来响应 I&#x2F;O 事件，处理程序执行<strong>非阻塞操作</strong></li>
</ul>
<p>Reactor 模式具有如下的优点：</p>
<ul>
<li>响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的</li>
<li>编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程的切换开销</li>
<li>可扩展性，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源</li>
<li>可复用性，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性</li>
</ul>
<p>根据 Reactor 的数量和处理资源池线程的数量不同，有三种典型的实现：</p>
<ul>
<li>单 Reactor 单线程</li>
<li>单 Reactor 多线程</li>
<li>主从 Reactor 多线程</li>
</ul>
<hr>
<h4 id="单R单线程"><a href="#单R单线程" class="headerlink" title="单R单线程"></a>单R单线程</h4><p>Reactor 对象通过 select 监控客户端请求事件，收到事件后通过 dispatch 进行分发：</p>
<ul>
<li><p>如果是建立连接请求事件，则由 Acceptor 通过 accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理</p>
</li>
<li><p>如果不是建立连接事件，则 Reactor 会分发给连接对应的 Handler 来响应，Handler 会完成 read、业务处理、send 的完整流程</p>
<p>说明：<strong>Handler 和 Acceptor 属于同一个线程</strong></p>
</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-单Reactor单线程.png" style="zoom:50%;">

<p>模型优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</p>
<p>模型缺点：</p>
<ul>
<li>性能问题：只有一个线程，无法发挥多核 CPU 的性能，Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li>
<li>可靠性问题：线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li>
</ul>
<p>使用场景：客户端的数量有限，业务处理非常快速，比如 Redis，业务处理的时间复杂度 O(1)</p>
<hr>
<h4 id="单R多线程"><a href="#单R多线程" class="headerlink" title="单R多线程"></a>单R多线程</h4><p>执行流程通同单 Reactor 单线程，不同的是：</p>
<ul>
<li><p>Handler 只负责响应事件，不做具体业务处理，通过 read 读取数据后，会分发给后面的 Worker 线程池进行业务处理</p>
</li>
<li><p>Worker 线程池会分配独立的线程完成真正的业务处理，将响应结果发给 Handler 进行处理，最后由 Handler 收到响应结果后通过 send 将响应结果返回给 Client</p>
</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-单Reactor多线程.png" style="zoom:50%;">

<p>模型优点：可以充分利用多核 CPU 的处理能力</p>
<p>模型缺点：</p>
<ul>
<li>多线程数据共享和访问比较复杂</li>
<li>Reactor 承担所有事件的监听和响应，在单线程中运行，高并发场景下容易成为性能瓶颈</li>
</ul>
<hr>
<h4 id="主从模型"><a href="#主从模型" class="headerlink" title="主从模型"></a>主从模型</h4><p>采用多个 Reactor ，执行流程：</p>
<ul>
<li><p>Reactor 主线程 MainReactor 通过 select <strong>监控建立连接事件</strong>，收到事件后通过 Acceptor 接收，处理建立连接事件，处理完成后 MainReactor 会将连接分配给 Reactor 子线程的 SubReactor（有多个）处理</p>
</li>
<li><p>SubReactor 将连接加入连接队列进行监听其他事件，并创建一个 Handler 用于处理该连接的事件，当有新的事件发生时，SubReactor 会调用连接对应的 Handler 进行响应</p>
</li>
<li><p>Handler 通过 read 读取数据后，会分发给 Worker 线程池进行业务处理</p>
</li>
<li><p>Worker 线程池会分配独立的线程完成真正的业务处理，将响应结果发给 Handler 进行处理，最后由 Handler 收到响应结果后通过 send 将响应结果返回给 Client</p>
</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-主从Reactor多线程.png" style="zoom: 50%;">

<p>模型优点</p>
<ul>
<li><strong>父线程与子线程</strong>的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理</li>
<li>父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据</li>
</ul>
<p>使用场景：Nginx 主从 Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持</p>
<hr>
<h3 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h3><p>Reactor 模式中，Reactor 等待某个事件的操作状态发生变化（文件描述符可读写，socket 可读写），然后把事件传递给事先注册的 Handler 来做实际的读写操作，其中的读写操作都需要应用程序同步操作，所以 <strong>Reactor 是非阻塞同步网络模型（NIO）</strong></p>
<p>把 I&#x2F;O 操作改为异步，交给操作系统来完成就能进一步提升性能，这就是异步网络模型 Proactor（AIO）：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-Proactor模型.png" style="zoom:50%;">

<p>工作流程：</p>
<ul>
<li>ProactorInitiator 创建 Proactor 和 Handler 对象，并将 Proactor 和 Handler 通过 Asynchronous Operation Processor（AsyOptProcessor）注册到内核</li>
<li>AsyOptProcessor 处理注册请求，并处理 I&#x2F;O 操作，完成I&#x2F;O后通知 Proactor</li>
<li>Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理，最后由 Handler 完成业务处理</li>
</ul>
<p>对比：Reactor 在事件发生时就通知事先注册的处理器（读写在应用程序线程中处理完成）；Proactor 是在事件发生时基于异步 I&#x2F;O 完成读写操作（内核完成），I&#x2F;O 完成后才回调应用程序的处理器进行业务处理</p>
<p>模式优点：异步 I&#x2F;O 更加充分发挥 DMA（Direct Memory Access 直接内存存取）的优势</p>
<p>模式缺点：</p>
<ul>
<li>编程复杂性，由于异步操作流程的事件的初始化和事件完成在时间和空间上都是相互分离的，因此开发异步应用程序更加复杂，应用程序还可能因为反向的流控而变得更加难以调试</li>
<li>内存使用，缓冲区在读或写操作的时间段内必须保持住，可能造成持续的不确定性，并且每个并发操作都要求有独立的缓存，Reactor 模式在 socket 准备好读或写之前是不要求开辟缓存的</li>
<li>操作系统支持，Windows 下通过 IOCP 实现了真正的异步 I&#x2F;O，而在 Linux 系统下，Linux2.6 才引入异步 I&#x2F;O，目前还不完善，所以在 Linux 下实现高并发网络编程都是以 Reactor 模型为主</li>
</ul>
<hr>
<h3 id="Netty-1"><a href="#Netty-1" class="headerlink" title="Netty"></a>Netty</h3><p>Netty 主要基于主从 Reactors 多线程模型做了一定的改进，Netty 的工作架构图：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-工作模型.png" style="zoom:50%;">

<p>工作流程：</p>
<ol>
<li><p>Netty 抽象出两组线程池 BossGroup 专门负责接收客户端的连接，WorkerGroup 专门负责网络的读写</p>
</li>
<li><p>BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup，该 Group 相当于一个事件循环组，含有多个事件循环，每一个事件循环是 NioEventLoop，所以可以有多个线程</p>
</li>
<li><p>NioEventLoop 表示一个<strong>循环处理任务的线程</strong>，每个 NioEventLoop 都有一个 Selector，用于监听绑定在其上的 Socket 的通讯</p>
</li>
<li><p>每个 Boss NioEventLoop 循环执行的步骤：</p>
<ul>
<li>轮询 accept 事件</li>
<li>处理 accept 事件，与 client 建立连接，生成 NioScocketChannel，并将其<strong>注册到某个 Worker 中</strong>的某个 NioEventLoop 上的 Selector，连接就与 NioEventLoop 绑定</li>
<li>处理任务队列的任务，即 runAllTasks</li>
</ul>
</li>
<li><p>每个 Worker NioEventLoop 循环执行的步骤：</p>
<ul>
<li>轮询 read、write 事件</li>
<li>处理 I&#x2F;O 事件，即 read，write 事件，在对应 NioSocketChannel 处理</li>
<li>处理任务队列的任务，即 runAllTasks</li>
</ul>
</li>
<li><p>每个 Worker NioEventLoop 处理业务时，会使用 Pipeline（管道），Pipeline 中包含了 Channel，即通过 Pipeline 可以获取到对应通道，管道中维护了很多的处理器 Handler</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-Channel与Pipeline.png" style="zoom: 50%;"></li>
</ol>
<hr>
<h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>开发简单的服务器端和客户端，基本介绍：</p>
<ul>
<li>Channel 理解为数据的通道，把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 Pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf</li>
<li>Handler 理解为数据的处理工序，Pipeline 负责发布事件传播给每个 Handler，Handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法），分 Inbound 和 Outbound 两类</li>
<li>EventLoop 理解为处理数据的执行者，既可以执行 IO 操作，也可以进行任务处理。每个执行者有任务队列，队列里可以堆放多个 Channel 的待处理任务，任务分为普通任务、定时任务。按照 Pipeline 顺序，依次按照 Handler 的规划（代码）处理数据</li>
</ul>
<p>代码实现：</p>
<ul>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.20.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>Server.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 1. 启动器，负责组装 netty 组件，启动服务器</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                <span class="comment">// 2. 线程组，boss 只负责【处理 accept 事件】， worker 只【负责 channel 上的读写】</span></span><br><span class="line">                .group(boss, worker)</span><br><span class="line">           	 	<span class="comment">//.option() 		// 给 ServerSocketChannel 配置参数</span></span><br><span class="line">            	<span class="comment">//.childOption()   	// 给 SocketChannel 配置参数</span></span><br><span class="line">                <span class="comment">// 3. 选择服务器的 ServerSocketChannel 实现</span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">// 4. boss 负责处理连接，worker(child) 负责处理读写，决定了能执行哪些操作(handler)</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="comment">// 5. channel 代表和客户端进行数据读写的通道 Initializer 初始化，负责添加别的 handler</span></span><br><span class="line">                    <span class="comment">// 7. 连接建立后，执行初始化方法</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="comment">// 添加具体的 handler</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());<span class="comment">// 将 ByteBuf 转成字符串</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123; <span class="comment">// 自定义 handler</span></span><br><span class="line">                            <span class="comment">// 读事件</span></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                                <span class="comment">// 打印转换好的字符串</span></span><br><span class="line">                                System.out.println(msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 6. 绑定监听端口</span></span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Client.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建启动器类</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                <span class="comment">// 2. 添加 EventLoop</span></span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">            	<span class="comment">//.option()，给 SocketChannel 配置参数</span></span><br><span class="line">                <span class="comment">// 3. 选择客户端 channel 实现</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">// 4. 添加处理器</span></span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="comment">// 4.1 连接建立后被调用</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="comment">// 将 Hello World 转为 ByteBuf</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 5. 连接到服务器，然后调用 4.1</span></span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>))</span><br><span class="line">                <span class="comment">// 6. 阻塞方法，直到连接建立</span></span><br><span class="line">                .sync()</span><br><span class="line">                <span class="comment">// 7. 代表连接对象</span></span><br><span class="line">                .channel()</span><br><span class="line">                <span class="comment">// 8. 向服务器发送数据</span></span><br><span class="line">                .writeAndFlush(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1py4y1E7oA">https://www.bilibili.com/video/BV1py4y1E7oA</a></p>
<hr>
<h2 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h2><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>事件循环对象 EventLoop，<strong>本质是一个单线程执行器同时维护了一个 Selector</strong>，有 run 方法处理 Channel 上源源不断的 IO 事件</p>
<p>事件循环组 EventLoopGroup 是一组 EventLoop，Channel 会调用 Boss EventLoopGroup 的 register 方法来绑定其中一个 Worker 的 EventLoop，后续这个 Channel 上的 IO 事件都由此 EventLoop 来处理，保证了事件处理时的线程安全</p>
<p>EventLoopGroup 类 API：</p>
<ul>
<li><p><code>EventLoop next()</code>：获取集合中下一个 EventLoop，EventLoopGroup 实现了 Iterable 接口提供遍历 EventLoop 的能力</p>
</li>
<li><p><code>Future&lt;?&gt; shutdownGracefully()</code>：优雅关闭的方法，会首先切换 EventLoopGroup 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行，从而确保整体应用是在正常有序的状态下退出的</p>
</li>
<li><p><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>：提交任务</p>
</li>
<li><p><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay</code>：提交定时任务</p>
</li>
</ul>
<hr>
<h4 id="任务传递"><a href="#任务传递" class="headerlink" title="任务传递"></a>任务传递</h4><p>把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventLoopServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="string">&quot;handler1&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                log.debug(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                                ctx.fireChannelRead(msg);   <span class="comment">// 让消息【传递】给下一个 handler</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;).addLast(group, <span class="string">&quot;handler2&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                log.debug(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ChannelHandlerContext <span class="title function_">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> &#123;</span><br><span class="line">    invokeChannelRead(findContextInbound(MASK_CHANNEL_READ), msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>), next);</span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    <span class="comment">// 下一个 handler 的事件循环是否与当前的事件循环是同一个线程</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="comment">// 是，直接调用</span></span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是，将要执行的代码作为任务提交给下一个 handler 处理</span></span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><h4 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h4><p>Channel 类 API：</p>
<ul>
<li><code>ChannelFuture close()</code>：关闭通道</li>
<li><code>ChannelPipeline pipeline()</code>：添加处理器</li>
<li><code>ChannelFuture write(Object msg)</code>：数据写入缓冲区</li>
<li><code>ChannelFuture writeAndFlush(Object msg)</code>：数据写入缓冲区并且刷出</li>
</ul>
<p>ChannelFuture 类 API：</p>
<ul>
<li><code>ChannelFuture sync()</code>：同步阻塞等待连接成功</li>
<li><code>ChannelFuture addListener(GenericFutureListener listener)</code>：异步等待</li>
</ul>
<p>代码实现：</p>
<ul>
<li>connect 方法是异步的，不等连接建立完成就返回，因此 channelFuture 对象中不能立刻获得到正确的 Channel 对象，需要等待</li>
<li>连接未建立 channel 打印为 <code>[id: 0x2e1884dd]</code>；建立成功打印为 <code>[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 1. 连接服务器，【异步非阻塞】，main 调用 connect 方法，真正执行连接的是 nio 线程</span></span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="comment">// 2.1 使用 sync 方法【同步】处理结果，阻塞当前线程，直到 nio 线程连接建立完毕</span></span><br><span class="line">        channelFuture.sync();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">        System.out.println(channel); <span class="comment">// 【打印】</span></span><br><span class="line">        <span class="comment">// 向服务器发送数据</span></span><br><span class="line">        channel.writeAndFlush(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        </span><br><span class="line">**************************************************************************************二选一</span><br><span class="line">        <span class="comment">// 2.2 使用 addListener 方法【异步】处理结果</span></span><br><span class="line">        channelFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// nio 线程连接建立好以后，回调该方法</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> future.channel();</span><br><span class="line">                	channel.writeAndFlush(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 建立失败，需要关闭</span></span><br><span class="line">                    future.channel().close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="关闭操作"><a href="#关闭操作" class="headerlink" title="关闭操作"></a>关闭操作</h4><p>关闭 EventLoopGroup 的运行，分为同步关闭和异步关闭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloseFutureClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                <span class="comment">// ....</span></span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.sync().channel();</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (line.equals(<span class="string">&quot;q&quot;</span>)) &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.writeAndFlush(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;input&quot;</span>).start();</span><br><span class="line">        <span class="comment">// 获取 CloseFuture 对象</span></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">closeFuture</span> <span class="operator">=</span> channel.closeFuture();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 同步处理关闭</span></span><br><span class="line">        System.out.println(<span class="string">&quot;waiting close...&quot;</span>);</span><br><span class="line">        closeFuture.sync();</span><br><span class="line">        System.out.println(<span class="string">&quot;处理关闭后的操作&quot;</span>);</span><br><span class="line">****************************************************</span><br><span class="line">        <span class="comment">// 2. 异步处理关闭</span></span><br><span class="line">        closeFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;处理关闭后的操作&quot;</span>);</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Netty 中的 Future 与 JDK 中的 Future 同名，但是功能的实现不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.util.concurrent;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">java</span>.util.concurrent.Future&lt;V&gt;</span><br></pre></td></tr></table></figure>

<p>Future 类 API：</p>
<ul>
<li><code>V get()</code>：阻塞等待获取任务执行结果</li>
<li><code>V getNow()</code>：非阻塞获取任务结果，还未产生结果时返回 null</li>
<li><code>Throwable cause()</code>：非阻塞获取失败信息，如果没有失败，返回 null</li>
<li><code>Future&lt;V&gt; sync()</code>：等待任务结束，如果任务失败，抛出异常</li>
<li><code>boolean cancel(boolean mayInterruptIfRunning)</code>：取消任务</li>
<li><code>Future&lt;V&gt; addListener(GenericFutureListener listener)</code>：添加回调，异步接收结果</li>
<li><code>boolean isSuccess()</code>：判断任务是否成功</li>
<li><code>boolean isCancellable()</code>：判断任务是否取消</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyFutureDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> group.next();</span><br><span class="line">        Future&lt;Integer&gt; future = eventLoop.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行计算&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">70</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        future.getNow();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;等待结果&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;&quot;</span> + future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="扩展子类"><a href="#扩展子类" class="headerlink" title="扩展子类"></a>扩展子类</h4><p>Promise 类是 Future 的子类，可以脱离任务独立存在，作为两个线程间传递结果的容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Promise</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Future</span>&lt;V&gt;</span><br></pre></td></tr></table></figure>

<p>Promise 类 API：</p>
<ul>
<li><code>Promise&lt;V&gt; setSuccess(V result)</code>：设置成功结果</li>
<li><code>Promise&lt;V&gt; setFailure(Throwable cause)</code>：设置失败结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyPromiseDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 准备 EventLoop 对象</span></span><br><span class="line">        <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>().next();</span><br><span class="line">        <span class="comment">// 2. 主动创建 promise</span></span><br><span class="line">        DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventLoop);</span><br><span class="line">        <span class="comment">// 3. 任意一个线程执行计算，计算完毕后向 promise 填充结果</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            promise.setSuccess(<span class="number">200</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 接受结果的线程</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;等待结果&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;&quot;</span> + promise.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>ChannelHandler 用来处理 Channel 上的各种事件，分为入站出站两种，所有 ChannelHandler 连接成双向链表就是 Pipeline</p>
<ul>
<li>入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果</li>
<li>出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工（入站和出站是对于服务端来说的）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">        .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">// 1. 通过 channel 拿到 pipeline</span></span><br><span class="line">                <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                <span class="comment">// 2. 添加处理器 head -&gt; h1 -&gt; h2 -&gt; h3 -&gt; h4 -&gt; tail</span></span><br><span class="line">                pipeline.addLast(<span class="string">&quot;h1&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> buf.toString(Charset.defaultCharset());</span><br><span class="line">                        <span class="comment">// 将数据传递给下一个【入站】handler，如果不调用该方法则链会断开</span></span><br><span class="line">                        <span class="built_in">super</span>.channelRead(ctx, s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                pipeline.addLast(<span class="string">&quot;h2&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                        <span class="comment">// 从【尾部开始向前触发】出站处理器</span></span><br><span class="line">                        ch.writeAndFlush(ctx.alloc().buffer().writeBytes(<span class="string">&quot;server&quot;</span>.getBytes()));</span><br><span class="line">                        <span class="comment">// 该方法会让管道从【当前 handler 向前】寻找出站处理器</span></span><br><span class="line">                        <span class="comment">// ctx.writeAndFlush();</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                pipeline.addLast(<span class="string">&quot;h3&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">                        <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                pipeline.addLast(<span class="string">&quot;h4&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">                        <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端依次打印：1 2 4 3 ，所以<strong>入站是按照 addLast 的顺序执行的，出站是按照 addLast 的逆序执行</strong></p>
<p>一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中关联着一个 ChannelHandler</p>
<p>入站事件和出站事件在一个双向链表中，两种类型的 handler 互不干扰：</p>
<ul>
<li>入站事件会从链表 head 往后传递到最后一个入站的 handler</li>
<li>出站事件会从链表 tail 往前传递到最前一个出站的 handler</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-ChannelPipeline.png"></p>
<hr>
<h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>ByteBuf 是对字节数据的封装，优点：</p>
<ul>
<li>池化，可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li>
<li>读写指针分离，不需要像 ByteBuffer 一样切换读写模式</li>
<li>可以自动扩容</li>
<li>支持链式调用，使用更流畅</li>
<li>零拷贝思想，例如 slice、duplicate、CompositeByteBuf</li>
</ul>
<hr>
<h4 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h4><p>创建方式</p>
<ul>
<li><code>ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(10)</code>：创建了一个默认的 ByteBuf，初始容量是 10</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ByteBuf <span class="title function_">buffer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (directByDefault) &#123;</span><br><span class="line">        <span class="keyword">return</span> directBuffer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heapBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(10)</code>：创建池化基于堆的 ByteBuf</p>
</li>
<li><p><code>ByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(10)</code>：创建池化基于直接内存的 ByteBuf</p>
</li>
<li><p><strong>推荐</strong>的创建方式：在添加处理器的方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>直接内存对比堆内存：</p>
<ul>
<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li>
<li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li>
</ul>
<p>池化的意义在于可以<strong>重用 ByteBuf</strong>，高并发时池化功能更节约内存，减少内存溢出的可能，与非池化对比：</p>
<ul>
<li>非池化，每次都要创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，堆内存会增加 GC 压力</li>
<li>池化，可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li>
</ul>
<p>池化功能的开启，可以通过下面的系统环境变量来设置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;	 <span class="comment"># VM 参数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现</li>
<li>4.1 之前，池化功能还不成熟，默认是非池化实现</li>
</ul>
<hr>
<h4 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h4><p>ByteBuf 由四部分组成，最开始读写指针（<strong>双指针</strong>）都在 0 位置</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-ByteBuf%E7%BB%84%E6%88%90.png"></p>
<p>写入方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>writeBoolean(boolean value)</td>
<td>写入 boolean 值</td>
<td>用一字节 01|00 代表 true|false</td>
</tr>
<tr>
<td>writeByte(int value)</td>
<td>写入 byte 值</td>
<td></td>
</tr>
<tr>
<td>writeInt(int value)</td>
<td>写入 int 值</td>
<td>Big Endian，即 0x250，写入后 00 00 02 50</td>
</tr>
<tr>
<td>writeIntLE(int value)</td>
<td>写入 int 值</td>
<td>Little Endian，即 0x250，写入后 50 02 00 00</td>
</tr>
<tr>
<td>writeBytes(ByteBuf src)</td>
<td>写入 ByteBuf</td>
<td></td>
</tr>
<tr>
<td>writeBytes(byte[] src)</td>
<td>写入 byte[]</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuffer src)</td>
<td>写入 NIO 的 ByteBuffer</td>
<td></td>
</tr>
<tr>
<td>int writeCharSequence(CharSequence s, Charset c)</td>
<td>写入字符串</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用</li>
<li>写入几位写指针后移几位，指向可以写入的位置</li>
<li>网络传输，默认习惯是 Big Endian</li>
</ul>
<p>扩容：写入数据时，容量不够了（初始容量是 10），这时会引发<strong>扩容</strong></p>
<ul>
<li>如果写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16</li>
<li>如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10 &#x3D; 1024（2^9&#x3D;512 不够）</li>
<li>扩容不能超过 max capacity 会报错</li>
</ul>
<p>读取方法：</p>
<ul>
<li><code>byte readByte()</code>：读取一个字节，读指针后移</li>
<li><code>byte getByte(int index)</code>：读取指定索引位置的字节，读指针不动</li>
<li><code>ByteBuf markReaderIndex()</code>：标记读数据的位置</li>
<li><code>ByteBuf resetReaderIndex()</code>：重置到标记位置，可以重复读取标记位置向后的数据</li>
</ul>
<hr>
<h4 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h4><p>Netty 中三种内存的回收：</p>
<ul>
<li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存</li>
<li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li>
<li>PooledByteBuf 和子类使用了池化机制，需要更复杂的规则来回收内存</li>
</ul>
<p>Netty 采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口，回收的规则：</p>
<ul>
<li>每个 ByteBuf 对象的初始计数为 1</li>
<li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li>
<li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li>
<li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> .ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 逻辑处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    buf.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pipeline 的存在，需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性，处理规则：</p>
<ul>
<li><p>创建 ByteBuf 放入 Pipeline</p>
</li>
<li><p>入站 ByteBuf 处理原则</p>
<ul>
<li><p>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release，反之不传递需要</p>
</li>
<li><p>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，此时必须 release</p>
</li>
<li><p>如果出现异常，ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</p>
</li>
<li><p>假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.debug();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// io.netty.util.ReferenceCountUtil#release(java.lang.Object)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ReferenceCounted) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ReferenceCounted) msg).release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>出站 ByteBuf 处理原则</p>
<ul>
<li>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</li>
</ul>
</li>
<li><p>不确定 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</p>
</li>
</ul>
<hr>
<h4 id="拷贝操作"><a href="#拷贝操作" class="headerlink" title="拷贝操作"></a>拷贝操作</h4><p>零拷贝方法：</p>
<ul>
<li><p><code>ByteBuf slice(int index, int length)</code>：对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，<strong>共用原始 ByteBuf 的内存</strong>，切片后的 ByteBuf 维护独立的 read，write 指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">    buf.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;);</span><br><span class="line">    <span class="comment">// 在切片过程中并没有发生数据复制</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">f1</span> <span class="operator">=</span> buf.slice(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    f1.retain();</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">f2</span> <span class="operator">=</span> buf.slice(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    f2.retain();</span><br><span class="line">    <span class="comment">// 对 f1 进行相关的操作也会体现在 buf 上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ByteBuf duplicate()</code>：截取原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的</p>
</li>
<li><p><code>CompositeByteBuf addComponents(boolean increaseWriterIndex, ByteBuf... buffers)</code>：合并多个 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">    buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">    buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">CompositeByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line">    <span class="comment">// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0</span></span><br><span class="line">    buf.addComponents(<span class="literal">true</span>, buf1, buf2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CompositeByteBuf 是一个组合的 ByteBuf，内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据</p>
<ul>
<li>优点：对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li>
<li>缺点：复杂了很多，多次操作会带来性能的损耗</li>
</ul>
</li>
</ul>
<p>深拷贝：</p>
<ul>
<li><code>ByteBuf copy()</code>：将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关</li>
</ul>
<p>池化相关：</p>
<ul>
<li><p>Unpooled 是一个工具类，提供了非池化的 ByteBuf 创建、组合、复制等操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf，零拷贝思想</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.wrappedBuffer(buf1, buf2);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="粘包半包"><a href="#粘包半包" class="headerlink" title="粘包半包"></a>粘包半包</h2><h3 id="现象演示"><a href="#现象演示" class="headerlink" title="现象演示"></a>现象演示</h3><p>在 TCP 传输中，客户端发送消息时，实际上是将数据写入 TCP 的缓存，此时数据的大小和缓存的大小就会造成粘包和半包</p>
<ul>
<li><p>当数据超过 TCP 缓存容量时，就会被拆分成多个包，通过 Socket 多次发送到服务端，服务端每次从缓存中取数据，产生半包问题</p>
</li>
<li><p>当数据小于 TCP 缓存容量时，缓存中可以存放多个包，客户端和服务端一次通信就可能传递多个包，这时候服务端就可能一次读取多个包，产生粘包的问题</p>
</li>
</ul>
<p>代码演示：</p>
<ul>
<li><p>客户端代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        send();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="comment">// 【在连接 channel 建立成功后，会触发 active 方法】</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 发送内容随机的数据包</span></span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span>];</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; r.nextInt(<span class="number">9</span>) + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                                    bytes[j] = (<span class="type">byte</span>) c;</span><br><span class="line">                                &#125;</span><br><span class="line">                                c++;</span><br><span class="line">                                buf.writeBytes(bytes);</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buf);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            <span class="comment">// 调整系统的接受缓冲区【滑动窗口】</span></span><br><span class="line">            <span class="comment">//serverBootstrap.option(ChannelOption.SO_RCVBUF, 10);</span></span><br><span class="line">            <span class="comment">// 调整 netty 的接受缓冲区（ByteBuf）</span></span><br><span class="line">            <span class="comment">//serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, </span></span><br><span class="line">            <span class="comment">//                            new AdaptiveRecvByteBufAllocator(16, 16, 16));</span></span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="comment">// 【这里可以添加解码器】</span></span><br><span class="line">                    <span class="comment">// LoggingHandler 用来打印消息</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">            channelFuture.sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">            log.debug(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>粘包效果展示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">09:<span class="number">57</span>:<span class="number">27.140</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler - [id: <span class="number">0xddbaaef6</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8701</span>] READ: 100B	<span class="comment">// 读了 100 字节，发生粘包</span></span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">30</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">31</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> |<span class="number">00000.</span>...<span class="number">.1</span>.....|</span><br><span class="line">|<span class="number">00000010</span>| <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">32</span> <span class="number">32</span> <span class="number">32</span> <span class="number">32</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">33</span> <span class="number">00</span> |...<span class="number">.2222</span>.....<span class="number">.3</span>.|</span><br><span class="line">|<span class="number">00000020</span>| <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">34</span> <span class="number">34</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> |.......<span class="number">.44</span>......|</span><br><span class="line">|<span class="number">00000030</span>| <span class="number">00</span> <span class="number">00</span> <span class="number">35</span> <span class="number">35</span> <span class="number">35</span> <span class="number">35</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">36</span> <span class="number">36</span> <span class="number">36</span> <span class="number">00</span> |.<span class="number">.5555</span>.....<span class="number">.666</span>.|</span><br><span class="line">|<span class="number">00000040</span>| <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">37</span> <span class="number">37</span> <span class="number">37</span> <span class="number">37</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> |.....<span class="number">.7777</span>......|</span><br><span class="line">|<span class="number">00000050</span>| <span class="number">38</span> <span class="number">38</span> <span class="number">38</span> <span class="number">38</span> <span class="number">38</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">39</span> <span class="number">39</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> |<span class="number">88888.</span>...<span class="number">.99</span>....|</span><br><span class="line">|<span class="number">00000060</span>| <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure></li>
</ul>
<p>解决方法：通过调整系统的接受缓冲区的滑动窗口和 Netty 的接受缓冲区保证每条包只含有一条数据，滑动窗口的大小仅决定了 Netty 读取的<strong>最小单位</strong>，实际每次读取的一般是它的整数倍</p>
<hr>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h4><p>发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点就是效率很低</p>
<p>客户端代码改造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 分 10 次发送</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="固定长度"><a href="#固定长度" class="headerlink" title="固定长度"></a>固定长度</h4><p>服务器端加入定长解码器，每一条消息采用固定长度。如果是半包消息，会缓存半包消息并等待下个包到达之后进行拼包合并，直到读取一个完整的消息包；如果是粘包消息，空余的位置会进行补 0，会浪费空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">10</span>));</span><br><span class="line">        <span class="comment">// LoggingHandler 用来打印消息</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">29</span>:<span class="number">06.522</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler - [id: <span class="number">0x38a70fbf</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10144</span>] READ: 10B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">31</span> <span class="number">31</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   |<span class="number">11.</span>.......      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:<span class="number">29</span>:<span class="number">06.522</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler - [id: <span class="number">0x38a70fbf</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10144</span>] READ: 10B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">32</span> <span class="number">32</span> <span class="number">32</span> <span class="number">32</span> <span class="number">32</span> <span class="number">32</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   |<span class="number">222222.</span>...      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h4><p>服务端加入行解码器，默认以 <code>\n</code> 或 <code>\r\n</code> 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">8</span>));</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>客户端在每条消息之后，加入 <code>\n</code> 分隔符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= r.nextInt(<span class="number">16</span>)+<span class="number">1</span>; j++) &#123;</span><br><span class="line">            buffer.writeByte((<span class="type">byte</span>) c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 10 代表 &#x27;\n&#x27;</span></span><br><span class="line">        buffer.writeByte(<span class="number">10</span>);</span><br><span class="line">        c++;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.writeAndFlush(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="预设长度"><a href="#预设长度" class="headerlink" title="预设长度"></a>预设长度</h4><p>LengthFieldBasedFrameDecoder 解码器自定义长度解决 TCP 粘包黏包问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> maxFrameLength		<span class="comment">// 数据最大长度</span></span><br><span class="line"><span class="type">int</span> lengthFieldOffset 	<span class="comment">// 长度字段偏移量，从第几个字节开始是内容的长度字段</span></span><br><span class="line"><span class="type">int</span> lengthFieldLength	<span class="comment">// 长度字段本身的长度</span></span><br><span class="line"><span class="type">int</span> lengthAdjustment 	<span class="comment">// 长度字段为基准，几个字节后才是内容</span></span><br><span class="line"><span class="type">int</span> initialBytesToStrip	<span class="comment">// 从头开始剥离几个字节解码后显示</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lengthFieldOffset   = <span class="number">1</span> (= the length of HDR1)</span><br><span class="line">lengthFieldLength   = <span class="number">2</span></span><br><span class="line">lengthAdjustment    = <span class="number">1</span> (= the length of HDR2)</span><br><span class="line">initialBytesToStrip = <span class="number">3</span> (= the length of HDR1 + LEN)</span><br><span class="line"></span><br><span class="line">BEFORE <span class="title function_">DECODE</span> <span class="params">(<span class="number">16</span> bytes)</span>                       AFTER <span class="title function_">DECODE</span> <span class="params">(<span class="number">13</span> bytes)</span><span class="comment">//解码</span></span><br><span class="line">+------+--------+------+----------------+      +------+----------------+</span><br><span class="line">| HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content |</span><br><span class="line">| <span class="number">0xCA</span> | <span class="number">0x000C</span> | <span class="number">0xFE</span> | <span class="string">&quot;HELLO, WORLD&quot;</span> |      | <span class="number">0xFE</span> | <span class="string">&quot;HELLO, WORLD&quot;</span> |</span><br><span class="line">+------+--------+------+----------------+      +------+----------------+</span><br></pre></td></tr></table></figure>

<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LengthFieldDecoderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(</span><br><span class="line">                <span class="comment">// int 占 4 字节，版本号一个字节</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>,<span class="number">5</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 个字节的内容长度， 实际内容</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        send(buffer, <span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">        send(buffer, <span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出缓存</span></span><br><span class="line">        channel.writeInbound(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(ByteBuf buffer, String content)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = content.getBytes();  <span class="comment">// 实际内容</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> bytes.length;          <span class="comment">// 实际内容长度</span></span><br><span class="line">        buffer.writeInt(length);</span><br><span class="line">        buffer.writeByte(<span class="number">1</span>);                <span class="comment">// 表示版本号</span></span><br><span class="line">        buffer.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">49</span>:<span class="number">59.344</span> [main] DEBUG io.netty.handler.logging.LoggingHandler - [id: 0xembedded, L:embedded - R:embedded] READ: 12B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">48</span> <span class="number">65</span> 6c 6c <span class="number">6f</span> 2c <span class="number">20</span> <span class="number">77</span> <span class="number">6f</span> <span class="number">72</span> 6c <span class="number">64</span>             |Hello, world    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:<span class="number">49</span>:<span class="number">59.344</span> [main] DEBUG io.netty.handler.logging.LoggingHandler - [id: 0xembedded, L:embedded - R:embedded] READ: 3B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">48</span> <span class="number">69</span> <span class="number">21</span>                                        |Hi!             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>访问 URL：<a href="http://localhost:8080/">http://localhost:8080/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">                    <span class="comment">// 只针对某一种类型的请求处理，此处针对 HttpRequest</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;HttpRequest&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpRequest msg)</span> &#123;</span><br><span class="line">                            <span class="comment">// 获取请求</span></span><br><span class="line">                            log.debug(msg.uri());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 返回响应</span></span><br><span class="line">                            <span class="type">DefaultFullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(</span><br><span class="line">                                msg.protocolVersion(), HttpResponseStatus.OK);</span><br><span class="line"></span><br><span class="line">                            <span class="type">byte</span>[] bytes = <span class="string">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>.getBytes();</span><br><span class="line"></span><br><span class="line">                            response.headers().setInt(CONTENT_LENGTH, bytes.length);</span><br><span class="line">                            response.content().writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 写回响应</span></span><br><span class="line">                            ctx.writeAndFlush(response);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;n3.server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>处理器代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodec</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageCodec</span>&lt;Message&gt; &#123;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充, 1 字节</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 获取内容的字节数组，msg 对象序列化</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(), <span class="keyword">new</span> <span class="title class_">MessageCodec</span>());</span><br><span class="line">    <span class="comment">// encode</span></span><br><span class="line">    <span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">    channel.writeOutbound(message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// decode</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MessageCodec</span>().encode(<span class="literal">null</span>, message, buf);</span><br><span class="line">    <span class="comment">// 入站</span></span><br><span class="line">    channel.writeInbound(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginRequestMessage</span> <span class="keyword">extends</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// set + get </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE.png"></p>
<hr>
<h4 id="Sharable"><a href="#Sharable" class="headerlink" title="Sharable"></a>Sharable</h4><p>@Sharable 注解的添加时机：</p>
<ul>
<li><p>当 handler 不保存状态时，就可以安全地在多线程下被共享</p>
</li>
<li><p>对于编解码器类不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler，它们的构造方法对 @Sharable 有限制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">ByteToMessageCodec</span><span class="params">(<span class="type">boolean</span> preferDirect)</span> &#123;</span><br><span class="line">    ensureNotSharable();</span><br><span class="line">    outboundMsgMatcher = TypeParameterMatcher.find(<span class="built_in">this</span>, ByteToMessageCodec.class, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">    encoder = <span class="keyword">new</span> <span class="title class_">Encoder</span>(preferDirect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">ensureNotSharable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果类上有该注解</span></span><br><span class="line">    <span class="keyword">if</span> (isSharable()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果能确保编解码器不会保存状态，可以继承 MessageToMessageCodec 父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="comment">// 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodecSharable</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">out</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        <span class="comment">// 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">		<span class="comment">// ....</span></span><br><span class="line">        outList.add(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="场景优化"><a href="#场景优化" class="headerlink" title="场景优化"></a>场景优化</h2><h3 id="空闲检测"><a href="#空闲检测" class="headerlink" title="空闲检测"></a>空闲检测</h3><h4 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h4><p>连接假死就是客户端数据发不出去，服务端也一直收不到数据，保持这种状态，假死的连接占用的资源不能自动释放，而且向假死连接发送数据，得到的反馈是发送超时</p>
<p>解决方案：每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死</p>
<p>IdleStateHandler 是 Netty 提供的处理空闲状态的处理器，用来判断是不是读空闲时间或写空闲时间过长</p>
<ul>
<li>参数一 long readerIdleTime：读空闲，表示多长时间没有读</li>
<li>参数二 long writerIdleTime：写空闲，表示多长时间没有写</li>
<li>参数三 long allIdleTime：读写空闲，表示多长时间没有读写</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">MessageCodec</span>());</span><br><span class="line">        <span class="comment">// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件，</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// ChannelDuplexHandler 【可以同时作为入站和出站】处理器</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelDuplexHandler</span>() &#123;</span><br><span class="line">            <span class="comment">// 用来触发特殊事件</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">                <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">                <span class="comment">// 触发了读空闲事件</span></span><br><span class="line">                <span class="keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;已经 5s 没有读到数据了&quot;</span>);</span><br><span class="line">                    ctx.channel().close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h4><p>客户端定时向服务器端发送数据，<strong>时间间隔要小于服务器定义的空闲检测的时间间隔</strong>，就能防止误判连接假死，这就是心跳机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">MessageCodec</span>());</span><br><span class="line">        <span class="comment">// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelDuplexHandler</span>() &#123;</span><br><span class="line">            <span class="comment">// 用来触发特殊事件</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">                <span class="comment">// 触发了写空闲事件</span></span><br><span class="line">                <span class="keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                    <span class="comment">// 3s 没有写数据了，【发送一个心跳包】</span></span><br><span class="line">                    ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">PingMessage</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="普通方式"><a href="#普通方式" class="headerlink" title="普通方式"></a>普通方式</h4><p>序列化，反序列化主要用在消息正文的转换上</p>
<ul>
<li>序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）</li>
<li>反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理</li>
</ul>
<p>代码实现：</p>
<ul>
<li><p>抽象一个 Serializer 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">    <span class="comment">// 反序列化方法</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span>;</span><br><span class="line">    <span class="comment">// 序列化方法</span></span><br><span class="line">    &lt;T&gt; <span class="type">byte</span>[] serialize(T object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供两个实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SerializerAlgorithm</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">	<span class="comment">// Java 实现</span></span><br><span class="line">    Java &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">                <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> in.readObject();</span><br><span class="line">                <span class="keyword">return</span> (T) object;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;SerializerAlgorithm.Java 反序列化错误&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out).writeObject(object);</span><br><span class="line">                <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;SerializerAlgorithm.Java 序列化错误&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// Json 实现(引入了 Gson 依赖)</span></span><br><span class="line">    Json &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, StandardCharsets.UTF_8), clazz);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(object).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要从协议的字节中得到是哪种序列化算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SerializerAlgorithm <span class="title function_">getByInt</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        SerializerAlgorithm[] array = SerializerAlgorithm.values();</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span> || type &gt; array.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;超过 SerializerAlgorithm 范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[type];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="ProtoBuf"><a href="#ProtoBuf" class="headerlink" title="ProtoBuf"></a>ProtoBuf</h4><h5 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>Codec（编解码器）的组成部分有两个：Decoder（解码器）和 Encoder（编码器）。Encoder 负责把业务数据转换成字节码数据，Decoder 负责把字节码数据转换成业务数据</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-编码解码.png" style="zoom: 67%;">



<p>Protobuf 是 Google 发布的开源项目，全称  Google Protocol Buffers ，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。很适合做数据存储或 RPC（远程过程调用 remote procedure call）数据交换格式。目前很多公司从 HTTP + Json 转向 TCP + Protobuf ，效率会更高</p>
<p>Protobuf 是以 message 的方式来管理数据，支持跨平台、跨语言（客户端和服务器端可以是不同的语言编写的），高性能、高可靠性</p>
<p>工作过程：使用 Protobuf 编译器自动生成代码，Protobuf 是将类的定义使用 .proto 文件进行描述，然后通过 protoc.exe 编译器根据  .proto 自动生成 .java 文件</p>
<hr>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><ul>
<li><p>单个 message：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; 								<span class="comment">// 版本</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;StudentPOJO&quot;</span>;	<span class="comment">// 生成的外部类名，同时也是文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Student</span> &#123; 	<span class="comment">// 在 StudentPOJO 外部类种生成一个内部类 Student，是真正发送的 POJO 对象</span></span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>; 	<span class="comment">// Student 类中有一个属性：名字为 id 类型为 int32(protobuf类型) ，1表示属性序号，不是值</span></span><br><span class="line">    <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-Protobuf编译文件.png" style="zoom:80%;">

<p>编译 <code>protoc.exe --java_out=.Student.proto</code>（cmd 窗口输入） 将生成的 StudentPOJO 放入到项目使用</p>
<p>Server 端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>() <span class="comment">//...</span></span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;	<span class="comment">// 创建一个通道初始化对象</span></span><br><span class="line">        <span class="comment">// 给pipeline 设置处理器</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 在pipeline加入ProtoBufDecoder，指定对哪种对象进行解码</span></span><br><span class="line">            ch.pipeline().addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">ProtobufDecoder</span>(</span><br><span class="line">                							StudentPOJO.Student.getDefaultInstance()));</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyServerHandler</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client 端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>().group(group) 			<span class="comment">// 设置线程组</span></span><br><span class="line">    .channel(NioSocketChannel.class) 	<span class="comment">// 设置客户端通道的实现类(反射)</span></span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 在pipeline中加入 ProtoBufEncoder</span></span><br><span class="line">            ch.pipeline().addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">ProtobufEncoder</span>());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>()); <span class="comment">// 加入自定义的业务处理器</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个 message：Protobuf 可以使用 message 管理其他的 message。假设某个项目需要传输 20 个对象，可以在一个文件里定义 20 个 message，最后再用一个总的 message 来决定在实际传输时真正需要传输哪一个对象</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> optimize_for = SPEED; 					<span class="comment">// 加快解析</span></span><br><span class="line"><span class="keyword">option</span> java_package=<span class="string">&quot;com.atguigu.netty.codec2&quot;</span>;	<span class="comment">// 指定生成到哪个包下</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname=<span class="string">&quot;MyDataInfo&quot;</span>; 		<span class="comment">// 外部类名, 文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">MyMessage</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个枚举类型，DataType 如果是 0 则表示一个 Student 对象实例，DataType 这个名称自定义</span></span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">DataType</span> &#123;</span><br><span class="line">        StudentType = <span class="number">0</span>; <span class="comment">//在 proto3 要求 enum 的编号从 0 开始</span></span><br><span class="line">        WorkerType = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 data_type 来标识传的是哪一个枚举类型，这里才真正开始定义 Message 的数据类型</span></span><br><span class="line">    DataType data_type = <span class="number">1</span>;  <span class="comment">// 所有后面的数字都只是编号而已</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// oneof 关键字，表示每次枚举类型进行传输时，限制最多只能传输一个对象。</span></span><br><span class="line">    <span class="comment">// dataBody名称也是自定义的</span></span><br><span class="line">    <span class="comment">// MyMessage 里出现的类型只有两个 DataType 类型，Student 或者 Worker 类型，在真正传输的时候只会有一个出现</span></span><br><span class="line">    <span class="keyword">oneof</span> dataBody &#123;</span><br><span class="line">        Student student = <span class="number">2</span>;  <span class="comment">//注意这后面的数字也都只是编号而已，上面DataType data_type = 1  占了第一个序号了</span></span><br><span class="line">        Worker worker = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;		<span class="comment">// Student类的属性</span></span><br><span class="line">    <span class="type">string</span> name = <span class="number">2</span>; 	<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="type">string</span> name=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int32</span> age=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<p>Server 端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">ProtobufDecoder</span>(MyDataInfo.MyMessage.getDefaultInstance()));</span><br></pre></td></tr></table></figure>

<p>Client 端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">ProtobufEncoder</span>());</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>HTTP 协议是无状态的，浏览器和服务器间的请求响应一次，下一次会重新创建连接。实现基于 WebSocket 的长连接的全双工的交互，改变 HTTP 协议多次请求的约束</p>
<p>开发需求：</p>
<ul>
<li>实现长连接，服务器与浏览器相互通信客户端</li>
<li>浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</li>
</ul>
<p>代码实现：</p>
<ul>
<li><p>WebSocket：</p>
<ul>
<li><p>WebSocket 的数据是<strong>以帧（frame）形式传递</strong>，WebSocketFrame 下面有六个子类，代表不同的帧格式</p>
</li>
<li><p>浏览器请求 URL：ws:&#x2F;&#x2F;localhost:8080&#x2F;xxx</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebSocket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建两个线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup);</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO));</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 基于 http 协议，使用 http 的编码和解码器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">                    <span class="comment">// 是以块方式写，添加 ChunkedWriteHandler 处理器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ChunkedWriteHandler</span>());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// http 数据在传输过程中是分段, HttpObjectAggregator 就是可以将多个段聚合</span></span><br><span class="line">                    <span class="comment">//  这就就是为什么，当浏览器发送大量数据时，就会发出多次 http 请求</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">8192</span>));</span><br><span class="line">        </span><br><span class="line">                    <span class="comment">// WebSocketServerProtocolHandler 核心功能是【将 http 协议升级为 ws 协议】，保持长连接</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">WebSocketServerProtocolHandler</span>(<span class="string">&quot;/hello&quot;</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 自定义的handler ，处理业务逻辑</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyTextWebSocketFrameHandler</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动服务器</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTextWebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;TextWebSocketFrame&gt; &#123;</span><br><span class="line">    <span class="comment">// TextWebSocketFrame 类型，表示一个文本帧(frame)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器收到消息 &quot;</span> + msg.text());</span><br><span class="line">        <span class="comment">// 回复消息</span></span><br><span class="line">        ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(<span class="string">&quot;服务器时间&quot;</span> + LocalDateTime.now() + <span class="string">&quot; &quot;</span> + msg.text()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当web客户端连接后， 触发方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// id 表示唯一的值，LongText 是唯一的 ShortText 不是唯一</span></span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asShortText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerRemoved 被调用&quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常发生 &quot;</span> + cause.getMessage());</span><br><span class="line">        ctx.close(); <span class="comment">// 关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTML：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> socket;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 判断当前浏览器是否支持websocket</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">WebSocket</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//go on</span></span></span><br><span class="line"><span class="language-javascript">        socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:8080/hello&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//相当于channelReado, ev 收到服务器端回送的消息</span></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> rt = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            rt.<span class="property">value</span> = rt.<span class="property">value</span> + <span class="string">&quot;\n&quot;</span> + ev.<span class="property">data</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//相当于连接开启(感知到连接开启)</span></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> rt = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            rt.<span class="property">value</span> = <span class="string">&quot;连接开启了..&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//相当于连接关闭(感知到连接关闭)</span></span></span><br><span class="line"><span class="language-javascript">        socket.<span class="property">onclose</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> rt = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            rt.<span class="property">value</span> = rt.<span class="property">value</span> + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;连接关闭了..&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;当前浏览器不支持websocket&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 发送消息到服务器</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">send</span>(<span class="params">message</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 先判断socket是否创建好</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(!<span class="variable language_">window</span>.<span class="property">socket</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(socket.<span class="property">readyState</span> == <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 通过socket 发送消息</span></span></span><br><span class="line"><span class="language-javascript">            socket.<span class="title function_">send</span>(message)</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;连接没有开启&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 300px; width: 300px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;发生消息&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;send(this.form.message.value)&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;responseText&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 300px; width: 300px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;清空内容&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h3><h4 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h4><p>参数配置方式：</p>
<ul>
<li>客户端通过 .option() 方法配置参数，给 SocketChannel 配置参数</li>
<li>服务器端：<ul>
<li>new ServerBootstrap().option()： 给 ServerSocketChannel 配置参数</li>
<li>new ServerBootstrap().childOption()：给 SocketChannel 配置参数</li>
</ul>
</li>
</ul>
<p>CONNECT_TIMEOUT_MILLIS 参数：</p>
<ul>
<li><p>属于 SocketChannal 参数</p>
</li>
<li><p>在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常</p>
</li>
<li><p>SO_TIMEOUT 主要用在阻塞 IO，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，可以调整超时时间</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionTimeoutTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>());</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">            future.sync().channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.debug(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="SO-BACKLOG"><a href="#SO-BACKLOG" class="headerlink" title="SO_BACKLOG"></a>SO_BACKLOG</h4><p>属于 ServerSocketChannal 参数，通过 <code>option(ChannelOption.SO_BACKLOG, value)</code> 来设置大小</p>
<p>在 Linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制</p>
<ul>
<li>sync queue：半连接队列，大小通过 <code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code> 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制</li>
<li>accept queue：全连接队列，大小通过 <code>/proc/sys/net/core/somaxconn</code> 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值。如果 accpet queue 队列满了，server 将<strong>发送一个拒绝连接的错误信息</strong>到 client</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p>
<hr>
<h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4><p>ALLOCATOR：属于 SocketChannal 参数，用来分配 ByteBuf， ctx.alloc()</p>
<p>RCVBUF_ALLOCATOR：属于 SocketChannal 参数</p>
<ul>
<li>控制 Netty 接收缓冲区大小</li>
<li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定</li>
</ul>
<hr>
<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是一种先进先出的数据结构，常见的应用场景：</p>
<ul>
<li><p>应用解耦：系统的耦合性越高，容错性就越低</p>
<p>实例：用户创建订单后，耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障都会造成下单异常，影响用户使用体验。使用消息队列解耦合，比如物流系统发生故障，需要几分钟恢复，将物流系统要处理的数据缓存到消息队列中，用户的下单操作正常完成。等待物流系统正常后处理存在消息队列中的订单消息即可，终端系统感知不到物流系统发生过几分钟故障</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E8%A7%A3%E8%80%A6.png"></p>
</li>
<li><p>流量削峰：应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮，使用消息队列可以将大量请求缓存起来，分散到很长一段时间处理，这样可以提高系统的稳定性和用户体验</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0.png"></p>
</li>
<li><p>数据分发：让数据在多个系统更加之间进行流通，数据的产生方不需要关心谁来使用数据，只需要将数据发送到消息队列，数据使用方直接在消息队列中直接获取数据</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E6%95%B0%E6%8D%AE%E5%88%86%E5%8F%91.png"></p>
</li>
</ul>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1L4411y7mn">https://www.bilibili.com/video/BV1L4411y7mn</a></p>
<hr>
<h3 id="安装测试"><a href="#安装测试" class="headerlink" title="安装测试"></a>安装测试</h3><p>安装需要 Java 环境，下载解压后进入安装目录，进行启动：</p>
<ul>
<li><p>启动 NameServer</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.启动 NameServer</span></span><br><span class="line"><span class="built_in">nohup</span> sh bin/mqnamesrv &amp;</span><br><span class="line"><span class="comment"># 2.查看启动日志</span></span><br><span class="line"><span class="built_in">tail</span> -f ~/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure>

<p>RocketMQ 默认的虚拟机内存较大，需要编辑如下两个配置文件，修改 JVM 内存大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑runbroker.sh和runserver.sh修改默认JVM大小</span></span><br><span class="line">vi runbroker.sh</span><br><span class="line">vi runserver.sh</span><br></pre></td></tr></table></figure>

<p>参考配置：JAVA_OPT&#x3D;”${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize&#x3D;128m  -XX:MaxMetaspaceSize&#x3D;320m”</p>
</li>
<li><p>启动 Broker</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.启动 Broker</span></span><br><span class="line"><span class="built_in">nohup</span> sh bin/mqbroker -n localhost:9876 autoCreateTopicEnable=<span class="literal">true</span> &amp;</span><br><span class="line"><span class="comment"># 2.查看启动日志</span></span><br><span class="line"><span class="built_in">tail</span> -f ~/logs/rocketmqlogs/broker.log </span><br></pre></td></tr></table></figure>
</li>
<li><p>发送消息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.设置环境变量</span></span><br><span class="line"><span class="built_in">export</span> NAMESRV_ADDR=localhost:9876</span><br><span class="line"><span class="comment"># 2.使用安装包的 Demo 发送消息</span></span><br><span class="line">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure>
</li>
<li><p>接受消息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">  <span class="comment"># 1.设置环境变量</span></span><br><span class="line">  <span class="built_in">export</span> NAMESRV_ADDR=localhost:9876</span><br><span class="line">  <span class="comment"># 2.接收消息</span></span><br><span class="line">  sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br><span class="line"></span><br><span class="line">* 关闭 RocketMQ：</span><br><span class="line"></span><br><span class="line">  ```sh</span><br><span class="line">  <span class="comment"># 1.关闭 NameServer</span></span><br><span class="line">  sh bin/mqshutdown namesrv</span><br><span class="line">  <span class="comment"># 2.关闭 Broker</span></span><br><span class="line">  sh bin/mqshutdown broker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 相关概念</span></span><br><span class="line"></span><br><span class="line">RocketMQ 主要由 Producer、Broker、Consumer 三部分组成，其中 Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息，NameServer 负责管理 Broker</span><br><span class="line"></span><br><span class="line">* 代理服务器（Broker Server）：消息中转角色，负责**存储消息、转发消息**。在 RocketMQ 系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备，也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等</span><br><span class="line">* 名字服务（Name Server）：充当**路由消息**的提供者。生产者或消费者能够通过名字服务查找各主题相应的 Broker IP 列表</span><br><span class="line">* 消息生产者（Producer）：负责**生产消息**，把业务应用系统里产生的消息发送到 Broker 服务器。RocketMQ 提供多种发送方式，同步发送、异步发送、顺序发送、单向发送，同步和异步方式均需要 Broker 返回确认信息，单向发送不需要；可以通过 MQ 的负载均衡模块选择相应的 Broker 集群队列进行消息投递，投递的过程支持快速失败并且低延迟</span><br><span class="line">* 消息消费者（Consumer）：负责**消费消息**，一般是后台系统负责异步消费，一个消息消费者会从 Broker 服务器拉取消息、并将其提供给应用程序。从用户应用的角度而提供了两种消费形式：</span><br><span class="line">  * 拉取式消费（Pull Consumer）：应用通主动调用 Consumer 的拉消息方法从 Broker 服务器拉消息，主动权由应用控制，一旦获取了批量消息，应用就会启动消费过程</span><br><span class="line">  * 推动式消费（Push Consumer）：该模式下 Broker 收到数据后会主动推送给消费端，实时性较高</span><br><span class="line">* 生产者组（Producer Group）：同一类 Producer 的集合，发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，**则 Broker 服务器会联系同一生产者组的其他生产者实例以提交或回溯消费**</span><br><span class="line">* 消费者组（Consumer Group）：同一类 Consumer 的集合，消费者实例必须订阅完全相同的 Topic，消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面更容易的实现负载均衡和容错。RocketMQ 支持两种消息模式：</span><br><span class="line">  *  集群消费（Clustering）：相同 Consumer Group 的每个 Consumer 实例平均分摊消息</span><br><span class="line">  *  广播消费（Broadcasting）：相同 Consumer Group 的每个 Consumer 实例都接收全量的消息</span><br><span class="line"></span><br><span class="line">每个 Broker 可以存储多个 Topic 的消息，每个 Topic 的消息也可以分片存储于不同的 Broker，Message Queue（消息队列）是用于存储消息的物理地址，每个 Topic 中的消息地址存储于多个 Message Queue 中</span><br><span class="line"></span><br><span class="line">* 主题（Topic）：表示一类消息的集合，每个主题包含若干条消息，每条消息只属于一个主题，是 RocketMQ 消息订阅的基本单位</span><br><span class="line"></span><br><span class="line">* 消息（Message）：消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ 中每个消息拥有唯一的 Message ID，且可以携带具有业务标识的 Key，系统提供了通过 Message ID 和 Key 查询消息的功能</span><br><span class="line"></span><br><span class="line">* 标签（Tag）：为消息设置的标志，用于同一主题下区分不同类型的消息。标签能够有效地保持代码的清晰度和连贯性，并优化 RocketMQ 提供的查询系统，消费者可以根据 Tag 实现对不同子主题的不同消费逻辑，实现更好的扩展性</span><br><span class="line"></span><br><span class="line">* 普通顺序消息（Normal Ordered Message）：消费者通过同一个消息队列（Topic 分区）收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的</span><br><span class="line"></span><br><span class="line">* 严格顺序消息（Strictly Ordered Message）：消费者收到的所有消息均是有顺序的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">官方文档：https://github.com/apache/rocketmq/tree/master/docs/cn（基础知识部分的笔记参考官方文档编写）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">****</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 消息操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 基本样例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 订阅发布</span></span><br><span class="line"></span><br><span class="line">消息的发布是指某个生产者向某个 Topic 发送消息，消息的订阅是指某个消费者关注了某个 Topic 中带有某些 Tag 的消息，进而从该 Topic 消费数据</span><br><span class="line"></span><br><span class="line">导入 MQ 客户端依赖：</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>消息发送者步骤分析：</p>
<ol>
<li>创建消息生产者 Producer，并制定生产者组名</li>
<li>指定 Nameserver 地址</li>
<li>启动 Producer</li>
<li>创建消息对象，指定主题 Topic、Tag 和消息体</li>
<li>发送消息</li>
<li>关闭生产者 Producer</li>
</ol>
<p>消息消费者步骤分析：</p>
<ol>
<li>创建消费者 Consumer，制定消费者组名</li>
<li>指定 Nameserver 地址</li>
<li>订阅主题 Topic 和 Tag</li>
<li>设置回调函数，处理消息</li>
<li>启动消费者 Consumer</li>
</ol>
<p>官方文档：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md">https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md</a></p>
<hr>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><h5 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h5><p>使用 RocketMQ 发送三种类型的消息：同步消息、异步消息和单向消息，其中前两种消息是可靠的，因为会有发送是否成功的应答</p>
<p>这种可靠性同步地发送方式使用的比较广泛，比如：重要的消息通知，短信通知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncProducer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    	<span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">    	producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    	<span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    	    <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">    	    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(</span><br><span class="line">                <span class="string">&quot;TopicTest&quot;</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">&quot;TagA&quot;</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">        		(<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span>);</span><br><span class="line">            </span><br><span class="line">        	<span class="comment">// 发送消息到一个Broker</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line">            <span class="comment">// 通过sendResult返回消息是否成功送达</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    	producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h5><p>异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待 Broker 的响应</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncProducer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    	<span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    	<span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">        <span class="type">int</span> <span class="variable">messageCount</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">		<span class="comment">// 根据消息数量实例化倒计时计算器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch2</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch2</span>(messageCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; messageCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;OrderID188&quot;</span>,</span><br><span class="line">                                      <span class="string">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// SendCallback接收异步返回结果的回调</span></span><br><span class="line">            producer.send(msg, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">                <span class="comment">// 发送成功回调函数</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%-10d OK %s %n&quot;</span>, index, sendResult.getMsgId());</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%-10d Exception %s %n&quot;</span>, index, e);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待5s</span></span><br><span class="line">        countDownLatch.await(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="单向发送"><a href="#单向发送" class="headerlink" title="单向发送"></a>单向发送</h5><p>单向发送主要用在不特别关心发送结果的场景，例如日志发送</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnewayProducer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    	<span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    	<span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        	<span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">        	<span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest&quot;</span>,<span class="string">&quot;TagA&quot;</span>,</span><br><span class="line">                          (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">        	<span class="comment">// 发送单向消息，没有任何返回结果</span></span><br><span class="line">        	producer.sendOneway(msg);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    	producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException &#123;</span><br><span class="line">    	<span class="comment">// 实例化消费者</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 订阅一个或者多个Topic，以及Tag来过滤需要消费的消息</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    	<span class="comment">// 注册消息监听器，回调实现类来处理从broker拉取回来的消息</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="comment">// 接受消息内容</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="comment">// 标记该消息已经被成功消费</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动消费者实例</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><h4 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h4><p>消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了三条消息分别是订单创建、订单付款、订单完成。消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的，RocketMQ 可以严格的保证消息有序。</p>
<p>顺序消息分为全局顺序消息与分区顺序消息，</p>
<ul>
<li>全局顺序：对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费，适用于性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景</li>
<li>分区顺序：对于指定的一个 Topic，所有消息根据 Sharding key 进行分区，同一个分组内的消息按照严格的 FIFO 顺序进行发布和消费。Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念，适用于性能要求高的场景</li>
</ul>
<p>在默认的情况下消息发送会采取 Round Robin 轮询方式把消息发送到不同的 queue（分区队列），而消费消息是从多个 queue 上拉取消息，这种情况发送和消费是不能保证顺序。但是如果控制发送的顺序消息只依次发送到同一个 queue 中，消费的时候只从这个 queue 上依次拉取，则就保证了顺序。当<strong>发送和消费参与的 queue 只有一个</strong>，则是全局有序；如果多个queue 参与，则为分区有序，即相对每个 queue，消息都是有序的</p>
<hr>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>一个订单的顺序流程是：创建、付款、推送、完成，订单号相同的消息会被先后发送到同一个队列中，消费时同一个 OrderId 获取到的肯定是同一个队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">		<span class="comment">// 标签集合</span></span><br><span class="line">        String[] tags = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;TagC&quot;</span>, <span class="string">&quot;TagD&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订单列表</span></span><br><span class="line">        List&lt;OrderStep&gt; orderList = <span class="keyword">new</span> <span class="title class_">Producer</span>().buildOrders();</span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 加个时间前缀</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> dateStr + <span class="string">&quot; Hello RocketMQ &quot;</span> + orderList.get(i);</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;OrderTopic&quot;</span>, tags[i % tags.length], <span class="string">&quot;KEY&quot;</span> + i, body.getBytes());</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数一：消息对象</span></span><br><span class="line"><span class="comment">             * 参数二：消息队列的选择器</span></span><br><span class="line"><span class="comment">             * 参数三：选择队列的业务标识（订单 ID）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg, <span class="keyword">new</span> <span class="title class_">MessageQueueSelector</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * mqs：队列集合</span></span><br><span class="line"><span class="comment">                 * msg：消息对象</span></span><br><span class="line"><span class="comment">                 * arg：业务标识的参数</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">public</span> MessageQueue <span class="title function_">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> &#123;</span><br><span class="line">                    <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> (Long) arg;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">index</span> <span class="operator">=</span> id % mqs.size(); <span class="comment">// 根据订单id选择发送queue</span></span><br><span class="line">                    <span class="keyword">return</span> mqs.get((<span class="type">int</span>) index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, orderList.get(i).getOrderId());<span class="comment">//订单id</span></span><br><span class="line"></span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;SendResult status:%s, queueId:%d, body:%s&quot;</span>,</span><br><span class="line">                    sendResult.getSendStatus(),</span><br><span class="line">                    sendResult.getMessageQueue().getQueueId(),</span><br><span class="line">                    body));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订单的步骤</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OrderStep</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> orderId;</span><br><span class="line">        <span class="keyword">private</span> String desc;</span><br><span class="line">        <span class="comment">// set + get</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成模拟订单数据</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderStep&gt; <span class="title function_">buildOrders</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;OrderStep&gt; orderList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OrderStep&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">OrderStep</span> <span class="variable">orderDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103111065L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;付款&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103117235L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103111065L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;付款&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103117235L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;付款&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103111065L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;推送&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103117235L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = <span class="keyword">new</span> <span class="title class_">OrderStep</span>();</span><br><span class="line">        orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">        orderDemo.setDesc(<span class="string">&quot;完成&quot;</span>);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> orderList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序消息消费，带事务方式（应用可控制Offset什么时候提交）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerInOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;please_rename_unique_group_name_3&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费</span></span><br><span class="line">        <span class="comment">// 如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">		<span class="comment">// 订阅三个tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;OrderTopic&quot;</span>, <span class="string">&quot;TagA || TagC || TagD&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;</span><br><span class="line">                context.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="comment">// 可以看到每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;consumeThread=&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;queueId=&quot;</span> + msg.getQueueId() + <span class="string">&quot;, content:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer Started.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h3><h4 id="原理解析-1"><a href="#原理解析-1" class="headerlink" title="原理解析"></a>原理解析</h4><p>定时消息（延迟队列）是指消息发送到 Broker 后，不会立即被消费，等待特定时间投递给真正的 Topic</p>
<p>RocketMQ 并不支持任意时间的延时，需要设置几个固定的延时等级，从 1s 到 2h 分别对应着等级 1 到 18，消息消费失败会进入延时消息队列，消息发送时间与设置的延时等级和重试次数有关，详见代码 <code>SendMessageProcessor.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">messageDelayLevel</span> <span class="operator">=</span> <span class="string">&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Broker 可以配置 messageDelayLevel，该属性是 Broker 的属性，不属于某个 Topic</p>
<p>发消息时，可以设置延迟等级 <code>msg.setDelayLevel(level)</code>，level 有以下三种情况：</p>
<ul>
<li>level &#x3D;&#x3D; 0：消息为非延迟消息</li>
<li>1&lt;&#x3D;level&lt;&#x3D;maxLevel：消息延迟特定时间，例如 level&#x3D;&#x3D;1，延迟 1s</li>
<li>level &gt; maxLevel：则 level&#x3D;&#x3D; maxLevel，例如 level&#x3D;&#x3D;20，延迟 2h</li>
</ul>
<p>定时消息会暂存在名为 SCHEDULE_TOPIC_XXXX 的 Topic 中，并根据 delayTimeLevel 存入特定的 queue，队列的标识 <code>queueId = delayTimeLevel – 1</code>，即<strong>一个 queue 只存相同延迟的消息</strong>，保证具有相同发送延迟的消息能够顺序消费。Broker 会为每个延迟级别提交一个定时任务，调度地消费 SCHEDULE_TOPIC_XXXX，将消息写入真实的 Topic</p>
<p>注意：定时消息在第一次写入和调度写入真实 Topic 时都会计数，因此发送数量、tps 都会变高</p>
<hr>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>提交了一个订单就可以发送一个延时消息，1h 后去检查这个订单的状态，如果还是未付款就取消订单释放库存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledMessageProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 实例化一个生产者来产生延时消息</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;ExampleProducerGroup&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalMessagesToSend</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;DelayTopic&quot;</span>, (<span class="string">&quot;Hello scheduled message &quot;</span> + i).getBytes());</span><br><span class="line">            <span class="comment">// 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)</span></span><br><span class="line">            message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            producer.send(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭生产者</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledMessageConsumer</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="comment">// 实例化消费者</span></span><br><span class="line">      <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;ExampleConsumer&quot;</span>);</span><br><span class="line">      consumer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">      <span class="comment">// 订阅Topics</span></span><br><span class="line">      consumer.subscribe(<span class="string">&quot;DelayTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">      <span class="comment">// 注册消息监听者</span></span><br><span class="line">      consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; messages, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">              <span class="keyword">for</span> (MessageExt message : messages) &#123;</span><br><span class="line">                  <span class="comment">// 打印延迟的时间段</span></span><br><span class="line">                  System.out.println(<span class="string">&quot;Receive message[msgId=&quot;</span> + message.getMsgId() + <span class="string">&quot;] &quot;</span> + (System.currentTimeMillis() - message.getBornTimestamp()) + <span class="string">&quot;ms later&quot;</span>);&#125;</span><br><span class="line">              <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 启动消费者</span></span><br><span class="line">      consumer.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h3><p>批量发送消息能显著提高传递小消息的性能，限制是这些批量消息应该有相同的 topic，相同的 waitStoreMsgOK，而且不能是延时消息，并且这一批消息的总大小不应超过 4MB</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;ExampleProducerGroup&quot;</span>)</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//启动producer</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        List&lt;Message&gt; msgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Message&gt;();</span><br><span class="line">        <span class="comment">// 创建消息对象，指定主题Topic、Tag和消息体</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;BatchTopic&quot;</span>, <span class="string">&quot;Tag1&quot;</span>, (<span class="string">&quot;Hello World&quot;</span> + <span class="number">1</span>).getBytes());</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;BatchTopic&quot;</span>, <span class="string">&quot;Tag1&quot;</span>, (<span class="string">&quot;Hello World&quot;</span> + <span class="number">2</span>).getBytes());</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;BatchTopic&quot;</span>, <span class="string">&quot;Tag1&quot;</span>, (<span class="string">&quot;Hello World&quot;</span> + <span class="number">3</span>).getBytes());</span><br><span class="line"></span><br><span class="line">        msgs.add(msg1);</span><br><span class="line">        msgs.add(msg2);</span><br><span class="line">        msgs.add(msg3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">result</span> <span class="operator">=</span> producer.send(msgs);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送结果:&quot;</span> + result);</span><br><span class="line">        <span class="comment">// 关闭生产者producer</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发送大批量数据时，可能不确定消息是否超过了大小限制（4MB），所以需要将消息列表分割一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListSplitter</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;List&lt;Message&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE_LIMIT</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Message&gt; messages;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> currIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListSplitter</span><span class="params">(List&lt;Message&gt; messages)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messages = messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currIndex &lt; messages.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Message&gt; <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> getStartIndex();</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextIndex</span> <span class="operator">=</span> startIndex;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messages.get(nextIndex);</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmpSize</span> <span class="operator">=</span> calcMessageSize(message);</span><br><span class="line">            <span class="comment">// 单个消息超过了最大的限制</span></span><br><span class="line">            <span class="keyword">if</span> (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                totalSize += tmpSize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Message&gt; subList = messages.subList(startIndex, nextIndex);</span><br><span class="line">        currIndex = nextIndex;</span><br><span class="line">        <span class="keyword">return</span> subList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getStartIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">currMessage</span> <span class="operator">=</span> messages.get(currIndex);</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmpSize</span> <span class="operator">=</span> calcMessageSize(currMessage);</span><br><span class="line">        <span class="keyword">while</span> (tmpSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">            currIndex += <span class="number">1</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messages.get(curIndex);</span><br><span class="line">            tmpSize = calcMessageSize(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcMessageSize</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmpSize</span> <span class="operator">=</span> message.getTopic().length() + message.getBody().length;</span><br><span class="line">        Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">            tmpSize += entry.getKey().length() + entry.getValue().length();</span><br><span class="line">        &#125;</span><br><span class="line">        tmpSize = tmpSize + <span class="number">20</span>; <span class="comment">// 增加⽇日志的开销20字节</span></span><br><span class="line">        <span class="keyword">return</span> tmpSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//把大的消息分裂成若干个小的消息</span></span><br><span class="line">        <span class="type">ListSplitter</span> <span class="variable">splitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListSplitter</span>(messages);</span><br><span class="line">        <span class="keyword">while</span> (splitter.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;Message&gt; listItem = splitter.next();</span><br><span class="line">                producer.send(listItem);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">//处理error</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="过滤消息"><a href="#过滤消息" class="headerlink" title="过滤消息"></a>过滤消息</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>RocketMQ 定义了一些基本语法来支持过滤特性，可以很容易地扩展：</p>
<ul>
<li>数值比较，比如：&gt;，&gt;&#x3D;，&lt;，&lt;&#x3D;，BETWEEN，&#x3D;</li>
<li>字符比较，比如：&#x3D;，&lt;&gt;，IN</li>
<li>IS NULL 或者 IS NOT NULL</li>
<li>逻辑符号 AND，OR，NOT</li>
</ul>
<p>常量支持类型为：</p>
<ul>
<li>数值，比如 123，3.1415</li>
<li>字符，比如 ‘abc’，必须用单引号包裹起来</li>
<li>NULL，特殊的常量</li>
<li>布尔值，TRUE 或 FALSE</li>
</ul>
<p>只有使用 push 模式的消费者才能用使用 SQL92 标准的 sql 语句，接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> MessageSelector messageSelector)</span></span><br></pre></td></tr></table></figure>

<p>例如：消费者接收包含 TAGA 或 TAGB 或 TAGC 的消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;CID_EXAMPLE&quot;</span>);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;TOPIC&quot;</span>, <span class="string">&quot;TAGA || TAGB || TAGC&quot;</span>);</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="原理解析-2"><a href="#原理解析-2" class="headerlink" title="原理解析"></a>原理解析</h4><p>RocketMQ 分布式消息队列的消息过滤方式是在 Consumer 端订阅消息时再做消息过滤的，所以是在 Broker 端实现的，优点是减少了对于 Consumer 无用消息的网络传输，缺点是增加了 Broker 的负担，而且实现相对复杂</p>
<p>RocketMQ 在 Producer 端写入消息和在 Consumer 端订阅消息采用<strong>分离存储</strong>的机制实现，Consumer 端订阅消息是需要通过 ConsumeQueue 这个消息消费的逻辑队列拿到一个索引，然后再从 CommitLog 里面读取真正的消息实体内容</p>
<p>ConsumeQueue 的存储结构如下，有 8 个字节存储的 Message Tag 的哈希值，基于 Tag 的消息过滤就是基于这个字段</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E6%B6%88%E8%B4%B9%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84.png"></p>
<ul>
<li><p>Tag 过滤：Consumer 端订阅消息时指定 Topic 和 TAG，然后将订阅请求构建成一个 SubscriptionData，发送一个 Pull 消息的请求给 Broker 端。Broker 端用这些数据先构建一个 MessageFilter，然后传给文件存储层 Store。Store 从 ConsumeQueue 读取到一条记录后，会用它记录的消息 tag hash 值去做过滤。因为在服务端只是根据 hashcode 进行判断，无法精确对 tag 原始字符串进行过滤，所以消费端拉取到消息后，还需要对消息的原始 tag 字符串进行比对，如果不同，则丢弃该消息，不进行消息消费</p>
</li>
<li><p>SQL92 过滤：工作流程和 Tag 过滤大致一样，只是在 Store 层的具体过滤方式不一样。真正的 SQL expression 的构建和执行由 rocketmq-filter 模块负责，每次过滤都去执行 SQL 表达式会影响效率，所以 RocketMQ 使用了 BloomFilter 来避免了每次都去执行</p>
</li>
</ul>
<hr>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>发送消息时，通过 putUserProperty 来设置消息的属性，SQL92 的表达式上下文为消息的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;FilterTopic&quot;</span>, <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">               (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            <span class="comment">// 设置一些属性</span></span><br><span class="line">            msg.putUserProperty(<span class="string">&quot;i&quot;</span>, String.valueOf(i));</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 SQL 筛选过滤消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 过滤属性大于 5  的消息</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;FilterTopic&quot;</span>, MessageSelector.bySql(<span class="string">&quot;i&gt;5&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置回调函数，处理消息</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="comment">//接受消息内容</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;consumeThread=&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;,&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动消费者consumer</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>RocketMQ 支持分布式事务消息，采用了 2PC 的思想来实现了提交事务消息，同时增加一个<strong>补偿逻辑</strong>来处理二阶段超时或者失败的消息，如下图所示：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.png"></p>
<p>事务消息的大致方案分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程</p>
<ol>
<li><p>事务消息发送及提交：</p>
<ul>
<li><p>发送消息（Half 消息），服务器将消息的主题和队列改为半消息状态，并放入半消息队列</p>
</li>
<li><p>服务端响应消息写入结果（如果写入失败，此时 Half 消息对业务不可见）</p>
</li>
<li><p>根据发送结果执行本地事务</p>
</li>
<li><p>根据本地事务状态执行 Commit 或者 Rollback</p>
</li>
</ul>
</li>
</ol>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E4%BA%8B%E5%8A%A1%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p>
<ol start="2">
<li><p>补偿机制：用于解决消息 Commit 或者 Rollback 发生超时或者失败的情况，比如出现网络问题</p>
<ul>
<li>Broker 服务端通过<strong>对比 Half 消息和 Op 消息</strong>，对未确定状态的消息推进 CheckPoint</li>
<li>没有 Commit&#x2F;Rollback 的事务消息，服务端根据根据半消息的生产者组，到 ProducerManager 中获取生产者（同一个 Group 的 Producer）的会话通道，发起一次回查（<strong>单向请求</strong>）</li>
<li>Producer 收到回查消息，检查事务消息状态表内对应的本地事务的状态</li>
<li>根据本地事务状态，重新 Commit 或者 Rollback</li>
</ul>
<p>RocketMQ 并不会无休止的进行事务状态回查，最大回查 15 次，如果 15 次回查还是无法得知事务状态，则默认回滚该消息，</p>
<p>回查服务：<code>TransactionalMessageCheckService#run</code></p>
</li>
</ol>
<hr>
<h4 id="两阶段"><a href="#两阶段" class="headerlink" title="两阶段"></a>两阶段</h4><h5 id="一阶段"><a href="#一阶段" class="headerlink" title="一阶段"></a>一阶段</h5><p>事务消息相对普通消息最大的特点就是<strong>一阶段发送的消息对用户是不可见的</strong>，因为对于 Half 消息，会备份原消息的主题与消息消费队列，然后改变主题为 RMQ_SYS_TRANS_HALF_TOPIC，由于消费组未订阅该主题，故消费端无法消费 Half 类型的消息</p>
<p>RocketMQ 会开启一个<strong>定时任务</strong>，从 Topic 为 RMQ_SYS_TRANS_HALF_TOPIC 中拉取消息进行消费，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息</p>
<p>RocketMQ 的具体实现策略：如果写入的是事务消息，对消息的 Topic 和 Queue 等属性进行替换，同时将原来的 Topic 和 Queue 信息存储到<strong>消息的属性</strong>中，因为消息的主题被替换，所以消息不会转发到该原主题的消息消费队列，消费者无法感知消息的存在，不会消费</p>
<hr>
<h5 id="二阶段"><a href="#二阶段" class="headerlink" title="二阶段"></a>二阶段</h5><p>一阶段写入不可见的消息后，二阶段操作：</p>
<ul>
<li><p>如果执行 Commit 操作，则需要让消息对用户可见，构建出 Half 消息的索引。一阶段的 Half 消息写到一个特殊的 Topic，构建索引时需要读取出 Half 消息，然后通过一次普通消息的写入操作将 Topic 和 Queue 替换成真正的目标 Topic 和 Queue，生成一条对用户可见的消息。其实就是利用了一阶段存储的消息的内容，在二阶段时恢复出一条完整的普通消息，然后走一遍消息写入流程</p>
</li>
<li><p>如果是 Rollback 则需要撤销一阶段的消息，因为消息本就不可见，所以并<strong>不需要真正撤销消息</strong>（实际上 RocketMQ 也无法去删除一条消息，因为是顺序写文件的）。RocketMQ 为了区分这条消息没有确定状态的消息，采用 Op 消息标识已经确定状态的事务消息（Commit 或者 Rollback）</p>
</li>
</ul>
<p><strong>事务消息无论是 Commit 或者 Rollback 都会记录一个 Op 操作</strong>，两者的区别是 Commit 相对于 Rollback 在写入 Op 消息前将原消息的主题和队列恢复。如果一条事务消息没有对应的 Op 消息，说明这个事务的状态还无法确定（可能是二阶段失败了）</p>
<p>RocketMQ 将 Op 消息写入到全局一个特定的 Topic 中，通过源码中的方法 <code>TransactionalMessageUtil.buildOpTopic()</code>，这个主题是一个内部的 Topic（像 Half 消息的 Topic 一样），不会被用户消费。Op 消息的内容为对应的 Half 消息的存储的 Offset，这样<strong>通过 Op  消息能索引到 Half 消息</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-OP%E6%B6%88%E6%81%AF.png"></p>
<hr>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><p>事务消息共有三种状态，提交状态、回滚状态、中间状态：</p>
<ul>
<li>TransactionStatus.CommitTransaction：提交事务，允许消费者消费此消息。</li>
<li>TransactionStatus.RollbackTransaction：回滚事务，代表该消息将被删除，不允许被消费</li>
<li>TransactionStatus.Unknown：中间状态，代表需要检查消息队列来确定状态</li>
</ul>
<p>使用限制：</p>
<ol>
<li>事务消息不支持延时消息和批量消息</li>
<li>Broker 配置文件中的参数 <code>transactionTimeout</code> 为特定时间，事务消息将在特定时间长度之后被检查。当发送事务消息时，还可以通过设置用户属性 <code>CHECK_IMMUNITY_TIME_IN_SECONDS</code> 来改变这个限制，该参数优先于 <code>transactionTimeout</code> 参数</li>
<li>为了避免单个消息被检查太多次而导致半队列消息累积，默认将单个消息的检查次数限制为 15 次，开发者可以通过 Broker 配置文件的 <code>transactionCheckMax</code> 参数来修改此限制。如果已经检查某条消息超过 N 次（N &#x3D; <code>transactionCheckMax</code>）， 则 Broker 将丢弃此消息，在默认情况下会打印错误日志。可以通过重写 <code>AbstractTransactionalMessageCheckListener</code> 类来修改这个行为</li>
<li>事务性消息可能不止一次被检查或消费</li>
<li>提交给用户的目标主题消息可能会失败，可以查看日志的记录。事务的高可用性通过 RocketMQ 本身的高可用性机制来保证，如果希望事务消息不丢失、并且事务完整性得到保证，可以使用同步的双重写入机制</li>
<li>事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享。与其他类型的消息不同，事务消息允许反向查询，MQ 服务器能通过消息的生产者 ID 查询到消费者</li>
</ol>
<hr>
<h5 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h5><p>实现事务的监听接口，当发送半消息成功时：</p>
<ul>
<li><code>executeLocalTransaction</code> 方法来执行本地事务，返回三个事务状态之一</li>
<li><code>checkLocalTransaction</code> 方法检查本地事务状态，响应消息队列的检查请求，返回三个事务状态之一</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">TransactionListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">transactionIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Integer&gt; localTrans = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> transactionIndex.getAndIncrement();</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> value % <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 将事务ID和状态存入 map 集合</span></span><br><span class="line">        localTrans.put(msg.getTransactionId(), status);</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 从 map 集合读出当前事务对应的状态</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> localTrans.get(msg.getTransactionId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != status) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <strong>TransactionMQProducer</strong> 类创建事务性生产者，并指定唯一的 <code>ProducerGroup</code>，就可以设置自定义线程池来处理这些检查请求，执行本地事务后，需要根据执行结果对消息队列进行回复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建消息生产者</span></span><br><span class="line">       	<span class="type">TransactionMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">       	<span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">100</span>, TimeUnit.SECONDS);</span><br><span class="line">        producer.setExecutorService(executorService);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建事务监听器</span></span><br><span class="line">		<span class="type">TransactionListener</span> <span class="variable">transactionListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionListenerImpl</span>();</span><br><span class="line">        <span class="comment">// 生产者的监听器</span></span><br><span class="line">        producer.setTransactionListener(transactionListener);</span><br><span class="line">       	<span class="comment">// 启动生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line">        String[] tags = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;TagB&quot;</span>, <span class="string">&quot;TagC&quot;</span>, <span class="string">&quot;TagD&quot;</span>, <span class="string">&quot;TagE&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TransactionTopic&quot;</span>, tags[i % tags.length], <span class="string">&quot;KEY&quot;</span> + i,</span><br><span class="line">                                (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                <span class="comment">// 发送消息</span></span><br><span class="line">                <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.sendMessageInTransaction(msg, <span class="literal">null</span>);</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       	<span class="comment">//Thread.sleep(1000000);</span></span><br><span class="line">        <span class="comment">//producer.shutdown();暂时不关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者代码和前面的实例相同的</p>
<hr>
<h2 id="系统特性"><a href="#系统特性" class="headerlink" title="系统特性"></a>系统特性</h2><h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><h4 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h4><p>NameServer 是一个简单的 Topic 路由注册中心，支持 Broker 的动态注册与发现，生产者或消费者能够通过名字服务查找各主题相应的 Broker IP 列表</p>
<p>NameServer 主要包括两个功能：</p>
<ul>
<li>Broker 管理，NameServer 接受 Broker 集群的注册信息，保存下来作为路由信息的基本数据，提供<strong>心跳检测机制</strong>检查 Broker 是否还存活，每 10 秒清除一次两小时没有活跃的 Broker</li>
<li>路由信息管理，每个 NameServer 将保存关于 Broker 集群的整个路由信息和用于客户端查询的队列信息，然后 Producer 和 Conumser 通过 NameServer 就可以知道整个 Broker 集群的路由信息，从而进行消息的投递和消费</li>
</ul>
<p>NameServer 特点：</p>
<ul>
<li>NameServer 通常是集群的方式部署，<strong>各实例间相互不进行信息通讯</strong></li>
<li>Broker 向每一台 NameServer（集群）注册自己的路由信息，所以每个 NameServer 实例上面<strong>都保存一份完整的路由信息</strong></li>
<li>当某个 NameServer 因某种原因下线了，Broker 仍可以向其它 NameServer 同步其路由信息</li>
</ul>
<p>BrokerServer 主要负责消息的存储、投递和查询以及服务高可用保证，在 RocketMQ 系统中接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备，也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等</p>
<p>Broker 包含了以下几个重要子模块：</p>
<ul>
<li><p>Remoting Module：整个 Broker 的实体，负责处理来自 Clients 端的请求</p>
</li>
<li><p>Client Manager：负责管理客户端（Producer&#x2F;Consumer）和维护 Consumer 的 Topic 订阅信息</p>
</li>
<li><p>Store Service：提供方便简单的 API 接口处理消息存储到物理硬盘和查询功能</p>
</li>
<li><p>HA Service：高可用服务，提供 Master Broker 和 Slave Broker 之间的数据同步功能</p>
</li>
<li><p>Index Service：根据特定的 Message key 对投递到 Broker 的消息进行索引服务，以提供消息的快速查询</p>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-Broker%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p>
<hr>
<h4 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h4><p>RocketMQ 的工作流程：</p>
<ul>
<li>启动 NameServer 监听端口，等待 Broker、Producer、Consumer 连上来，相当于一个路由控制中心</li>
<li>Broker 启动，跟<strong>所有的 NameServer 保持长连接</strong>，每隔 30s 时间向 NameServer 上报 Topic 路由信息（心跳包）。心跳包中包含当前 Broker 信息（IP、端口等）以及存储所有 Topic 信息。注册成功后，NameServer 集群中就有 Topic 跟 Broker 的映射关系</li>
<li>收发消息前，先创建 Topic，创建 Topic 时需要指定该 Topic 要存储在哪些 Broker 上，也可以在发送消息时自动创建 Topic</li>
<li>Producer 启动时先跟 NameServer 集群中的<strong>其中一台</strong>建立长连接，并从 NameServer 中获取当前发送的 Topic 存在哪些 Broker 上，同时 Producer 会默认每隔 30s 向 NameServer <strong>定时拉取</strong>一次路由信息</li>
<li>Producer 发送消息时，根据消息的 Topic 从本地缓存的 TopicPublishInfoTable 获取路由信息，如果没有则会从 NameServer 上重新拉取并更新，轮询队列列表并选择一个队列 MessageQueue，然后与队列所在的 Broker 建立长连接，向 Broker 发消息</li>
<li>Consumer 跟 Producer 类似，跟其中一台 NameServer 建立长连接，<strong>定时获取路由信息</strong>，根据当前订阅 Topic 存在哪些 Broker 上，直接跟 Broker 建立连接通道，在完成客户端的负载均衡后，选择其中的某一个或者某几个 MessageQueue 来拉取消息并进行消费</li>
</ul>
<hr>
<h4 id="生产消费"><a href="#生产消费" class="headerlink" title="生产消费"></a>生产消费</h4><p>At least Once：至少一次，指每个消息必须投递一次，Consumer 先 Pull 消息到本地，消费完成后才向服务器返回 ACK，如果没有消费一定不会 ACK 消息</p>
<p>回溯消费：指 Consumer 已经消费成功的消息，由于业务上需求需要重新消费，Broker 在向 Consumer 投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于 Consumer 系统故障，恢复后需要重新消费 1 小时前的数据，RocketMQ 支持按照时间回溯消费，时间维度精确到毫秒</p>
<p>分布式队列因为有高可靠性的要求，所以数据要进行<strong>持久化存储</strong></p>
<ol>
<li>消息生产者发送消息</li>
<li>MQ 收到消息，将消息进行持久化，在存储中新增一条记录</li>
<li>返回 ACK 给生产者</li>
<li>MQ push 消息给对应的消费者，然后等待消费者返回 ACK</li>
<li>如果消息消费者在指定时间内成功返回 ACK，那么 MQ 认为消息消费成功，在存储中删除消息；如果 MQ 在指定时间内没有收到 ACK，则认为消息消费失败，会尝试重新 push 消息，重复执行 4、5、6 步骤</li>
<li>MQ 删除消息</li>
</ol>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E6%B6%88%E6%81%AF%E5%AD%98%E5%8F%96.png"></p>
<hr>
<h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>RocketMQ 中 Broker 负责存储消息转发消息，所以以下的结构是存储在 Broker Server 上的，生产者和消费者与 Broker 进行消息的收发是通过主题对应的 Message Queue 完成，类似于通道</p>
<p>RocketMQ 消息的存储是由 ConsumeQueue 和 CommitLog 配合完成 的，CommitLog 是消息真正的<strong>物理存储</strong>文件，ConsumeQueue 是消息的逻辑队列，类似数据库的<strong>索引节点</strong>，存储的是指向物理存储的地址。<strong>每个 Topic 下的每个 Message Queue 都有一个对应的 ConsumeQueue 文件</strong></p>
<p>每条消息都会有对应的索引信息，Consumer 通过 ConsumeQueue 这个结构来读取消息实体内容</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"></p>
<ul>
<li>CommitLog：消息主体以及元数据的存储主体，存储 Producer 端写入的消息内容，消息内容不是定长的。消息主要是<strong>顺序写入</strong>日志文件，单个文件大小默认 1G，偏移量代表下一次写入的位置，当文件写满了就继续写入下一个文件</li>
<li>ConsumerQueue：消息消费队列，存储消息在 CommitLog 的索引。RocketMQ 消息消费时要遍历 CommitLog 文件，并根据主题 Topic 检索消息，这是非常低效的。引入 ConsumeQueue 作为消费消息的索引，<strong>保存了指定 Topic 下的队列消息在 CommitLog 中的起始物理偏移量 offset</strong>，消息大小 size 和消息 Tag 的 HashCode 值，每个 ConsumeQueue 文件大小约 5.72M</li>
<li>IndexFile：为了消息查询提供了一种通过 Key 或时间区间来查询消息的方法，通过 IndexFile 来查找消息的方法<strong>不影响发送与消费消息的主流程</strong>。IndexFile 的底层存储为在文件系统中实现的 HashMap 结构，故 RocketMQ 的索引文件其底层实现为 <strong>hash 索引</strong></li>
</ul>
<p>RocketMQ 采用的是混合型的存储结构，即为 Broker 单个实例下所有的队列共用一个日志数据文件（CommitLog）来存储。混合型存储结构（多个 Topic 的消息实体内容都存储于一个 CommitLog 中）针对 Producer 和 Consumer 分别采用了<strong>数据和索引部分相分离</strong>的存储结构，Producer 发送消息至 Broker 端，然后 Broker 端使用同步或者异步的方式对消息刷盘持久化，保存至 CommitLog 中。只要消息被持久化至磁盘文件 CommitLog 中，Producer 发送的消息就不会丢失，Consumer 也就肯定有机会去消费这条消息</p>
<p>服务端支持长轮询模式，当消费者无法拉取到消息后，可以等下一次消息拉取，Broker 允许等待 30s 的时间，只要这段时间内有新消息到达，将直接返回给消费端。RocketMQ 的具体做法是，使用 Broker 端的后台服务线程 ReputMessageService 不停地分发请求并异步构建 ConsumeQueue（逻辑消费队列）和 IndexFile（索引文件）数据</p>
<hr>
<h4 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h4><p>操作系统分为用户态和内核态，文件操作、网络操作需要涉及这两种形态的切换，需要进行数据复制。一台服务器把本机磁盘文件的内容发送到客户端，分为两个步骤：</p>
<ul>
<li><p>read：读取本地文件内容</p>
</li>
<li><p>write：将读取的内容通过网络发送出去</p>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C.png"></p>
<p>补充：Prog → NET → I&#x2F;O → 零拷贝部分的笔记详解相关内容</p>
<p>通过使用 mmap 的方式，可以省去向用户态的内存复制，RocketMQ 充分利用<strong>零拷贝技术</strong>，提高消息存盘和网络发送的速度</p>
<p>RocketMQ 通过 MappedByteBuffer 对文件进行读写操作，利用了 NIO 中的 FileChannel 模型将磁盘上的物理文件直接映射到用户态的内存地址中，将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率</p>
<p>MappedByteBuffer 内存映射的方式<strong>限制</strong>一次只能映射 1.5~2G 的文件至用户态的虚拟内存，所以 RocketMQ 默认设置单个 CommitLog 日志数据文件为 1G。RocketMQ 的文件存储使用定长结构来存储，方便一次将整个文件映射至内存</p>
<hr>
<h4 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h4><p>页缓存（PageCache）是 OS 对文件的缓存，每一页的大小通常是 4K，用于加速对文件的读写。因为 OS 将一部分的内存用作 PageCache，所以程序对文件进行顺序读写的速度几乎接近于内存的读写速度</p>
<ul>
<li>对于数据的写入，OS 会先写入至 Cache 内，随后通过异步的方式由 pdflush 内核线程将 Cache 内的数据刷盘至物理磁盘上</li>
<li>对于数据的读取，如果一次读取文件时出现未命中 PageCache 的情况，OS 从物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行<strong>预读取</strong>（局部性原理，最大 128K）</li>
</ul>
<p>在 RocketMQ 中，ConsumeQueue 逻辑消费队列存储的数据较少，并且是顺序读取，在 PageCache 机制的预读取作用下，Consume Queue 文件的读性能几乎接近读内存，即使在有消息堆积情况下也不会影响性能。但是 CommitLog 消息存储的日志数据文件读取内容时会产生较多的随机访问读取，严重影响性能。选择合适的系统 IO 调度算法和固态硬盘，比如设置调度算法为 Deadline，随机读的性能也会有所提升</p>
<hr>
<h4 id="刷盘机制"><a href="#刷盘机制" class="headerlink" title="刷盘机制"></a>刷盘机制</h4><p>两种持久化的方案：</p>
<ul>
<li>关系型数据库 DB：IO 读写性能比较差，如果 DB 出现故障，则 MQ 的消息就无法落盘存储导致线上故障，可靠性不高</li>
<li>文件系统：消息刷盘至所部署虚拟机&#x2F;物理机的文件系统来做持久化，分为异步刷盘和同步刷盘两种模式。消息刷盘为消息存储提供了一种高效率、高可靠性和高性能的数据持久化方式，除非部署 MQ 机器本身或是本地磁盘挂了，一般不会出现无法持久化的问题</li>
</ul>
<p>RocketMQ 采用文件系统的方式，无论同步还是异步刷盘，都使用<strong>顺序 IO</strong>，因为磁盘的顺序读写要比随机读写快很多</p>
<ul>
<li><p>同步刷盘：只有在消息真正持久化至磁盘后 RocketMQ 的 Broker 端才会真正返回给 Producer 端一个成功的 ACK 响应，保障 MQ 消息的可靠性，但是性能上会有较大影响，一般适用于金融业务应用该模式较多</p>
</li>
<li><p>异步刷盘：利用 OS 的 PageCache，只要消息写入内存 PageCache 即可将成功的 ACK 返回给 Producer 端，降低了读写延迟，提高了 MQ 的性能和吞吐量。消息刷盘采用<strong>后台异步线程</strong>提交的方式进行，当内存里的消息量积累到一定程度时，触发写磁盘动作</p>
</li>
</ul>
<p>通过 Broker 配置文件里的 flushDiskType 参数设置采用什么方式，可以配置成 SYNC_FLUSH、ASYNC_FLUSH 中的一个</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E5%88%B7%E7%9B%98%E6%9C%BA%E5%88%B6.png"></p>
<p>官方文档：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md">https://github.com/apache/rocketmq/blob/master/docs/cn/design.md</a></p>
<hr>
<h3 id="集群设计"><a href="#集群设计" class="headerlink" title="集群设计"></a>集群设计</h3><h4 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h4><p>常用的以下几种模式：</p>
<ul>
<li><p>单 Master 模式：这种方式风险较大，一旦 Broker 重启或者宕机，会导致整个服务不可用</p>
</li>
<li><p>多 Master 模式：一个集群无 Slave，全是 Master</p>
<ul>
<li><p>优点：配置简单，单个 Master 宕机或重启维护对应用无影响，在磁盘配置为 RAID10 时，即使机器宕机不可恢复情况下，由于 RAID10 磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高</p>
</li>
<li><p>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响</p>
</li>
</ul>
</li>
<li><p>多 Master 多 Slave 模式（同步）：每个 Master 配置一个 Slave，有多对 Master-Slave，HA 采用<strong>同步双写</strong>方式，即只有主备都写成功，才向应用返回成功</p>
<ul>
<li>优点：数据与服务都无单点故障，Master 宕机情况下，消息无延迟，服务可用性与数据可用性都非常高</li>
<li>缺点：性能比异步复制略低（大约低 10% 左右），发送单个消息的 RT 略高，目前不能实现主节点宕机，备机自动切换为主机</li>
</ul>
</li>
<li><p>多 Master 多 Slave 模式（异步）：HA 采用异步复制的方式，会造成主备有短暂的消息延迟（毫秒级别）</p>
<ul>
<li>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时 Master 宕机后，消费者仍然可以从 Slave 消费，而且此过程对应用透明，不需要人工干预，性能同多 Master 模式几乎一样</li>
<li>缺点：Master 宕机，磁盘损坏情况下会丢失少量消息</li>
</ul>
</li>
</ul>
<hr>
<h4 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h4><p>RocketMQ 网络部署特点：</p>
<ul>
<li><p>NameServer 是一个几乎<strong>无状态节点</strong>，节点之间相互独立，无任何信息同步</p>
</li>
<li><p>Broker 部署相对复杂，Broker 分为 Master 与 Slave，Master 可以部署多个，一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master，Master 与 Slave 的对应关系通过指定相同 BrokerName、不同 BrokerId 来定义，BrokerId 为 0 是 Master，非 0 表示 Slave。<strong>每个 Broker 与 NameServer 集群中的所有节点建立长连接</strong>，定时注册 Topic 信息到所有 NameServer</p>
<p>说明：部署架构上也支持一 Master 多 Slave，但只有 BrokerId&#x3D;1 的从服务器才会参与消息的读负载（读写分离）</p>
</li>
<li><p>Producer 与 NameServer 集群中的其中<strong>一个节点（随机选择）建立长连接</strong>，定期从 NameServer 获取 Topic 路由信息，并向提供 Topic 服务的 Master 建立长连接，且定时向 Master <strong>发送心跳</strong>。Producer 完全无状态，可集群部署</p>
</li>
<li><p>Consumer 与 NameServer 集群中的其中一个节点（随机选择）建立长连接，定期从 NameServer 获取 Topic 路由信息，并向提供  Topic 服务的 Master、Slave 建立长连接，且定时向 Master、Slave 发送心跳</p>
<p>Consumer 既可以从 Master 订阅消息，也可以从 Slave 订阅消息，在向 Master 拉取消息时，Master 服务器会根据拉取偏移量与最大偏移量的距离（判断是否读老消息，产生读 I&#x2F;O），以及从服务器是否可读等因素建议下一次是从 Master 还是 Slave 拉取</p>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84.png"></p>
<p>官方文档：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/architecture.md">https://github.com/apache/rocketmq/blob/master/docs/cn/architecture.md</a></p>
<hr>
<h4 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h4><p>NameServer 节点是无状态的，且各个节点直接的数据是一致的，部分 NameServer 不可用也可以保证 MQ 服务正常运行</p>
<p>BrokerServer 的高可用通过 Master 和 Slave 的配合：</p>
<ul>
<li>Slave 只负责读，当 Master 不可用，对应的 Slave 仍能保证消息被正常消费</li>
<li>配置多组 Master-Slave 组，其他的 Master-Slave 组也会保证消息的正常发送和消费</li>
<li>目前不支持把 Slave 自动转成 Master，需要手动停止 Slave 角色的 Broker，更改配置文件，用新的配置文件启动 Broker</li>
</ul>
<p>生产端的高可用：在创建 Topic 的时候，把 Topic 的<strong>多个 Message Queue 创建在多个 Broker 组</strong>上（相同 Broker 名称，不同 brokerId 的机器），当一个 Broker 组的 Master 不可用后，其他组的 Master 仍然可用，Producer 仍然可以发送消息</p>
<p>消费端的高可用：在 Consumer 的配置文件中，并不需要设置是从 Master Broker 读还是从 Slave 读，当 Master 不可用或者繁忙的时候，Consumer 会被自动切换到从 Slave 读。有了自动切换的机制，当一个 Master 机器出现故障后，Consumer 仍然可以从 Slave 读取消息，不影响 Consumer 程序，达到了消费端的高可用性</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E9%AB%98%E5%8F%AF%E7%94%A8.png"></p>
<hr>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>如果一个 Broker 组有 Master 和 Slave，消息需要从 Master 复制到 Slave 上，有同步和异步两种复制方式：</p>
<ul>
<li><p>同步复制方式：Master 和 Slave 均写成功后才反馈给客户端写成功状态。在同步复制方式下，如果 Master 出故障， Slave 上有全部的备份数据，容易恢复，但是同步复制会增大数据写入延迟，降低系统吞吐量</p>
</li>
<li><p>异步复制方式：只要 Master 写成功，即可反馈给客户端写成功状态，系统拥有较低的延迟和较高的吞吐量，但是如果 Master 出了故障，有些数据因为没有被写入 Slave，有可能会丢失</p>
</li>
</ul>
<p>同步复制和异步复制是通过 Broker 配置文件里的 brokerRole 参数进行设置的，可以设置成 ASYNC_MASTE、RSYNC_MASTER、SLAVE 三个值中的一个</p>
<p>一般把刷盘机制配置成 ASYNC_FLUSH，主从复制为 SYNC_MASTER，这样即使有一台机器出故障，仍然能保证数据不丢</p>
<p>RocketMQ 支持消息的高可靠，影响消息可靠性的几种情况：</p>
<ol>
<li>Broker 非正常关闭</li>
<li>Broker 异常 Crash</li>
<li>OS Crash</li>
<li>机器掉电，但是能立即恢复供电情况</li>
<li>机器无法开机（可能是 CPU、主板、内存等关键设备损坏）</li>
<li>磁盘设备损坏</li>
</ol>
<p>前四种情况都属于硬件资源可立即恢复情况，RocketMQ 在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式）</p>
<p>后两种属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ 在这两种情况下，通过主从异步复制，可保证 99% 的消息不丢，但是仍然会有极少量的消息可能丢失。通过<strong>同步双写技术</strong>可以完全避免单点，但是会影响性能，适合对消息可靠性要求极高的场合，RocketMQ 从 3.0 版本开始支持同步双写</p>
<hr>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h4 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h4><p>RocketMQ 中的负载均衡可以分为 Producer 端发送消息时候的负载均衡和 Consumer 端订阅消息的负载均衡</p>
<p>Producer 端在发送消息时，会先根据 Topic 找到指定的 TopicPublishInfo，在获取了 TopicPublishInfo 路由信息后，RocketMQ 的客户端在默认方式调用 <code>selectOneMessageQueue()</code> 方法从 TopicPublishInfo 中的 messageQueueList 中选择一个队列 MessageQueue 进行发送消息</p>
<p>默认会<strong>轮询所有的 Message Queue 发送</strong>，以让消息平均落在不同的 queue 上，而由于 queue可以散落在不同的 Broker，所以消息就发送到不同的 Broker 下，图中箭头线条上的标号代表顺序，发布方会把第一条消息发送至 Queue 0，然后第二条消息发送至 Queue 1，以此类推：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-producer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png"></p>
<p>容错策略均在 MQFaultStrategy 这个类中定义，有一个 sendLatencyFaultEnable 开关变量：</p>
<ul>
<li>如果开启，会在<strong>随机（只有初始化索引变量时才随机，正常都是递增）递增取模</strong>的基础上，再过滤掉 not available 的 Broker</li>
<li>如果关闭，采用随机递增取模的方式选择一个队列（MessageQueue）来发送消息</li>
</ul>
<p>LatencyFaultTolerance 机制是实现消息发送高可用的核心关键所在，对之前失败的，按一定的时间做退避。例如上次请求的 latency 超过 550Lms，就退避 3000Lms；超过 1000L，就退避 60000L</p>
<hr>
<h4 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h4><p>在 RocketMQ 中，Consumer 端的两种消费模式（Push&#x2F;Pull）都是基于拉模式来获取消息的，而在 Push 模式只是对 Pull 模式的一种封装，其本质实现为消息拉取线程在从服务器拉取到一批消息，提交到消息消费线程池后，又继续向服务器再次尝试拉取消息，如果未拉取到消息，则延迟一下又继续拉取</p>
<p>在两种基于拉模式的消费方式（Push&#x2F;Pull）中，均需要 Consumer 端在知道从 Broker 端的哪一个消息队列中去获取消息，所以在 Consumer 端来做负载均衡，即 Broker 端中多个 MessageQueue 分配给同一个 Consumer Group 中的哪些 Consumer 消费</p>
<ul>
<li><p>广播模式下要求一条消息需要投递到一个消费组下面所有的消费者实例，所以不存在负载均衡，在实现上，Consumer 分配 queue 时，所有 Consumer 都分到所有的 queue。</p>
</li>
<li><p>在集群消费模式下，每条消息只需要投递到订阅这个 Topic 的 Consumer Group 下的一个实例即可，RocketMQ 采用主动拉取的方式拉取并消费消息，在拉取的时候需要明确指定拉取哪一条 Message Queue</p>
</li>
</ul>
<p>集群模式下，每当消费者实例的数量有变更，都会触发一次所有实例的负载均衡，这时候会按照 queue 的数量和实例的数量平均分配 queue 给每个实例。默认的分配算法是 AllocateMessageQueueAveragely：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E5%B9%B3%E5%9D%87%E9%98%9F%E5%88%97%E5%88%86%E9%85%8D.png"></p>
<p>  还有一种平均的算法是 AllocateMessageQueueAveragelyByCircle，以环状轮流均分 queue 的形式：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E5%B9%B3%E5%9D%87%E9%98%9F%E5%88%97%E8%BD%AE%E6%B5%81%E5%88%86%E9%85%8D.png"></p>
<p>集群模式下，<strong>queue 都是只允许分配一个实例</strong>，如果多个实例同时消费一个 queue 的消息，由于拉取哪些消息是 Consumer 主动控制的，会导致同一个消息在不同的实例下被消费多次</p>
<p>通过增加 Consumer 实例去分摊 queue 的消费，可以起到水平扩展的消费能力的作用。而当有实例下线时，会重新触发负载均衡，这时候原来分配到的 queue 将分配到其他实例上继续消费。但是如果 Consumer 实例的数量比 Message Queue 的总数量还多的话，多出来的 Consumer 实例将无法分到 queue，也就无法消费到消息，也就无法起到分摊负载的作用了，所以需要<strong>控制让 queue 的总数量大于等于 Consumer 的数量</strong></p>
<hr>
<h4 id="原理解析-3"><a href="#原理解析-3" class="headerlink" title="原理解析"></a>原理解析</h4><p>在 Consumer 启动后，会通过定时任务不断地向 RocketMQ 集群中的所有 Broker 实例发送心跳包。Broker 端在收到 Consumer 的心跳消息后，会将它维护在 ConsumerManager 的本地缓存变量 consumerTable，同时并将封装后的客户端网络通道信息保存在本地缓存变量 channelInfoTable 中，为 Consumer 端的负载均衡提供可以依据的元数据信息</p>
<p>Consumer 端实现负载均衡的核心类 <strong>RebalanceImpl</strong></p>
<p>在 Consumer 实例的启动流程中的会启动 MQClientInstance 实例，完成负载均衡服务线程 RebalanceService 的启动（<strong>每隔 20s 执行一次</strong>负载均衡），RebalanceService 线程的 run() 方法最终调用的是 RebalanceImpl 类的 rebalanceByTopic() 方法，该方法是实现 Consumer 端负载均衡的核心。rebalanceByTopic() 方法会根据广播模式还是集群模式做不同的逻辑处理。主要看集群模式：</p>
<ul>
<li><p>从 rebalanceImpl 实例的本地缓存变量 topicSubscribeInfoTable 中，获取该 Topic 主题下的消息消费队列集合 mqSet</p>
</li>
<li><p>根据 Topic 和 consumerGroup 为参数调用 <code>mQClientFactory.findConsumerIdList()</code> 方法向 Broker 端发送获取该消费组下消费者 ID 列表的 RPC 通信请求（Broker 端基于前面 Consumer 端上报的心跳包数据而构建的 consumerTable 做出响应返回，业务请求码 <code>GET_CONSUMER_LIST_BY_GROUP</code>）</p>
</li>
<li><p>先对 Topic 下的消息消费队列、消费者 ID 排序，然后用消息队列分配策略算法（默认是消息队列的平均分配算法），计算出待拉取的消息队列。平均分配算法类似于分页的算法，将所有 MessageQueue 排好序类似于记录，将所有消费端 Consumer 排好序类似页数，并求出每一页需要包含的平均 size 和每个页面记录的范围 range，最后遍历整个 range 而计算出当前 Consumer 端应该分配到的记录（这里即为 MessageQueue）</p>
</li>
<li><p>调用 updateProcessQueueTableInRebalance() 方法，先将分配到的消息队列集合 mqSet 与 processQueueTable 做一个过滤比对</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%87%8D%E6%96%B0%E5%B9%B3%E8%A1%A1%E7%AE%97%E6%B3%95.png"></p>
</li>
<li><p>processQueueTable 标注的红色部分，表示与分配到的消息队列集合 mqSet 互不包含，将这些队列设置 Dropped 属性为 true，然后查看这些队列是否可以移除出 processQueueTable 缓存变量。具体执行 removeUnnecessaryMessageQueue() 方法，即每隔 1s  查看是否可以获取当前消费处理队列的锁，拿到的话返回 true；如果等待 1s 后，仍然拿不到当前消费处理队列的锁则返回 false。如果返回 true，则从 processQueueTable 缓存变量中移除对应的 Entry</p>
</li>
<li><p>processQueueTable 的绿色部分，表示与分配到的消息队列集合 mqSet 的交集，判断该 ProcessQueue 是否已经过期了，在 Pull 模式的不用管，如果是 Push 模式的，设置 Dropped 属性为 true，并且调用 removeUnnecessaryMessageQueue() 方法，像上面一样尝试移除 Entry</p>
</li>
<li><p>为过滤后的消息队列集合 mqSet 中每个 MessageQueue 创建 ProcessQueue 对象存入 RebalanceImpl 的 processQueueTable 队列中（其中调用 RebalanceImpl 实例的 <code>computePullFromWhere(MessageQueue mq)</code> 方法获取该 MessageQueue 对象的下一个进度消费值 offset，随后填充至接下来要创建的 pullRequest 对象属性中），并<strong>创建拉取请求对象</strong> pullRequest 添加到拉取列表 pullRequestList 中，最后执行 dispatchPullRequest() 方法，将 Pull 消息的请求对象 PullRequest 放入 PullMessageService 服务线程的<strong>阻塞队列</strong> pullRequestQueue 中，待该服务线程取出后向 Broker 端发起 Pull 消息的请求</p>
<p>对比下 RebalancePushImpl 和 RebalancePullImpl 两个实现类的 dispatchPullRequest() 方法，RebalancePullImpl 类里面的该方法为空</p>
</li>
</ul>
<p>消息消费队列在同一消费组不同消费者之间的负载均衡，其核心设计理念是在<strong>一个消息消费队列在同一时间只允许被同一消费组内的一个消费者消费，一个消息消费者能同时消费多个消息队列</strong></p>
<hr>
<h3 id="消息查询"><a href="#消息查询" class="headerlink" title="消息查询"></a>消息查询</h3><h4 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h4><p>RocketMQ 支持按照两种维度进行消息查询：按照 Message ID 查询消息、按照 Message Key 查询消息</p>
<ul>
<li><p>RocketMQ 中的 MessageID 的长度总共有 16 字节，其中包含了消息存储主机地址（IP 地址和端口），消息 Commit Log offset</p>
<p>实现方式：Client 端从 MessageID 中解析出 Broker 的地址（IP 地址和端口）和 Commit Log 的偏移地址，封装成一个 RPC 请求后通过 Remoting 通信层发送（业务请求码 VIEW_MESSAGE_BY_ID）。Broker 端走的是 QueryMessageProcessor，读取消息的过程用其中的 CommitLog 的 offset 和 size 去 CommitLog 中找到真正的记录并解析成一个完整的消息返回</p>
</li>
<li><p>按照 Message Key 查询消息，IndexFile 索引文件为提供了通过 Message Key 查询消息的服务</p>
<p>实现方式：通过 Broker 端的 QueryMessageProcessor 业务处理器来查询，读取消息的过程用 <strong>Topic 和 Key</strong> 找到 IndexFile 索引文件中的一条记录，根据其中的 CommitLog Offset 从 CommitLog 文件中读取消息的实体内容</p>
</li>
</ul>
<hr>
<h4 id="索引机制"><a href="#索引机制" class="headerlink" title="索引机制"></a>索引机制</h4><p>RocketMQ 的索引文件逻辑结构，类似 JDK 中 HashMap 的实现，具体结构如下：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-IndexFile%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6.png"></p>
<p>IndexFile 文件的存储在 <code>$HOME\store\index$&#123;fileName&#125;</code>，文件名 fileName 是以创建时的时间戳命名，文件大小是固定的，等于 <code>40+500W*4+2000W*20= 420000040</code> 个字节大小。如果消息的 properties 中设置了 UNIQ_KEY 这个属性，就用 <code>topic + “#” + UNIQ_KEY</code> 作为 key 来做写入操作；如果消息设置了 KEYS 属性（多个 KEY 以空格分隔），也会用 <code>topic + “#” + KEY</code> 来做索引</p>
<p>整个 Index File 的结构如图，40 Byte 的 Header 用于保存一些总的统计信息，<code>4*500W</code> 的 Slot Table 并不保存真正的索引数据，而是保存每个槽位对应的单向链表的<strong>头指针</strong>，即一个 Index File 可以保存 2000W 个索引，<code>20*2000W</code> 是<strong>真正的索引数据</strong></p>
<p>索引数据包含了 Key Hash&#x2F;CommitLog Offset&#x2F;Timestamp&#x2F;NextIndex offset 这四个字段，一共 20 Byte</p>
<ul>
<li>NextIndex offset 即前面读出来的 slotValue，如果有 hash 冲突，就可以用这个字段将所有冲突的索引用链表的方式串起来</li>
<li>Timestamp 记录的是消息 storeTimestamp 之间的差，并不是一个绝对的时间</li>
</ul>
<p>参考文档：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md">https://github.com/apache/rocketmq/blob/master/docs/cn/design.md</a></p>
<hr>
<h3 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h3><h4 id="消息重投"><a href="#消息重投" class="headerlink" title="消息重投"></a>消息重投</h4><p>生产者在发送消息时，同步消息和异步消息失败会重投，oneway 没有任何保证。消息重投保证消息尽可能发送成功、不丢失，但当出现消息量大、网络抖动时，可能会造成消息重复；生产者主动重发、Consumer 负载变化也会导致重复消息。</p>
<p>如下方法可以设置消息重投策略：</p>
<ul>
<li>retryTimesWhenSendFailed：同步发送失败重投次数，默认为 2，因此生产者会最多尝试发送 retryTimesWhenSendFailed + 1 次。不会选择上次失败的 Broker，尝试向其他 Broker 发送，<strong>最大程度保证消息不丢</strong>。超过重投次数抛出异常，由客户端保证消息不丢。当出现 RemotingException、MQClientException 和部分 MQBrokerException 时会重投</li>
<li>retryTimesWhenSendAsyncFailed：异步发送失败重试次数，异步重试不会选择其他 Broker，仅在同一个 Broker 上做重试，<strong>不保证消息不丢</strong></li>
<li>retryAnotherBrokerWhenNotStoreOK：消息刷盘（主或备）超时或 slave 不可用（返回状态非 SEND_OK），是否尝试发送到其他  Broker，默认 false，十分重要消息可以开启</li>
</ul>
<p>注意点：</p>
<ul>
<li>如果同步模式发送失败，则选择到下一个 Broker，如果异步模式发送失败，则<strong>只会在当前 Broker 进行重试</strong></li>
<li>发送消息超时时间默认 3000 毫秒，就不会再尝试重试</li>
</ul>
<hr>
<h4 id="消息重试-1"><a href="#消息重试-1" class="headerlink" title="消息重试"></a>消息重试</h4><p>Consumer 消费消息失败后，提供了一种重试机制，令消息再消费一次。Consumer 消费消息失败可以认为有以下几种情况：</p>
<ul>
<li>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99% 也不成功，所以需要提供一种定时重试机制，即过 10 秒后再重试</li>
<li>由于依赖的下游应用服务不可用，例如 DB 连接不可用，外系统网络不可达等。这种情况即使跳过当前失败的消息，消费其他消息同样也会报错，这种情况建议应用 sleep 30s，再消费下一条消息，这样可以减轻 Broker 重试消息的压力</li>
</ul>
<p>RocketMQ 会为每个消费组都设置一个 Topic 名称为 <code>%RETRY%+consumerGroup</code> 的重试队列（这个 Topic 的重试队列是<strong>针对消费组</strong>，而不是针对每个 Topic 设置的），用于暂时保存因为各种异常而导致 Consumer 端无法消费的消息</p>
<ul>
<li><p>顺序消息的重试，当消费者消费消息失败后，消息队列 RocketMQ 会自动不断进行消息重试（每次间隔时间为 1 秒），这时应用会出现消息消费被阻塞的情况。所以在使用顺序消息时，必须保证应用能够及时监控并处理消费失败的情况，避免阻塞现象的发生</p>
</li>
<li><p>无序消息（普通、定时、延时、事务消息）的重试，可以通过设置返回状态达到消息重试的结果。无序消息的重试只针对集群消费方式生效，广播方式不提供失败重试特性，即消费失败后，失败消息不再重试，继续消费新的消息</p>
</li>
</ul>
<p><strong>无序消息情况下</strong>，因为异常恢复需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ 对于重试消息的处理是先保存至 Topic 名称为 <code>SCHEDULE_TOPIC_XXXX</code> 的延迟队列中，后台定时任务<strong>按照对应的时间进行 Delay 后</strong>重新保存至 <code>%RETRY%+consumerGroup</code> 的重试队列中</p>
<p>消息队列 RocketMQ 默认允许每条消息最多重试 16 次，每次重试的间隔时间如下表示：</p>
<table>
<thead>
<tr>
<th align="center">第几次重试</th>
<th align="center">与上次重试的间隔时间</th>
<th align="center">第几次重试</th>
<th align="center">与上次重试的间隔时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">10 秒</td>
<td align="center">9</td>
<td align="center">7 分钟</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">30 秒</td>
<td align="center">10</td>
<td align="center">8 分钟</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1 分钟</td>
<td align="center">11</td>
<td align="center">9 分钟</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">2 分钟</td>
<td align="center">12</td>
<td align="center">10 分钟</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">3 分钟</td>
<td align="center">13</td>
<td align="center">20 分钟</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">4 分钟</td>
<td align="center">14</td>
<td align="center">30 分钟</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">5 分钟</td>
<td align="center">15</td>
<td align="center">1 小时</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">6 分钟</td>
<td align="center">16</td>
<td align="center">2 小时</td>
</tr>
</tbody></table>
<p>如果消息重试 16 次后仍然失败，消息将<strong>不再投递</strong>，如果严格按照上述重试时间间隔计算，某条消息在一直消费失败的前提下，将会在接下来的 4 小时 46 分钟之内进行 16 次重试，超过这个时间范围消息将不再重试投递</p>
<p>时间间隔不支持自定义配置，最大重试次数可通过自定义参数 <code>MaxReconsumeTimes</code> 取值进行配置，若配置超过 16 次，则超过的间隔时间均为 2 小时</p>
<p>说明：一条消息无论重试多少次，<strong>消息的 Message ID 是不会改变的</strong></p>
<hr>
<h4 id="重试操作"><a href="#重试操作" class="headerlink" title="重试操作"></a>重试操作</h4><p>集群消费方式下，消息消费失败后期望消息重试，需要在消息监听器接口的实现中明确进行配置（三种方式任选一种）：</p>
<ul>
<li>返回 Action.ReconsumeLater （推荐）</li>
<li>返回 null</li>
<li>抛出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理消息</span></span><br><span class="line">        doConsumeMessage(message);</span><br><span class="line">        <span class="comment">//方式1：返回 Action.ReconsumeLater，消息将重试</span></span><br><span class="line">        <span class="keyword">return</span> Action.ReconsumeLater;</span><br><span class="line">        <span class="comment">//方式2：返回 null，消息将重试</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//方式3：直接抛出异常， 消息将重试</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Consumer Message exceotion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集群消费方式下，消息失败后期望消息不重试，需要捕获消费逻辑中可能抛出的异常，最终返回 Action.CommitMessage，此后这条消息将不会再重试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doConsumeMessage(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// 捕获消费逻辑中的所有异常，并返回 Action.CommitMessage;</span></span><br><span class="line">            <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消息处理正常，直接返回 Action.CommitMessage;</span></span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义消息最大重试次数，RocketMQ 允许 Consumer 启动的时候设置最大重试次数，重试时间间隔将按照如下策略：</p>
<ul>
<li>最大重试次数小于等于 16 次，则重试时间间隔同上表描述</li>
<li>最大重试次数大于 16 次，超过 16 次的重试时间间隔均为每次 2 小时</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">// 配置对应 Group ID 的最大消息重试次数为 20 次</span></span><br><span class="line">properties.put(PropertyKeyConst.MaxReconsumeTimes,<span class="string">&quot;20&quot;</span>);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> ONSFactory.createConsumer(properties);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>消息最大重试次数的设置对相同 Group ID 下的所有 Consumer 实例有效。例如只对相同 Group ID 下两个 Consumer 实例中的其中一个设置了 MaxReconsumeTimes，那么该配置对两个 Consumer 实例均生效</li>
<li>配置采用覆盖的方式生效，即最后启动的 Consumer 实例会覆盖之前的启动实例的配置</li>
</ul>
<p>消费者收到消息后，可按照如下方式获取消息的重试次数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取消息的重试次数</span></span><br><span class="line">        System.out.println(message.getReconsumeTimes());</span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）</p>
<p>当一条消息初次消费失败，消息队列 RocketMQ 会自动进行消息重试，达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时 RocketMQ 不会立刻将消息丢弃，而是将其发送到该消费者对应的死信队列中</p>
<p>死信消息具有以下特性：</p>
<ul>
<li>不会再被消费者正常消费</li>
<li>有效期与正常消息相同，均为 3 天，3 天后会被自动删除，所以请在死信消息产生后的 3 天内及时处理</li>
</ul>
<p>死信队列具有以下特性：</p>
<ul>
<li><strong>一个死信队列对应一个 Group ID， 而不是对应单个消费者实例</strong></li>
<li>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列</li>
<li>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic</li>
</ul>
<p>一条消息进入死信队列，需要排查可疑因素并解决问题后，可以在消息队列 RocketMQ 控制台重新发送该消息，让消费者重新消费一次</p>
<hr>
<h3 id="幂等消费"><a href="#幂等消费" class="headerlink" title="幂等消费"></a>幂等消费</h3><p>消息队列 RocketMQ 消费者在接收到消息以后，需要根据业务上的唯一 Key 对消息做幂等处理</p>
<p>At least Once 机制保证消息不丢失，但是可能会造成消息重复，RocketMQ 中无法避免消息重复（Exactly-Once），在互联网应用中，尤其在网络不稳定的情况下，几种情况：</p>
<ul>
<li><p>发送时消息重复：当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或客户端宕机，导致服务端对客户端应答失败。此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息</p>
</li>
<li><p>投递时消息重复：消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。为了保证消息至少被消费一次，消息队列 RocketMQ 的服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息</p>
</li>
<li><p>负载均衡时消息重复：当消息队列 RocketMQ 的 Broker 或客户端重启、扩容或缩容时，会触发 Rebalance，此时消费者可能会收到重复消息</p>
</li>
</ul>
<p>处理方式：</p>
<ul>
<li><p>因为 Message ID 有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以 Message ID 作为处理依据，最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息 Key 进行设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">message.setKey(<span class="string">&quot;ORDERID_100&quot;</span>);</span><br><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br></pre></td></tr></table></figure>
</li>
<li><p>订阅方收到消息时可以根据消息的 Key 进行幂等处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">&quot;ons_test&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessageListener</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> Action <span class="title function_">consume</span><span class="params">(Message message, ConsumeContext context)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> message.getKey()</span><br><span class="line">        <span class="comment">// 根据业务唯一标识的 key 做幂等处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>生产者流控，因为 Broker 处理能力达到瓶颈；消费者流控，因为消费能力达到瓶颈</p>
<p>生产者流控：</p>
<ul>
<li>CommitLog 文件被锁时间超过 osPageCacheBusyTimeOutMills 时，参数默认为 1000ms，返回流控</li>
<li>如果开启 transientStorePoolEnable &#x3D;&#x3D; true，且 Broker 为异步刷盘的主机，且 transientStorePool 中资源不足，拒绝当前 send 请求，返回流控</li>
<li>Broker 每隔 10ms 检查 send 请求队列头部请求的等待时间，如果超过 waitTimeMillsInSendQueue，默认 200ms，拒绝当前 send 请求，返回流控。</li>
<li>Broker 通过拒绝 send 请求方式实现流量控制</li>
</ul>
<p>注意：生产者流控，不会尝试消息重投</p>
<p>消费者流控：</p>
<ul>
<li>消费者本地缓存消息数超过 pullThresholdForQueue 时，默认 1000</li>
<li>消费者本地缓存消息大小超过 pullThresholdSizeForQueue 时，默认 100MB</li>
<li>消费者本地缓存消息跨度超过 consumeConcurrentlyMaxSpan 时，默认 2000</li>
</ul>
<p>消费者流控的结果是降低拉取频率</p>
<hr>
<h2 id="原理解析-4"><a href="#原理解析-4" class="headerlink" title="原理解析"></a>原理解析</h2><h3 id="Namesrv"><a href="#Namesrv" class="headerlink" title="Namesrv"></a>Namesrv</h3><h4 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h4><h5 id="启动方法"><a href="#启动方法" class="headerlink" title="启动方法"></a>启动方法</h5><p>NamesrvStartup 类中有 Namesrv 服务的启动方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果启动时 使用 -c  -p  设置参数了，这些参数存储在 args 中</span></span><br><span class="line">    main0(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> NamesrvController <span class="title function_">main0</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 namesrv 控制器，用来初始化 namesrv 启动 namesrv 关闭 namesrv</span></span><br><span class="line">        <span class="type">NamesrvController</span> <span class="variable">controller</span> <span class="operator">=</span> createNamesrvController(args);</span><br><span class="line">		<span class="comment">// 启动 controller</span></span><br><span class="line">        start(controller);</span><br><span class="line">        <span class="keyword">return</span> controller;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="comment">// 出现异常，停止系统</span></span><br><span class="line">        System.exit(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NamesrvStartup#createNamesrvController：读取配置信息，初始化 Namesrv 控制器</p>
<ul>
<li><p><code>ServerUtil.parseCmdLine(&quot;mqnamesrv&quot;, args, buildCommandlineOptions(options)，..)</code>：解析启动时的参数信息</p>
</li>
<li><p><code>namesrvConfig = new NamesrvConfig()</code>：创建 Namesrv 配置对象</p>
<ul>
<li><code>private String rocketmqHome</code>：获取 ROCKETMQ_HOME 值</li>
<li><code>private boolean orderMessageEnable = false</code>：<strong>顺序消息</strong>功能是否开启</li>
</ul>
</li>
<li><p><code>nettyServerConfig = new NettyServerConfig()</code>：Netty 的服务器配置对象</p>
</li>
<li><p><code>nettyServerConfig.setListenPort(9876)</code>：Namesrv 服务器的<strong>监听端口设置为 9876</strong></p>
</li>
<li><p><code>if (commandLine.hasOption(&#39;c&#39;))</code>：读取命令行 -c 的参数值</p>
<p><code>in = new BufferedInputStream(new FileInputStream(file))</code>：读取指定目录的配置文件</p>
<p><code>properties.load(in)</code>：将配置文件信息加载到 properties 对象，相关属性会复写到 Namesrv 配置和 Netty 配置对象</p>
<p><code>namesrvConfig.setConfigStorePath(file)</code>：将配置文件的路径保存到配置保存字段</p>
</li>
<li><p><code>if (null == namesrvConfig.getRocketmqHome())</code>：检查 ROCKETMQ_HOME 配置是否是空，是空就报错</p>
</li>
<li><p><code>lc = (LoggerContext) LoggerFactory.getILoggerFactory()</code>：创建日志对象</p>
</li>
<li><p><code>controller = new NamesrvController(namesrvConfig, nettyServerConfig)</code>：<strong>创建 Namesrv 控制器</strong></p>
</li>
</ul>
<p>NamesrvStartup#start：启动 Namesrv 控制器</p>
<ul>
<li><p><code>boolean initResult = controller.initialize()</code>：初始化方法</p>
</li>
<li><p><code> Runtime.getRuntime().addShutdownHook(new ShutdownHookThread())</code>：JVM HOOK 平滑关闭的逻辑， 当 JVM 被关闭时，主动调用 controller.shutdown() 方法，让服务器平滑关机</p>
</li>
<li><p><code>controller.start()</code>：启动服务器</p>
</li>
</ul>
<p>源码解析参考视频：<a href="https://space.bilibili.com/457326371">https://space.bilibili.com/457326371</a></p>
<hr>
<h5 id="控制器类"><a href="#控制器类" class="headerlink" title="控制器类"></a>控制器类</h5><p>NamesrvController 用来初始化和启动 Namesrv 服务器</p>
<ul>
<li><p>成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutorService;	<span class="comment">// 调度线程池，用来执行定时任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RouteInfoManager routeInfoManager;					<span class="comment">// 管理【路由信息】的对象</span></span><br><span class="line"><span class="keyword">private</span> RemotingServer remotingServer;								<span class="comment">// 【网络层】封装对象</span></span><br><span class="line"><span class="keyword">private</span> BrokerHousekeepingService brokerHousekeepingService;		<span class="comment">// 用于监听 channel 状态</span></span><br></pre></td></tr></table></figure>

<p><code>private ExecutorService remotingExecutor</code>：业务线程池，<strong>netty 线程解析报文成 RemotingCommand 对象，然后将该对象交给业务线程池再继续处理</strong></p>
</li>
<li><p>初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 加载本地kv配置（我还不明白 kv 配置是啥）</span></span><br><span class="line">    <span class="built_in">this</span>.kvConfigManager.load();</span><br><span class="line">    <span class="comment">// 创建网络服务器对象，【将 netty 的配置和监听器传入】</span></span><br><span class="line">    <span class="comment">// 监听器监听 channel 状态的改变，会向事件队列发起事件，最后交由 service 处理</span></span><br><span class="line">    <span class="built_in">this</span>.remotingServer = <span class="keyword">new</span> <span class="title class_">NettyRemotingServer</span>(<span class="built_in">this</span>.nettyServerConfig, <span class="built_in">this</span>.brokerHousekeepingService);</span><br><span class="line">    <span class="comment">// 【创建业务线程池，默认线程数 8】</span></span><br><span class="line">    <span class="built_in">this</span>.remotingExecutor = Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads().);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册协议处理器（缺省协议处理器），【处理器是 DefaultRequestProcessor】，线程使用的是刚创建的业务的线程池</span></span><br><span class="line">    <span class="built_in">this</span>.registerProcessor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时任务1：每 10 秒钟检查 broker 存活状态，将 IDLE 状态的 broker 移除【扫描机制，心跳检测】</span></span><br><span class="line">    <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 扫描 brokerLiveTable 表，将两小时没有活动的 broker 关闭，</span></span><br><span class="line">            <span class="comment">// 通过 next.getKey() 获取 broker 的地址，然后【关闭服务器与broker物理节点的 channel】</span></span><br><span class="line">            NamesrvController.<span class="built_in">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时任务2：每 10 分钟打印一遍 kv 配置。</span></span><br><span class="line">    <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            NamesrvController.<span class="built_in">this</span>.kvConfigManager.printAllPeriodically();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 服务器网络层启动。</span></span><br><span class="line">    <span class="built_in">this</span>.remotingServer.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.fileWatchService != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.fileWatchService.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h4><h5 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h5><p>RocketMQ 的 RPC 通信采用 Netty 组件作为底层通信库，同样也遵循了 Reactor 多线程模型，NettyRemotingServer 类负责框架的通信服务，同时又在这之上做了一些扩展和优化</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-Reactor%E8%AE%BE%E8%AE%A1.png"></p>
<p>RocketMQ 基于 NettyRemotingServer 的 Reactor 多线程模型：</p>
<ul>
<li><p>一个 Reactor 主线程（eventLoopGroupBoss）负责监听 TCP 网络连接请求，建立好连接创建 SocketChannel（RocketMQ 会自动根据 OS 的类型选择 NIO 和 Epoll，也可以通过参数配置），并注册到 Selector 上，然后监听真正的网络数据</p>
</li>
<li><p>拿到网络数据交给 Worker 线程池（eventLoopGroupSelector，默认设置为 3），在真正执行业务逻辑之前需要进行 SSL 验证、编解码、空闲检查、网络连接管理，这些工作交给 defaultEventExecutorGroup（默认设置为 8）去做</p>
</li>
<li><p>处理业务操作放在业务线程池中执行，根据 RomotingCommand 的<strong>业务请求码 code</strong> 去 processorTable 这个本地缓存变量中找到对应的 processor，封装成 task 任务提交给对应的 processor 处理线程池来执行（sendMessageExecutor，以发送消息为例）</p>
</li>
<li><p>从入口到业务逻辑的几个步骤中线程池一直再增加，这跟每一步逻辑复杂性相关，越复杂，需要的并发通道越宽</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>线程数</th>
<th>线程名</th>
<th>线程具体说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>NettyBoss_%d</td>
<td>Reactor 主线程</td>
</tr>
<tr>
<td>N</td>
<td>NettyServerEPOLLSelector_%d_%d</td>
<td>Reactor 线程池</td>
</tr>
<tr>
<td>M1</td>
<td>NettyServerCodecThread_%d</td>
<td>Worker 线程池</td>
</tr>
<tr>
<td>M2</td>
<td>RemotingExecutorThread_%d</td>
<td>业务 processor 处理线程池</td>
</tr>
</tbody></table>
<p>RocketMQ 的异步通信流程：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.png"></p>
<p>&#x3D;&#x3D;todo：后期对 Netty 有了更深的认知后会进行扩充，现在暂时 copy 官方文档&#x3D;&#x3D;</p>
<p>官方文档：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md#2-%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6">https://github.com/apache/rocketmq/blob/master/docs/cn/design.md#2-%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6</a></p>
<hr>
<h5 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h5><p>NettyRemotingServer 类成员变量：</p>
<ul>
<li><p>服务器相关属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServerBootstrap serverBootstrap;				<span class="comment">// netty 服务端启动对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup eventLoopGroupSelector;		<span class="comment">// netty worker 组线程池，【默认 3 个线程】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup eventLoopGroupBoss;			<span class="comment">// netty boss 组线程池，【一般是 1 个线程】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> NettyServerConfig nettyServerConfig;			<span class="comment">// netty 服务端网络配置</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">0</span>;										<span class="comment">// 服务器绑定的端口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>公共线程池：注册处理器时如果未指定线程池，则业务处理使用公共线程池，线程数量默认是 4 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService publicExecutor;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件监听器：Nameserver 使用 BrokerHouseKeepingService，Broker 使用 ClientHouseKeepingService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelEventListener channelEventListener;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件处理线程池：默认是 8</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> DefaultEventExecutorGroup defaultEventExecutorGroup;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器：执行循环任务，并且将定时器线程设置为守护线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="string">&quot;ServerHouseKeepingService&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理器：多个 Channel 共享的处理器 Handler，多个通道使用同一个对象</p>
</li>
<li><p>Netty 配置对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServerConfig</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="comment">// 服务端启动时监听的端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">listenPort</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line">    <span class="comment">// 【业务线程池】 线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverWorkerThreads</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 根据该值创建 remotingServer 内部的一个 publicExecutor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverCallbackExecutorThreads</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// netty 【worker】线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverSelectorThreads</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 【单向访问】时的并发限制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverOnewaySemaphoreValue</span> <span class="operator">=</span> <span class="number">256</span>;</span><br><span class="line">    <span class="comment">// 【异步访问】时的并发限制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverAsyncSemaphoreValue</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// channel 最大的空闲存活时间 默认是 2min</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverChannelMaxIdleTimeSeconds</span> <span class="operator">=</span> <span class="number">120</span>;</span><br><span class="line">    <span class="comment">// 发送缓冲区大小 65535</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverSocketSndBufSize</span> <span class="operator">=</span> NettySystemConfig.socketSndbufSize;</span><br><span class="line">    <span class="comment">// 接收缓冲区大小 65535</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">serverSocketRcvBufSize</span> <span class="operator">=</span> NettySystemConfig.socketRcvbufSize;</span><br><span class="line">    <span class="comment">// 是否启用 netty 内存池 默认开启</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">serverPooledByteBufAllocatorEnable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认 linux 会启用 【epoll】</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">useEpollNativeSelector</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>构造方法：</p>
<ul>
<li><p>无监听器构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NettyRemotingServer</span><span class="params">(<span class="keyword">final</span> NettyServerConfig nettyServerConfig)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nettyServerConfig, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有参构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NettyRemotingServer</span><span class="params">(<span class="keyword">final</span> NettyServerConfig nettyServerConfig,</span></span><br><span class="line"><span class="params">                           <span class="keyword">final</span> ChannelEventListener channelEventListener)</span> &#123;</span><br><span class="line">    <span class="comment">// 服务器对客户端主动发起请求时并发限制。【单向请求和异步请求】的并发限制</span></span><br><span class="line">    <span class="built_in">super</span>(nettyServerConfig.getServerOnewaySemaphoreValue(), nettyServerConfig.getServerAsyncSemaphoreValue());</span><br><span class="line">	<span class="comment">// Netty 的启动器，负责组装 netty 组件</span></span><br><span class="line">    <span class="built_in">this</span>.serverBootstrap = <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    <span class="comment">// 成员变量的赋值</span></span><br><span class="line">    <span class="built_in">this</span>.nettyServerConfig = nettyServerConfig;</span><br><span class="line">    <span class="built_in">this</span>.channelEventListener = channelEventListener;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共线程池的线程数量，默认给的0，这里最终修改为4.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">publicThreadNums</span> <span class="operator">=</span> nettyServerConfig.getServerCallbackExecutorThreads();</span><br><span class="line">    <span class="keyword">if</span> (publicThreadNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        publicThreadNums = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建公共线程池，指定线程工厂，设置线程名称前缀：NettyServerPublicExecutor_[数字]</span></span><br><span class="line">    <span class="built_in">this</span>.publicExecutor = Executors.newFixedThreadPool(publicThreadNums, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>()&#123;.&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个 netty 的线程组，一个是boss组，一个是worker组，【linux 系统默认启用 epoll】</span></span><br><span class="line">    <span class="keyword">if</span> (useEpoll()) &#123;...&#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">	<span class="comment">// SSL 相关</span></span><br><span class="line">    loadSslContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="启动方法-1"><a href="#启动方法-1" class="headerlink" title="启动方法"></a>启动方法</h5><p>核心方法的解析：</p>
<ul>
<li><p>start()：启动方法，<strong>创建 BootStrap，并添加 NettyServerHandler 处理器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Channel Pipeline 内的 handler 使用的线程资源，【线程分配给 handler 处理事件】</span></span><br><span class="line">    <span class="built_in">this</span>.defaultEventExecutorGroup = <span class="keyword">new</span> <span class="title class_">DefaultEventExecutorGroup</span>(...);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建通用共享的处理器 handler，【非常重要的 NettyServerHandler】</span></span><br><span class="line">    prepareSharableHandlers();</span><br><span class="line"></span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">childHandler</span> <span class="operator">=</span></span><br><span class="line">        <span class="comment">// 配置工作组 boss（数量1） 和 worker（数量3） 组</span></span><br><span class="line">        <span class="built_in">this</span>.serverBootstrap.group(<span class="built_in">this</span>.eventLoopGroupBoss, <span class="built_in">this</span>.eventLoopGroupSelector)</span><br><span class="line">        <span class="comment">// 设置服务端 ServerSocketChannel 类型， Linux 用 epoll</span></span><br><span class="line">        .channel(useEpoll() ? EpollServerSocketChannel.class : NioServerSocketChannel.class)</span><br><span class="line">        <span class="comment">// 设置服务端 channel 选项</span></span><br><span class="line">        .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">        <span class="comment">// 客户端 channel 选项</span></span><br><span class="line">        .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">        <span class="comment">// 设置服务器端口</span></span><br><span class="line">        .localAddress(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="built_in">this</span>.nettyServerConfig.getListenPort()))</span><br><span class="line">        <span class="comment">// 向 channel pipeline 添加了很多 handler，【包括 NettyServerHandler】</span></span><br><span class="line">        .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;&#125;);</span><br><span class="line">            </span><br><span class="line">	<span class="comment">// 客户端开启 内存池，使用的内存池是  PooledByteBufAllocator.DEFAULT</span></span><br><span class="line">    <span class="keyword">if</span> (nettyServerConfig.isServerPooledByteBufAllocatorEnable()) &#123;</span><br><span class="line">        childHandler.childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 同步等待建立连接，并绑定端口。</span></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="built_in">this</span>.serverBootstrap.bind().sync();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">addr</span> <span class="operator">=</span> (InetSocketAddress) sync.channel().localAddress();</span><br><span class="line">        <span class="comment">// 将服务器成功绑定的端口号赋值给字段 port。</span></span><br><span class="line">        <span class="built_in">this</span>.port = addr.getPort();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// housekeepingService 不为空，则创建【网络异常事件处理器】</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.channelEventListener != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 线程一直轮询 nettyEvent 状态，根据 CONNECT,CLOSE,IDLE,EXCEPTION 四种事件类型</span></span><br><span class="line">        <span class="comment">// CONNECT 不做操作，其余都是回调 onChannelDestroy 【关闭服务器与 Broker 物理节点的 Channel】</span></span><br><span class="line">        <span class="built_in">this</span>.nettyEventExecutor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交定时任务，每一秒 执行一次。扫描 responseTable 表，将过期的数据移除</span></span><br><span class="line">    <span class="built_in">this</span>.timer.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       		NettyRemotingServer.<span class="built_in">this</span>.scanResponseTable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">3</span>, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>registerProcessor()：注册业务处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerProcessor</span><span class="params">(<span class="type">int</span> requestCode, NettyRequestProcessor processor, ExecutorService executor)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorThis</span> <span class="operator">=</span> executor;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == executor) &#123;</span><br><span class="line">        <span class="comment">// 未指定线程池资源，将公共线程池赋值</span></span><br><span class="line">        executorThis = <span class="built_in">this</span>.publicExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pair 对象，第一个参数代表的是处理器， 第二个参数是线程池，默认是公共的线程池</span></span><br><span class="line">    Pair&lt;NettyRequestProcessor, ExecutorService&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;NettyRequestProcessor, ExecutorService&gt;(processor, executorThis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key 是请求码，value 是 Pair 对象</span></span><br><span class="line">    <span class="built_in">this</span>.processorTable.put(requestCode, pair);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getProcessorPair()：<strong>根据请求码获取对应的处理器和线程池资源</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Pair&lt;NettyRequestProcessor, ExecutorService&gt; <span class="title function_">getProcessorPair</span><span class="params">(<span class="type">int</span> requestCode)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> processorTable.get(requestCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h5><p>在 RocketMQ 消息队列中支持通信的方式主要有同步（sync）、异步（async）、单向（oneway）三种，其中单向通信模式相对简单，一般用在发送心跳包场景下，无需关注其 Response</p>
<p>服务器主动向客户端发起请求时，使用三种方法</p>
<ul>
<li><p>invokeSync()： 同步调用，<strong>服务器需要阻塞等待调用的返回结果</strong></p>
<ul>
<li><code>int opaque = request.getOpaque()</code>：获取请求 ID（与请求码不同）</li>
<li><code>responseFuture = new ResponseFuture(...)</code>：<strong>创建响应对象</strong>，没有回调函数和 Once</li>
<li><code>this.responseTable.put(opaque, responseFuture)</code>：<strong>加入到响应映射表中</strong>，key 为请求 ID</li>
<li><code>SocketAddress addr = channel.remoteAddress()</code>：获取客户端的地址信息</li>
<li><code>channel.writeAndFlush(request).addListener(...)</code>：将<strong>业务 Command 信息</strong>写入通道，业务线程将数据交给 Netty ，Netty 的 IO 线程接管写刷数据的操作，<strong>监听器由 IO 线程在写刷后回调</strong><ul>
<li><code>if (f.isSuccess())</code>：写入成功会将响应对象设置为成功状态直接 return，写入失败设置为失败状态</li>
<li><code>responseTable.remove(opaque)</code>：将当前请求的 responseFuture <strong>从映射表移除</strong></li>
<li><code>responseFuture.setCause(f.cause())</code>：设置错误的信息</li>
<li><code>responseFuture.putResponse(null)</code>：响应 Command 设置为 null</li>
</ul>
</li>
<li><code>responseCommand = responseFuture.waitResponse(timeoutMillis)</code>：当前线程设置超时时间挂起，<strong>同步等待响应</strong></li>
<li><code>if (null == responseCommand)</code>：超时或者出现异常，直接报错</li>
<li><code>return responseCommand</code>：返回响应 Command 信息</li>
</ul>
</li>
<li><p>invokeAsync()：异步调用，有回调对象，无返回值</p>
<ul>
<li><code>boolean acquired = this.semaphoreAsync.tryAcquire(timeoutMillis, TimeUnit.MILLISECONDS)</code>：获取信号量的许可证，信号量用来<strong>限制异步请求</strong>的数量</li>
<li><code>if (acquired)</code>：许可证获取失败说明并发较高，会抛出异常</li>
<li><code>once = new SemaphoreReleaseOnlyOnce(this.semaphoreAsync)</code>：Once 对象封装了释放信号量的操作</li>
<li><code>costTime = System.currentTimeMillis() - beginStartTime</code>：计算一下耗费的时间，超时不再发起请求</li>
<li><code>responseFuture = new ResponseFuture()</code>：<strong>创建响应对象，包装了回调函数和 Once 对象</strong></li>
<li><code>this.responseTable.put(opaque, responseFuture)</code>：加入到响应映射表中，key 为请求 ID</li>
<li><code>channel.writeAndFlush(request).addListener(...)</code>：写刷数据<ul>
<li><code>if (f.isSuccess())</code>：写刷成功，设置 responseFuture 发生状态为 true</li>
<li><code>requestFail(opaque)</code>：写入失败，使用 publicExecutor <strong>公共线程池异步执行回调对象的函数</strong></li>
<li><code>responseFuture.release()</code>：出现异常会释放信号量</li>
</ul>
</li>
</ul>
</li>
<li><p>invokeOneway()：单向调用，不关注响应结果</p>
<ul>
<li><code>request.markOnewayRPC()</code>：设置单向标记，对端检查标记可知该请是单向请求</li>
<li><code>boolean acquired = this.semaphoreOneway.tryAcquire(timeoutMillis, TimeUnit.MILLISECONDS)</code>：获取信号量的许可证，信号量用来<strong>限制单向请求</strong>的数量</li>
</ul>
</li>
</ul>
<hr>
<h4 id="处理器类"><a href="#处理器类" class="headerlink" title="处理器类"></a>处理器类</h4><h5 id="协议设计-1"><a href="#协议设计-1" class="headerlink" title="协议设计"></a>协议设计</h5><p>在 Client 和 Server 之间完成一次消息发送时，需要对发送的消息进行一个协议约定，所以自定义 RocketMQ 的消息协议。在 RocketMQ 中，为了高效地在网络中传输消息和对收到的消息读取，就需要对消息进行编解码，RemotingCommand 这个类在消息传输过程中对所有数据内容的封装，不但包含了所有的数据结构，还包含了编码解码操作</p>
<table>
<thead>
<tr>
<th>Header字段</th>
<th>类型</th>
<th>Request 说明</th>
<th>Response 说明</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>int</td>
<td>请求操作码，应答方根据不同的请求码进行不同的处理</td>
<td>应答响应码，0 表示成功，非 0 则表示各种错误</td>
</tr>
<tr>
<td>language</td>
<td>LanguageCode</td>
<td>请求方实现的语言</td>
<td>应答方实现的语言</td>
</tr>
<tr>
<td>version</td>
<td>int</td>
<td>请求方程序的版本</td>
<td>应答方程序的版本</td>
</tr>
<tr>
<td>opaque</td>
<td>int</td>
<td>相当于 requestId，在同一个连接上的不同请求标识码，与响应消息中的相对应</td>
<td>应答不做修改直接返回</td>
</tr>
<tr>
<td>flag</td>
<td>int</td>
<td>区分是普通 RPC 还是 onewayRPC 的标志</td>
<td>区分是普通 RPC 还是 onewayRPC的标志</td>
</tr>
<tr>
<td>remark</td>
<td>String</td>
<td>传输自定义文本信息</td>
<td>传输自定义文本信息</td>
</tr>
<tr>
<td>extFields</td>
<td>HashMap&lt;String, String&gt;</td>
<td>请求自定义扩展信息</td>
<td>响应自定义扩展信息</td>
</tr>
</tbody></table>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE.png"></p>
<p>传输内容主要可以分为以下四部分：</p>
<ul>
<li><p>消息长度：总长度，四个字节存储，占用一个 int 类型</p>
</li>
<li><p>序列化类型&amp;消息头长度：同样占用一个 int 类型，第一个字节表示序列化类型，后面三个字节表示消息头长度</p>
</li>
<li><p>消息头数据：经过序列化后的消息头数据</p>
</li>
<li><p>消息主体数据：消息主体的二进制字节数据内容</p>
</li>
</ul>
<p>官方文档：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md">https://github.com/apache/rocketmq/blob/master/docs/cn/design.md</a></p>
<hr>
<h5 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h5><p>NettyServerHandler 类用来处理 Channel 上的事件，在 NettyRemotingServer 启动时注册到 Netty 中，可以处理 RemotingCommand 相关的数据，针对某一种类型的<strong>请求处理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;RemotingCommand&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 服务器处理接受到的请求信息</span></span><br><span class="line">        processMessageReceived(ctx, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processMessageReceived</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">RemotingCommand</span> <span class="variable">cmd</span> <span class="operator">=</span> msg;</span><br><span class="line">    <span class="keyword">if</span> (cmd != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 根据请求的类型进行处理</span></span><br><span class="line">        <span class="keyword">switch</span> (cmd.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> REQUEST_COMMAND:<span class="comment">// 客户端发起的请求，走这里</span></span><br><span class="line">                processRequestCommand(ctx, cmd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RESPONSE_COMMAND:<span class="comment">// 客户端响应的数据，走这里【当前类本身是服务器类也是客户端类】</span></span><br><span class="line">                processResponseCommand(ctx, cmd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NettyRemotingAbstract#processRequestCommand：<strong>处理请求的数据</strong></p>
<ul>
<li><p><code>matched = this.processorTable.get(cmd.getCode())</code>：根据业务请求码获取 Pair 对象，包含<strong>处理器和线程池资源</strong></p>
</li>
<li><p><code>pair = null == matched ? this.defaultRequestProcessor : matched</code>：未找到处理器则使用缺省处理器</p>
</li>
<li><p><code>int opaque = cmd.getOpaque()</code>：获取请求 ID</p>
</li>
<li><p><code>Runnable run = new Runnable()</code>：创建任务对象，任务在提交到线程池后开始执行</p>
<ul>
<li><p><code>doBeforeRpcHooks()</code>：RPC HOOK 前置处理</p>
</li>
<li><p><code>callback = new RemotingResponseCallback()</code>：<strong>封装响应客户端的逻辑</strong></p>
<ul>
<li><code>doAfterRpcHooks()</code>：RPC HOOK 后置处理</li>
<li><code>if (!cmd.isOnewayRPC())</code>：条件成立说明不是单向请求，需要结果</li>
<li><code>response.setOpaque(opaque)</code>：将请求 ID 设置到 response</li>
<li><code>response.markResponseType()</code>：<strong>设置当前请求是响应</strong></li>
<li><code>ctx.writeAndFlush(response)</code>： <strong>将响应数据交给 Netty IO 线程，完成数据写和刷</strong></li>
</ul>
</li>
<li><p><code>if (pair.getObject1() instanceof AsyncNettyRequestProcessor)</code>：Nameserver 默认使用 DefaultRequestProcessor 处理器，是一个 AsyncNettyRequestProcessor 子类</p>
</li>
<li><p><code>processor = (AsyncNettyRequestProcessor)pair.getObject1()</code>：获取处理器</p>
</li>
<li><p><code>processor.asyncProcessRequest(ctx, cmd, callback)</code>：异步调用，首先 processRequest，然后 callback 响应客户端</p>
<p><code>DefaultRequestProcessor.processRequest</code>：<strong>根据业务码处理请求，执行对应的操作</strong></p>
<p><code>ClientRemotingProcessor.processRequest</code>：处理事务回查消息，或者回执消息，需要消费者回执一条消息给生产者</p>
</li>
</ul>
</li>
<li><p><code>requestTask = new RequestTask(run, ctx.channel(), cmd)</code>：将任务对象、通道、请求封装成 RequestTask 对象</p>
</li>
<li><p><code>pair.getObject2().submit(requestTask)</code>：<strong>获取处理器对应的线程池，将 task 提交，从 IO 线程切换到业务线程</strong></p>
</li>
</ul>
<p>NettyRemotingAbstract#processResponseCommand：<strong>处理响应的数据</strong></p>
<ul>
<li><code>int opaque = cmd.getOpaque()</code>：获取请求 ID</li>
<li><code>responseFuture = responseTable.get(opaque)</code>：<strong>从响应映射表中获取对应的对象</strong></li>
<li><code>responseFuture.setResponseCommand(cmd)</code>：设置响应的 Command 对象</li>
<li><code>responseTable.remove(opaque)</code>：从映射表中移除对象，代表处理完成</li>
<li><code>if (responseFuture.getInvokeCallback() != null)</code>：包含回调对象，异步执行回调对象</li>
<li><code>responseFuture.putResponse(cmd)</code>：不包含回调对象，<strong>同步调用时，唤醒等待的业务线程</strong></li>
</ul>
<p>流程：客户端 invokeSync → 服务器的 processRequestCommand → 客户端的 processResponseCommand → 结束</p>
<hr>
<h4 id="路由信息"><a href="#路由信息" class="headerlink" title="路由信息"></a>路由信息</h4><h5 id="信息管理"><a href="#信息管理" class="headerlink" title="信息管理"></a>信息管理</h5><p>RouteInfoManager 类负责管理路由信息，NamesrvController 的构造方法中创建该类的实例对象，管理服务端的路由数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouteInfoManager</span> &#123;</span><br><span class="line">    <span class="comment">// Broker 两个小时不活跃，视为离线，被定时任务删除</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">BROKER_CHANNEL_EXPIRED_TIME</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 读写锁，保证线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">// 主题队列数据，一个主题对应多个队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable;</span><br><span class="line">    <span class="comment">// Broker 数据列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable;</span><br><span class="line">    <span class="comment">// 集群</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable;</span><br><span class="line">    <span class="comment">// Broker 存活信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable;</span><br><span class="line">    <span class="comment">// 服务过滤</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h5><p>DefaultRequestProcessor REGISTER_BROKER 方法解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RemotingCommand <span class="title function_">registerBroker</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建响应请求的对象，设置为响应类型，【先设置响应的状态码时系统错误码】</span></span><br><span class="line">    <span class="comment">// 反射创建 RegisterBrokerResponseHeader 对象设置到 response.customHeader 属性中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">RemotingCommand</span> <span class="variable">response</span> <span class="operator">=</span> RemotingCommand.createResponseCommand(RegisterBrokerResponseHeader.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取出反射创建的 RegisterBrokerResponseHeader 用户自定义header对象。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">RegisterBrokerResponseHeader</span> <span class="variable">responseHeader</span> <span class="operator">=</span> (RegisterBrokerResponseHeader) response.readCustomHeader();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射创建 RegisterBrokerRequestHeader 对象，并且将 request.extFields 中的数据写入到该对象中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">RegisterBrokerRequestHeader</span> <span class="variable">requestHeader</span> <span class="operator">=</span> request.decodeCommandCustomHeader(RegisterBrokerRequestHeader.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CRC 校验，计算请求中的 CRC 值和请求头中包含的是否一致</span></span><br><span class="line">    <span class="keyword">if</span> (!checksum(ctx, request, requestHeader)) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(<span class="string">&quot;crc32 not match&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TopicConfigSerializeWrapper topicConfigWrapper;</span><br><span class="line">    <span class="keyword">if</span> (request.getBody() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 【解析请求体 body】，解码出来的数据就是当前机器的主题信息</span></span><br><span class="line">        topicConfigWrapper = TopicConfigSerializeWrapper.decode(request.getBody(), TopicConfigSerializeWrapper.class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        topicConfigWrapper = <span class="keyword">new</span> <span class="title class_">TopicConfigSerializeWrapper</span>();</span><br><span class="line">        topicConfigWrapper.getDataVersion().setCounter(<span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>));</span><br><span class="line">        topicConfigWrapper.getDataVersion().setTimestamp(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册方法</span></span><br><span class="line">    <span class="comment">// 参数1 集群、参数2：节点ip地址、参数3：brokerName、参数4：brokerId 注意brokerId=0的节点为主节点</span></span><br><span class="line">    <span class="comment">// 参数5：ha节点ip地址、参数6当前节点主题信息、参数7：过滤服务器列表、参数8：当前服务器和客户端通信的channel</span></span><br><span class="line">    <span class="type">RegisterBrokerResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.namesrvController.getRouteInfoManager().registerBroker(..);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结果信息 写到 responseHeader 中</span></span><br><span class="line">    responseHeader.setHaServerAddr(result.getHaServerAddr());</span><br><span class="line">    responseHeader.setMasterAddr(result.getMasterAddr());</span><br><span class="line">    <span class="comment">// 获取 kv配置，写入 response body 中，【kv 配置是顺序消息相关的】</span></span><br><span class="line">    <span class="type">byte</span>[] jsonValue = <span class="built_in">this</span>.namesrvController.getKvConfigManager().getKVListByNamespace(NamesrvUtil.NAMESPACE_ORDER_TOPIC);</span><br><span class="line">    response.setBody(jsonValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// code 设置为 SUCCESS</span></span><br><span class="line">    response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">    response.setRemark(<span class="literal">null</span>);</span><br><span class="line">	<span class="comment">// 返回 response ，【返回的 response 由 callback 对象处理】</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RouteInfoManager#registerBroker：注册 Broker 的信息</p>
<ul>
<li><p><code>RegisterBrokerResult result = new RegisterBrokerResult()</code>：返回结果的封装对象</p>
</li>
<li><p><code>this.lock.writeLock().lockInterruptibly()</code>：加写锁后<strong>同步执行</strong></p>
</li>
<li><p><code>brokerNames = this.clusterAddrTable.get(clusterName)</code>：获取当前集群上的 Broker 名称列表，是空就新建列表</p>
</li>
<li><p><code>brokerNames.add(brokerName)</code>：将当前 Broker 名字加入到集群列表</p>
</li>
<li><p><code>brokerData = this.brokerAddrTable.get(brokerName)</code>：获取当前 Broker 的 brokerData，是空就新建放入映射表</p>
</li>
<li><p><code>brokerAddrsMap = brokerData.getBrokerAddrs()</code>：获取当前 Broker 的物理节点 map 表，进行遍历，如果物理节点角色发生变化（slave → master），先将旧数据从物理节点 map 中移除，然后重写放入，<strong>保证节点的唯一性</strong></p>
</li>
<li><p><code>if (null != topicConfigWrapper &amp;&amp; MixAll.MASTER_ID == brokerId)</code>：Broker 上的 Topic 不为 null，并且当前物理节点是  Broker 上的 master 节点</p>
<p><code>tcTable = topicConfigWrapper.getTopicConfigTable()</code>：获取当前 Broker 信息中的主题映射表</p>
<p><code>if (tcTable != null)</code>：映射表不空就加入或者更新到 Namesrv 内</p>
</li>
<li><p><code> prevBrokerLiveInfo = this.brokerLiveTable.put(brokerAddr)</code>：添加<strong>当前节点的 BrokerLiveInfo</strong> ，返回上一次心跳时当前 Broker 节点的存活对象数据。<strong>NamesrvController  中的定时任务会扫描映射表 brokerLiveTable</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BrokerLiveInfo</span> <span class="variable">prevBrokerLiveInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.brokerLiveTable.put(brokerAddr, <span class="keyword">new</span> <span class="title class_">BrokerLiveInfo</span>(</span><br><span class="line">    System.currentTimeMillis(),topicConfigWrapper.getDataVersion(), channel,haServerAddr));</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>if (MixAll.MASTER_ID != brokerId)</code>：当前 Broker 不是 master 节点，<strong>获取主节点的信息</strong>设置到结果对象</p>
</li>
<li><p><code>this.lock.writeLock().unlock()</code>：释放写锁</p>
</li>
</ul>
<hr>
<h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><h4 id="MappedFile"><a href="#MappedFile" class="headerlink" title="MappedFile"></a>MappedFile</h4><h5 id="成员属性-1"><a href="#成员属性-1" class="headerlink" title="成员属性"></a>成员属性</h5><p>MappedFile 类是最基础的存储类，继承自 ReferenceResource 类，用来<strong>保证线程安全</strong></p>
<p>MappedFile 类成员变量：</p>
<ul>
<li><p>内存相关：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OS_PAGE_SIZE</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">4</span>;<span class="comment">// 内存页大小：默认是 4k</span></span><br><span class="line"><span class="keyword">private</span> AtomicLong TOTAL_MAPPED_VIRTUAL_MEMORY;	<span class="comment">// 当前进程下所有的 mappedFile 占用的总虚拟内存大小</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger TOTAL_MAPPED_FILES;		<span class="comment">// 当前进程下所有的 mappedFile 个数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数据位点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> AtomicInteger wrotePosition;	<span class="comment">// 当前 mappedFile 的数据写入点</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> AtomicInteger committedPosition;<span class="comment">// 当前 mappedFile 的数据提交点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger flushedPosition;	<span class="comment">// 数据落盘位点，在这之前的数据是持久化的安全数据</span></span><br><span class="line">												<span class="comment">// flushedPosition-wrotePosition 之间的数据属于脏页</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文件相关：CL 是 CommitLog，CQ 是 ConsumeQueue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String fileName;	<span class="comment">// 文件名称，CL和CQ文件名是【第一条消息的物理偏移量】，索引文件是【年月日时分秒】</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> fileFromOffset;<span class="comment">// 文件名转long，代表该对象的【起始偏移量】	</span></span><br><span class="line"><span class="keyword">private</span> File file;			<span class="comment">// 文件对象</span></span><br></pre></td></tr></table></figure>

<p><strong>MF 中以物理偏移量作为文件名，可以更好的寻址和进行判断</strong></p>
</li>
<li><p>内存映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> FileChannel fileChannel;			<span class="comment">// 文件通道</span></span><br><span class="line"><span class="keyword">private</span> MappedByteBuffer mappedByteBuffer;	<span class="comment">// 内存映射缓冲区，访问虚拟内存</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>ReferenceResource 类成员变量：</p>
<ul>
<li><p>引用数量：当 <code>refCount &lt;= 0</code> 时，表示该资源可以释放了，没有任何其他程序依赖它了，用原子类保证线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">refCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">1</span>);	<span class="comment">// 初始值为 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>存活状态：表示资源的存活状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">available</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>是否清理：默认值 false，当执行完子类对象的 cleanup() 清理方法后，该值置为 true ，表示资源已经全部释放</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">cleanupOver</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一次关闭资源的时间：用来记录超时时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">firstShutdownTimestamp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><p>MappedFile 类核心方法：</p>
<ul>
<li><p>appendMessage()：提供上层向内存映射中追加消息的方法，消息如何追加由 AppendMessageCallback 控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：消息     参数二：追加消息回调</span></span><br><span class="line"><span class="keyword">public</span> AppendMessageResult <span class="title function_">appendMessage</span><span class="params">(MessageExtBrokerInner msg, AppendMessageCallback cb)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字节数组写入到文件通道</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">appendMessage</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] data)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>flush()：刷盘接口，参数 flushLeastPages  代表刷盘的最小页数 ，等于 0 时属于强制刷盘；&gt; 0 时需要脏页（计算方法在数据位点）达到该值才进行物理刷盘；文件写满时强制刷盘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">flush</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> flushLeastPages)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>selectMappedBuffer()：该方法以 pos 为开始位点 ，到有效数据为止，创建一个切片 ByteBuffer 作为数据副本，供业务访问数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SelectMappedBufferResult <span class="title function_">selectMappedBuffer</span><span class="params">(<span class="type">int</span> pos)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>destroy()：销毁映射文件对象，并删除关联的系统文件，参数是强制关闭资源的时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">destroy</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> intervalForcibly)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>cleanup()：<strong>释放堆外内存</strong>，更新总虚拟内存和总内存映射文件数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cleanup</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> currentRef)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>warmMappedFile()：内存预热，当要新建的 MappedFile 对象大于 1g 时执行该方法。mappedByteBuffer 已经通过mmap映射，此时操作系统中只是记录了该文件和该 Buffer 的映射关系，而并没有映射到物理内存中，对该 MappedFile 的每个 Page Cache 进行写入一个字节分配内存，<strong>将映射文件全部加载到内存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">warmMappedFile</span><span class="params">(FlushDiskType type, <span class="type">int</span> pages)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mlock()：锁住指定的内存区域避免被操作系统调到 swap 空间，减少了缺页异常的产生</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mlock</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>swap space 是磁盘上的一块区域，可以是一个分区或者一个文件或者是组合。当系统物理内存不足时，Linux 会将内存中不常访问的数据保存到 swap 区域上，这样系统就可以有更多的物理内存为各个进程服务，而当系统需要访问 swap 上存储的内容时，需要通过<strong>缺页中断</strong>将 swap 上的数据加载到内存中</p>
</li>
</ul>
<p>ReferenceResource 类核心方法：</p>
<ul>
<li><p>hold()：增加引用记数 refCount，方法加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">hold</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>shutdown()：关闭资源，参数代表强制关闭资源的时间间隔</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 系统当前时间 - firstShutdownTimestamp 时间  &gt; intervalForcibly 进行【强制关闭】</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> intervalForcibly)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>release()：引用计数减 1，当 refCount  为 0 时，调用子类的 cleanup 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="MapQueue"><a href="#MapQueue" class="headerlink" title="MapQueue"></a>MapQueue</h4><h5 id="成员属性-2"><a href="#成员属性-2" class="headerlink" title="成员属性"></a>成员属性</h5><p>MappedFileQueue 用来管理 MappedFile 文件</p>
<p>成员变量：</p>
<ul>
<li><p>管理目录：CommitLog 是 <code>../store/commitlog</code>， ConsumeQueue 是 <code>../store/xxx_topic/0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String storePath;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mappedFileSize;	<span class="comment">// 目录下每个文件大小，CL文件默认 1g，CQ文件 默认 600w字节</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;MappedFile&gt; mappedFiles;	<span class="comment">//目录下的每个 mappedFile 都加入该集合</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数据位点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">flushedWhere</span> <span class="operator">=</span> <span class="number">0</span>;		<span class="comment">// 目录的刷盘位点，值为 mf.fileName + mf.wrotePosition</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">committedWhere</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">// 目录的提交位点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>消息存储：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">storeTimestamp</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">// 当前目录下最后一条 msg 的存储时间</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建服务：新建 MappedFile 实例，继承自 ServiceThread 是一个任务对象，run 方法用来创建实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AllocateMappedFileService allocateMappedFileService;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h5><p>核心方法：</p>
<ul>
<li><p>load()：Broker 启动时，加载本地磁盘数据，该方法读取 storePath 目录下的文件，创建 MappedFile 对象放入集合内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">load</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>getLastMappedFile()：获取当前正在顺序写入的 MappedFile 对象，如果最后一个 MappedFile 写满了，或者不存在 MappedFile 对象，则创建新的 MappedFile</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：文件起始偏移量；参数二：当list为空时，是否新建 MappedFile</span></span><br><span class="line"><span class="keyword">public</span> MappedFile <span class="title function_">getLastMappedFile</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> startOffset, <span class="type">boolean</span> needCreate)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>flush()：根据 flushedWhere 属性查找合适的 MappedFile，调用该 MappedFile 的落盘方法，并更新全局的 flushedWhere</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数：0 表示强制刷新， &gt; 0 脏页数据必须达到 flushLeastPages 才刷新</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">flush</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> flushLeastPages)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>findMappedFileByOffset()：根据偏移量查询对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> MappedFile <span class="title function_">findMappedFileByOffset</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> offset, <span class="keyword">final</span> <span class="type">boolean</span> returnFirstOnNotFound)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>deleteExpiredFileByTime()：CL 删除过期文件，根据文件的保留时长决定是否删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：过期时间； 参数二：删除两个文件之间的时间间隔； 参数三：mf.destory传递的参数； 参数四：true 强制删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteExpiredFileByTime</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> expiredTime,<span class="keyword">final</span> <span class="type">int</span> deleteFilesInterval, <span class="keyword">final</span> <span class="type">long</span> intervalForcibly, <span class="keyword">final</span> <span class="type">boolean</span> cleanImmediately)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>deleteExpiredFileByOffset()：CQ 删除过期文件，遍历每个 MF 文件，获取当前文件最后一个数据单元的物理偏移量，小于 offset 说明当前 MF 文件内都是过期数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：consumeLog 目录下最小物理偏移量，就是第一条消息的 offset； </span></span><br><span class="line"><span class="comment">// 参数二：ConsumerQueue 文件内每个数据单元固定大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteExpiredFileByOffset</span><span class="params">(<span class="type">long</span> offset, <span class="type">int</span> unitSize)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="CommitLog"><a href="#CommitLog" class="headerlink" title="CommitLog"></a>CommitLog</h4><h5 id="成员属性-3"><a href="#成员属性-3" class="headerlink" title="成员属性"></a>成员属性</h5><p>成员变量：</p>
<ul>
<li><p>魔数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MESSAGE_MAGIC_CODE</span> <span class="operator">=</span> -<span class="number">626843481</span>;	<span class="comment">// 消息的第一个字段是大小，第二个字段就是魔数	</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">BLANK_MAGIC_CODE</span> <span class="operator">=</span> -<span class="number">875286124</span>;	<span class="comment">// 文件尾消息的魔法值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>MappedFileQueue：用于管理 <code>../store/commitlog</code> 目录下的文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> MappedFileQueue mappedFileQueue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>存储服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> DefaultMessageStore defaultMessageStore;	<span class="comment">// 存储模块对象，上层服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FlushCommitLogService flushCommitLogService;	<span class="comment">// 刷盘服务，默认实现是异步刷盘</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>回调器：控制消息的哪些字段添加到 MappedFile</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AppendMessageCallback appendMessageCallback;</span><br></pre></td></tr></table></figure>
</li>
<li><p>队列偏移量字典表：key 是主题队列 id，value 是偏移量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HashMap&lt;String, Long&gt; topicQueueTable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Long&gt;(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>锁相关：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">beginTimeInLock</span> <span class="operator">=</span> <span class="number">0</span>;		 	<span class="comment">// 写数据时加锁的开始时间</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> PutMessageLock putMessageLock;		<span class="comment">// 写锁，两个实现类：自旋锁和重入锁</span></span><br></pre></td></tr></table></figure>

<p>因为发送消息是需要持久化的，在 Broker 端持久化时会获取该锁，<strong>保证发送的消息的线程安全</strong></p>
</li>
</ul>
<p>构造方法：</p>
<ul>
<li><p>有参构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CommitLog</span><span class="params">(<span class="keyword">final</span> DefaultMessageStore defaultMessageStore)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 MappedFileQueue 对象</span></span><br><span class="line">    <span class="comment">// 参数1：../store/commitlog； 参数2：【1g】； 参数3：allocateMappedFileService</span></span><br><span class="line">    <span class="built_in">this</span>.mappedFileQueue = <span class="keyword">new</span> <span class="title class_">MappedFileQueue</span>(...);</span><br><span class="line">    <span class="comment">// 默认 异步刷盘，创建这个对象</span></span><br><span class="line">   	<span class="built_in">this</span>.flushCommitLogService = <span class="keyword">new</span> <span class="title class_">FlushRealTimeService</span>();</span><br><span class="line">    <span class="comment">// 控制消息哪些字段追加到 mappedFile，【消息最大是 4M】</span></span><br><span class="line">   	<span class="built_in">this</span>.appendMessageCallback = <span class="keyword">new</span> <span class="title class_">DefaultAppendMessageCallback</span>(...);</span><br><span class="line">    <span class="comment">// 默认使用自旋锁</span></span><br><span class="line">    <span class="built_in">this</span>.putMessageLock = ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-2"><a href="#成员方法-2" class="headerlink" title="成员方法"></a>成员方法</h5><p>CommitLog 类核心方法：</p>
<ul>
<li><p>start()：会启动刷盘服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>shutdown()：关闭刷盘服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>load()：加载 CommitLog 目录下的文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">load</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>getMessage()：根据 offset 查询单条信息，返回的结果对象内部封装了一个 ByteBuffer，该 Buffer 表示 <code>[offset, offset + size]</code> 区间的 MappedFile 的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SelectMappedBufferResult <span class="title function_">getMessage</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> offset, <span class="keyword">final</span> <span class="type">int</span> size)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>deleteExpiredFile()：删除过期文件，方法由 DefaultMessageStore 的定时任务调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteExpiredFile</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>asyncPutMessage()：<strong>存储消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;PutMessageResult&gt; <span class="title function_">asyncPutMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>msg.setStoreTimestamp(System.currentTimeMillis())</code>：设置存储时间，后面获取到写锁后这个事件会重写</li>
<li><code>msg.setBodyCRC(UtilAll.crc32(msg.getBody()))</code>：获取消息的 CRC 值</li>
<li><code>topic、queueId</code>：获取主题和队列 ID</li>
<li><code>if (msg.getDelayTimeLevel() &gt; 0) </code>：<strong>获取消息的延迟级别，这里是延迟消息实现的关键</strong></li>
<li><code>topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC</code>：<strong>修改消息的主题为 <code>SCHEDULE_TOPIC_XXXX</code></strong></li>
<li><code>queueId = ScheduleMessageService.delayLevel2QueueId()</code>：<strong>队列 ID 为延迟级别 -1</strong></li>
<li><code>MessageAccessor.putProperty</code>：<strong>将原来的消息主题和 ID 存入消息的属性 <code>REAL_TOPIC</code> 中</strong></li>
<li><code>mappedFile = this.mappedFileQueue.getLastMappedFile()</code>：获取当前顺序写的 MappedFile 对象</li>
<li><code>putMessageLock.lock()</code>：<strong>获取写锁</strong></li>
<li><code>msg.setStoreTimestamp(beginLockTimestamp)</code>：设置消息的存储时间为获取锁的时间</li>
<li><code>if (null == mappedFile || mappedFile.isFull())</code>：文件写满了创建新的 MF 对象</li>
<li><code>result = mappedFile.appendMessage(msg, this.appendMessageCallback)</code>：<strong>消息追加</strong>，核心逻辑在回调器类</li>
<li><code>putMessageLock.unlock()</code>：释放写锁</li>
<li><code>this.defaultMessageStore.unlockMappedFile(..)</code>：将 MappedByteBuffer 从 lock 切换为 unlock 状态</li>
<li><code>putMessageResult = new PutMessageResult(PutMessageStatus.PUT_OK, result)</code>：结果封装</li>
<li><code>flushResultFuture = submitFlushRequest(result, msg)</code>：<strong>唤醒刷盘线程</strong></li>
<li><code>replicaResultFuture = submitReplicaRequest(result, msg)</code>：HA 消息同步</li>
</ul>
</li>
<li><p>recoverNormally()：正常关机时的恢复方法，存储模块启动时<strong>先恢复所有的 ConsumeQueue 数据，再恢复 CommitLog 数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数表示恢复阶段 ConsumeQueue 中已知的最大的消息 offset</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverNormally</span><span class="params">(<span class="type">long</span> maxPhyOffsetOfConsumeQueue)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>int index = mappedFiles.size() - 3</code>：从倒数第三个 file 开始向后恢复</p>
</li>
<li><p><code>dispatchRequest = this.checkMessageAndReturnSize()</code>：每次从切片内解析出一条 msg 封装成 DispatchRequest 对象</p>
</li>
<li><p><code>size = dispatchRequest.getMsgSize()</code>：获取消息的大小，检查 DispatchRequest 对象的状态</p>
<p>情况 1：正常数据，则 <code>mappedFileOffset += size</code></p>
<p>情况 2：文件尾数据，处理下一个文件，mappedFileOffset 置为 0，magic_code 表示文件尾</p>
</li>
<li><p><code>processOffset += mappedFileOffset</code>：计算出正确的数据存储位点，并设置 MappedFileQueue 的目录刷盘位点</p>
</li>
<li><p><code>this.mappedFileQueue.truncateDirtyFiles(processOffset)</code>：调整 MFQ 中文件的刷盘位点</p>
</li>
<li><p><code>if (maxPhyOffsetOfConsumeQueue &gt;= processOffset)</code>：删除冗余数据，将超过全局位点的 CQ 下的文件删除，将包含全局位点的 CQ 下的文件重新定位</p>
</li>
</ul>
</li>
<li><p>recoverAbnormally()：异常关机时的恢复方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverAbnormally</span><span class="params">(<span class="type">long</span> maxPhyOffsetOfConsumeQueue)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>int index = mappedFiles.size() - 1</code>：从尾部开始遍历 MFQ，验证 MF 的第一条消息，找到第一个验证通过的文件对象</li>
<li><code>dispatchRequest = this.checkMessageAndReturnSize()</code>：每次解析出一条 msg 封装成 DispatchRequest 对象</li>
<li><code>this.defaultMessageStore.doDispatch(dispatchRequest)</code>：<strong>重建 ConsumerQueue 和 Index，避免上次异常停机导致 CQ 和 Index 与 CommitLog 不对齐</strong></li>
<li>剩余逻辑与正常关机的恢复方法相似</li>
</ul>
</li>
</ul>
<hr>
<h5 id="服务线程"><a href="#服务线程" class="headerlink" title="服务线程"></a>服务线程</h5><p>AppendMessageCallback 消息追加服务实现类为 DefaultAppendMessageCallback</p>
<ul>
<li><p>doAppend()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AppendMessageResult <span class="title function_">doAppend</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>long wroteOffset = fileFromOffset + byteBuffer.position()</code>：消息写入的位置，物理偏移量 phyOffset</li>
<li><code>String msgId</code>：<strong>消息 ID，规则是客户端 IP + 消息偏移量 phyOffset</strong></li>
<li><code>byte[] topicData</code>：序列化消息，将消息的字段压入到  msgStoreItemMemory 这个 Buffer 中</li>
<li><code>byteBuffer.put(this.msgStoreItemMemory.array(), 0, msgLen)</code>：将 msgStoreItemMemory 中的数据写入 MF 对象的内存映射的 Buffer 中，数据还没落盘</li>
<li><code>AppendMessageResult result</code>：构造结果对象，包括存储位点、是否成功、队列偏移量等信息</li>
<li><code>CommitLog.this.topicQueueTable.put(key, ++queueOffset)</code>：更新队列偏移量</li>
</ul>
</li>
</ul>
<p>FlushRealTimeService 刷盘 CL 数据，默认是异步刷盘类 FlushRealTimeService</p>
<ul>
<li><p>run()：运行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>while (!this.isStopped())</code>：stopped为 true 才跳出循环</p>
</li>
<li><p><code>boolean flushCommitLogTimed</code>：控制线程的休眠方式，默认是 false，使用 <code>CountDownLatch.await()</code> 休眠，设置为 true 时使用 <code>Thread.sleep()</code> 休眠</p>
</li>
<li><p><code>int interval</code>：获取配置中的刷盘时间间隔</p>
</li>
<li><p><code>int flushPhysicQueueLeastPages</code>：<strong>获取最小刷盘页数，默认是 4 页</strong>，脏页达到指定页数才刷盘</p>
</li>
<li><p><code>int flushPhysicQueueThoroughInterval</code>：获取强制刷盘周期，默认是 10 秒，达到周期后强制刷盘，不考虑脏页</p>
</li>
<li><p><code>if (flushCommitLogTimed)</code>：<strong>休眠逻辑</strong>，避免 CPU 占用太长时间，导致无法执行其他更紧急的任务</p>
</li>
<li><p><code>CommitLog.this.mappedFileQueue.flush(flushPhysicQueueLeastPages)</code>：<strong>刷盘</strong></p>
</li>
<li><p><code>for (int i = 0; i &lt; RETRY_TIMES_OVER &amp;&amp; !result; i++)</code>：stopped 停止标记为 true 时，需要确保所有的数据都已经刷盘，所以此处尝试 10 次强制刷盘，</p>
<p><code>result = CommitLog.this.mappedFileQueue.flush(0)</code>：<strong>强制刷盘</strong></p>
</li>
</ul>
</li>
</ul>
<p>同步刷盘类 GroupCommitService</p>
<ul>
<li><p>run()：运行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>while (!this.isStopped())</code>：stopped为 true 才跳出循环</p>
<p><code>this.waitForRunning(10)</code>：线程休眠 10 毫秒，最后调用 <code>onWaitEnd()</code> 进行<strong>请求的交换</strong> <code>swapRequests()</code></p>
<p><code>this.doCommit()</code>：做提交逻辑</p>
<ul>
<li><p><code>if (!this.requestsRead.isEmpty()) </code>：读请求集合不为空</p>
<p><code>for (GroupCommitRequest req : this.requestsRead)</code>：遍历所有的读请求，请求中的属性：</p>
<ul>
<li><code>private final long nextOffset</code>：本条消息存储之后，下一条消息开始的 offset</li>
<li><code>private CompletableFuture&lt;PutMessageStatus&gt; flushOKFuture</code>：Future 对象</li>
</ul>
<p><code>boolean flushOK = ...</code>：当前请求关注的数据是否全部落盘，<strong>落盘成功唤醒消费者线程</strong></p>
<p><code>for (int i = 0; i &lt; 2 &amp;&amp; !flushOK; i++)</code>：尝试进行两次强制刷盘，保证刷盘成功</p>
<p><code>CommitLog.this.mappedFileQueue.flush(0)</code>：强制刷盘</p>
<p><code>req.wakeupCustomer(flushOK ? ...)</code>：设置 Future 结果，在 Future 阻塞的线程在这里会被唤醒</p>
<p><code>this.requestsRead.clear()</code>：清理 reqeustsRead 列表，方便交换时成为 requestsWrite 使用</p>
</li>
<li><p><code>else</code>：读请求集合为空</p>
<p><code>CommitLog.this.mappedFileQueue.flush(0)</code>：强制刷盘</p>
</li>
</ul>
</li>
<li><p><code>this.swapRequests()</code>：交换读写请求</p>
</li>
<li><p><code>this.doCommit()</code>：交换后做一次提交</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="ConsQueue"><a href="#ConsQueue" class="headerlink" title="ConsQueue"></a>ConsQueue</h4><h5 id="成员属性-4"><a href="#成员属性-4" class="headerlink" title="成员属性"></a>成员属性</h5><p>ConsumerQueue 是消息消费队列，存储消息在 CommitLog 的索引，便于快速定位消息</p>
<p>成员变量：</p>
<ul>
<li><p>数据单元：ConsumerQueueData 数据单元的固定大小是 20 字节，默认申请 20 字节的缓冲区</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CQ_STORE_UNIT_SIZE</span> <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件管理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MappedFileQueue mappedFileQueue;	<span class="comment">// 文件管理器，管理 CQ 目录下的文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String storePath;					<span class="comment">// 目录，比如../store/consumequeue/xxx_topic/0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mappedFileSize;				<span class="comment">// 每一个 CQ 存储文件大小，默认 20 * 30w = 600w byte</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>存储主模块：上层的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultMessageStore defaultMessageStore;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String topic;					<span class="comment">// CQ 主题</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> queueId;					<span class="comment">// CQ 队列，每一个队列都有一个 ConsumeQueue 对象进行管理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer byteBufferIndex;	<span class="comment">// 临时缓冲区，插新的 CQData 时使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">maxPhysicOffset</span> <span class="operator">=</span> -<span class="number">1</span>;			<span class="comment">// 当前ConsumeQueue内存储的最大消息物理偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">minLogicOffset</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">// 当前ConsumeQueue内存储的最小消息物理偏移量</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>构造方法：</p>
<ul>
<li><p>有参构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConsumeQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 申请了一个 20 字节大小的 临时缓冲区</span></span><br><span class="line">    <span class="built_in">this</span>.byteBufferIndex = ByteBuffer.allocate(CQ_STORE_UNIT_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-3"><a href="#成员方法-3" class="headerlink" title="成员方法"></a>成员方法</h5><p>ConsumeQueue 启动阶段方法：</p>
<ul>
<li>load()：第一步，加载 storePath 目录下的文件，初始化 MappedFileQueue</li>
<li>recover()：第二步，恢复 ConsumeQueue 数据<ul>
<li>从倒数第三个 MF 文件开始向后遍历，依次读取 MF 中 20 个字节的 CQData 数据，检查 offset 和 size 是否是有效数据</li>
<li>找到无效的 CQData 的位点，该位点就是 CQ 的刷盘点和数据顺序写入点</li>
<li>删除无效的 MF 文件，调整当前顺序写的 MF 文件的数据位点</li>
</ul>
</li>
</ul>
<p>其他方法：</p>
<ul>
<li><p>truncateDirtyLogicFiles()：CommitLog 恢复阶段调用，将 ConsumeQueue 有效数据文件与 CommitLog 对齐，将超出部分的数据文删除掉，并调整当前文件的数据位点。Broker 启动阶段先恢复 CQ 的数据，再恢复 CL 数据，但是<strong>数据要以 CL 为基准</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是最大消息物理偏移量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">truncateDirtyLogicFiles</span><span class="params">(<span class="type">long</span> phyOffet)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>flush()：刷盘，调用 MFQ 的刷盘方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">flush</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> flushLeastPages)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>deleteExpiredFile()：删除过期文件，将小于 offset 的所有 MF 文件删除，offset 是 CommitLog 目录下最小的物理偏移量，小于该值的 CL 文件已经没有了，所以 CQ 也没有存在的必要</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteExpiredFile</span><span class="params">(<span class="type">long</span> offset)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>putMessagePositionInfoWrapper()：<strong>向 CQ 中追加 CQData 数据</strong>，由存储主模块 DefaultMessageStore 内部的异步线程调用，负责构建 ConsumeQueue 文件和 Index 文件的，该线程会持续关注 CommitLog 文件，当 CommitLog 文件内有新数据写入，就读出来封装成 DispatchRequest 对象，转发给 ConsumeQueue 或者 IndexService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putMessagePositionInfoWrapper</span><span class="params">(DispatchRequest request)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>getIndexBuffer()：转换 startIndex 为 offset，获取包含该 offset 的 MappedFile 文件，读取 <code>[offset%maxSize, mfPos]</code> 范围的数据，包装成结果对象返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SelectMappedBufferResult <span class="title function_">getIndexBuffer</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> startIndex)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="IndexFile"><a href="#IndexFile" class="headerlink" title="IndexFile"></a>IndexFile</h4><h5 id="成员属性-5"><a href="#成员属性-5" class="headerlink" title="成员属性"></a>成员属性</h5><p>IndexFile 类成员属性</p>
<ul>
<li><p>哈希：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">hashSlotSize</span> <span class="operator">=</span> <span class="number">4</span>;	<span class="comment">// 每个 hash 桶的大小是 4 字节，【用来存放索引的编号】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> hashSlotNum;			<span class="comment">// hash 桶的个数，默认 500 万</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>索引：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">indexSize</span> <span class="operator">=</span> <span class="number">20</span>;		<span class="comment">// 每个 index 条目的大小是 20 字节</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">invalidIndex</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">// 无效索引编号：0 特殊值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> indexNum;				<span class="comment">// 默认值：2000w</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IndexHeader indexHeader;	<span class="comment">// 索引头</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MappedFile mappedFile;			<span class="comment">// 【索引文件使用的 MF 文件】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FileChannel fileChannel;			<span class="comment">// 文件通道</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MappedByteBuffer mappedByteBuffer;<span class="comment">// 从 MF 中获取的内存映射缓冲区</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>构造方法：</p>
<ul>
<li><p>有参构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// endPhyOffset 上个索引文件 最后一条消息的 物理偏移量</span></span><br><span class="line"><span class="comment">// endTimestamp 上个索引文件 最后一条消息的 存储时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">IndexFile</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="type">int</span> hashSlotNum, <span class="keyword">final</span> <span class="type">int</span> indexNum,</span></span><br><span class="line"><span class="params">                 <span class="keyword">final</span> <span class="type">long</span> endPhyOffset, <span class="keyword">final</span> <span class="type">long</span> endTimestamp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 文件大小 40 + 500w * 4 + 2000w * 20</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">fileTotalSize</span> <span class="operator">=</span></span><br><span class="line">        IndexHeader.INDEX_HEADER_SIZE + (hashSlotNum * hashSlotSize) + (indexNum * indexSize);</span><br><span class="line">    <span class="comment">// 创建 mf 对象，会在disk上创建文件</span></span><br><span class="line">    <span class="built_in">this</span>.mappedFile = <span class="keyword">new</span> <span class="title class_">MappedFile</span>(fileName, fileTotalSize);</span><br><span class="line">    <span class="comment">// 创建 索引头对象，传递 索引文件mf 的切片数据</span></span><br><span class="line">    <span class="built_in">this</span>.indexHeader = <span class="keyword">new</span> <span class="title class_">IndexHeader</span>(byteBuffer);</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-4"><a href="#成员方法-4" class="headerlink" title="成员方法"></a>成员方法</h5><p>IndexFile 类方法</p>
<ul>
<li><p>load()：加载 IndexHeader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>flush()：MappedByteBuffer 内的数据强制落盘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>isWriteFull()：检查当前的 IndexFile 已写索引数是否 &gt;&#x3D; indexNum，达到该值则当前 IndexFile 不能继续追加 IndexData 了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isWriteFull</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>destroy()：删除文件时使用的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">destroy</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> intervalForcibly)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>putKey()：添加索引数据，解决哈希冲突使用<strong>头插法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：消息的 key，uniq_key 或者 keys=&quot;aaa bbb ccc&quot; 会分别为 aaa bbb ccc 创建索引</span></span><br><span class="line"><span class="comment">// 参数二：消息的物理偏移量；  参数三：消息存储时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">putKey</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="type">long</span> phyOffset, <span class="keyword">final</span> <span class="type">long</span> storeTimestamp)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>int slotPos = keyHash % this.hashSlotNum</code>：对 key 计算哈希后，取模得到对应的哈希槽 slot 下标，然后计算出哈希槽的存储位置 absSlotPos</li>
<li><code>int slotValue = this.mappedByteBuffer.getInt(absSlotPos)</code>：获取槽中的值，如果是无效值说明没有哈希冲突</li>
<li><code>timeDiff = timeDiff / 1000</code>：计算当前 msg 存储时间减去索引文件内第一条消息存储时间的差值，转化为秒进行存储</li>
<li><code>int absIndexPos</code>：计算当前索引数据存储的位置，开始填充索引数据到对应的位置</li>
<li><code>this.mappedByteBuffer.putInt(absIndexPos + 4 + 8 + 4, slotValue)</code>：<strong>hash 桶的原值，头插法</strong></li>
<li><code>this.mappedByteBuffer.putInt(absSlotPos, this.indexHeader...)</code>：在 slot 放入当前索引的索引编号</li>
<li><code>if (this.indexHeader.getIndexCount() &lt;= 1)</code>：索引文件插入的第一条数据，需要设置起始偏移量和存储时间</li>
<li><code>if (invalidIndex == slotValue)</code>：没有哈希冲突，说明占用了一个新的 hash slot</li>
<li><code>this.indexHeader</code>：设置索引头的相关属性</li>
</ul>
</li>
<li><p>selectPhyOffset()：从索引文件查询消息的物理偏移量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：查询结果全部放到该list内； 参数二：查询key； 参数三：结果最大数限制； 参数四五：时间范围</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectPhyOffset</span><span class="params">(<span class="keyword">final</span> List&lt;Long&gt; phyOffsets, <span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="type">int</span> maxNum,<span class="keyword">final</span> <span class="type">long</span> begin, <span class="keyword">final</span> <span class="type">long</span> end, <span class="type">boolean</span> lock)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>if (this.mappedFile.hold())</code>： MF 的引用记数 +1，查询期间 MF 资源<strong>不能被释放</strong></li>
<li><code>int slotValue = this.mappedByteBuffer.getInt(absSlotPos)</code>：获取槽中的值，可能是无效值或者索引编号，如果是无效值说明查询未命中</li>
<li><code>int absIndexPos</code>：计算出索引编号对应索引数据的开始位点</li>
<li><code>this.mappedByteBuffer</code>：读取索引数据</li>
<li><code>long timeRead = this.indexHeader.getBeginTimestamp() + timeDiff</code>：计算出准确的存储时间</li>
<li><code>boolean timeMatched = (timeRead &gt;= begin) &amp;&amp; (timeRead &lt;= end)</code>：时间范围的匹配</li>
<li><code>phyOffsets.add(phyOffsetRead)</code>：将命中的消息索引的消息偏移量加入到 list 集合中</li>
<li><code>nextIndexToRead = prevIndexRead</code>：遍历前驱节点</li>
</ul>
</li>
</ul>
<hr>
<h4 id="IndexServ"><a href="#IndexServ" class="headerlink" title="IndexServ"></a>IndexServ</h4><h5 id="成员属性-6"><a href="#成员属性-6" class="headerlink" title="成员属性"></a>成员属性</h5><p>IndexService 类用来管理 IndexFile 文件</p>
<p>成员变量：</p>
<ul>
<li><p>存储主模块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultMessageStore defaultMessageStore;</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引文件存储目录：<code>../store/index</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String storePath;</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引对象集合：目录下的每个文件都有一个 IndexFile 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IndexFile&gt; indexFileList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;IndexFile&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> hashSlotNum;		<span class="comment">// 每个索引文件包含的 哈希桶数量 ：500w</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> indexNum;			<span class="comment">// 每个索引文件包含的 索引条目数量 ：2000w</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-5"><a href="#成员方法-5" class="headerlink" title="成员方法"></a>成员方法</h5><ul>
<li><p>load()：加载 storePath 目录下的文件，为每个文件创建一个 IndexFile 实例对象，并加载 IndexHeader 信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">load</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> lastExitOK)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>deleteExpiredFile()：删除过期索引文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数 offset 表示 CommitLog 内最早的消息的 phyOffset</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteExpiredFile</span><span class="params">(<span class="type">long</span> offset)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.readWriteLock.readLock().lock()</code>：加锁判断</li>
<li><code>long endPhyOffset = this.indexFileList.get(0).getEndPhyOffset()</code>：获取目录中第一个文件的结束偏移量</li>
<li><code>if (endPhyOffset &lt; offset)</code>：索引目录内存在过期的索引文件，并且当前的 IndexFile 都是过期的数据</li>
<li><code>for (int i = 0; i &lt; (files.length - 1); i++)</code>：遍历文件列表，删除过期的文件</li>
</ul>
</li>
<li><p>buildIndex()：存储主模块 DefaultMessageStore 内部的异步线程调用，构建 Index 数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildIndex</span><span class="params">(DispatchRequest req)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>indexFile = retryGetAndCreateIndexFile()</code>：获取或者创建顺序写的索引文件对象</p>
</li>
<li><p><code>buildKey(topic, req.getUniqKey())</code>：<strong>构建索引 key，<code>topic + # + uniqKey</code></strong></p>
</li>
<li><p><code>indexFile = putKey()</code>：插入索引文件</p>
</li>
<li><p><code>if (keys != null &amp;&amp; keys.length() &gt; 0)</code>：消息存在自定义索引 keys</p>
<p><code>for (int i = 0; i &lt; keyset.length; i++)</code>：遍历每个索引，为每个 key 调用一次 putKey</p>
</li>
</ul>
</li>
<li><p>getAndCreateLastIndexFile()：获取当前顺序写的 IndexFile，没有就创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> IndexFile <span class="title function_">getAndCreateLastIndexFile</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="HAService"><a href="#HAService" class="headerlink" title="HAService"></a>HAService</h4><h5 id="HAService-1"><a href="#HAService-1" class="headerlink" title="HAService"></a>HAService</h5><h6 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h6><p>HAService 类成员变量：</p>
<ul>
<li><p>主节点属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// master 节点当前有多少个 slave 节点与其进行数据同步</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">connectionCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// master 节点会给每个发起连接的 slave 节点的通道创建一个 HAConnection，【控制 master 端向 slave 端传输数据】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;HAConnection&gt; connectionList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// master 向 slave 节点推送的最大的 offset，表示数据同步的进度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">push2SlaveMaxOffset</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>内部类属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装了绑定服务器指定端口，监听 slave 的连接的逻辑，没有使用 Netty，使用了原生态的 NIO 去做</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AcceptSocketService acceptSocketService;</span><br><span class="line"><span class="comment">// 控制生产者线程阻塞等待的逻辑</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> GroupTransferService groupTransferService;</span><br><span class="line"><span class="comment">// slave 节点的客户端对象，【slave 端才会正常运行该实例】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HAClient haClient;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程通信对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">WaitNotifyObject</span> <span class="variable">waitNotifyObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitNotifyObject</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>成员方法：</p>
<ul>
<li><p>start()：启动高可用服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 监听从节点</span></span><br><span class="line">    <span class="built_in">this</span>.acceptSocketService.beginAccept();</span><br><span class="line">    <span class="comment">// 启动监听服务</span></span><br><span class="line">    <span class="built_in">this</span>.acceptSocketService.start();</span><br><span class="line">    <span class="comment">// 启动转移服务</span></span><br><span class="line">    <span class="built_in">this</span>.groupTransferService.start();</span><br><span class="line">    <span class="comment">// 启动从节点客户端实例</span></span><br><span class="line">    <span class="built_in">this</span>.haClient.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h6><p>AcceptSocketService 类用于<strong>监听从节点的连接</strong>，创建 HAConnection 连接对象</p>
<p>成员变量：</p>
<ul>
<li><p>端口信息：Master 绑定监听的端口信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SocketAddress socketAddressListen;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端通道：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ServerSocketChannel serverSocketChannel;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多路复用器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Selector selector;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>成员方法：</p>
<ul>
<li><p>beginAccept()：开始监听连接，<strong>NIO</strong> 标准模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beginAccept</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>run()：服务启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.selector.select(1000)</code>：多路复用器阻塞获取就绪的通道，最多等待 1 秒钟</li>
<li><code>Set&lt;SelectionKey&gt; selected = this.selector.selectedKeys()</code>：获取选择器中所有注册的通道中已经就绪好的事件</li>
<li><code>for (SelectionKey k : selected)</code>：遍历所有就绪的事件</li>
<li><code>if ((k.readyOps() &amp; SelectionKey.OP_ACCEPT) != 0)</code>：说明 <code>OP_ACCEPT</code> 事件就绪</li>
<li><code>SocketChannel sc = ((ServerSocketChannel) k.channel()).accept()</code>：<strong>获取到客户端连接的通道</strong></li>
<li><code>HAConnection conn = new HAConnection(HAService.this, sc)</code>：<strong>为每个连接 master 服务器的 slave 创建连接对象</strong></li>
<li><code>conn.start()</code>：<strong>启动 HAConnection 对象</strong>，内部启动两个服务为读数据服务、写数据服务</li>
<li><code>HAService.this.addConnection(conn)</code>：加入到 HAConnection 集合内</li>
</ul>
</li>
</ul>
<hr>
<h6 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h6><p>GroupTransferService 用来控制数据同步</p>
<p>成员方法：</p>
<ul>
<li><p>doWaitTransfer()：等待主从数据同步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doWaitTransfer</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>if (!this.requestsRead.isEmpty())</code>：读请求不为空</li>
<li><code>boolean transferOK = HAService.this.push2SlaveMaxOffset... &gt;= req.getNextOffset()</code>：<strong>主从同步是否完成</strong></li>
<li><code>req.wakeupCustomer(transferOK ? ...)</code>：唤醒消费者</li>
<li><code>this.requestsRead.clear()</code>：清空读请求</li>
</ul>
</li>
<li><p>swapRequests()：交换读写请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapRequests</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="HAClient"><a href="#HAClient" class="headerlink" title="HAClient"></a>HAClient</h5><h6 id="成员属性-7"><a href="#成员属性-7" class="headerlink" title="成员属性"></a>成员属性</h6><p>HAClient 是 slave 端运行的代码，用于<strong>和 master 服务器建立长连接</strong>，上报本地同步进度，消费服务器发来的 msg 数据</p>
<p>成员变量：</p>
<ul>
<li><p>缓冲区：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">READ_MAX_BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;	<span class="comment">// 默认大小：4 MB</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ByteBuffer</span> <span class="variable">byteBufferRead</span> <span class="operator">=</span> ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);</span><br><span class="line"><span class="keyword">private</span> <span class="type">ByteBuffer</span> <span class="variable">byteBufferBackup</span> <span class="operator">=</span> ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>主节点地址：格式为 <code>ip:port</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;String&gt; masterAddress = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;()</span><br></pre></td></tr></table></figure>
</li>
<li><p>NIO 属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer reportOffset;	<span class="comment">// 通信使用NIO，所以消息使用块传输，上报 slave offset 使用</span></span><br><span class="line"><span class="keyword">private</span> SocketChannel socketChannel;	<span class="comment">// 客户端与 master 的会话通道				</span></span><br><span class="line"><span class="keyword">private</span> Selector selector;				<span class="comment">// 多路复用器</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通信时间：上次会话通信时间，用于控制 socketChannel 是否关闭的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastWriteTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br></pre></td></tr></table></figure>
</li>
<li><p>进度信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">currentReportedOffset</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">// slave 当前的进度信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">dispatchPosition</span> <span class="operator">=</span> <span class="number">0</span>;		<span class="comment">// 控制 byteBufferRead position 指针</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="成员方法-6"><a href="#成员方法-6" class="headerlink" title="成员方法"></a>成员方法</h6><ul>
<li><p>run()：启动方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>if (this.connectMaster())</code>：连接主节点，连接失败会休眠 5 秒</p>
<ul>
<li><code>String addr = this.masterAddress.get()</code>：获取 master 暴露的 HA 地址端口信息</li>
<li><code>this.socketChannel = RemotingUtil.connect(socketAddress)</code>：建立连接</li>
<li><code>this.socketChannel.register(this.selector, SelectionKey.OP_READ)</code>：注册到多路复用器，<strong>关注读事件</strong></li>
<li><code>this.currentReportedOffset</code>： 初始化上报进度字段为 slave 的 maxPhyOffset</li>
</ul>
</li>
<li><p><code>if (this.isTimeToReportOffset())</code>：slave 每 5 秒会上报一次 slave 端的同步进度信息给 master</p>
<p><code>boolean result = this.reportSlaveMaxOffset()</code>：<strong>上报同步信息</strong>，上报失败关闭连接</p>
</li>
<li><p><code>this.selector.select(1000)</code>：多路复用器阻塞获取就绪的通道，最多等待 1 秒钟，<strong>获取到就绪事件或者超时后结束</strong></p>
</li>
<li><p><code>boolean ok = this.processReadEvent()</code>：处理读事件</p>
</li>
<li><p><code>if (!reportSlaveMaxOffsetPlus())</code>：检查是否重新上报同步进度</p>
</li>
</ul>
</li>
<li><p>reportSlaveMaxOffset()：上报 slave 同步进度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">reportSlaveMaxOffset</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> maxOffset)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先向缓冲区写入 slave 端最大偏移量，写完以后切换为指定置为初始状态</p>
</li>
<li><p><code>for (int i = 0; i &lt; 3 &amp;&amp; this.reportOffset.hasRemaining(); i++)</code>：尝试三次写数据</p>
<p><code>this.socketChannel.write(this.reportOffset)</code>：<strong>写数据</strong></p>
</li>
<li><p><code>return !this.reportOffset.hasRemaining()</code>：写成功之后 pos &#x3D; limit</p>
</li>
</ul>
</li>
<li><p>processReadEvent()：处理 master 发送给 slave 数据，返回 true 表示处理成功   false 表示 Socket 处于半关闭状态，需要上层重建 haClient</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">processReadEvent</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>int readSizeZeroTimes = 0</code>：控制 while 循环的一个条件变量，当值为 3 时跳出循环</p>
</li>
<li><p><code>while (this.byteBufferRead.hasRemaining())</code>：byteBufferRead 有空间可以去 Socket 读缓冲区加载数据</p>
</li>
<li><p><code>int readSize = this.socketChannel.read(this.byteBufferRead)</code>：<strong>从通道读数据</strong></p>
</li>
<li><p><code>if (readSize &gt; 0)</code>：加载成功，有新数据</p>
<p><code>readSizeZeroTimes = 0</code>：置为 0</p>
<p><code>boolean result = this.dispatchReadRequest()</code>：处理数据的核心逻辑</p>
</li>
<li><p><code>else if (readSize == 0) </code>：连续无新数据 3 次，跳出循环</p>
</li>
<li><p><code>else</code>：readSize &#x3D; -1 就表示 Socket 处于半关闭状态，对端已经关闭了</p>
</li>
</ul>
</li>
<li><p>dispatchReadRequest()：<strong>处理数据的核心逻辑</strong>，master 与 slave 传输的数据格式 <code>&#123;[phyOffset][size][data...]&#125;</code>，phyOffset 表示数据区间的开始偏移量，data 代表数据块，最大 32kb，可能包含多条消息的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dispatchReadRequest</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>final int msgHeaderSize = 8 + 4</code>：协议头大小 12</p>
</li>
<li><p><code>int readSocketPos = this.byteBufferRead.position()</code>：记录缓冲区处理数据前的 pos 位点，用于恢复指针</p>
</li>
<li><p><code>int diff = ...</code>：当前 byteBufferRead 还剩多少 byte 未处理，每处理一条帧数据都会更新 dispatchPosition</p>
</li>
<li><p><code>if (diff &gt;= msgHeaderSize)</code>：缓冲区还有完整的协议头 header 数据</p>
</li>
<li><p><code>if (diff &gt;= (msgHeaderSize + bodySize))</code>：说明<strong>缓冲区内是包含当前帧的全部数据的</strong>，开始处理帧数据 </p>
<p><code>HAService...appendToCommitLog(masterPhyOffset, bodyData)</code>：<strong>存储数据到 CommitLog</strong>，并构建 Index 和 CQ</p>
<p><code>this.byteBufferRead.position(readSocketPos)</code>：恢复 byteBufferRead 的 pos 指针</p>
<p><code>this.dispatchPosition += msgHeaderSize + bodySize</code>：加一帧数据长度，处理下一条数据使用</p>
<p><code>if (!reportSlaveMaxOffsetPlus())</code>：上报 slave 同步信息</p>
</li>
<li><p><code>if (!this.byteBufferRead.hasRemaining())</code>：缓冲区写满了，重新分配缓冲区</p>
</li>
</ul>
</li>
<li><p>reallocateByteBuffer()：重新分配缓冲区</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reallocateByteBuffer</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>int remain = READ_MAX_BUFFER_SIZE - this.dispatchPosition</code>：表示缓冲区尚未处理过的字节数量</p>
</li>
<li><p><code>if (remain &gt; 0)</code>：条件成立，说明缓冲区<strong>最后一帧数据是半包数据</strong>，但是不能丢失数据</p>
<p><code>this.byteBufferBackup.put(this.byteBufferRead)</code>：<strong>将半包数据拷贝到 backup 缓冲区</strong></p>
</li>
<li><p><code>this.swapByteBuffer()</code>：交换 backup 成为 read</p>
</li>
<li><p><code>this.byteBufferRead.position(remain)</code>：设置 pos 为 remain ，后续加载数据 pos 从remain 开始向后移动</p>
</li>
<li><p><code>this.dispatchPosition = 0</code>：当前缓冲区交换之后，相当于是一个全新的 byteBuffer，所以分配指针归零</p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="HAConn"><a href="#HAConn" class="headerlink" title="HAConn"></a>HAConn</h5><h6 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h6><p>HAConnection 类成员变量：</p>
<ul>
<li><p>会话通道：master 和 slave 之间通信的 SocketChannel </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SocketChannel socketChannel;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端地址：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String clientAddr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> WriteSocketService writeSocketService;	<span class="comment">// 写数据服务</span></span><br><span class="line"><span class="keyword">private</span> ReadSocketService readSocketService;	<span class="comment">// 读数据服务</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>请求位点：在 slave 上报本地的进度之后被赋值，该值大于 0 后同步逻辑才会运行，master 如果不知道 slave 节点当前消息的存储进度，就无法给 slave 推送数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">slaveRequestOffset</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应答位点： 保存最新的 slave 上报的 offset 信息，slaveAckOffset 之前的数据都可以认为 slave 已经同步完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">slaveAckOffset</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>核心方法：</p>
<ul>
<li><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HAConnection</span><span class="params">(<span class="keyword">final</span> HAService haService, <span class="keyword">final</span> SocketChannel socketChannel)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一些东西</span></span><br><span class="line">    <span class="comment">// 设置 socket 读写缓冲区为 64kb 大小</span></span><br><span class="line">    <span class="built_in">this</span>.socketChannel.socket().setReceiveBufferSize(<span class="number">1024</span> * <span class="number">64</span>);</span><br><span class="line">    <span class="built_in">this</span>.socketChannel.socket().setSendBufferSize(<span class="number">1024</span> * <span class="number">64</span>);</span><br><span class="line">    <span class="comment">// 创建读写服务</span></span><br><span class="line">    <span class="built_in">this</span>.writeSocketService = <span class="keyword">new</span> <span class="title class_">WriteSocketService</span>(<span class="built_in">this</span>.socketChannel);</span><br><span class="line">    <span class="built_in">this</span>.readSocketService = <span class="keyword">new</span> <span class="title class_">ReadSocketService</span>(<span class="built_in">this</span>.socketChannel);</span><br><span class="line">    <span class="comment">// 自增</span></span><br><span class="line">    <span class="built_in">this</span>.haService.getConnectionCount().incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.readSocketService.start();</span><br><span class="line">    <span class="built_in">this</span>.writeSocketService.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="ReadSocket"><a href="#ReadSocket" class="headerlink" title="ReadSocket"></a>ReadSocket</h6><p>ReadSocketService 类是一个任务对象，slave 向 master 传输的帧格式为 <code>[long][long][long]</code>，上报的是 slave 本地的同步进度，同步进度是一个 long 值</p>
<p>成员变量：</p>
<ul>
<li><p>读缓冲：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">READ_MAX_BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;	<span class="comment">// 默认大小 1MB</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ByteBuffer</span> <span class="variable">byteBufferRead</span> <span class="operator">=</span> ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>NIO 属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Selector selector;			<span class="comment">// 多路复用器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SocketChannel socketChannel;	<span class="comment">// master 与 slave 之间的会话 SocketChannel</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>处理位点：缓冲区处理位点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">processPosition</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上次读操作的时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">lastReadTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>核心方法：</p>
<ul>
<li><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReadSocketService</span><span class="params">(<span class="keyword">final</span> SocketChannel socketChannel)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.socketChannel.register(this.selector, SelectionKey.OP_READ)</code>：通道注册到多路复用器，关注读事件</li>
<li><code>this.setDaemon(true)</code>：设置为守护线程</li>
</ul>
</li>
<li><p>运行方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>this.selector.select(1000)</code>：多路复用器阻塞获取就绪的通道，最多等待 1 秒钟，获取到就绪事件或者超时后结束</p>
</li>
<li><p><code>boolean ok = this.processReadEvent()</code>：<strong>读数据的核心方法</strong>，返回 true 表示处理成功   false 表示 Socket 处于半关闭状态，需要上层重建 HAConnection 对象</p>
<ul>
<li><p><code>int readSizeZeroTimes = 0</code>：控制 while 循环，当连续从 Socket 读取失败 3 次（未加载到数据）跳出循环</p>
</li>
<li><p><code>if (!this.byteBufferRead.hasRemaining())</code>：byteBufferRead 已经全部使用完，需要清理数据并更新位点</p>
</li>
<li><p><code>while (this.byteBufferRead.hasRemaining())</code>：byteBufferRead 有空间可以去 Socket 读缓冲区加载数据</p>
</li>
<li><p><code>int readSize = this.socketChannel.read(this.byteBufferRead)</code>：<strong>从通道读数据</strong></p>
</li>
<li><p><code>if (readSize &gt; 0)</code>：加载成功，有新数据</p>
<p><code>if ((byteBufferRead.position() - processPosition) &gt;= 8)</code>：缓冲区的可读数据最少包含一个数据帧</p>
<ul>
<li><code>int pos = ...</code>：<strong>获取可读帧数据中最后一个完整的帧数据的位点，后面的数据丢弃</strong></li>
</ul>
</li>
<li><p><code>long readOffset = ...byteBufferRead.getLong(pos - 8)</code>：读取最后一帧数据，slave 端当前的同步进度信息</p>
<ul>
<li><code>this.processPosition = pos</code>：更新处理位点</li>
<li><code>HAConnection.this.slaveAckOffset = readOffset</code>：更新应答位点</li>
<li><code>if (HAConnection.this.slaveRequestOffset &lt; 0)</code>：条件成立<strong>给 slaveRequestOffset 赋值</strong></li>
<li><code>HAConnection...notifyTransferSome(slaveAckOffset)</code>：<strong>唤醒阻塞的生产者线程</strong></li>
</ul>
</li>
<li><p><code>else if (readSize == 0) </code>：读取 3 次无新数据跳出循环</p>
</li>
<li><p><code>else</code>：readSize &#x3D; -1 就表示 Socket 处于半关闭状态，对端已经关闭了</p>
</li>
</ul>
</li>
<li><p><code>if (interval &gt; 20)</code>：超过 20 秒未发生通信，直接结束循环</p>
</li>
</ul>
</li>
</ul>
<hr>
<h6 id="WriteSocket"><a href="#WriteSocket" class="headerlink" title="WriteSocket"></a>WriteSocket</h6><p>WriteSocketService 类是一个任务对象，master 向 slave 传输的数据帧格式为 <code>&#123;[phyOffset][size][data...]&#125;&#123;[phyOffset][size][data...]&#125;</code></p>
<ul>
<li>phyOffset：数据区间的开始偏移量，并不表示某一条具体的消息，表示的数据块开始的偏移量位置</li>
<li>size：同步的数据块的大小</li>
<li>data：数据块，最大 32kb，可能包含多条消息的数据</li>
</ul>
<p>成员变量：</p>
<ul>
<li><p>协议头：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">headerSize</span> <span class="operator">=</span> <span class="number">8</span> + <span class="number">4</span>;		<span class="comment">// 协议头大小：12</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer byteBufferHeader;	<span class="comment">// 帧头缓冲区</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>NIO 属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Selector selector;			<span class="comment">// 多路复用器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SocketChannel socketChannel;	<span class="comment">// master 与 slave 之间的会话 SocketChannel</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>处理位点：下一次传输同步数据的位置信息，master 给当前 slave 同步的位点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">nextTransferFromWhere</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上次写操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">lastWriteOver</span> <span class="operator">=</span> <span class="literal">true</span>;							<span class="comment">// 上一轮数据是否传输完毕</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastWriteTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();	<span class="comment">// 上次写操作的时间</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>核心方法：</p>
<ul>
<li><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">WriteSocketService</span><span class="params">(<span class="keyword">final</span> SocketChannel socketChannel)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.socketChannel.register(this.selector, SelectionKey.OP_WRITE)</code>：通道注册到多路复用器，关注写事件</li>
<li><code>this.setDaemon(true)</code>：设置为守护线程</li>
</ul>
</li>
<li><p>运行方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>this.selector.select(1000)</code>：多路复用器阻塞获取就绪的通道，最多等待 1 秒钟，获取到就绪事件或者超时后结束</p>
</li>
<li><p><code>if (-1 == HAConnection.this.slaveRequestOffset)</code>：<strong>等待 slave 同步完数据</strong></p>
</li>
<li><p><code>if (-1 == this.nextTransferFromWhere)</code>：条件成立，需要初始化该变量</p>
<p><code>if (0 == HAConnection.this.slaveRequestOffset)</code>：slave 是一个全新节点，从正在顺序写的 MF 开始同步数据</p>
<p><code>long masterOffset = ...</code>：获取 master 最大的 offset，并计算归属的 mappedFile 文件的开始 offset</p>
<p><code>this.nextTransferFromWhere = masterOffset</code>：<strong>赋值给下一次传输同步数据的位置信息</strong></p>
<p><code>this.nextTransferFromWhere = HAConnection.this.slaveRequestOffset</code>：大部分情况走这个赋值逻辑</p>
</li>
<li><p><code>if (this.lastWriteOver)</code>：上一次待发送数据全部发送完成</p>
<p><code>if (interval &gt; 5)</code>：<strong>超过 5 秒未同步数据，发送一个 header 心跳数据包，维持长连接</strong></p>
</li>
<li><p><code>else</code>：上一轮的待发送数据未全部发送，需要同步数据到 slave 节点</p>
</li>
<li><p><code>SelectMappedBufferResult selectResult</code>：<strong>到 CommitLog 中查询 nextTransferFromWhere 开始位置的数据</strong></p>
</li>
<li><p><code>if (size &gt; 32k)</code>：一次最多同步 32k 数据</p>
</li>
<li><p><code>this.nextTransferFromWhere += size</code>：增加 size，下一轮传输跳过本帧数据</p>
</li>
<li><p><code>selectResult.getByteBuffer().limit(size)</code>：设置 byteBuffer 可访问数据区间为 [pos, size]</p>
</li>
<li><p><code>this.selectMappedBufferResult = selectResult</code>：<strong>待发送的数据</strong></p>
</li>
<li><p><code>this.byteBufferHeader.put</code>：<strong>构建帧头数据</strong></p>
</li>
<li><p><code>this.lastWriteOver = this.transferData()</code>：处理数据，返回是否处理完成</p>
</li>
</ul>
</li>
<li><p>同步方法：<strong>同步数据到 slave 节点</strong>，返回 true 表示本轮数据全部同步完成，false 表示本轮同步未完成（Header 和 Body 其中一个未同步完成都会返回 false）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">transferData</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>int writeSizeZeroTimes= 0</code>：控制 while 循环，当写失败连续 3 次时，跳出循环）跳出循环</p>
</li>
<li><p><code>while (this.byteBufferHeader.hasRemaining())</code>：<strong>帧头数据缓冲区有待发送的数据</strong></p>
</li>
<li><p><code>int writeSize = this.socketChannel.write(this.byteBufferHeader)</code>：向通道写帧头数据</p>
</li>
<li><p><code>if (null == this.selectMappedBufferResult)</code>：说明是心跳数据，返回心跳数据是否发送完成</p>
</li>
<li><p><code>if (!this.byteBufferHeader.hasRemaining())</code>：<strong>Header写成功之后，才进行写 Body</strong></p>
</li>
<li><p><code>while (this.selectMappedBufferResult.getByteBuffer().hasRemaining())</code>：<strong>数据缓冲区有待发送的数据</strong></p>
</li>
<li><p><code>int writeSize = this.socketChannel.write(this.selectMappedBufferResult...)</code>：向通道写帧头数据</p>
</li>
<li><p><code>if (writeSize &gt; 0)</code>：写数据成功，但是不代表 SMBR 中的数据全部写完成</p>
</li>
<li><p><code>boolean result</code>：判断是否发送完成，返回该值</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="MesStore"><a href="#MesStore" class="headerlink" title="MesStore"></a>MesStore</h4><h5 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h5><p>DefaultMessageStore 类核心是整个存储服务的调度类</p>
<ul>
<li><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultMessageStore</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.allocateMappedFileService.start()</code>：启动<strong>创建 MappedFile 文件服务</strong></li>
<li><code>this.indexService.start()</code>：启动索引服务</li>
</ul>
</li>
<li><p>load()：先加载 CommitLog，再加载 ConsumeQueue，最后加载 IndexFile，加载完进入恢复阶段，先恢复 CQ，在恢复 CL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">load</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>start()：核心启动方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>lock = lockFile.getChannel().tryLock(0, 1, false)</code>：获取文件锁，获取失败说明当前目录已经启动过 Broker</p>
</li>
<li><p><code>long maxPhysicalPosInLogicQueue = commitLog.getMinOffset()</code>：遍历全部的 CQ 对象，获取 CQ 中消息的最大偏移量</p>
</li>
<li><p><code>this.reputMessageService.start()</code>：设置分发服务的分发位点，启动<strong>分发服务</strong>，构建 ConsumerQueue 和 IndexFile</p>
</li>
<li><p><code>if (dispatchBehindBytes() &lt;= 0)</code>：线程等待分发服务将分发数据全部处理完毕</p>
</li>
<li><p><code>this.recoverTopicQueueTable()</code>：因为修改了 CQ 数据，所以再次构建队列偏移量字段表</p>
</li>
<li><p><code>this.haService.start()</code>：启动 <strong>HA 服务</strong></p>
</li>
<li><p><code>this.handleScheduleMessageService()</code>：启动<strong>消息调度服务</strong></p>
</li>
<li><p><code>this.flushConsumeQueueService.start()</code>：启动 CQ <strong>消费队列刷盘服务</strong></p>
</li>
<li><p><code>this.commitLog.start()</code>：启动 <strong>CL 刷盘服务</strong></p>
</li>
<li><p><code>this.storeStatsService.start()</code>：启动状态存储服务</p>
</li>
<li><p><code>this.createTempFile()</code>：创建 AbortFile，正常关机时 JVM HOOK 会删除该文件，<strong>异常宕机时该文件不会删除</strong>，开机数据恢复阶段根据是否存在该文件，执行不同的恢复策略</p>
</li>
<li><p><code>this.addScheduleTask()</code>：添加定时任务</p>
<ul>
<li><p><code>DefaultMessageStore.this.cleanFilesPeriodically()</code>：<strong>定时清理过期文件</strong>，周期是 10 秒</p>
<ul>
<li><code>this.cleanCommitLogService.run()</code>：启动清理过期的 CL 文件服务</li>
<li><code>this.cleanConsumeQueueService.run()</code>：启动清理过期的 CQ 文件服务</li>
</ul>
</li>
<li><p><code>DefaultMessageStore.this.checkSelf()</code>：每 10 分种进行健康检查</p>
</li>
<li><p><code>DefaultMessageStore.this.cleanCommitLogService.isSpaceFull()</code>：<strong>磁盘预警定时任务</strong>，每 10 秒一次</p>
<ul>
<li><p><code>if (physicRatio &gt; this.diskSpaceWarningLevelRatio)</code>：检查磁盘是否到达 waring 阈值，默认 90%</p>
<p><code>boolean diskok = ...runningFlags.getAndMakeDiskFull()</code>：设置磁盘写满标记</p>
</li>
<li><p><code>boolean diskok = ...this.runningFlags.getAndMakeDiskOK()</code>：设置磁盘可写标记</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>this.shutdown = false</code>：刚启动，设置为 false</p>
</li>
</ul>
</li>
<li><p>shutdown()：关闭各种服务和线程资源，设置存储模块状态为关闭状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>destroy()：销毁 Broker 的工作目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="服务线程-1"><a href="#服务线程-1" class="headerlink" title="服务线程"></a>服务线程</h5><p>ServiceThread 类被很多服务继承，本身是一个 Runnable 任务对象，继承者通过重写 run 方法来实现服务的逻辑</p>
<ul>
<li><p>run()：一般实现方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过参数 stopped 控制服务的停止，使用 volatile 修饰保证可见性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stopped</span> <span class="operator">=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>shutdown()：停止线程，首先设置 stopped 为 true，然后进行唤醒，默认不直接打断线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>waitForRunning()：挂起线程，设置唤醒标记 hasNotified 为 false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">waitForRunning</span><span class="params">(<span class="type">long</span> interval)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>wakeup()：唤醒线程，设置 hasNotified 为 true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="构建服务"><a href="#构建服务" class="headerlink" title="构建服务"></a>构建服务</h5><p>AllocateMappedFileService <strong>创建 MappedFile 服务</strong></p>
<ul>
<li><p>mmapOperation()：核心服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">mmapOperation</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>req = this.requestQueue.take()</code>： <strong>从 requestQueue 阻塞队列（优先级）中获取 AllocateRequest 任务</strong></li>
<li><code>if (...isTransientStorePoolEnable())</code>：条件成立使用直接内存写入数据， 从直接内存中 commit 到 FileChannel 中</li>
<li><code>mappedFile = new MappedFile(req.getFilePath(), req.getFileSize())</code>：根据请求的路径和大小创建对象</li>
<li><code>mappedFile.warmMappedFile()</code>：判断 mappedFile 大小，只有 CommitLog 才进行文件预热</li>
<li><code>req.setMappedFile(mappedFile)</code>：将创建好的 MF 对象的赋值给请求对象的成员属性</li>
<li><code>req.getCountDownLatch().countDown()</code>：<strong>唤醒请求的阻塞线程</strong></li>
</ul>
</li>
<li><p>putRequestAndReturnMappedFile()：MappedFileQueue 中用来创建 MF 对象的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> MappedFile <span class="title function_">putRequestAndReturnMappedFile</span><span class="params">(String nextFilePath, String nextNextFilePath, <span class="type">int</span> fileSize)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>AllocateRequest nextReq = new AllocateRequest(...)</code>：创建 nextFilePath 的 AllocateRequest 对象，放入请求列表和阻塞队列，然后创建 nextNextFilePath 的 AllocateRequest 对象，放入请求列表和阻塞队列</li>
<li><code>AllocateRequest result = this.requestTable.get(nextFilePath)</code>：从请求列表获取 nextFilePath 的请求对象</li>
<li><code>result.getCountDownLatch().await(...)</code>：<strong>线程挂起</strong>，直到超时或者 nextFilePath 对应的 MF 文件创建完成</li>
<li><code>return result.getMappedFile()</code>：返回创建好的 MF 文件对象</li>
</ul>
</li>
</ul>
<p>ReputMessageService 消息分发服务，用于构<strong>建 ConsumerQueue 和 IndexFile 文件</strong></p>
<ul>
<li><p>run()：<strong>循环执行 doReput 方法</strong>，所以发送的消息存储进 CL 就可以产生对应的 CQ，每执行一次线程休眠 1 毫秒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>doReput()：实现分发的核心逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReput</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>for (boolean doNext = true; this.isCommitLogAvailable() &amp;&amp; doNext; )</code>：循环遍历</li>
<li><code>SelectMappedBufferResult result</code>： 从 CommitLog 拉取数据，数据范围 <code>[reputFromOffset, 包含该偏移量的 MF 的最大 Pos]</code>，封装成结果对象</li>
<li><code>DispatchRequest dispatchRequest</code>：从结果对象读取出一条 DispatchRequest 数据</li>
<li><code>DefaultMessageStore.this.doDispatch(dispatchRequest)</code>：将数据交给分发器进行分发，用于<strong>构建 CQ 和索引文件</strong></li>
<li><code>this.reputFromOffset += size</code>：更新数据范围</li>
</ul>
</li>
</ul>
<hr>
<h5 id="刷盘服务"><a href="#刷盘服务" class="headerlink" title="刷盘服务"></a>刷盘服务</h5><p>FlushConsumeQueueService 刷盘 CQ 数据</p>
<ul>
<li><p>run()：每隔 1 秒执行一次刷盘服务，跳出循环后还会执行一次强制刷盘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>doFlush()：刷盘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFlush</span><span class="params">(<span class="type">int</span> retryTimes)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>int flushConsumeQueueLeastPages</code>：脏页阈值，默认是 2</p>
</li>
<li><p><code>if (retryTimes == RETRY_TIMES_OVER)</code>：<strong>重试次数是 3</strong> 时设置强制刷盘，设置脏页阈值为 0</p>
</li>
<li><p><code>int flushConsumeQueueThoroughInterval</code>：两次刷新的<strong>时间间隔超过 60 秒</strong>会强制刷盘</p>
</li>
<li><p><code>for (ConsumeQueue cq : maps.values())</code>：遍历所有的 CQ，进行刷盘</p>
</li>
<li><p><code>DefaultMessageStore.this.getStoreCheckpoint().flush()</code>：强制刷盘时将 StoreCheckpoint 瞬时数据刷盘</p>
</li>
</ul>
</li>
</ul>
<p>FlushCommitLogService 刷盘 CL 数据，默认是异步刷盘</p>
<ul>
<li><p>run()：运行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>while (!this.isStopped())</code>：stopped为 true 才跳出循环</p>
</li>
<li><p><code>boolean flushCommitLogTimed</code>：控制线程的休眠方式，默认是 false，使用 <code>CountDownLatch.await()</code> 休眠，设置为 true 时使用 <code>Thread.sleep()</code> 休眠</p>
</li>
<li><p><code>int interval</code>：获取配置中的刷盘时间间隔</p>
</li>
<li><p><code>int flushPhysicQueueLeastPages</code>：获取最小刷盘页数，默认是 4 页，脏页达到指定页数才刷盘</p>
</li>
<li><p><code>int flushPhysicQueueThoroughInterval</code>：获取强制刷盘周期，默认是 10 秒，达到周期后强制刷盘，不考虑脏页</p>
</li>
<li><p><code>if (flushCommitLogTimed)</code>：休眠逻辑，避免 CPU 占用太长时间，导致无法执行其他更紧急的任务</p>
</li>
<li><p><code>CommitLog.this.mappedFileQueue.flush(flushPhysicQueueLeastPages)</code>：<strong>刷盘</strong></p>
</li>
<li><p><code>for (int i = 0; i &lt; RETRY_TIMES_OVER &amp;&amp; !result; i++)</code>：stopped 停止标记为 true 时，需要确保所有的数据都已经刷盘，所以此处尝试 10 次强制刷盘，</p>
<p><code>result = CommitLog.this.mappedFileQueue.flush(0)</code>：<strong>强制刷盘</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="清理服务"><a href="#清理服务" class="headerlink" title="清理服务"></a>清理服务</h5><p>CleanCommitLogService 清理过期的 CL 数据，定时任务 10 秒调用一次，<strong>先清理 CL，再清理 CQ</strong>，因为 CQ 依赖于 CL 的数据</p>
<ul>
<li><p>run()：运行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>deleteExpiredFiles()：删除过期 CL 文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteExpiredFiles</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>long fileReservedTime</code>：默认 72，代表文件的保留时间</li>
<li><code>boolean timeup = this.isTimeToDelete()</code>：当前时间是否是凌晨 4 点</li>
<li><code>boolean spacefull = this.isSpaceToDelete()</code>：CL 或者 CQ 的目录磁盘使用率达到阈值标准 85%</li>
<li><code>boolean manualDelete = this.manualDeleteFileSeveralTimes &gt; 0</code>：手动删除文件</li>
<li><code>fileReservedTime *= 60 * 60 * 1000</code>：默认保留 72 小时</li>
<li><code>deleteCount = DefaultMessageStore.this.commitLog.deleteExpiredFile()</code>：<strong>调用 MFQ 对象的删除方法</strong></li>
</ul>
</li>
</ul>
<p>CleanConsumeQueueService 清理过期的 CQ 数据</p>
<ul>
<li><p>run()：运行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>deleteExpiredFiles()：删除过期 CQ 文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteExpiredFiles</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>int deleteLogicsFilesInterval</code>：清理 CQ 的时间间隔，默认 100 毫秒</li>
<li><code>long minOffset = DefaultMessageStore.this.commitLog.getMinOffset()</code>：获取 CL 文件中最小的物理偏移量</li>
<li><code>if (minOffset &gt; this.lastPhysicalMinOffset)</code>：CL 最小的偏移量大于 CQ 最小的，说明有过期数据</li>
<li><code>this.lastPhysicalMinOffset = minOffset</code>：更新 CQ 的最小偏移量</li>
<li><code>for (ConsumeQueue logic : maps.values())</code>：遍历所有的 CQ 文件</li>
<li><code>logic.deleteExpiredFile(minOffset)</code>：<strong>调用 MFQ 对象的删除方法</strong></li>
<li><code>DefaultMessageStore.this.indexService.deleteExpiredFile(minOffset)</code>：<strong>删除过期的索引文件</strong></li>
</ul>
</li>
</ul>
<hr>
<h5 id="获取消息"><a href="#获取消息" class="headerlink" title="获取消息"></a>获取消息</h5><p>DefaultMessageStore#getMessage 用于获取消息，在 PullMessageProcessor#processRequest 方法中被调用 （提示：建议学习消费者源码时再阅读）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// offset: 客户端拉消息使用位点；   maxMsgNums: 32；  messageFilter: 一般这里是 tagCode 过滤 </span></span><br><span class="line"><span class="keyword">public</span> GetMessageResult <span class="title function_">getMessage</span><span class="params">(<span class="keyword">final</span> String group, <span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="type">int</span> queueId, <span class="keyword">final</span> <span class="type">long</span> offset, <span class="keyword">final</span> <span class="type">int</span> maxMsgNums, <span class="keyword">final</span> MessageFilter messageFilter)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>if (this.shutdown)</code>：检查运行状态</p>
</li>
<li><p><code>GetMessageResult getResult</code>：创建查询结果对象</p>
</li>
<li><p><code>final long maxOffsetPy = this.commitLog.getMaxOffset()</code>：<strong>获取 CommitLog 最大物理偏移量</strong></p>
</li>
<li><p><code>ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId)</code>：根据主题和队列 ID 获取 ConsumeQueue对象</p>
</li>
<li><p><code>minOffset, maxOffset</code>：获取当前 ConsumeQueue 的最小 offset 和 最大 offset，<strong>判断是否满足本次 Pull 的 offset</strong></p>
<p><code>if (maxOffset == 0)</code>：说明队列内无数据，设置状态为 NO_MESSAGE_IN_QUEUE，外层进行长轮询</p>
<p><code>else if (offset &lt; minOffset)</code>：说明 offset 太小了，设置状态为 OFFSET_TOO_SMALL</p>
<p><code>else if (offset == maxOffset)</code>：消费进度持平，设置状态为 OFFSET_OVERFLOW_ONE，外层进行长轮询</p>
<p><code>else if (offset &gt; maxOffset)</code>：说明 offset 越界了，设置状态为 OFFSET_OVERFLOW_BADLY</p>
</li>
<li><p><code>SelectMappedBufferResult bufferConsumeQueue</code>：查询 CQData <strong>获取包含该 offset 的 MappedFile 文件</strong>，如果该文件不是顺序写的文件，就读取 <code>[offset%maxSize, 文件尾]</code> 范围的数据，反之读取 <code>[offset%maxSize, 文件名+wrotePosition尾]</code> </p>
<p>先查 CQ 的原因：因为 CQ 时 CL 的索引，通过 CQ 查询 CL 更加快捷</p>
</li>
<li><p><code>if (bufferConsumeQueue != null)</code>：只有再 CQ 删除过期数据的逻辑执行时，条件才不成立，一般都是成立的</p>
</li>
<li><p><code>long nextPhyFileStartOffset = Long.MIN_VALUE</code>：下一个 commitLog 物理文件名，初始值为最小值</p>
</li>
<li><p><code>long maxPhyOffsetPulling = 0</code>：本次拉消息最后一条消息的物理偏移量</p>
</li>
<li><p><code>for ()</code>：<strong>处理数据</strong>，每次处理 20 字节处理字节数大于 16000 时跳出循环</p>
</li>
<li><p><code>offsetPy, sizePy, tagsCode</code>：读取 20 个字节后，获取消息物理偏移量、消息大小、消息 tagCode</p>
</li>
<li><p><code>boolean isInDisk = checkInDiskByCommitOffset(...)</code>：<strong>检查消息是热数据还是冷数据</strong>，false 为热数据</p>
<ul>
<li><code>long memory</code>：Broker 系统 40% 内存的字节数，写数据时内存不够会使用 LRU 算法淘汰数据，将淘汰数据持久化到磁盘</li>
<li><code>return (maxOffsetPy - offsetPy) &gt; memory</code>：返回 true 说明数据已经持久化到磁盘，为冷数据</li>
</ul>
</li>
<li><p><code>if (this.isTheBatchFull())</code>：<strong>控制是否跳出循环</strong></p>
<ul>
<li><p><code>if (0 == bufferTotal || 0 == messageTotal)</code>：本次 pull 消息未拉取到任何东西，需要外层 for 循环继续，返回 false</p>
</li>
<li><p><code>if (maxMsgNums &lt;= messageTotal)</code>：结果对象内消息数已经超过了最大消息数量，可以结束循环了</p>
</li>
<li><p><code>if (isInDisk)</code>：冷数据</p>
<p><code>if ((bufferTotal + sizePy) &gt; ...)</code>：冷数据一次 pull 请求最大允许获取 64kb 的消息</p>
<p><code>if (messageTotal &gt; ...)</code>：冷数据一次 pull 请求最大允许获取8 条消息</p>
</li>
<li><p><code>else</code>：热数据</p>
<p><code>if ((bufferTotal + sizePy) &gt; ...)</code>：热数据一次 pull 请求最大允许获取 256kb 的消息</p>
<p><code>if (messageTotal &gt; ...)</code>：冷数据一次 pull 请求最大允许获取32 条消息</p>
</li>
</ul>
</li>
<li><p><code>if (messageFilter != null)</code>：按照消息 tagCode 进行过滤</p>
</li>
<li><p><code>selectResult = this.commitLog.getMessage(offsetPy, sizePy)</code>：根据 CQ 消息物理偏移量和消息大小<strong>到 commitLog 中查询这条 msg</strong></p>
</li>
<li><p><code>if (null == selectResult)</code>：条件成立说明 commitLog 执行了删除过期文件的定时任务，因为是先清理的 CL，所以 CQ 还有该索引数据</p>
</li>
<li><p><code>nextPhyFileStartOffset = this.commitLog.rollNextFile(offsetPy)</code>：获取包含该 offsetPy 的下一个数据文件的文件名</p>
</li>
<li><p><code>getResult.addMessage(selectResult)</code>：<strong>将本次循环查询出来的 msg 加入到 getResult 内</strong></p>
</li>
<li><p><code>status = GetMessageStatus.FOUND</code>：查询状态设置为 FOUND</p>
</li>
<li><p><code>nextPhyFileStartOffset = Long.MIN_VALUE</code>：设置为最小值，跳过期 CQData 数据的逻辑</p>
</li>
<li><p><code>nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE)</code>：计算客户端下一次 pull 时使用的位点信息</p>
</li>
<li><p><code>getResult.setSuggestPullingFromSlave(diff &gt; memory)</code>：<strong>选择主从节点的建议</strong></p>
<ul>
<li><code>diff &gt; memory =&gt; true</code>：表示本轮查询最后一条消息为冷数据，Broker 建议客户端下一次 pull 时到 slave 节点</li>
<li><code>diff &gt; memory =&gt; false</code>：表示本轮查询最后一条消息为热数据，Broker 建议客户端下一次 pull 时到 master 节点</li>
</ul>
</li>
<li><p><code>getResult.setStatus(status)</code>：设置结果状态</p>
</li>
<li><p><code>getResult.setNextBeginOffset(nextBeginOffset)</code>：设置客户端下一次 pull 时的 offset</p>
</li>
<li><p><code>getResult.setMaxOffset(maxOffset)</code>：设置 queue 的最大 offset 和最小 offset</p>
</li>
<li><p><code>return getResult</code>：返回结果对象</p>
</li>
</ul>
<hr>
<h4 id="Broker-1"><a href="#Broker-1" class="headerlink" title="Broker"></a>Broker</h4><p>BrokerStartup 启动方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    start(createBrokerController(args));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BrokerController <span class="title function_">start</span><span class="params">(BrokerController controller)</span> &#123;</span><br><span class="line">    controller.start();	<span class="comment">// 启动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BrokerStartup#createBrokerController：构造控制器，并初始化</p>
<ul>
<li><code>final BrokerController controller()</code>：创建实例对象</li>
<li><code>boolean initResult = controller.initialize()</code>：控制器初始化<ul>
<li><code>this.registerProcessor()</code>：<strong>注册了处理器，包括发送消息、拉取消息、查询消息等核心处理器</strong></li>
<li><code>initialTransaction()</code>：初始化了事务服务，用于进行<strong>事务回查</strong></li>
</ul>
</li>
</ul>
<p>BrokerController#start：核心启动方法</p>
<ul>
<li><p><code>this.messageStore.start()</code>：<strong>启动存储服务</strong></p>
</li>
<li><p><code>this.remotingServer.start()</code>：启动 Netty 通信服务</p>
</li>
<li><p><code>this.fileWatchService.start()</code>：启动文件监听服务</p>
</li>
<li><p><code>startProcessorByHa(messageStoreConfig.getBrokerRole())</code>：<strong>启动事务回查</strong></p>
</li>
<li><p><code>this.scheduledExecutorService.scheduleAtFixedRate()</code>：每隔 30s 向 NameServer 上报 Topic 路由信息，<strong>心跳机制</strong></p>
<p><code>BrokerController.this.registerBrokerAll(true, false, brokerConfig.isForceRegister())</code></p>
</li>
</ul>
<hr>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><h4 id="生产者类"><a href="#生产者类" class="headerlink" title="生产者类"></a>生产者类</h4><h5 id="生产者类-1"><a href="#生产者类-1" class="headerlink" title="生产者类"></a>生产者类</h5><p>DefaultMQProducer 是生产者的默认实现类</p>
<p>成员变量：</p>
<ul>
<li><p>生产者实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">transient</span> DefaultMQProducerImpl defaultMQProducerImpl</span><br></pre></td></tr></table></figure>
</li>
<li><p>生产者组：发送事务消息，Broker 端进行事务回查（补偿机制）时，选择当前生产者组的下一个生产者进行事务回查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String producerGroup;</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认主题：isAutoCreateTopicEnable 开启时，当发送消息指定的 Topic 在 Namesrv 未找到路由信息，使用该值创建 Topic 信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">createTopicKey</span> <span class="operator">=</span> TopicValidator.AUTO_CREATE_TOPIC_KEY_TOPIC;</span><br><span class="line"><span class="comment">// 值为【TBW102】，Just for testing or demo program</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>消息重投：系统特性消息重试部分详解了三个参数的作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">retryTimesWhenSendFailed</span> <span class="operator">=</span> <span class="number">2</span>;		<span class="comment">// 同步发送失败后重试的发送次数，加上第一次发送，一共三次</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">retryTimesWhenSendAsyncFailed</span> <span class="operator">=</span> <span class="number">2</span>;	<span class="comment">// 异步</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">retryAnotherBrokerWhenNotStoreOK</span> <span class="operator">=</span> <span class="literal">false</span>;	<span class="comment">// 消息未存储成功，选择其他 Broker 重试</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>消息队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">defaultTopicQueueNums</span> <span class="operator">=</span> <span class="number">4</span>;		<span class="comment">// 默认 Broker 创建的队列数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>消息属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sendMsgTimeout</span> <span class="operator">=</span> <span class="number">3000</span>;					<span class="comment">// 发送消息的超时限制</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">compressMsgBodyOverHowmuch</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">4</span>;	<span class="comment">// 压缩阈值，当 msg body 超过 4k 后使用压缩</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxMessageSize</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;		<span class="comment">// 消息体的最大限制，默认 4M</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">TraceDispatcher</span> <span class="variable">traceDispatcher</span> <span class="operator">=</span> <span class="literal">null</span>;		<span class="comment">// 消息轨迹</span></span><br><span class="line"></span><br><span class="line">构造方法：</span><br><span class="line"></span><br><span class="line">* 构造方法：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String namespace, <span class="keyword">final</span> String producerGroup, RPCHook rpcHook)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.namespace = namespace;</span><br><span class="line">      <span class="built_in">this</span>.producerGroup = producerGroup;</span><br><span class="line">      <span class="comment">// 创建生产者实现对象</span></span><br><span class="line">      defaultMQProducerImpl = <span class="keyword">new</span> <span class="title class_">DefaultMQProducerImpl</span>(<span class="built_in">this</span>, rpcHook);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>成员方法：</p>
<ul>
<li><p>start()：启动方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">    <span class="comment">// 重置生产者组名，如果传递了命名空间，则 【namespace%group】</span></span><br><span class="line">    <span class="built_in">this</span>.setProducerGroup(withNamespace(<span class="built_in">this</span>.producerGroup));</span><br><span class="line">    <span class="comment">// 生产者实现对象启动</span></span><br><span class="line">    <span class="built_in">this</span>.defaultMQProducerImpl.start();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != traceDispatcher) &#123;</span><br><span class="line">      	<span class="comment">// 消息轨迹的逻辑</span></span><br><span class="line">   		traceDispatcher.start(<span class="built_in">this</span>.getNamesrvAddr(), <span class="built_in">this</span>.getAccessChannel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>send()：<strong>发送消息</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SendResult <span class="title function_">send</span><span class="params">(Message msg)</span>&#123;</span><br><span class="line">    <span class="comment">// 校验消息</span></span><br><span class="line">    Validators.checkMessage(msg, <span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 设置消息 Topic</span></span><br><span class="line">    msg.setTopic(withNamespace(msg.getTopic()));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.defaultMQProducerImpl.send(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>request()：请求方法，<strong>需要消费者回执消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Message <span class="title function_">request</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">    msg.setTopic(withNamespace(msg.getTopic()));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.defaultMQProducerImpl.request(msg, mq, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="实现者类"><a href="#实现者类" class="headerlink" title="实现者类"></a>实现者类</h5><p>DefaultMQProducerImpl 类是默认的生产者实现类</p>
<p>成员变量：</p>
<ul>
<li><p>实例对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultMQProducer defaultMQProducer;	<span class="comment">// 持有默认生产者对象，用来获取对象中的配置信息</span></span><br><span class="line"><span class="keyword">private</span> MQClientInstance mQClientFactory;			<span class="comment">// 客户端实例对象，生产者启动后需要注册到该客户端对象内</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主题发布信息映射表：key 是 Topic，value 是发布信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, TopicPublishInfo&gt; topicPublishInfoTable = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, TopicPublishInfo&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步发送消息：相关信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; asyncSenderThreadPoolQueue;<span class="comment">// 异步发送消息，异步线程池使用的队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService defaultAsyncSenderExecutor;	<span class="comment">// 异步发送消息默认使用的线程池</span></span><br><span class="line"><span class="keyword">private</span> ExecutorService asyncSenderExecutor;				<span class="comment">// 异步消息发送线程池，指定后就不使用默认线程池了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器：执行定时任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="string">&quot;RequestHouseKeepingService&quot;</span>, <span class="literal">true</span>);	<span class="comment">// 守护线程</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>状态信息：服务的状态，默认创建状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ServiceState</span> <span class="variable">serviceState</span> <span class="operator">=</span> ServiceState.CREATE_JUST;</span><br></pre></td></tr></table></figure>
</li>
<li><p>压缩等级：ZIP 压缩算法的等级，默认是 5，越高压缩效果好，但是压缩的更慢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">zipCompressLevel</span> <span class="operator">=</span> Integer.parseInt(System.getProperty..., <span class="string">&quot;5&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>容错策略：选择队列的容错策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">MQFaultStrategy</span> <span class="variable">mqFaultStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MQFaultStrategy</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>钩子：用来进行前置或者后置处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;SendMessageHook&gt; sendMessageHookList;			<span class="comment">// 发送消息的钩子，留给用户扩展使用</span></span><br><span class="line">ArrayList&lt;CheckForbiddenHook&gt; checkForbiddenHookList;	<span class="comment">// 对比上面的钩子，可以抛异常，控制消息是否可以发送</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RPCHook rpcHook;						 	<span class="comment">// 传递给 NettyRemotingClient</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>构造方法：</p>
<ul>
<li><p>默认构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultMQProducerImpl</span><span class="params">(<span class="keyword">final</span> DefaultMQProducer defaultMQProducer)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认 RPC HOOK 是空</span></span><br><span class="line">    <span class="built_in">this</span>(defaultMQProducer, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有参构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultMQProducerImpl</span><span class="params">(<span class="keyword">final</span> DefaultMQProducer defaultMQProducer, RPCHook rpcHook)</span> &#123;</span><br><span class="line">    <span class="comment">// 属性赋值</span></span><br><span class="line">    <span class="built_in">this</span>.defaultMQProducer = defaultMQProducer;</span><br><span class="line">    <span class="built_in">this</span>.rpcHook = rpcHook;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建【异步消息线程池任务队列】，长度是 5w</span></span><br><span class="line">    <span class="built_in">this</span>.asyncSenderThreadPoolQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">50000</span>);</span><br><span class="line">    <span class="comment">// 创建默认的异步消息任务线程池</span></span><br><span class="line">    <span class="built_in">this</span>.defaultAsyncSenderExecutor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">        <span class="comment">// 核心线程数和最大线程数都是 系统可用的计算资源（8核16线程的系统就是 16）...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5><ul>
<li><p>start()：启动方法，参数默认是 true，代表正常的启动路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> startFactory)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>this.serviceState = ServiceState.START_FAILED</code>：先修改为启动失败，成功后再修改，这种思想很常见</p>
</li>
<li><p><code>this.checkConfig()</code>：判断生产者组名不能是空，也不能是 default_PRODUCER</p>
</li>
<li><p><code>if (!getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP))</code>：条件成立说明当前生产者不是内部产生者，内部生产者是<strong>处理消息回退</strong>的这种情况使用的生产者</p>
<p><code>this.defaultMQProducer.changeInstanceNameToPID()</code>：修改生产者实例名称为当前进程的 PID</p>
</li>
<li><p><code> this.mQClientFactory = ...</code>：获取当前进程的 MQ 客户端实例对象，从 factoryTable 中获取 key 为 客户端 ID，格式是<code>ip@pid</code>，<strong>一个 JVM 进程只有一个 PID，也只有一个 MQClientInstance</strong></p>
</li>
<li><p><code>boolean registerOK = mQClientFactory.registerProducer(...)</code>：将生产者注册到 RocketMQ 客户端实例内</p>
</li>
<li><p><code>this.topicPublishInfoTable.put(...)</code>：添加一个主题发布信息，key 是 <strong>TBW102</strong> ，value 是一个空对象</p>
</li>
<li><p><code>mQClientFactory.start()</code>：启动 RocketMQ 客户端实例对象</p>
</li>
<li><p><code>this.mQClientFactory.sendHeartbeatToAllBrokerWithLock()</code>：RocketMQ <strong>客户端实例向已知的 Broker 节点发送一次心跳</strong>（也是定时任务）</p>
</li>
<li><p><code>this.timer.scheduleAtFixedRate()</code>： request 发送的消息需要消费着回执信息，启动定时任务每秒一次删除超时请求</p>
<ul>
<li>生产者 msg 添加信息关联 ID 发送到 Broker</li>
<li>消费者从 Broker 拿到消息后会检查 msg 类型是一个需要回执的消息，处理完消息后会根据 msg 关联 ID 和客户端 ID 生成一条响应结果消息发送到 Broker，Broker 判断为回执消息，会根据客户端ID 找到 channel 推送给生产者</li>
<li>生产者拿到回执消息后，读取出来关联 ID 找到对应的 RequestFuture，将阻塞线程唤醒</li>
</ul>
</li>
</ul>
</li>
<li><p>sendDefaultImpl()：发送消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数1：消息；参数2：发送模式（同步异步单向）；参数3：回调函数，异步发送时需要；参数4：发送超时时间, 默认 3 秒</span></span><br><span class="line"><span class="keyword">private</span> SendResult <span class="title function_">sendDefaultImpl</span><span class="params">(msg, communicationMode, sendCallback,timeout)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>this.makeSureStateOK()</code>：校验生产者状态是运行中，否则抛出异常</p>
</li>
<li><p><code>topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic())</code>：<strong>获取当前消息主题的发布信息</strong></p>
<ul>
<li><p><code>this.topicPublishInfoTable.get(topic)</code>：先尝试从本地主题发布信息映射表获取信息，获取不到继续执行</p>
</li>
<li><p><code>this.mQClientFactory.update...FromNameServer(topic)</code>：然后从 Namesrv 更新该 Topic 的路由数据</p>
</li>
<li><p><code>this.mQClientFactory.update...FromNameServer(...)</code>：<strong>路由数据是空，获取默认 TBW102 的数据</strong></p>
<p><code>return topicPublishInfo</code>：返回 TBW102 主题的发布信息</p>
</li>
</ul>
</li>
<li><p><code>String[] brokersSent = new String[timesTotal]</code>：下标索引代表第几次发送，值代表这次发送选择 Broker name</p>
</li>
<li><p><code>for (; times &lt; timesTotal; times++)</code>：循环发送，<strong>发送成功或者发送尝试次数达到上限，结束循环</strong></p>
</li>
<li><p><code>String lastBrokerName = null == mq ? null : mq.getBrokerName()</code>：获取上次发送失败的 BrokerName</p>
</li>
<li><p><code>mqSelected = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName)</code>：从发布信息中选择一个队列，生产者的<strong>负载均衡策略</strong>，参考系统特性章节</p>
</li>
<li><p><code>brokersSent[times] = mq.getBrokerName()</code>：将本次选择的 BrokerName 存入数组</p>
</li>
<li><p><code>msg.setTopic(this.defaultMQProducer.withNamespace(msg.getTopic()))</code>：<strong>产生重投，重投消息需要加上标记</strong></p>
</li>
<li><p><code>sendResult = this.sendKernelImpl</code>：核心发送方法</p>
</li>
<li><p><code>switch (communicationMode)</code>：异步或者单向消息直接返回 null，异步通过回调函数处理，同步发送进入逻辑判断</p>
<p><code>if (sendResult.getSendStatus() != SendStatus.SEND_OK)</code>：<strong>服务端 Broker 存储失败，需要重试其他 Broker</strong></p>
</li>
<li><p><code>throw new MQClientException()</code>：未找到当前主题的路由数据，无法发送消息，抛出异常</p>
</li>
</ul>
</li>
<li><p>sendKernelImpl()：<strong>核心发送方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数1：消息；参数2：选择的队列；参数3：发送模式（同步异步单向）；参数4：回调函数，异步发送时需要；参数5：主题发布信息；参数6：剩余超时时间限制</span></span><br><span class="line"><span class="keyword">private</span> SendResult <span class="title function_">sendKernelImpl</span><span class="params">(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>brokerAddr = this.mQClientFactory(...)</code>：<strong>获取指定 BrokerName 对应的 mater 节点的地址</strong>，master 节点的 ID 为 0，集群模式下，<strong>发送消息要发到主节点</strong></p>
</li>
<li><p><code>brokerAddr = MixAll.brokerVIPChannel()</code>：Broker 启动时会绑定两个服务器端口，一个是普通端口，一个是 VIP 端口，服务器端根据不同端口创建不同的的 NioSocketChannel</p>
</li>
<li><p><code>byte[] prevBody = msg.getBody()</code>：获取消息体</p>
</li>
<li><p><code>if (!(msg instanceof MessageBatch))</code>：非批量消息，需要重新设置消息 ID</p>
<p><code>MessageClientIDSetter.setUniqID(msg)</code>：<strong>msg id 由两部分组成</strong>，一部分是 ip 地址、进程号、Classloader 的 hashcode，另一部分是时间差（当前时间减去当月一号的时间）和计数器的值</p>
</li>
<li><p><code>if (this.tryToCompressMessage(msg))</code>：判断消息是否压缩，压缩需要设置压缩标记</p>
</li>
<li><p><code>hasCheckForbiddenHook、hasSendMessageHook</code>：执行钩子方法</p>
</li>
<li><p><code>requestHeader = new SendMessageRequestHeader()</code>：设置发送消息的消息头</p>
</li>
<li><p><code>if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX))</code>：重投的发送消息</p>
</li>
<li><p><code>switch (communicationMode)</code>：异步发送一种处理方式，单向和同步同样的处理逻辑</p>
<p><code>sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage()</code>：<strong>发送消息</strong></p>
<ul>
<li><code>request = RemotingCommand.createRequestCommand()</code>：创建一个 RequestCommand 对象</li>
<li><code>request.setBody(msg.getBody())</code>：<strong>将消息放入请求体</strong></li>
<li><code>switch (communicationMode)</code>：<strong>根据不同的模式 invoke 不同的方法</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>request()：请求方法，消费者回执消息，这种消息是异步消息</p>
<ul>
<li><p><code>requestResponseFuture = new RequestResponseFuture(correlationId, timeout, null)</code>：创建请求响应对象</p>
</li>
<li><p><code>getRequestFutureTable().put(correlationId, requestResponseFuture)</code>：放入RequestFutureTable 映射表中</p>
</li>
<li><p><code>this.sendDefaultImpl(msg, CommunicationMode.ASYNC, new SendCallback())</code>：<strong>发送异步消息，有回调函数</strong></p>
</li>
<li><p><code>return waitResponse(msg, timeout, requestResponseFuture, cost)</code>：用来挂起请求的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> Message <span class="title function_">waitResponseMessage</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="comment">// 请求挂起</span></span><br><span class="line">      <span class="built_in">this</span>.countDownLatch.await(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.responseMsg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">* 当消息被消费后，客户端处理响应时通过消息的关联 ID，从映射表中获取消息的 RequestResponseFuture，执行下面的方法唤醒挂起线程</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putResponseMessage</span><span class="params">(<span class="keyword">final</span> Message responseMsg)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.responseMsg = responseMsg;</span><br><span class="line">      <span class="built_in">this</span>.countDownLatch.countDown();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="路由信息-1"><a href="#路由信息-1" class="headerlink" title="路由信息"></a>路由信息</h4><p>TopicPublishInfo 类用来存储路由信息</p>
<p>成员变量：</p>
<ul>
<li><p>顺序消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">orderTopic</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;MessageQueue&gt; messageQueueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();			<span class="comment">// 主题全部的消息队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">ThreadLocalIndex</span> <span class="variable">sendWhichQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalIndex</span>();	<span class="comment">// 消息队列索引</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 【消息队列类】</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageQueue</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;MessageQueue&gt;, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> String topic;</span><br><span class="line">    <span class="keyword">private</span> String brokerName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> queueId;<span class="comment">// 队列 ID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>路由数据：主题对应的路由数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TopicRouteData topicRouteData;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicRouteData</span> <span class="keyword">extends</span> <span class="title class_">RemotingSerializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderTopicConf;</span><br><span class="line">    <span class="keyword">private</span> List&lt;QueueData&gt; queueDatas;		<span class="comment">// 队列数据</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;BrokerData&gt; brokerDatas;	<span class="comment">// Broker 数据</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueData</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;QueueData&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String brokerName;	<span class="comment">// 节点名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> readQueueNums;	<span class="comment">// 读队列数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> writeQueueNums;	<span class="comment">// 写队列数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> perm;			<span class="comment">// 权限</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> topicSynFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BrokerData</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;BrokerData&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String cluster;		<span class="comment">// 集群名</span></span><br><span class="line">    <span class="keyword">private</span> String brokerName;	<span class="comment">// Broker节点名称</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Long<span class="comment">/* brokerId */</span>, String<span class="comment">/* broker address */</span>&gt; brokerAddrs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>核心方法：</p>
<ul>
<li><p>selectOneMessageQueue()：<strong>选择消息队列</strong>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是上次失败时的 brokerName，可以为 null</span></span><br><span class="line"><span class="keyword">public</span> MessageQueue <span class="title function_">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> String lastBrokerName)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lastBrokerName == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历消息队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.messageQueueList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 【获取队列的索引，+1】</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="built_in">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line">            <span class="comment">// 获取队列的下标位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> Math.abs(index) % <span class="built_in">this</span>.messageQueueList.size();</span><br><span class="line">            <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 获取消息队列</span></span><br><span class="line">            <span class="type">MessageQueue</span> <span class="variable">mq</span> <span class="operator">=</span> <span class="built_in">this</span>.messageQueueList.get(pos);</span><br><span class="line">            <span class="comment">// 与上次选择的不同就可以返回</span></span><br><span class="line">            <span class="keyword">if</span> (!mq.getBrokerName().equals(lastBrokerName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="公共配置"><a href="#公共配置" class="headerlink" title="公共配置"></a>公共配置</h4><p>公共的配置信息类</p>
<ul>
<li><p>ClientConfig 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientConfig</span> &#123;</span><br><span class="line">    <span class="comment">// Namesrv 地址配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">namesrvAddr</span> <span class="operator">=</span> NameServerAddressUtils.getNameServerAddresses();</span><br><span class="line">    <span class="comment">// 客户端的 IP 地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">clientIP</span> <span class="operator">=</span> RemotingUtil.getLocalAddress();</span><br><span class="line">    <span class="comment">// 客户端实例名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">instanceName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;rocketmq.client.name&quot;</span>, <span class="string">&quot;DEFAULT&quot;</span>);</span><br><span class="line">    <span class="comment">// 客户端回调线程池的数量，平台核心数，8核16线程的电脑返回16</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">clientCallbackExecutorThreads</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="comment">// 命名空间</span></span><br><span class="line">    <span class="keyword">protected</span> String namespace;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">AccessChannel</span> <span class="variable">accessChannel</span> <span class="operator">=</span> AccessChannel.LOCAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取路由信息的间隔时间 30s</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pollNameServerInterval</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 客户端与 broker 之间的心跳周期 30s</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">heartbeatBrokerInterval</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 消费者持久化消费的周期 5s</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">persistConsumerOffsetInterval</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">pullTimeDelayMillsWhenException</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">unitMode</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> String unitName;</span><br><span class="line">    <span class="comment">// vip 通道，broker 启动时绑定两个端口，其中一个是 vip 通道</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">vipChannelEnabled</span> <span class="operator">=</span> Boolean.parseBoolean();</span><br><span class="line">    <span class="comment">// 语言，默认是 Java</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">LanguageCode</span> <span class="variable">language</span> <span class="operator">=</span> LanguageCode.JAVA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NettyClientConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClientConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 客户端工作线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">clientWorkerThreads</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 回调处理线程池 线程数：平台核心数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">clientCallbackExecutorThreads</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="comment">// 单向请求并发数，默认 65535</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">clientOnewaySemaphoreValue</span> <span class="operator">=</span> NettySystemConfig.CLIENT_ONEWAY_SEMAPHORE_VALUE;</span><br><span class="line">    <span class="comment">// 异步请求并发数，默认 65535</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">clientAsyncSemaphoreValue</span> <span class="operator">=</span> NettySystemConfig.CLIENT_ASYNC_SEMAPHORE_VALUE;</span><br><span class="line">    <span class="comment">// 客户端连接服务器的超时时间限制 3秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">connectTimeoutMillis</span> <span class="operator">=</span> <span class="number">3000</span>;</span><br><span class="line">    <span class="comment">// 客户端未激活周期，60s（指定时间内 ch 未激活，需要关闭）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">channelNotActiveInterval</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">60</span>;</span><br><span class="line">    <span class="comment">// 客户端与服务器 ch 最大空闲时间 2分钟</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">clientChannelMaxIdleTimeSeconds</span> <span class="operator">=</span> <span class="number">120</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 底层 Socket 写和收 缓冲区的大小 65535  64k</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">clientSocketSndBufSize</span> <span class="operator">=</span> NettySystemConfig.socketSndbufSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">clientSocketRcvBufSize</span> <span class="operator">=</span> NettySystemConfig.socketRcvbufSize;</span><br><span class="line">    <span class="comment">// 客户端 netty 是否启动内存池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">clientPooledByteBufAllocatorEnable</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 客户端是否超时关闭 Socket 连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">clientCloseSocketIfTimeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="客户端类"><a href="#客户端类" class="headerlink" title="客户端类"></a>客户端类</h4><h5 id="成员属性-8"><a href="#成员属性-8" class="headerlink" title="成员属性"></a>成员属性</h5><p>MQClientInstance 是 RocketMQ 客户端实例，在一个 JVM 进程中只有一个客户端实例，<strong>既服务于生产者，也服务于消费者</strong></p>
<p>成员变量：</p>
<ul>
<li><p>配置信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> instanceIndex;			<span class="comment">// 索引一般是 0，因为客户端实例一般都是一个进程只有一个</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String clientId;				<span class="comment">// 客户端 ID ip@pid</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> bootTimestamp;			<span class="comment">// 客户端的启动时间</span></span><br><span class="line"><span class="keyword">private</span> ServiceState serviceState;			<span class="comment">// 客户端状态</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生产者消费者的映射表：key 是组名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, MQProducerInner&gt; producerTable</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, MQConsumerInner&gt; consumerTable</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, MQAdminExtInner&gt; adminExtTable</span><br></pre></td></tr></table></figure>
</li>
<li><p>网络层配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> NettyClientConfig nettyClientConfig;</span><br></pre></td></tr></table></figure>
</li>
<li><p>核心功能的实现：负责将 MQ 业务层的数据转换为网络层的 RemotingCommand 对象，使用内部持有的 NettyRemotingClient 对象的 invoke 系列方法，完成网络 IO（同步、异步、单向）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MQClientAPIImpl mQClientAPIImpl;</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地路由数据：key 是主题名称，value 路由信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, TopicRouteData&gt; topicRouteTable = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>锁信息：两把锁，锁不同的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lockNamesrv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lockHeartbeat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>调度线程池：单线程，执行定时任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutorService;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Broker 映射表：key 是 BrokerName</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 物理节点映射表，value：Long 是 brokerID，【ID=0 的是主节点，其他是从节点】，String 是地址 ip:port</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, HashMap&lt;Long, String&gt;&gt; brokerAddrTable;</span><br><span class="line"><span class="comment">// 物理节点版本映射表，String 是地址 ip:port，Integer 是版本</span></span><br><span class="line">ConcurrentMap&lt;String, HashMap&lt;String, Integer&gt;&gt; brokerVersionTable;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端的协议处理器</strong>：用于处理 IO 事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClientRemotingProcessor clientRemotingProcessor;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PullMessageService pullMessageService;		<span class="comment">// 拉消息服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RebalanceService rebalanceService;			<span class="comment">// 消费者负载均衡服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConsumerStatsManager consumerStatsManager;	<span class="comment">// 消费者状态管理</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内部生产者实例：处理消费端<strong>消息回退</strong>，用该生产者发送回退消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultMQProducer defaultMQProducer;</span><br></pre></td></tr></table></figure>
</li>
<li><p>心跳次数统计：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">sendHeartbeatTimesTotal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>构造方法：</p>
<ul>
<li><p>MQClientInstance 有参构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MQClientInstance</span><span class="params">(ClientConfig clientConfig, <span class="type">int</span> instanceIndex, String clientId, RPCHook rpcHook)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.clientConfig = clientConfig;</span><br><span class="line">    <span class="built_in">this</span>.instanceIndex = instanceIndex;</span><br><span class="line">    <span class="comment">// Netty 相关的配置信息</span></span><br><span class="line">    <span class="built_in">this</span>.nettyClientConfig = <span class="keyword">new</span> <span class="title class_">NettyClientConfig</span>();</span><br><span class="line">    <span class="comment">// 平台核心数</span></span><br><span class="line">    <span class="built_in">this</span>.nettyClientConfig.setClientCallbackExecutorThreads(...);</span><br><span class="line">    <span class="built_in">this</span>.nettyClientConfig.setUseTLS(clientConfig.isUseTLS());</span><br><span class="line">    <span class="comment">// 【创建客户端协议处理器】</span></span><br><span class="line">    <span class="built_in">this</span>.clientRemotingProcessor = <span class="keyword">new</span> <span class="title class_">ClientRemotingProcessor</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 创建 API 实现对象</span></span><br><span class="line">    <span class="comment">// 参数一：客户端网络配置</span></span><br><span class="line">    <span class="comment">// 参数二：客户端协议处理器，注册到客户端网络层</span></span><br><span class="line">    <span class="comment">// 参数三：rpcHook，注册到客户端网络层</span></span><br><span class="line">    <span class="comment">// 参数四：客户端配置</span></span><br><span class="line">    <span class="built_in">this</span>.mQClientAPIImpl = <span class="keyword">new</span> <span class="title class_">MQClientAPIImpl</span>(<span class="built_in">this</span>.nettyClientConfig, <span class="built_in">this</span>.clientRemotingProcessor, rpcHook, clientConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 内部生产者，指定内部生产者的组</span></span><br><span class="line">    <span class="built_in">this</span>.defaultMQProducer = <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(MixAll.CLIENT_INNER_PRODUCER_GROUP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MQClientAPIImpl 有参构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MQClientAPIImpl</span><span class="params">(nettyClientConfig, clientRemotingProcessor, rpcHook, clientConfig)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.clientConfig = clientConfig;</span><br><span class="line">    topAddressing = <span class="keyword">new</span> <span class="title class_">TopAddressing</span>(MixAll.getWSAddr(), clientConfig.getUnitName());</span><br><span class="line">    <span class="comment">// 创建网络层对象，参数二为 null 说明客户端并不关心 channel event</span></span><br><span class="line">    <span class="built_in">this</span>.remotingClient = <span class="keyword">new</span> <span class="title class_">NettyRemotingClient</span>(nettyClientConfig, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 业务处理器</span></span><br><span class="line">    <span class="built_in">this</span>.clientRemotingProcessor = clientRemotingProcessor;</span><br><span class="line">    <span class="comment">// 注册 RpcHook</span></span><br><span class="line">    <span class="built_in">this</span>.remotingClient.registerRPCHook(rpcHook);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 注册回退消息的请求码</span></span><br><span class="line">    <span class="built_in">this</span>.remotingClient.registerProcessor(RequestCode.PUSH_REPLY_MESSAGE_TO_CLIENT, <span class="built_in">this</span>.clientRemotingProcessor, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-7"><a href="#成员方法-7" class="headerlink" title="成员方法"></a>成员方法</h5><ul>
<li><p>start()：启动方法</p>
<ul>
<li><code>synchronized (this)</code>：加锁保证线程安全，保证只有一个实例对象启动</li>
<li><code>this.mQClientAPIImpl.start()</code>：启动客户端网络层，底层调用 RemotingClient 类 </li>
<li><code>this.startScheduledTask()</code>：启动定时任务</li>
<li><code>this.pullMessageService.start()</code>：启动拉取消息服务</li>
<li><code>this.rebalanceService.start()</code>：启动负载均衡服务</li>
<li><code>this.defaultMQProducer...start(false)</code>：启动内部生产者，参数为 false 代表不启动实例</li>
</ul>
</li>
<li><p>startScheduledTask()：<strong>启动定时任务</strong>，调度线程池是单线程</p>
<ul>
<li><p><code>if (null == this.clientConfig.getNamesrvAddr())</code>：Namesrv 地址是空，需要两分钟拉取一次 Namesrv 地址</p>
</li>
<li><p>定时任务 1：<strong>从 Namesrv 更新客户端本地的路由数据</strong>，周期 30 秒一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取生产者和消费者订阅的主题集合，遍历集合，对比从 namesrv 拉取最新的主题路由数据和本地数据，是否需要更新</span></span><br><span class="line">MQClientInstance.<span class="built_in">this</span>.updateTopicRouteInfoFromNameServer();</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时任务 2：周期 30 秒一次，两个任务</p>
<ul>
<li><strong>清理下线的 Broker 节点</strong>，遍历客户端的 Broker 物理节点映射表，将所有主题数据都不包含的 Broker 物理节点清理掉，如果被清理的 Broker 下所有的物理节点都没有了，就将该 Broker 的映射数据删除掉</li>
<li><strong>向在线的所有的 Broker 发送心跳数据</strong>，同步发送的方式，返回值是 Broker 物理节点的版本号，更新版本映射表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MQClientInstance.<span class="built_in">this</span>.cleanOfflineBroker();</span><br><span class="line">MQClientInstance.<span class="built_in">this</span>.sendHeartbeatToAllBrokerWithLock();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 心跳数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeartbeatData</span> <span class="keyword">extends</span> <span class="title class_">RemotingSerializable</span> &#123;</span><br><span class="line">    <span class="comment">// 客户端 ID  ip@pid</span></span><br><span class="line">    <span class="keyword">private</span> String clientID;</span><br><span class="line">    <span class="comment">// 存储客户端所有生产者数据</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;ProducerData&gt; producerDataSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ProducerData&gt;();</span><br><span class="line">    <span class="comment">// 存储客户端所有消费者数据</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;ConsumerData&gt; consumerDataSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ConsumerData&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时任务 3：消费者持久化消费数据，周期 5 秒一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MQClientInstance.<span class="built_in">this</span>.persistAllConsumerOffset();</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时任务 4：动态调整消费者线程池，周期 1 分钟一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MQClientInstance.<span class="built_in">this</span>.adjustThreadPool();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>updateTopicRouteInfoFromNameServer()：<strong>更新路由数据</strong>，通过加锁保证当前实例只有一个线程去更新</p>
<ul>
<li><p><code>if (isDefault &amp;&amp; defaultMQProducer != null)</code>：需要默认数据</p>
<p><code>topicRouteData = ...getDefaultTopicRouteInfoFromNameServer()</code>：从 Namesrv 获取默认的 TBW102 的路由数据</p>
</li>
<li><p><code>topicRouteData = ...getTopicRouteInfoFromNameServer(topic)</code>：需要<strong>从 Namesrv 获取</strong>路由数据（同步）</p>
</li>
<li><p><code>old = this.topicRouteTable.get(topic)</code>：获取客户端实例本地的该主题的路由数据</p>
</li>
<li><p><code>boolean changed = topicRouteDataIsChange(old, topicRouteData)</code>：对比本地和最新下拉的数据是否一致</p>
</li>
<li><p><code>if (changed)</code>：不一致进入更新逻辑</p>
<p><code>this.brokerAddrTable.put(...)</code>：更新客户端 broker 物理<strong>节点映射表</strong></p>
<p><code>Update Pub info</code>：更新生产者信息</p>
<ul>
<li><code>publishInfo = topicRouteData2TopicPublishInfo(topic, topicRouteData)</code>：将主题路由数据转化为发布数据，会<strong>创建消息队列 MQ</strong>，放入发布数据对象的集合中</li>
<li><code>impl.updateTopicPublishInfo(topic, publishInfo)</code>：生产者将主题的发布数据保存到它本地，方便发送消息使用</li>
</ul>
<p><code>Update sub info</code>：更新消费者信息，创建 MQ 队列，更新订阅信息，用于负载均衡</p>
<p><code>this.topicRouteTable.put(topic, cloneTopicRouteData)</code>：<strong>将数据放入本地路由表</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="网络通信-1"><a href="#网络通信-1" class="headerlink" title="网络通信"></a>网络通信</h4><h5 id="成员属性-9"><a href="#成员属性-9" class="headerlink" title="成员属性"></a>成员属性</h5><p>NettyRemotingClient 类负责客户端的网络通信</p>
<p>成员变量：</p>
<ul>
<li><p>Netty 服务相关属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> NettyClientConfig nettyClientConfig;			<span class="comment">// 客户端的网络层配置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();		<span class="comment">// 客户端网络层启动对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup eventLoopGroupWorker;			<span class="comment">// 客户端网络层 Netty IO 线程组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Channel 映射表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ChannelWrapper&gt; channelTables;<span class="comment">// key 是服务器的地址，value 是通道对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lockChannelTables</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();		  <span class="comment">// 锁，控制并发安全</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器：启动定时任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="string">&quot;ClientHouseKeepingService&quot;</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ExecutorService publicExecutor;		<span class="comment">// 公共线程池</span></span><br><span class="line"><span class="keyword">private</span> ExecutorService callbackExecutor; 	<span class="comment">// 回调线程池，客户端发起异步请求，服务器的响应数据由回调线程池处理</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>事件监听器：客户端这里是 null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChannelEventListener channelEventListener;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>构造方法</p>
<ul>
<li><p>无参构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NettyRemotingClient</span><span class="params">(<span class="keyword">final</span> NettyClientConfig nettyClientConfig)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(nettyClientConfig, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有参构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">NettyRemotingClient</span><span class="params">(nettyClientConfig, channelEventListener)</span> &#123;</span><br><span class="line">    <span class="comment">// 父类创建了2个信号量，1、控制单向请求的并发度，2、控制异步请求的并发度</span></span><br><span class="line">    <span class="built_in">super</span>(nettyClientConfig.getClientOnewaySemaphoreValue(), nettyClientConfig.getClientAsyncSemaphoreValue());</span><br><span class="line">    <span class="built_in">this</span>.nettyClientConfig = nettyClientConfig;</span><br><span class="line">    <span class="built_in">this</span>.channelEventListener = channelEventListener;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建公共线程池</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">publicThreadNums</span> <span class="operator">=</span> nettyClientConfig.getClientCallbackExecutorThreads();</span><br><span class="line">    <span class="keyword">if</span> (publicThreadNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        publicThreadNums = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.publicExecutor = Executors.newFixedThreadPool(publicThreadNums,);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Netty IO 线程，1个线程</span></span><br><span class="line">    <span class="built_in">this</span>.eventLoopGroupWorker = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>, );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nettyClientConfig.isUseTLS()) &#123;</span><br><span class="line">  		sslContext = TlsHelper.buildSslContext(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-8"><a href="#成员方法-8" class="headerlink" title="成员方法"></a>成员方法</h5><ul>
<li><p>start()：启动方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// channel pipeline 内的 handler 使用的线程资源，默认 4 个</span></span><br><span class="line">    <span class="built_in">this</span>.defaultEventExecutorGroup = <span class="keyword">new</span> <span class="title class_">DefaultEventExecutorGroup</span>();</span><br><span class="line">    <span class="comment">// 配置 netty 客户端启动类对象</span></span><br><span class="line">    <span class="type">Bootstrap</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.bootstrap.group(<span class="built_in">this</span>.eventLoopGroupWorker).channel(NioSocketChannel.class)</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                <span class="comment">// 加几个handler</span></span><br><span class="line">                pipeline.addLast(</span><br><span class="line">                    <span class="comment">// 服务端的数据，都会来到这个</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">// 注意 Bootstrap 只是配置好客户端的元数据了，【在这里并没有创建任何 channel 对象】</span></span><br><span class="line">    <span class="comment">// 定时任务 扫描 responseTable 中超时的 ResponseFuture，避免客户端线程长时间阻塞</span></span><br><span class="line">    <span class="built_in">this</span>.timer.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">     	NettyRemotingClient.<span class="built_in">this</span>.scanResponseTable();</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">3</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 这里是 null，不启动</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.channelEventListener != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.nettyEventExecutor.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单向通信：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RemotingCommand <span class="title function_">invokeSync</span><span class="params">(String addr, <span class="keyword">final</span> RemotingCommand request, <span class="type">long</span> timeoutMillis)</span> &#123;</span><br><span class="line">    <span class="comment">// 开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">beginStartTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 获取或者创建客户端与服务端（addr）的通道 channel</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="built_in">this</span>.getAndCreateChannel(addr);</span><br><span class="line">    <span class="comment">// 条件成立说明客户端与服务端 channel 通道正常，可以通信</span></span><br><span class="line">    <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行 rpcHook 拓展点</span></span><br><span class="line">            doBeforeRpcHooks(addr, request);</span><br><span class="line">            <span class="comment">// 计算耗时，如果当前耗时已经超过 timeoutMillis 限制，则直接抛出异常，不再进行系统通信</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">costTime</span> <span class="operator">=</span> System.currentTimeMillis() - beginStartTime;</span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt; costTime) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemotingTimeoutException</span>(<span class="string">&quot;invokeSync call timeout&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 参数1：客户端-服务端通道channel</span></span><br><span class="line">            <span class="comment">// 参数二：网络层传输对象，封装着请求数据</span></span><br><span class="line">            <span class="comment">// 参数三：剩余的超时限制</span></span><br><span class="line">            <span class="type">RemotingCommand</span> <span class="variable">response</span> <span class="operator">=</span> <span class="built_in">this</span>.invokeSyncImpl(channel, request, ...);</span><br><span class="line">            <span class="comment">// 后置处理</span></span><br><span class="line">            doAfterRpcHooks(RemotingHelper.parseChannelRemoteAddr(channel), request, response);</span><br><span class="line">            <span class="comment">// 返回响应数据</span></span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingSendRequestException e) &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.closeChannel(addr, channel);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemotingConnectException</span>(addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h4><h5 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h5><p>BrokerStartup 初始化 BrokerController 调用 <code>registerProcessor()</code> 方法将 SendMessageProcessor 注册到 NettyRemotingServer 中，对应的请求 ID 为 <code>SEND_MESSAGE = 10</code>，NettyServerHandler 在处理请求时通过 CMD 会获取处理器执行 processRequest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：处理通道的事件；   参数二：客户端</span></span><br><span class="line"><span class="keyword">public</span> RemotingCommand <span class="title function_">processRequest</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span>  &#123;</span><br><span class="line">    <span class="type">RemotingCommand</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   	response = asyncProcessRequest(ctx, request).get();</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SendMessageProcessor#asyncConsumerSendMsgBack：异步发送消费者的回调消息</p>
<ul>
<li><p><code>final RemotingCommand response</code>：创建一个服务器响应对象</p>
</li>
<li><p><code>final ConsumerSendMsgBackRequestHeader requestHeader</code>：解析出客户端请求头信息，几个<strong>核心字段</strong>：</p>
<ul>
<li><code>private Long offset</code>：回退消息的 CommitLog offset</li>
<li><code>private Integer delayLevel</code>：延迟级别，一般是 0</li>
<li><code>private String originMsgId, originTopic</code>：原始的消息 ID，主题</li>
<li><code>private Integer maxReconsumeTimes</code>：最大重试次数，默认是 16 次</li>
</ul>
</li>
<li><p><code>if ()</code>：鉴权，是否找到订阅组配置、Broker 是否支持写请求、订阅组是否支持消息重试</p>
</li>
<li><p><code>String newTopic = MixAll.getRetryTopic(...)</code>：<strong>获取消费者组的重试主题</strong>，规则是 <code>%RETRY%GroupName</code></p>
</li>
<li><p><code>int queueIdInt = Math.abs()</code>：<strong>重试主题下的队列 ID 是 0</strong></p>
</li>
<li><p><code>TopicConfig topicConfig</code>：获取重试主题的配置信息</p>
</li>
<li><p><code>MessageExt msgExt</code>：根据消息的物理 offset 到存储模块查询，内部先查询出这条消息的 size，然后再根据 offset 和 size 查询出整条 msg</p>
</li>
<li><p><code>final String retryTopic</code>：获取消息的原始主题</p>
</li>
<li><p><code>if (null == retryTopic)</code>：条件成立说明<strong>当前消息是第一次被回退</strong>， 添加 <code>RETRY_TOPIC</code> 属性</p>
</li>
<li><p><code>msgExt.setWaitStoreMsgOK(false)</code>：异步刷盘</p>
</li>
<li><p><code>if (msgExt...() &gt;= maxReconsumeTimes || delayLevel &lt; 0)</code>：消息重试次数超过最大次数，不支持重试</p>
<p><code>newTopic = MixAll.getDLQTopic()</code>：<strong>获取消费者的死信队列</strong>，规则是 <code>%DLQ%GroupName</code></p>
<p><code>queueIdInt, topicConfig</code>：死信队列 ID 为 0，创建死信队列的配置</p>
</li>
<li><p><code>if (0 == delayLevel)</code>：说明延迟级别由 Broker 控制</p>
<p><code>delayLevel = 3 + msgExt.getReconsumeTimes()</code>：<strong>延迟级别默认从 3 级开始</strong>，每重试一次，延迟级别 +1</p>
</li>
<li><p><code>msgExt.setDelayTimeLevel(delayLevel)</code>：<strong>将延迟级别设置进消息属性</strong>，存储时会检查该属性，该属性值 &gt; 0 会<strong>将消息的主题和队列修改为调度主题和调度队列 ID</strong></p>
</li>
<li><p><code>MessageExtBrokerInner msgInner</code>：创建一条空消息，消息属性从 offset 查询出来的 msg 中拷贝</p>
</li>
<li><p><code>msgInner.setReconsumeTimes)</code>：重试次数设置为原 msg 的次数 +1</p>
</li>
<li><p><code>UtilAll.isBlank(originMsgId)</code>：判断消息是否是初次返回到服务器</p>
<ul>
<li>true：说明 msgExt 消息是第一次被返回到服务器，此时使用该 msg 的 id 作为 originMessageId</li>
<li>false：说明原始消息已经被重试不止 1 次，此时使用 offset 查询出来的 msg 中的 originMessageId</li>
</ul>
</li>
<li><p><code>CompletableFuture putMessageResult = ..asyncPutMessage(msgInner)</code>：调用存储模块存储消息</p>
<p><code>DefaultMessageStore#asyncPutMessage</code>：</p>
<ul>
<li><code>PutMessageResult result = this.commitLog.asyncPutMessage(msg)</code>：<strong>将新消息存储到 CommitLog 中</strong></li>
</ul>
</li>
</ul>
<hr>
<h5 id="调度服务"><a href="#调度服务" class="headerlink" title="调度服务"></a>调度服务</h5><p>DefaultMessageStore 中有成员属性 ScheduleMessageService，在 start 方法中会启动该调度服务</p>
<p>成员变量：</p>
<ul>
<li><p>延迟级别属性表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储延迟级别对应的 延迟时间长度 （单位：毫秒）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Integer <span class="comment">/* level */</span>, Long<span class="comment">/* delay timeMillis */</span>&gt; delayLevelTable;</span><br><span class="line"><span class="comment">// 存储延迟级别 queue 的消费进度 offset，该 table 每 10 秒钟，会持久化一次，持久化到本地磁盘</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Integer <span class="comment">/* level */</span>, Long<span class="comment">/* offset */</span>&gt; offsetTable;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最大延迟级别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> maxDelayLevel;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块启动状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时器：内部有线程资源，可执行调度任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Timer timer;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>成员方法：</p>
<ul>
<li><p>load()：加载调度消息，<strong>初始化 delayLevelTable 和 offsetTable</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">load</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>start()：启动消息调度服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>if (started.compareAndSet(false, true))</code>：将启动状态设为 true</p>
</li>
<li><p><code>this.timer</code>：创建定时器对象</p>
</li>
<li><p><code>for (... : this.delayLevelTable.entrySet())</code>：为<strong>每个延迟级别创建一个延迟任务</strong>提交到 timer ，周期执行，这样就可以<strong>将延迟消息得到及时的消费</strong></p>
</li>
<li><p><code>this.timer.scheduleAtFixedRate()</code>：提交周期型任务，延迟 10 秒执行，周期为 10 秒，持久化延迟队列消费进度任务</p>
<p><code>ScheduleMessageService.this.persist()</code>：持久化消费进度</p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="调度任务"><a href="#调度任务" class="headerlink" title="调度任务"></a>调度任务</h5><p>DeliverDelayedMessageTimerTask 是一个任务类</p>
<p>成员变量：</p>
<ul>
<li><p>延迟级别：延迟队列任务处理的延迟级别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> delayLevel;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费进度：延迟队列任务处理的延迟队列的消费进度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> offset;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>成员方法：</p>
<ul>
<li><p>run()：执行任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isStarted()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.executeOnTimeup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>executeOnTimeup()：执行任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeOnTimeup</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ConsumeQueue cq</code>：获取出该延迟队列任务处理的<strong>延迟队列 ConsumeQueue</strong></p>
</li>
<li><p><code>SelectMappedBufferResult bufferCQ</code>：根据消费进度查询出 SMBR 对象</p>
</li>
<li><p><code>for (; i &lt; bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE)</code>：每次读取 20 各字节的数据</p>
</li>
<li><p><code>offsetPy, sizePy</code>：延迟消息的物理偏移量和消息大小</p>
</li>
<li><p><code>long tagsCode</code>：延迟消息的交付时间，在 ReputMessageService 转发时根据消息的 DELAY 属性是否 &gt;0 ，会在 tagsCode 字段存储交付时间</p>
</li>
<li><p><code>long deliver... = this.correctDeliverTimestamp(..)</code>：<strong>校准交付时间</strong>，延迟时间过长会调整为当前时间立刻执行</p>
</li>
<li><p><code>long countdown = deliverTimestamp - now</code>：计算差值</p>
</li>
<li><p><code>if (countdown &lt;= 0)</code>：<strong>消息已经到达交付时间了</strong></p>
<p><code>MessageExt msgExt</code>：根据物理偏移量和消息大小获取这条消息</p>
<p><code>MessageExtBrokerInner msgInner</code>：<strong>构建一条新消息</strong>，将原消息的属性拷贝过来</p>
<ul>
<li><code>long tagsCodeValue</code>：不再是交付时间了</li>
<li><code>MessageAccessor.clearProperty(msgInner, DELAY..)</code>：清理新消息的 DELAY 属性，避免存储时重定向到延迟队列</li>
<li><code>msgInner.setTopic()</code>：<strong>修改主题为原始的主题 <code>%RETRY%GroupName</code></strong></li>
<li><code>String queueIdStr</code>：修改队列 ID 为原始的 ID</li>
</ul>
<p><code>PutMessageResult putMessageResult</code>：<strong>将新消息存储到 CommitLog</strong>，消费者订阅的是目标主题，会再次消费该消息</p>
</li>
<li><p><code>else</code>：消息还未到达交付时间</p>
<p><code>ScheduleMessageService.this.timer.schedule()</code>：创建该延迟级别的任务，延迟 countDown 毫秒之后再执行</p>
<p><code>ScheduleMessageService.this.updateOffset()</code>：更新延迟级别队列的消费进度</p>
</li>
<li><p><code>PutMessageResult putMessageResult</code></p>
</li>
<li><p><code>bufferCQ == null</code>：说明通过消费进度没有获取到数据</p>
<p><code>if (offset &lt; cqMinOffset)</code>：如果消费进度比最小位点都小，说明是过期数据，重置为最小位点 </p>
</li>
<li><p><code>ScheduleMessageService.this.timer.schedule()</code>：重新提交该延迟级别对应的延迟队列任务，延迟 100 毫秒后执行</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="事务消息-1"><a href="#事务消息-1" class="headerlink" title="事务消息"></a>事务消息</h4><h5 id="生产者类-2"><a href="#生产者类-2" class="headerlink" title="生产者类"></a>生产者类</h5><p>TransactionMQProducer 类发送事务消息时使用</p>
<p>成员变量：</p>
<ul>
<li><p>事务回查线程池资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">* 事务监听器：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">private</span> TransactionListener transactionListener;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>核心方法：</p>
<ul>
<li><p>start()：启动方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.defaultMQProducerImpl.initTransactionEnv()</code>：初始化生产者实例和回查线程池资源</li>
<li><code>super.start()</code>：启动生产者实例</li>
</ul>
</li>
<li><p>sendMessageInTransaction()：发送事务消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TransactionSendResult <span class="title function_">sendMessageInTransaction</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> Object arg)</span> &#123;</span><br><span class="line">    msg.setTopic(NamespaceUtil.wrapNamespace(<span class="built_in">this</span>.getNamespace(), msg.getTopic()));</span><br><span class="line">    <span class="comment">// 调用实现类的发送方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.defaultMQProducerImpl.sendMessageInTransaction(msg, <span class="literal">null</span>, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>TransactionListener transactionListener = getCheckListener()</code>：获取监听器</p>
</li>
<li><p><code>if (null == localTransactionExecuter &amp;&amp; null == transactionListener)</code>：两者都为 null 抛出异常</p>
</li>
<li><p><code>MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, &quot;true&quot;)</code>：<strong>设置事务标志</strong></p>
</li>
<li><p><code>sendResult = this.send(msg)</code>：发送消息，同步发送</p>
</li>
<li><p><code>switch (sendResult.getSendStatus())</code>：<strong>判断发送消息的结果状态</strong></p>
</li>
<li><p><code>case SEND_OK</code>：消息发送成功</p>
<p><code>msg.setTransactionId(transactionId)</code>：<strong>设置事务 ID 为消息的 UNIQ_KEY 属性</strong></p>
<p><code>localTransactionState = ...executeLocalTransactionBranch(msg, arg)</code>：<strong>执行本地事务</strong></p>
</li>
<li><p><code>case SLAVE_NOT_AVAILABLE</code>：其他情况都需要回滚事务</p>
<p><code>localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE</code>：<strong>事务状态设置为回滚</strong></p>
</li>
<li><p><code>this.endTransaction(sendResult, ...)</code>：结束事务</p>
<ul>
<li><code>EndTransactionRequestHeader requestHeader</code>：构建事务结束头对象</li>
<li><code>this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway()</code>：向 Broker 发起事务结束的单向请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="接受消息"><a href="#接受消息" class="headerlink" title="接受消息"></a>接受消息</h5><p>SendMessageProcessor 是服务端处理客户端发送来的消息的处理器，<code>processRequest()</code> 方法处理请求</p>
<p>核心方法：</p>
<ul>
<li><p><code>asyncProcessRequest()</code>：处理请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;RemotingCommand&gt; <span class="title function_">asyncProcessRequest</span><span class="params">(ChannelHandlerContext ctx,</span></span><br><span class="line"><span class="params">                                                              RemotingCommand request)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> SendMessageContext mqtraceContext;</span><br><span class="line">    <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">            <span class="comment">// 回调消息回退</span></span><br><span class="line">        <span class="keyword">case</span> RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.asyncConsumerSendMsgBack(ctx, request);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 解析出请求头对象</span></span><br><span class="line">            <span class="type">SendMessageRequestHeader</span> <span class="variable">requestHeader</span> <span class="operator">=</span> parseRequestHeader(request);</span><br><span class="line">            <span class="keyword">if</span> (requestHeader == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建上下文对象</span></span><br><span class="line">            mqtraceContext = buildMsgContext(ctx, requestHeader);</span><br><span class="line">            <span class="comment">// 前置处理器</span></span><br><span class="line">            <span class="built_in">this</span>.executeSendMessageHookBefore(ctx, request, mqtraceContext);</span><br><span class="line">            <span class="comment">// 判断是否是批量消息</span></span><br><span class="line">            <span class="keyword">if</span> (requestHeader.isBatch()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.asyncSendBatchMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.asyncSendMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>asyncSendMessage()：异步处理发送消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> CompletableFuture&lt;RemotingCommand&gt; <span class="title function_">asyncSendMessage</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request, SendMessageContext mqtraceContext, SendMessageRequestHeader requestHeader)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>RemotingCommand response</code>：创建响应对象</p>
</li>
<li><p><code>MessageExtBrokerInner msgInner = new MessageExtBrokerInner()</code>：创建 msgInner 对象，并赋值相关的属性，主题和队列 ID 都是请求头中的</p>
</li>
<li><p><code>String transFlag</code>：<strong>获取事务属性</strong></p>
</li>
<li><p><code>if (transFlag != null &amp;&amp; Boolean.parseBoolean(transFlag))</code>：判断事务属性是否是 true，走事务消息的存储流程</p>
<ul>
<li><p><code>putMessageResult = ...asyncPrepareMessage(msgInner)</code>：<strong>事务消息处理流程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;PutMessageResult&gt; <span class="title function_">asyncPutHalfMessage</span><span class="params">(MessageExtBrokerInner messageInner)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用存储模块，将修改后的 msg 存储进 Broker(CommitLog)</span></span><br><span class="line">    <span class="keyword">return</span> store.asyncPutMessage(parseHalfMessageInner(messageInner));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TransactionalMessageBridge#parseHalfMessageInner：</p>
<ul>
<li><code>MessageAccessor.putProperty(...)</code>：<strong>将消息的原主题和队列 ID 放入消息的属性中</strong></li>
<li><code>msgInner.setSysFlag(...)</code>：消息设置为非事务状态</li>
<li><code>msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic())</code>：<strong>消息主题设置为半消息主题</strong></li>
<li><code>msgInner.setQueueId(0)</code>：<strong>队列 ID 设置为 0</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><code>else</code>：普通消息存储</p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="回查处理"><a href="#回查处理" class="headerlink" title="回查处理"></a>回查处理</h5><p>ClientRemotingProcessor 是客户端用于处理请求，创建 MQClientAPIImpl 时将该处理器注册到 Netty 中，<code>processRequest()</code> 方法根据请求的命令码，进行不同的处理，事务回查的处理命令码为 <code>CHECK_TRANSACTION_STATE</code></p>
<p>Broker 端有定时任务发送回查请求</p>
<p>成员方法：</p>
<ul>
<li><p>checkTransactionState()：检查事务状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RemotingCommand <span class="title function_">checkTransactionState</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>final CheckTransactionStateRequestHeader requestHeader</code>：解析出请求头对象</li>
<li><code>final MessageExt messageExt</code>：从请求 body 中解析出服务器回查的事务消息</li>
<li><code>String transactionId</code>：提取 UNIQ_KEY 字段属性值赋值给事务 ID</li>
<li><code>final String group</code>：提取生产者组名</li>
<li><code>MQProducerInner producer = this...selectProducer(group)</code>：根据生产者组获取生产者对象</li>
<li><code>String addr = RemotingHelper.parseChannelRemoteAddr()</code>：解析出要回查的 Broker 服务器的地址</li>
<li><code>producer.checkTransactionState(addr, messageExt, requestHeader)</code>：生产者的事务回查<ul>
<li><code>Runnable request = new Runnable()</code>：<strong>创建回查事务状态任务对象</strong><ul>
<li>获取生产者的 TransactionCheckListener 和 TransactionListener，选择一个不为 null 的监听器进行事务状态回查</li>
<li><code>this.processTransactionState()</code>：处理回查状态<ul>
<li><code>EndTransactionRequestHeader thisHeader</code>：构建 EndTransactionRequestHeader 对象</li>
<li><code>DefaultMQProducerImpl...endTransactionOneway()</code>：向 Broker 发起结束事务单向请求，<strong>二阶段提交</strong></li>
</ul>
</li>
</ul>
</li>
<li><code>this.checkExecutor.submit(request)</code>：提交到线程池运行</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>参考图：<a href="https://www.processon.com/view/link/61c8257e0e3e7474fb9dcbc0">https://www.processon.com/view/link/61c8257e0e3e7474fb9dcbc0</a></p>
<p>参考视频：<a href="https://space.bilibili.com/457326371">https://space.bilibili.com/457326371</a></p>
<hr>
<h5 id="事务提交"><a href="#事务提交" class="headerlink" title="事务提交"></a>事务提交</h5><p>EndTransactionProcessor 类是服务端用来处理客户端发来的提交或者回滚请求</p>
<ul>
<li><p>processRequest()：处理请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RemotingCommand <span class="title function_">processRequest</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>EndTransactionRequestHeader requestHeader</code>：从请求中解析出 EndTransactionRequestHeader</p>
</li>
<li><p><code>if (MessageSysFlag.TRANSACTION_COMMIT_TYPE)</code>：<strong>事务提交</strong></p>
<p><code>result = this.brokerController...commitMessage(requestHeader)</code>：根据 commitLogOffset 提取出 halfMsg 消息</p>
<p><code>MessageExtBrokerInner msgInner</code>：根据 result 克隆出一条新消息</p>
<ul>
<li><p><code>msgInner.setTopic(msgExt.getUserProperty(...))</code>：<strong>设置回原主题</strong></p>
</li>
<li><p><code>msgInner.setQueueId(Integer.parseInt(msgExt.getUserProperty(..)))</code>：<strong>设置回原队列 ID</strong></p>
</li>
<li><p><code>MessageAccessor.clearProperty()</code>：清理上面的两个属性</p>
</li>
</ul>
<p><code>MessageAccessor.clearProperty(msgInner, ...)</code>：<strong>清理事务属性</strong></p>
<p><code>RemotingCommand sendResult = sendFinalMessage(msgInner)</code>：调用存储模块存储至 Broker</p>
<p><code>this.brokerController...deletePrepareMessage(result.getPrepareMessage())</code>：<strong>向删除（OP）队列添加消息</strong>，消息体的数据是 halfMsg 的 queueOffset，<strong>表示半消息队列指定的 offset 的消息已被删除</strong></p>
<ul>
<li><code>if (this...putOpMessage(msgExt, TransactionalMessageUtil.REMOVETAG))</code>：添加一条 OP 数据<ul>
<li><code>MessageQueue messageQueue</code>：新建一个消息队列，OP 队列</li>
<li><code>return addRemoveTagInTransactionOp(messageExt, messageQueue)</code>：添加数据<ul>
<li><code>Message message</code>：创建 OP 消息</li>
<li><code>writeOp(message, messageQueue)</code>：写入 OP 消息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>else if (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE)</code>：<strong>事务回滚</strong></p>
<p><code>this.brokerController...deletePrepareMessage(result.getPrepareMessage())</code>：<strong>也需要向 OP 队列添加消息</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><h4 id="消费者类"><a href="#消费者类" class="headerlink" title="消费者类"></a>消费者类</h4><h5 id="默认消费"><a href="#默认消费" class="headerlink" title="默认消费"></a>默认消费</h5><p>DefaultMQPushConsumer 类是默认的消费者类</p>
<p>成员变量：</p>
<ul>
<li><p>消费者实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">transient</span> DefaultMQPushConsumerImpl defaultMQPushConsumerImpl;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String consumerGroup;									<span class="comment">// 消费者组</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">MessageModel</span> <span class="variable">messageModel</span> <span class="operator">=</span> MessageModel.CLUSTERING;	<span class="comment">// 消费模式，默认集群模式</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>订阅信息：key 是主题，value 是过滤表达式，一般是 tag</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, String &gt; subscription = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;()</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息监听器：<strong>消息处理逻辑</strong>，并发消费 MessageListenerConcurrently，顺序（分区）消费 MessageListenerOrderly</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> MessageListener messageListener;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费位点：当从 Broker 获取当前组内该 queue 的 offset 不存在时，consumeFromWhere 才有效，默认值代表从队列的最后 offset 开始消费，当队列内再有一条新的 msg 加入时，消费者才会去消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ConsumeFromWhere</span> <span class="variable">consumeFromWhere</span> <span class="operator">=</span> ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费时间戳：当消费位点配置的是 CONSUME_FROM_TIMESTAMP 时，并且服务器 Group 内不存在该 queue 的 offset 时，会使用该时间戳进行消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">consumeTimestamp</span> <span class="operator">=</span> UtilAll.timeMillisToHumanString3(System.currentTimeMillis() - (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">30</span>));<span class="comment">// 消费者创建时间 - 30秒，转换成 格式： 年月日小时分钟秒，比如 20220203171201</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>队列分配策略：主题下的队列分配策略，RebalanceImpl 对象依赖该算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AllocateMessageQueueStrategy allocateMessageQueueStrategy;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费进度存储器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> OffsetStore offsetStore;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>核心方法：</p>
<ul>
<li><p>start()：启动消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>shutdown()：关闭消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>registerMessageListener()：注册消息监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerMessageListener</span><span class="params">(MessageListener messageListener)</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>subscribe()：添加订阅信息，<strong>将订阅信息放入负载均衡对象的 subscriptionInner 中</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(String topic, String subExpression)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>unsubscribe()：删除订阅指定主题的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unsubscribe</span><span class="params">(String topic)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>suspend()：停止消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">suspend</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>resume()：恢复消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resume</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h5><p>DefaultMQPushConsumerImpl 是默认消费者的实现类</p>
<p>成员变量：</p>
<ul>
<li><p>客户端实例：整个进程内只有一个客户端实例对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> MQClientInstance mQClientFactory;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者实例：门面对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultMQPushConsumer defaultMQPushConsumer;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>负载均衡</strong>：分配订阅主题的队列给当前消费者，20 秒钟一个周期执行 Rebalance 算法（客户端实例触发）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">RebalanceImpl</span> <span class="variable">rebalanceImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RebalancePushImpl</span>(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> consumerStartTimestamp;	<span class="comment">// 消费者启动时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ServiceState serviceState;	<span class="comment">// 消费者状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">pause</span> <span class="operator">=</span> <span class="literal">false</span>;		<span class="comment">// 是否暂停</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">consumeOrderly</span> <span class="operator">=</span> <span class="literal">false</span>;		<span class="comment">// 是否顺序消费</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>拉取消息</strong>：封装拉消息的 API，服务器 Broker 返回结果中包含下次 Pull 时推荐的 BrokerId，根据本次请求数据的冷热程度进行推荐</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> PullAPIWrapper pullAPIWrapper;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>消息消费</strong>服务：并发消费和顺序消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ConsumeMessageService consumeMessageService;</span><br></pre></td></tr></table></figure>
</li>
<li><p>流控：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">queueFlowControlTimes</span> <span class="operator">=</span> <span class="number">0</span>;			<span class="comment">// 队列流控次数，默认每1000次流控，进行一次日志打印</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">queueMaxSpanFlowControlTimes</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">// 流控使用，控制打印日志</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HOOK：钩子方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 过滤消息 hook</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;FilterMessageHook&gt; filterMessageHookList;</span><br><span class="line"><span class="comment">// 消息执行hook，在消息处理前和处理后分别执行 hook.before  hook.after 系列方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ConsumeMessageHook&gt; consumeMessageHookList;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>核心方法：</p>
<ul>
<li><p>start()：加锁保证线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> </span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.checkConfig()</code>：检查配置，包括组名、消费模式、订阅信息、消息监听器等</li>
<li><code>this.copySubscription()</code>：拷贝订阅信息到 RebalanceImpl 对象<ul>
<li><code>this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData)</code>：将订阅信息加入 rbl 的 map 中</li>
<li><code>this.messageListenerInner = ...getMessageListener()</code>：将消息监听器保存到实例对象</li>
<li><code>switch (this.defaultMQPushConsumer.getMessageModel())</code>：判断消费模式，广播模式下直接返回</li>
<li><code>final String retryTopic</code>：创建当前<strong>消费者组重试的主题名</strong>，规则 <code>%RETRY%ConsumerGroup</code></li>
<li><code>SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData()</code>：创建重试主题的订阅数据对象</li>
<li><code>this.rebalanceImpl.getSubscriptionInner().put(retryTopic, subscriptionData)</code>：将创建的重试主题加入到 rbl 对象的 map 中，<strong>消息重试时会加入到该主题，消费者订阅这个主题之后，就有机会再次拿到该消息进行消费处理</strong></li>
</ul>
</li>
<li><code>this.mQClientFactory = ...getOrCreateMQClientInstance()</code>：获取客户端实例对象</li>
<li><code>this.rebalanceImpl.</code>：初始化负载均衡对象，设置<strong>队列分配策略对象</strong>到属性中</li>
<li><code>this.pullAPIWrapper = new PullAPIWrapper()</code>：创建拉消息 API 对象，内部封装了查询推荐主机算法</li>
<li><code>this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList)</code>：将过滤 Hook 列表注册到该对象内，消息拉取下来之后会执行该 Hook，<strong>再进行一次自定义的消息过滤</strong></li>
<li><code>this.offsetStore = new RemoteBrokerOffsetStore()</code>：默认集群模式下创建消息进度存储器</li>
<li><code>this.consumeMessageService = ...</code>：根据消息监听器的类型创建消费服务</li>
<li><code>this.consumeMessageService.start()</code>：启动消费服务</li>
<li><code>boolean registerOK = mQClientFactory.registerConsumer()</code>：<strong>将消费者注册到客户端实例中</strong>，客户端提供的服务：<ul>
<li>心跳服务：把订阅数据同步到订阅主题的 Broker</li>
<li>拉消息服务：内部 PullMessageService 启动线程，基于 PullRequestQueue 工作，消费者负载均衡分配到队列后会向该队列提交 PullRequest</li>
<li>队列负载服务：每 20 秒调用一次 <code>consumer.doRebalance()</code> 接口</li>
<li>消息进度持久化</li>
<li>动态调整消费者、消费服务线程池</li>
</ul>
</li>
<li><code>mQClientFactory.start()</code>：启动客户端实例</li>
<li><code> this.updateTopic</code>：从 nameserver 获取主题路由数据，生成主题集合放入 rbl 对象的 table</li>
<li><code>this.mQClientFactory.checkClientInBroker()</code>：检查服务器是否支持消息过滤模式，一般使用 tag 过滤，服务器默认支持</li>
<li><code>this.mQClientFactory.sendHeartbeatToAllBrokerWithLock()</code>：向所有已知的 Broker 节点，<strong>发送心跳数据</strong></li>
<li><code>this.mQClientFactory.rebalanceImmediately()</code>：唤醒 rbl 线程，触发负载均衡执行</li>
</ul>
</li>
</ul>
<hr>
<h4 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h4><h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><p>MQClientInstance#start 中会启动负载均衡服务 RebalanceService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 检查停止标记</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="comment">// 休眠 20 秒，防止其他线程饥饿，所以【每 20 秒负载均衡一次】</span></span><br><span class="line">        <span class="built_in">this</span>.waitForRunning(waitInterval);</span><br><span class="line">        <span class="comment">// 调用客户端实例的负载均衡方法，底层【会遍历所有消费者，调用消费者的负载均衡】</span></span><br><span class="line">        <span class="built_in">this</span>.mqClientFactory.doRebalance();</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RebalanceImpl 类成员变量：</p>
<ul>
<li><p>分配给当前消费者的处理队列：处理消息队列集合，<strong>ProcessQueue 是 MQ 队列在消费者端的快照</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ConcurrentMap&lt;MessageQueue, ProcessQueue&gt; processQueueTable;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者订阅主题的队列信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* topic */</span>, Set&lt;MessageQueue&gt;&gt; topicSubscribeInfoTable;</span><br></pre></td></tr></table></figure>
</li>
<li><p>订阅数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* topic */</span>, SubscriptionData&gt; subscriptionInner;</span><br></pre></td></tr></table></figure>
</li>
<li><p>队列分配策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AllocateMessageQueueStrategy allocateMessageQueueStrategy;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>成员方法：</p>
<ul>
<li><p>doRebalance()：负载均衡方法，以每个消费者实例为粒度进行负载均衡</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doRebalance</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> isOrder)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前消费者的订阅数据</span></span><br><span class="line">    Map&lt;String, SubscriptionData&gt; subTable = <span class="built_in">this</span>.getSubscriptionInner();</span><br><span class="line">    <span class="keyword">if</span> (subTable != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的订阅主题</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 获取订阅的主题</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="comment">// 按照主题进行负载均衡</span></span><br><span class="line">            <span class="built_in">this</span>.rebalanceByTopic(topic, isOrder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将分配到当前消费者的队列进行过滤，不属于当前消费者订阅主题的直接移除</span></span><br><span class="line">    <span class="built_in">this</span>.truncateMessageQueueNotMyTopic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集群模式下：</p>
<ul>
<li><p><code>Set&lt;MessageQueue&gt; mqSet = this.topicSubscribeInfoTable.get(topic)</code>：订阅的主题下的全部队列信息</p>
</li>
<li><p><code>cidAll = this...findConsumerIdList(topic, consumerGroup)</code>：从服务器获取消费者组下的全部消费者 ID</p>
</li>
<li><p><code>Collections.sort(mqAll)</code>：主题 MQ 队列和消费者 ID 都进行排序，<strong>保证每个消费者的视图一致性</strong></p>
</li>
<li><p><code>allocateResult = strategy.allocate()</code>： <strong>调用队列分配策略</strong>，给当前消费者进行分配 MessageQueue（下一节）</p>
</li>
<li><p><code>boolean changed = this.updateProcessQueueTableInRebalance(...)</code>：<strong>更新队列处理集合</strong>，mqSet 是 rbl 算法分配到当前消费者的 MQ 集合</p>
<ul>
<li><p><code>while (it.hasNext())</code>：遍历当前消费者的所有处理队列</p>
</li>
<li><p><code>if (mq.getTopic().equals(topic))</code>：该 MQ 是 本次 rbl 分配算法计算的主题</p>
</li>
<li><p><code>if (!mqSet.contains(mq))</code>：该 MQ 经过 rbl 计算之后，<strong>被分配到其它 Consumer 节点</strong></p>
<p><code>pq.setDropped(true)</code>：将删除状态设置为 true</p>
<p><code>if (this.removeUnnecessaryMessageQueue(mq, pq))</code>：删除不需要的 MQ 队列</p>
<ul>
<li><p><code>this...getOffsetStore().persist(mq)</code>：在 MQ 归属的 Broker 节点持久化消费进度</p>
</li>
<li><p><code>this...getOffsetStore().removeOffset(mq)</code>：删除该 MQ 在本地的消费进度</p>
</li>
<li><p><code>if (this.defaultMQPushConsumerImpl.isConsumeOrderly() &amp;&amp;)</code>：是否是<strong>顺序消费</strong>和集群模式</p>
<p><code>if (pq.getLockConsume().tryLock(1000, ..))</code>： 获取锁成功，说明顺序消费任务已经停止消费工作</p>
<p><code>return this.unlockDelay(mq, pq)</code>：<strong>释放锁 Broker 端的队列锁，向服务器发起 oneway 的解锁请求</strong></p>
<ul>
<li><code>if (pq.hasTempMessage())</code>：队列中有消息，延迟 20 秒释放队列分布式锁，确保全局范围内只有一个消费任务 运行中</li>
<li><code>else</code>：当前消费者本地该消费任务已经退出，直接释放锁</li>
</ul>
<p><code>else</code>：顺序消费任务正在消费一批消息，不可打断，增加尝试获取锁的次数</p>
</li>
</ul>
<p><code>it.remove()</code>：从 processQueueTable 移除该 MQ</p>
</li>
<li><p><code>else if (pq.isPullExpired())</code>：说明当前 MQ 还是被当前 Consumer 消费，此时判断一下是否超过 2 分钟未到服务器 拉消息，如果条件成立进行上述相同的逻辑</p>
</li>
<li><p><code>for (MessageQueue mq : mqSet)</code>：开始处理当前主题<strong>新分配到当前节点的队列</strong></p>
<p><code>if (isOrder &amp;&amp; !this.lock(mq))</code>：<strong>顺序消息为了保证有序性，需要获取队列锁</strong></p>
<p><code>ProcessQueue pq = new ProcessQueue()</code>：为每个新分配的消息队列创建快照队列</p>
<p><code>long nextOffset = this.computePullFromWhere(mq)</code>：<strong>从服务端获取新分配的 MQ 的消费进度</strong></p>
<p><code>ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq)</code>：保存到处理队列集合</p>
<p><code>PullRequest pullRequest = new PullRequest()</code>：<strong>创建拉取请求对象</strong></p>
</li>
<li><p><code>this.dispatchPullRequest(pullRequestList)</code>：放入 PullMessageService 的<strong>本地阻塞队列</strong>内，用于拉取消息工作</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>lockAll()：续约锁，对消费者的所有队列进行续约</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockAll</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>HashMap&lt;String, Set&lt;MessageQueue&gt;&gt; brokerMqs</code>：将分配给当前消费者的全部 MQ 按照 BrokerName 分组</p>
</li>
<li><p><code>while (it.hasNext())</code>：遍历所有的分组</p>
</li>
<li><p><code>final Set&lt;MessageQueue&gt; mqs</code>：获取该 Broker 上分配给当前消费者的 queue 集合</p>
</li>
<li><p><code>FindBrokerResult findBrokerResult</code>：查询 Broker 主节点信息</p>
</li>
<li><p><code>LockBatchRequestBody requestBody</code>：创建请求对象，填充属性</p>
</li>
<li><p><code>Set&lt;MessageQueue&gt; lockOKMQSet</code>：<strong>以组为单位向 Broker 发起批量续约锁的同步请求</strong>，返回成功的队列集合</p>
</li>
<li><p><code>for (MessageQueue mq : lockOKMQSet)</code>：遍历续约锁成功的 MQ</p>
<p><code>processQueue.setLocked(true)</code>：<strong>分布式锁状态设置为 true，表示允许顺序消费</strong></p>
<p><code>processQueue.setLastLockTimestamp(System.currentTimeMillis())</code>：设置上次获取锁的时间为当前时间</p>
</li>
<li><p><code>for (MessageQueue mq : mqs)</code>：遍历当前 Broker 上的所有队列集合</p>
<p><code>if (!lockOKMQSet.contains(mq))</code>：条件成立说明续约锁失败</p>
<p><code>processQueue.setLocked(false)</code>：<strong>分布式锁状态设置为 false，表示不允许顺序消费</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="队列分配"><a href="#队列分配" class="headerlink" title="队列分配"></a>队列分配</h5><p>AllocateMessageQueueStrategy 类是队列的分配策略</p>
<ul>
<li><p>平均分配：AllocateMessageQueueAveragely 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：消费者组       								参数二：当前消费者id   </span></span><br><span class="line"><span class="comment">// 参数三：主题的全部队列，包括所有 broker 上该主题的 mq  	参数四：全部消费者id集合</span></span><br><span class="line"><span class="keyword">public</span> List&lt;MessageQueue&gt; <span class="title function_">allocate</span><span class="params">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll, List&lt;String&gt; cidAll)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前消费者在全部消费者中的位置，【全部消费者是已经排序好的，排在前面的优先分配更多的队列】</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> cidAll.indexOf(currentCID);</span><br><span class="line">    <span class="comment">// 平均分配完以后，还剩余的待分配的 mq 的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> mqAll.size() % cidAll.size();</span><br><span class="line">    <span class="comment">// 首先判断整体的 mq 的数量是否小于消费者的数量，小于消费者的数量就说明不够分的，先分一个</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">averageSize</span> <span class="operator">=</span> mqAll.size() &lt;= cidAll.size() ? <span class="number">1</span> :</span><br><span class="line">    	<span class="comment">// 成立需要多分配一个队列，因为更靠前</span></span><br><span class="line">    	(mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size() + <span class="number">1</span> : mqAll.size() / cidAll.size());</span><br><span class="line">    <span class="comment">// 获取起始的分配位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod) ? index * averageSize : index * averageSize + mod;</span><br><span class="line">    <span class="comment">// 防止索引越界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> Math.min(averageSize, mqAll.size() - startIndex);</span><br><span class="line">    <span class="comment">// 开始分配，【挨着分配，是直接就把当前的 消费者分配完成】</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">        result.add(mqAll.get((startIndex + i) % mqAll.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列排序后：Q1 → Q2 → Q3，消费者排序后 C1 → C2 → C3</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E5%B9%B3%E5%9D%87%E9%98%9F%E5%88%97%E5%88%86%E9%85%8D.png"></p>
</li>
<li><p>轮流分配：AllocateMessageQueueAveragelyByCircle</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-%E5%B9%B3%E5%9D%87%E9%98%9F%E5%88%97%E8%BD%AE%E6%B5%81%E5%88%86%E9%85%8D.png"></p>
</li>
<li><p>指定机房平均分配：AllocateMessageQueueByMachineRoom，前提是 Broker 的命名规则为 <code>机房名@BrokerName</code></p>
</li>
</ul>
<hr>
<h4 id="拉取服务"><a href="#拉取服务" class="headerlink" title="拉取服务"></a>拉取服务</h4><h5 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h5><p>MQClientInstance#start 中会启动消息拉取服务：PullMessageService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查停止标记，【循环拉取】</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从阻塞队列中获取拉消息请求</span></span><br><span class="line">            <span class="type">PullRequest</span> <span class="variable">pullRequest</span> <span class="operator">=</span> <span class="built_in">this</span>.pullRequestQueue.take();</span><br><span class="line">            <span class="comment">// 拉取消息，获取请求对应的使用当前消费者组中的哪个消费者，调用消费者的 pullMessage 方法</span></span><br><span class="line">            <span class="built_in">this</span>.pullMessage(pullRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Pull Message Service Run Method exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultMQPushConsumerImpl#pullMessage：</p>
<ul>
<li><p><code>ProcessQueue processQueue = pullRequest.getProcessQueue()</code>：获取请求对应的快照队列，并判断是否是删除状态</p>
</li>
<li><p><code>this.executePullRequestLater()</code>：如果当前消费者不是运行状态，则拉消息任务延迟 3 秒后执行，如果是暂停状态延迟 1 秒</p>
</li>
<li><p><strong>流控的逻辑</strong>：</p>
<p><code>long cachedMessageCount = processQueue.getMsgCount().get()</code>：获取消费者本地该 queue 快照内缓存的消息数量，如果大于 1000 条，进行流控，延迟 50 毫秒</p>
<p><code>long cachedMessageSizeInMiB</code>： 消费者本地该 queue 快照内缓存的消息容量 size，超过 100m 消息未被消费进行流控</p>
<p><code>if(processQueue.getMaxSpan() &gt; 2000)</code>：消费者本地缓存消息第一条消息最后一条消息跨度超过 2000 进行流控</p>
</li>
<li><p><code>SubscriptionData subscriptionData</code>：本次拉消息请求订阅的主题数据，如果调用了 <code>unsubscribe(主题)</code> 将会获取为 null</p>
</li>
<li><p><code>PullCallback pullCallback = new PullCallback()</code>：<strong>拉消息处理回调对象</strong></p>
<ul>
<li><p><code>pullResult = ...processPullResult()</code>：预处理 PullResult 结果，将服务器端指定 MQ 的拉消息<strong>下一次的推荐节点</strong>保存到 pullFromWhichNodeTable 中，<strong>并进行消息过滤</strong></p>
</li>
<li><p><code>case FOUND</code>：正常拉取到消息</p>
<p><code>pullRequest.setNextOffset(pullResult.getNextBeginOffset())</code>：更新 pullRequest 对象下一次拉取消息的位点</p>
<p><code>if (pullResult.getMsgFoundList() == null...)</code>：消息过滤导致消息全部被过滤掉，需要立马发起下一次拉消息</p>
<p><code>boolean .. = processQueue.putMessage()</code>：将服务器拉取的消息集合<strong>加入到消费者本地</strong>的 processQueue 内</p>
<p><code>DefaultMQPushConsumerImpl...submitConsumeRequest()</code>：<strong>提交消费任务，分为顺序消费和并发消费</strong></p>
<p><code>Defaul..executePullRequestImmediately(pullRequest)</code>：将更新过 nextOffset 字段的 PullRequest 对象，再次放到 pullMessageService 的阻塞队列中，<strong>形成闭环</strong></p>
</li>
<li><p><code>case NO_NEW_MSG ||NO_MATCHED_MSG</code>：<strong>表示本次 pull 没有新的可消费的信息</strong></p>
<p><code>pullRequest.setNextOffset()</code>：更新更新 pullRequest 对象下一次拉取消息的位点</p>
<p><code>Defaul..executePullRequestImmediately(pullRequest)</code>：再次拉取请求</p>
</li>
<li><p><code>case OFFSET_ILLEGAL</code>：<strong>本次 pull 时使用的 offset 是无效的</strong>，即 offset &gt; maxOffset || offset  &lt; minOffset</p>
<p><code>pullRequest.setNextOffset()</code>：调整 pullRequest.nextOffset 为正确的 offset</p>
<p><code>pullRequest.getProcessQueue().setDropped(true)</code>：设置该 processQueue 为删除状态，如果有该 queue 的消费任务，消费任务会马上停止</p>
<p><code>DefaultMQPushConsumerImpl.this.executeTaskLater()</code>：提交异步任务，10 秒后去执行</p>
<ul>
<li><p><code>DefaultMQPushConsumerImpl...updateOffset()</code>：更新 offsetStore 该 MQ 的 offset 为正确值，内部直接替换</p>
</li>
<li><p><code>DefaultMQPushConsumerImpl...persist()</code>：持久化该 messageQueue 的 offset 到 Broker 端</p>
</li>
<li><p><code>DefaultMQPushConsumerImpl...removeProcessQueue()</code>： 删除该消费者该 messageQueue 对应的 processQueue</p>
</li>
<li><p>这里没有再次提交 pullRequest 到 pullMessageService 的队列，那该队列不再拉消息了吗？</p>
<p>负载均衡 rbl 程序会重建该队列的 processQueue，重建完之后会为该队列创建新的 PullRequest 对象</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>int sysFlag = PullSysFlag.buildSysFlag()</code>：<strong>构建标志对象</strong>，sysFlag 高 4 位未使用，低 4 位使用，从左到右 0000 0011</p>
<ul>
<li>第一位：表示是否提交消费者本地该队列的 offset，一般是 1</li>
<li>第二位：表示是否允许服务器端进行长轮询，一般是 1</li>
<li>第三位：表示是否提交消费者本地该主题的订阅数据，一般是 0</li>
<li>第四位：表示是否为类过滤，一般是 0</li>
</ul>
</li>
<li><p><code>this.pullAPIWrapper.pullKernelImpl()</code>：拉取消息的核心方法</p>
</li>
</ul>
<hr>
<h5 id="封装对象"><a href="#封装对象" class="headerlink" title="封装对象"></a>封装对象</h5><p>PullAPIWrapper 类封装了拉取消息的 API</p>
<p>成员变量：</p>
<ul>
<li><p>推荐拉消息使用的主机 ID：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ConcurrentMap&lt;MessageQueue, AtomicLong<span class="comment">/* brokerId */</span>&gt; pullFromWhichNodeTable</span><br></pre></td></tr></table></figure></li>
</ul>
<p>成员方法：</p>
<ul>
<li><p>pullKernelImpl()：拉消息</p>
<ul>
<li><p><code>FindBrokerResult findBrokerResult</code>：<strong>本地查询指定 BrokerName 的地址信息</strong>，推荐节点或者主节点</p>
</li>
<li><p><code>if (null == findBrokerResult)</code>：查询不到，就到 Namesrv 获取指定 topic 的路由数据</p>
</li>
<li><p><code>if (findBrokerResult.isSlave())</code>：成立说明 findBrokerResult 表示的主机为 slave 节点，<strong>slave 不存储 offset 信息</strong></p>
<p><code>sysFlagInner = PullSysFlag.clearCommitOffsetFlag(sysFlagInner)</code>：将 sysFlag 标记位中 CommitOffset 的位置为 0</p>
</li>
<li><p><code>PullMessageRequestHeader requestHeader</code>：创建请求头对象，封装所有的参数</p>
</li>
<li><p><code>PullResult pullResult = this.mQClientFactory.getMQClientAPIImpl().pullMessage()</code>：调用客户端实例的方法，核心逻辑就是<strong>将业务数据转化为 RemotingCommand  通过 NettyRemotingClient 的 IO 进行通信</strong></p>
<ul>
<li><p><code>RemotingCommand request</code>：创建网络层传输对象 RemotingCommand 对象，<strong>请求 ID 为 <code>PULL_MESSAGE = 11</code></strong></p>
</li>
<li><p><code>return this.pullMessageSync(...)</code>：此处是<strong>异步调用，处理结果放入 ResponseFuture 中</strong>，参考服务端小节的处理器类 <code>NettyServerHandler#processMessageReceived</code> 方法</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>RemotingCommand response = responseFuture.getResponseCommand()</code>：获取服务器端响应数据 response</p>
<ul>
<li><code>PullResult pullResult</code>：从 response 内提取出来拉消息结果对象，将响应头 PullMessageResponseHeader 对象中信息<strong>填充到 PullResult 中</strong>，列出两个重要的字段：</li>
<li><code>private Long suggestWhichBrokerId</code>：服务端建议客户端下次 Pull 时选择的 BrokerID</li>
<li><code>private Long nextBeginOffset</code>：客户端下次 Pull 时使用的 offset 信息</li>
</ul>
</li>
<li><p><code>pullCallback.onSuccess(pullResult)</code>：将 PullResult 交给拉消息结果处理回调对象，调用 onSuccess 方法</p>
</li>
</ul>
<hr>
<h4 id="拉取处理"><a href="#拉取处理" class="headerlink" title="拉取处理"></a>拉取处理</h4><h5 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h5><p>BrokerStartup#createBrokerController 方法中创建了 BrokerController 并进行初始化，调用 <code>registerProcessor()</code> 方法将处理器 PullMessageProcessor 注册到 NettyRemotingServer 中，对应的请求 ID 为 <code>PULL_MESSAGE = 11</code>，NettyServerHandler 在处理请求时通过请求 ID 会获取处理器执行 processRequest 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：服务器与客户端 netty 通道； 参数二：客户端请求； 参数三：是否允许服务器端长轮询，默认 true</span></span><br><span class="line"><span class="keyword">private</span> RemotingCommand <span class="title function_">processRequest</span><span class="params">(<span class="keyword">final</span> Channel channel, RemotingCommand request, <span class="type">boolean</span> brokerAllowSuspend)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>RemotingCommand response</code>：创建响应对象，设置为响应类型的请求，响应头是 PullMessageResponseHeader</p>
</li>
<li><p><code>final PullMessageResponseHeader responseHeader</code>：获取响应对象的 header</p>
</li>
<li><p><code>final PullMessageRequestHeader requestHeader</code>：解析出请求头 PullMessageRequestHeader</p>
</li>
<li><p><code>response.setOpaque(request.getOpaque())</code>：设置 opaque 属性，客户端<strong>根据该字段获取 ResponseFuture</strong> 进行处理</p>
</li>
<li><p>进行一些鉴权的逻辑：是否允许长轮询、提交 offset、topicConfig 是否是空、队列 ID 是否合理</p>
</li>
<li><p><code>ConsumerGroupInfo consumerGroupInfo</code>：获取消费者组信息，包含全部的消费者和订阅数据</p>
</li>
<li><p><code>subscriptionData = consumerGroupInfo.findSubscriptionData()</code>：<strong>获取指定主题的订阅数据</strong></p>
</li>
<li><p><code>if (!ExpressionType.isTagType()</code>：表达式匹配</p>
</li>
<li><p><code>MessageFilter messageFilter</code>：创建消息过滤器，一般是通过 tagCode 进行过滤</p>
</li>
<li><p><code>DefaultMessageStore.getMessage()</code>：<strong>查询消息的核心逻辑，在 Broker 端查询消息</strong>（存储端笔记详解了该源码）</p>
</li>
<li><p><code>response.setRemark()</code>：设置此次响应的状态</p>
</li>
<li><p><code>responseHeader.set..</code>：设置响应头对象的一些字段</p>
</li>
<li><p><code>switch (this.brokerController.getMessageStoreConfig().getBrokerRole())</code>：如果当前主机节点角色为 slave 并且<strong>从节点读</strong>并未开启的话，直接给客户端 一个状态 <code>PULL_RETRY_IMMEDIATELY</code>，并设置为下次从主节点读</p>
</li>
<li><p><code>if (this.brokerController.getBrokerConfig().isSlaveReadEnable())</code>：消费太慢，<strong>下次从另一台机器拉取</strong></p>
</li>
<li><p><code>switch (getMessageResult.getStatus())</code>：根据 getMessageResult 的状态设置 response 的 code</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">GetMessageStatus</span> &#123;</span><br><span class="line">    FOUND,					<span class="comment">// 查询成功</span></span><br><span class="line">    NO_MATCHED_MESSAGE,		<span class="comment">// 未查询到到消息，服务端过滤 tagCode</span></span><br><span class="line">    MESSAGE_WAS_REMOVING,	<span class="comment">// 查询时赶上 CommitLog 清理过期文件，导致查询失败，立刻尝试</span></span><br><span class="line">    OFFSET_FOUND_NULL,		<span class="comment">// 查询时赶上 ConsumerQueue 清理过期文件，导致查询失败，【进行长轮询】</span></span><br><span class="line">    OFFSET_OVERFLOW_BADLY,	<span class="comment">// pullRequest.offset 越界 maxOffset</span></span><br><span class="line">    OFFSET_OVERFLOW_ONE,	<span class="comment">// pullRequest.offset == CQ.maxOffset，【进行长轮询】</span></span><br><span class="line">    OFFSET_TOO_SMALL,		<span class="comment">// pullRequest.offset 越界 minOffset</span></span><br><span class="line">    NO_MATCHED_LOGIC_QUEUE,	<span class="comment">// 没有匹配到逻辑队列</span></span><br><span class="line">    NO_MESSAGE_IN_QUEUE,	<span class="comment">// 空队列，创建队列也是因为查询导致，【进行长轮询】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>switch (response.getCode())</code>：根据 response 状态做对应的业务处理</p>
<p><code>case ResponseCode.SUCCESS</code>：查询成功</p>
<ul>
<li><code>final byte[] r = this.readGetMessageResult()</code>：本次 pull 出来的全部消息导入 byte 数组</li>
<li><code>response.setBody(r)</code>：将消息的 byte 数组保存到 response body 字段</li>
</ul>
<p><code>case ResponseCode.PULL_NOT_FOUND</code>：产生这种情况大部分原因是 <code>pullRequest.offset  ==  queue.maxOffset</code>，说明已经没有需要获取的消息，此时如果直接返回给客户端，客户端会立刻重新请求，还是继续返回该状态，频繁拉取服务器导致服务器压力大，所以此处<strong>需要长轮询</strong></p>
<ul>
<li><code>if (brokerAllowSuspend &amp;&amp; hasSuspendFlag)</code>：brokerAllowSuspend &#x3D; true，当长轮询结束再次执行 processRequest 时该参数为 false，所以<strong>每次 Pull 请求至多在服务器端长轮询控制一次</strong></li>
<li><code>PullRequest pullRequest = new PullRequest()</code>：创建长轮询 PullRequest 对象</li>
<li><code>this.brokerController...suspendPullRequest(topic, queueId, pullRequest)</code>：将长轮询请求对象交给长轮询服务<ul>
<li><code>String key = this.buildKey(topic, queueId)</code>：构建一个 <code>topic@queueId</code> 的 key</li>
<li><code>ManyPullRequest mpr = this.pullRequestTable.get(key)</code>：从拉请求表中获取对象</li>
<li><code>mpr.addPullRequest(pullRequest)</code>：<strong>将 PullRequest 对象放入到长轮询的请求集合中</strong></li>
</ul>
</li>
<li><code>response = null</code>：响应设置为 null 内部的 callBack 就不会给客户端发送任何数据，<strong>不进行通信</strong>，否则就又开始重新请求</li>
</ul>
</li>
<li><p><code>boolean storeOffsetEnable</code>：允许长轮询、sysFlag 表示提交消费者本地该队列的offset、当前 broker 节点角色为 master 节点三个条件成立，才<strong>在 Broker 端存储消费者组内该主题的指定 queue 的消费进度</strong></p>
</li>
<li><p><code>return response</code>：返回 response，不为 null 时外层 processRequestCommand 的 callback 会将数据写给客户端</p>
</li>
</ul>
<hr>
<h5 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h5><p>PullRequestHoldService 类负责长轮询，BrokerController#start 方法中调用了 <code>this.pullRequestHoldService.start()</code> 启动该服务</p>
<p>核心方法：</p>
<ul>
<li><p>run()：核心运行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 循环运行</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">            <span class="comment">// 服务器开启长轮询开关：每次循环休眠5秒</span></span><br><span class="line">            <span class="built_in">this</span>.waitForRunning(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 服务器关闭长轮询开关：每次循环休眠1秒</span></span><br><span class="line">            <span class="built_in">this</span>.waitForRunning(...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查持有的请求</span></span><br><span class="line">        <span class="built_in">this</span>.checkHoldRequest();</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>checkHoldRequest()：检查所有的请求</p>
<ul>
<li><code>for (String key : this.pullRequestTable.keySet())</code>：<strong>处理所有的 topic@queueId 的逻辑</strong></li>
<li><code>String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR)</code>：key 按照 @ 拆分，得到 topic 和 queueId</li>
<li><code>long offset = this...getMaxOffsetInQueue(topic, queueId)</code>： 到存储模块查询该 ConsumeQueue 的<strong>最大 offset</strong></li>
<li><code>this.notifyMessageArriving(topic, queueId, offset)</code>：通知消息到达</li>
</ul>
</li>
<li><p>notifyMessageArriving()：<strong>通知消息到达</strong>的逻辑，ReputMessageService 消息分发服务也会调用该方法</p>
<ul>
<li><code>ManyPullRequest mpr = this.pullRequestTable.get(key)</code>：获取对应的的 manyPullRequest 对象</li>
<li><code>List&lt;PullRequest&gt; requestList</code>：获取该队列下的所有 PullRequest，并进行遍历</li>
<li><code>List&lt;PullRequest&gt; replayList</code>：当某个 pullRequest 不超时，并且对应的 <code>CQ.maxOffset &lt;= pullRequest.offset</code>，就将该 PullRequest 再放入该列表</li>
<li><code>long newestOffset</code>：该值为 CQ 的 maxOffset</li>
<li><code>if (newestOffset &gt; request.getPullFromThisOffset())</code>：<strong>请求对应的队列内可以 pull 消息了，结束长轮询</strong></li>
<li><code>boolean match</code>：进行过滤匹配</li>
<li><code>this.brokerController...executeRequestWhenWakeup()</code>：将满足条件的 pullRequest 再次提交到线程池内执行<ul>
<li><code>final RemotingCommand response</code>：执行 processRequest 方法，并且<strong>不会触发长轮询</strong></li>
<li><code>channel.writeAndFlush(response).addListene()</code>：<strong>将结果数据发送给客户端</strong></li>
</ul>
</li>
<li><code>if (System.currentTimeMillis() &gt;= ...)</code>：判断该 pullRequest 是否超时，超时后的也是重新提交到线程池，并且不进行长轮询</li>
<li><code>mpr.addPullRequest(replayList)</code>：将未满足条件的 PullRequest 对象再次添加到 ManyPullRequest 属性中</li>
</ul>
</li>
</ul>
<hr>
<h5 id="结果类"><a href="#结果类" class="headerlink" title="结果类"></a>结果类</h5><p>GetMessageResult 类成员信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetMessageResult</span> &#123;</span><br><span class="line">    <span class="comment">// 查询消息时，最底层都是 mappedFile 支持的查询，查询时返回给外层一个 SelectMappedBufferResult，</span></span><br><span class="line">    <span class="comment">// mappedFile 每查询一次都会 refCount++ ，通过SelectMappedBufferResult持有mappedFile，完成资源释放的句柄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SelectMappedBufferResult&gt; messageMapedList =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;SelectMappedBufferResult&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该List内存储消息，每一条消息都被转成 ByteBuffer 表示了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ByteBuffer&gt; messageBufferList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ByteBuffer&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 查询结果状态</span></span><br><span class="line">    <span class="keyword">private</span> GetMessageStatus status;</span><br><span class="line">    <span class="comment">// 客户端下次再向当前Queue拉消息时，使用的 offset</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> nextBeginOffset;</span><br><span class="line">    <span class="comment">// 当前queue最小offset</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> minOffset;</span><br><span class="line">    <span class="comment">// 当前queue最大offset</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> maxOffset;</span><br><span class="line">    <span class="comment">// 消息总byte大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">bufferTotalSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 服务器建议客户端下次到该 queue 拉消息时是否使用 【从节点】</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">suggestPullingFromSlave</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="队列快照"><a href="#队列快照" class="headerlink" title="队列快照"></a>队列快照</h4><h5 id="成员属性-10"><a href="#成员属性-10" class="headerlink" title="成员属性"></a>成员属性</h5><p>ProcessQueue 类是消费队列的快照</p>
<p>成员变量：</p>
<ul>
<li><p>属性字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">msgCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();	<span class="comment">// 队列中消息数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">msgSize</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();	<span class="comment">// 消息总大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">queueOffsetMax</span> <span class="operator">=</span> <span class="number">0L</span>;				<span class="comment">// 快照中最大 offset</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">dropped</span> <span class="operator">=</span> <span class="literal">false</span>;				<span class="comment">// 快照是否移除</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">lastPullTimestamp</span> <span class="operator">=</span> current;		<span class="comment">// 上一次拉消息的时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">lastConsumeTimestamp</span> <span class="operator">=</span> current;	<span class="comment">// 上一次消费消息的时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">lastLockTimestamp</span> <span class="operator">=</span> current;		<span class="comment">// 上一次获取锁的时间</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>消息容器</strong>：key 是消息偏移量，val 是消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Long, MessageExt&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>顺序消费临时容器</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, MessageExt&gt; consumingMsgOrderlyTreeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Long, MessageExt&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lockTreeMap;		<span class="comment">// 读写锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lockConsume;					<span class="comment">// 重入锁，【顺序消费使用】</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序消费状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="literal">false</span>;		<span class="comment">// 是否是锁定状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">consuming</span> <span class="operator">=</span> <span class="literal">false</span>;		<span class="comment">// 是否是消费中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-9"><a href="#成员方法-9" class="headerlink" title="成员方法"></a>成员方法</h5><p>核心成员方法</p>
<ul>
<li><p>putMessage()：将 Broker 拉取下来的 msgs 存储到快照队列内，返回为 true 表示提交顺序消费任务，false 表示不提交</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">putMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>this.lockTreeMap.writeLock().lockInterruptibly()</code>：获取写锁</p>
</li>
<li><p><code>for (MessageExt msg : msgs)</code>：遍历 msgs 全部加入 msgTreeMap，key 是消息的 queueOffset</p>
</li>
<li><p><code>if (!msgTreeMap.isEmpty() &amp;&amp; !this.consuming)</code>：<strong>消息容器中存在未处理的消息，并且不是消费中的状态</strong></p>
<p><code>dispatchToConsume = true</code>：代表需要提交顺序消费任务</p>
<p><code>this.consuming = true</code>：设置为顺序消费执行中的状态</p>
</li>
<li><p><code>this.lockTreeMap.writeLock().unlock()</code>：释放写锁</p>
</li>
</ul>
</li>
<li><p>removeMessage()：移除已经消费的消息，参数是已经消费的消息集合，并发消费使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">removeMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>long result = -1</code>：结果初始化为 -1 </li>
<li><code>this.lockTreeMap.writeLock().lockInterruptibly()</code>：获取写锁</li>
<li><code>this.lastConsumeTimestamp = now</code>：更新上一次消费消息的时间为现在</li>
<li><code>if (!msgTreeMap.isEmpty())</code>：判断消息容器是否是空，<strong>是空直接返回 -1</strong></li>
<li><code>result = this.queueOffsetMax + 1</code>：设置结果，<strong>删除完后消息容器为空时返回</strong></li>
<li><code>for (MessageExt msg : msgs)</code>：将已经消费的消息全部从 msgTreeMap 移除</li>
<li><code>if (!msgTreeMap.isEmpty())</code>：移除后容器内还有待消费的消息，<strong>获取第一条消息 offset 返回</strong></li>
<li><code>this.lockTreeMap.writeLock().unlock()</code>：释放写锁</li>
</ul>
</li>
<li><p>takeMessages()：获取一批消息，顺序消费使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;MessageExt&gt; <span class="title function_">takeMessages</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> batchSize)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.lockTreeMap.writeLock().lockInterruptibly()</code>：获取写锁</li>
<li><code>this.lastConsumeTimestamp = now</code>：更新上一次消费消息的时间为现在</li>
<li><code>for (int i = 0; i &lt; batchSize; i++)</code>：从头节点开始获取消息</li>
<li><code>result.add(entry.getValue())</code>：将消息放入结果集合</li>
<li><code>consumingMsgOrderlyTreeMap.put()</code>：将消息加入顺序消费容器中</li>
<li><code>if (result.isEmpty())</code>：条件成立说明顺序消费容器本地快照内的消息全部处理完了，<strong>当前顺序消费任务需要停止</strong></li>
<li><code>consuming = false</code>：消费状态置为 false</li>
<li><code>this.lockTreeMap.writeLock().unlock()</code>：释放写锁</li>
</ul>
</li>
<li><p>commit()：处理完一批消息后调用，顺序消费使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">commit</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.lockTreeMap.writeLock().lockInterruptibly()</code>：获取写锁</li>
<li><code>Long offset = this.consumingMsgOrderlyTreeMap.lastKey()</code>：获取顺序消费临时容器最后一条数据的 key</li>
<li><code>msgCount, msgSize</code>：更新顺序消费相关的字段</li>
<li><code>this.consumingMsgOrderlyTreeMap.clear()</code>：清空顺序消费容器的数据</li>
<li><code>return offset + 1</code>：<strong>消费者下一条消费的位点</strong></li>
<li><code>this.lockTreeMap.writeLock().unlock()</code>：释放写锁</li>
</ul>
</li>
<li><p>cleanExpiredMsg()：清除过期消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanExpiredMsg</span><span class="params">(DefaultMQPushConsumer pushConsumer)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>if (pushConsumer.getDefaultMQPushConsumerImpl().isConsumeOrderly()) </code>：顺序消费不执行过期清理逻辑</li>
<li><code>int loop = msgTreeMap.size() &lt; 16 ? msgTreeMap.size() : 16</code>：最多循环 16 次</li>
<li><code>if (!msgTreeMap.isEmpty() &amp;&amp;)</code>：如果容器中第一条消息的消费开始时间与当前系统时间差值 &gt; 15min，则取出该消息</li>
<li><code>else</code>：直接跳出循环，因为<strong>快照队列内的消息是有顺序的</strong>，第一条消息不过期，其他消息都不过期</li>
<li><code>pushConsumer.sendMessageBack(msg, 3)</code>：<strong>消息回退</strong>到服务器，设置该消息的延迟级别为 3</li>
<li><code>if (!msgTreeMap.isEmpty() &amp;&amp; msg.getQueueOffset() == msgTreeMap.firstKey())</code>：条件成立说明消息回退期间，该目标消息并没有被消费任务成功消费</li>
<li><code>removeMessage(Collections.singletonList(msg))</code>：从 treeMap 将该回退成功的 msg 删除</li>
</ul>
</li>
</ul>
<hr>
<h4 id="并发消费"><a href="#并发消费" class="headerlink" title="并发消费"></a>并发消费</h4><h5 id="成员属性-11"><a href="#成员属性-11" class="headerlink" title="成员属性"></a>成员属性</h5><p>ConsumeMessageConcurrentlyService 负责并发消费服务</p>
<p>成员变量：</p>
<ul>
<li><p>消息监听器：封装处理消息的逻辑，该监听器由开发者实现，并注册到 defaultMQPushConsumer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MessageListenerConcurrently messageListener;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; consumeRequestQueue;	<span class="comment">// 消费任务队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String consumerGroup;							<span class="comment">// 消费者组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor consumeExecutor;				<span class="comment">// 消费任务线程池，默认 20</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutorService;<span class="comment">// 调度线程池，延迟提交消费任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService cleanExpireMsgExecutors;	<span class="comment">// 清理过期消息任务线程池，15min 一次</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-10"><a href="#成员方法-10" class="headerlink" title="成员方法"></a>成员方法</h5><p>ConsumeMessageConcurrentlyService 并发消费核心方法</p>
<ul>
<li><p>start()：启动消费服务，DefaultMQPushConsumerImpl 启动时会调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 提交“清理过期消息任务”任务，延迟15min之后执行，之后每15min执行一次</span></span><br><span class="line">    <span class="built_in">this</span>.cleanExpireMsgExecutors.scheduleAtFixedRate(() -&gt;  cleanExpireMsg()&#125;, </span><br><span class="line">                                                     <span class="number">15</span>, <span class="number">15</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cleanExpireMsg()：清理过期消息任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cleanExpireMsg</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Iterator&lt;Map.Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it </code>：获取分配给当前消费者的队列</li>
<li><code>while (it.hasNext())</code>：遍历所有的队列</li>
<li><code>pq.cleanExpiredMsg(this.defaultMQPushConsumer)</code>：调用队列快照 ProcessQueue 清理过期消息的方法</li>
</ul>
</li>
<li><p>submitConsumeRequest()：提交消费请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：从服务器 pull 下来的这批消息</span></span><br><span class="line"><span class="comment">// 参数二：消息归属 mq 在消费者端的 processQueue，提交消费任务之前，msgs已经加入到该pq内了</span></span><br><span class="line"><span class="comment">// 参数三：消息归属队列</span></span><br><span class="line"><span class="comment">// 参数四：并发消息此参数无效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submitConsumeRequest</span><span class="params">(List&lt;MessageExt&gt; msgs, ProcessQueue processQueue, MessageQueue messageQueue, <span class="type">boolean</span> dispatchToConsume)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>final int consumeBatchSize</code>：<strong>一个消费任务可消费的消息数量</strong>，默认为 1</p>
</li>
<li><p><code>if (msgs.size() &lt;= consumeBatchSize)</code>：判断一个消费任务是否可以提交</p>
<p><code>ConsumeRequest consumeRequest</code>：封装为消费请求</p>
<p><code>this.consumeExecutor.submit(consumeRequest)</code>：提交消费任务，异步执行消息的处理</p>
</li>
<li><p><code>else</code>：说明消息较多，需要多个消费任务</p>
<p><code>for (int total = 0; total &lt; msgs.size(); )</code>：将消息拆分成多个消费任务</p>
</li>
</ul>
</li>
<li><p>processConsumeResult()：处理消费结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数一：消费结果状态；  参数二：消费上下文；  参数三：当前消费任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConsumeResult</span><span class="params">(status, context, consumeRequest)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>switch (status)</code>：根据消费结果状态进行处理</p>
</li>
<li><p><code>case CONSUME_SUCCESS</code>：消费成功</p>
<p><code>if (ackIndex &gt;= consumeRequest.getMsgs().size())</code>：消费成功的话，ackIndex 设置成 <code>消费消息数 - 1</code> 的值，比如有 5 条消息，这里就设置为 4</p>
<p><code>ok, failed</code>：ok 设置为消息数量，failed 设置为 0</p>
</li>
<li><p><code>case RECONSUME_LATER</code>：消费失败</p>
<p><code>ackIndex = -1</code>：设置为 -1</p>
</li>
<li><p><code>switch (this.defaultMQPushConsumer.getMessageModel())</code>：判断消费模式，默认是<strong>集群模式</strong></p>
</li>
<li><p><code>for (int i = ackIndex + 1; i &lt; msgs.size(); i++)</code>：当消费失败时 ackIndex 为 -1，i 的起始值为 0，该消费任务内的<strong>全部消息</strong>都会尝试回退给服务器</p>
</li>
<li><p><code>MessageExt msg</code>：提取一条消息</p>
</li>
<li><p><code>boolean result = this.sendMessageBack(msg, context)</code>：<strong>发送消息回退，同步发送</strong></p>
</li>
<li><p><code>if (!result)</code>：回退失败的消息，将<strong>消息的重试属性加 1</strong>，并加入到回退失败的集合</p>
</li>
<li><p><code>if (!msgBackFailed.isEmpty())</code>：回退失败集合不为空</p>
</li>
</ul>
<p><code>consumeRequest.getMsgs().removeAll(msgBackFailed)</code>：将回退失败的消息从当前消费任务的 msgs 集合内移除</p>
<p><code>this.submitConsumeRequestLater()</code>：<strong>回退失败的消息会再次提交消费任务</strong>，延迟 5 秒钟后再次尝试消费</p>
</li>
<li><p><code>long offset = ...removeMessage(msgs)</code>：从 pq 中删除已经消费成功的消息，返回 offset</p>
</li>
<li><p><code>this...getOffsetStore().updateOffset()</code>：更新消费者本地该 mq 的<strong>消费进度</strong></p>
</li>
</ul>
<hr>
<h5 id="消费请求"><a href="#消费请求" class="headerlink" title="消费请求"></a>消费请求</h5><p>ConsumeRequest 是 ConsumeMessageConcurrentlyService 的内部类，是一个 Runnable 任务对象</p>
<p>成员变量：</p>
<ul>
<li><p>分配到该消费任务的消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;MessageExt&gt; msgs;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ProcessQueue processQueue;	<span class="comment">// 消息处理队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MessageQueue messageQueue;	<span class="comment">// 消息队列</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>核心方法：</p>
<ul>
<li><p>run()：执行任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>if (this.processQueue.isDropped())</code>：条件成立说明该 queue 经过 rbl 算法分配到其他的 consumer</li>
<li><code>MessageListenerConcurrently listener</code>：获取消息监听器</li>
<li><code>ConsumeConcurrentlyContext context</code>：创建消费上下文对象</li>
<li><code>defaultMQPushConsumerImpl.resetRetryAndNamespace()</code>：重置重试标记<ul>
<li><code>final String groupTopic</code>：获取当前消费者组的重试主题 <code>%RETRY%GroupName</code></li>
<li><code>for (MessageExt msg : msgs)</code>：遍历所有的消息</li>
<li><code>String retryTopic = msg.getProperty(...)</code>：原主题，一般消息没有该属性，只有被重复消费的消息才有</li>
<li><code>if (retryTopic != null &amp;&amp; groupTopic.equals(...))</code>：条件成立说明该消息是被重复消费的消息</li>
<li><code>msg.setTopic(retryTopic)</code>：将被<strong>重复消费的消息主题修改回原主题</strong></li>
</ul>
</li>
<li><code>if (ConsumeMessageConcurrentlyService...hasHook())</code>：前置处理</li>
<li><code>boolean hasException = false</code>：消费过程中，是否向外抛出异常</li>
<li><code>MessageAccessor.setConsumeStartTimeStamp()</code>：给每条消息设置消费开始时间</li>
<li><code>status = listener.consumeMessage(Collections.unmodifiableList(msgs), context)</code>：<strong>消费消息</strong></li>
<li><code>if (ConsumeMessageConcurrentlyService...hasHook())</code>：后置处理</li>
<li><code>...processConsumeResult(status, context, this)</code>：<strong>处理消费结果</strong></li>
</ul>
</li>
</ul>
<hr>
<h4 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h4><h5 id="成员属性-12"><a href="#成员属性-12" class="headerlink" title="成员属性"></a>成员属性</h5><p>ConsumeMessageOrderlyService 负责顺序消费服务</p>
<p>成员变量：</p>
<ul>
<li><p>消息监听器：封装处理消息的逻辑，该监听器由开发者实现，并注册到 defaultMQPushConsumer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MessageListenerOrderly messageListener;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; consumeRequestQueue;	<span class="comment">// 消费任务队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String consumerGroup;							<span class="comment">// 消费者组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stopped</span> <span class="operator">=</span> <span class="literal">false</span>;					<span class="comment">// 消费停止状态</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor consumeExecutor;				<span class="comment">// 消费任务线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutorService;<span class="comment">// 调度线程池，延迟提交消费任务</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>队列锁：消费者本地 MQ 锁，<strong>确保本地对于需要顺序消费的 MQ 同一时间只有一个任务在执行</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">MessageQueueLock</span> <span class="variable">messageQueueLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueueLock</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageQueueLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;MessageQueue, Object&gt; mqLockTable = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;MessageQueue, Object&gt;();</span><br><span class="line">    <span class="comment">// 获取本地队列锁对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">fetchLockObject</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mqLockTable.get(mq);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == objLock) &#123;</span><br><span class="line">            objLock = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">prevLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mqLockTable.putIfAbsent(mq, objLock);</span><br><span class="line">            <span class="keyword">if</span> (prevLock != <span class="literal">null</span>) &#123;</span><br><span class="line">                objLock = prevLock;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已经获取了 Broker 端该 Queue 的独占锁，为什么还要获取本地队列锁对象？（这里我也没太懂，先记录下来，本地多线程？）</p>
<ul>
<li>Broker queue 占用锁的角度是 Client 占用，Client 从 Broker 的某个占用了锁的 queue 拉取下来消息以后，将消息存储到消费者本地的 ProcessQueue 中，快照对象的 consuming 属性置为 true，表示本地的队列正在消费处理中</li>
<li>ProcessQueue  调用 takeMessages 方法时会获取下一批待处理的消息，获取不到会修改 <code>consuming = false</code>，本消费任务马上停止。</li>
<li>如果此时 Pull 再次拉取一批当前 ProcessQueue  的 msg，会再次向顺序消费服务提交消费任务，此时需要本地队列锁对象同步本地线程</li>
</ul>
</li>
</ul>
<hr>
<h5 id="成员方法-11"><a href="#成员方法-11" class="headerlink" title="成员方法"></a>成员方法</h5><ul>
<li><p>start()：启动消费服务，DefaultMQPushConsumerImpl 启动时会调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.scheduledExecutorService.scheduleAtFixedRate()</code>：提交锁续约任务，延迟 1 秒执行，周期为 20 秒钟</li>
<li><code>ConsumeMessageOrderlyService.this.lockMQPeriodically()</code>：<strong>锁续约任务</strong><ul>
<li><code>this.defaultMQPushConsumerImpl.getRebalanceImpl().lockAll()</code>：对消费者的所有队列进行续约</li>
</ul>
</li>
</ul>
</li>
<li><p>submitConsumeRequest()：<strong>提交消费任务请求</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：true 表示创建消费任务并提交，false不创建消费任务，说明消费者本地已经有消费任务在执行了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submitConsumeRequest</span><span class="params">(...., <span class="keyword">final</span> <span class="type">boolean</span> dispathToConsume)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dispathToConsume) &#123;</span><br><span class="line">        <span class="comment">// 当前进程内不存在 顺序消费任务，创建新的消费任务，【提交到消费任务线程池】</span></span><br><span class="line">        <span class="type">ConsumeRequest</span> <span class="variable">consumeRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumeRequest</span>(processQueue, messageQueue);</span><br><span class="line">        <span class="built_in">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>processConsumeResult()：消费结果处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数1：msgs 本轮循环消费的消息集合    					参数2：status  消费状态</span></span><br><span class="line"><span class="comment">// 参数3：context 消费上下文 							参数4：消费任务</span></span><br><span class="line"><span class="comment">// 返回值：boolean 决定是否继续循环处理pq内的消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processConsumeResult</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs, <span class="keyword">final</span> ConsumeOrderlyStatus status, <span class="keyword">final</span> ConsumeOrderlyContext context, <span class="keyword">final</span> ConsumeRequest consumeRequest)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>if (context.isAutoCommit()) </code>：默认自动提交</p>
</li>
<li><p><code>switch (status)</code>：根据消费状态进行不同的处理</p>
</li>
<li><p><code>case SUCCESS</code>：消费成功</p>
<p><code>commitOffset = ...commit()</code>：调用 pq 提交方法，会将本次循环处理的消息从顺序消费 map 删除，并且返回消息进度</p>
</li>
<li><p><code>case SUSPEND_CURRENT_QUEUE_A_MOMENT</code>：挂起当前队列</p>
<p><code>consumeRequest.getProcessQueue().makeMessageToConsumeAgain(msgs)</code>：<strong>回滚消息</strong></p>
<ul>
<li><code>for (MessageExt msg : msgs)</code>：遍历所有的消息</li>
<li><code>this.consumingMsgOrderlyTreeMap.remove(msg.getQueueOffset())</code>：从顺序消费临时容器中移除</li>
<li><code>this.msgTreeMap.put(msg.getQueueOffset(), msg)</code>：添加到消息容器</li>
</ul>
</li>
<li><p><code>this.submitConsumeRequestLater()</code>：再次提交消费任务，1 秒后执行</p>
</li>
<li><p><code>continueConsume = false</code>：设置为 false，<strong>外层会退出本次的消费任务</strong></p>
</li>
<li><p><code>this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(...)</code>：更新本地消费进度</p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="消费请求-1"><a href="#消费请求-1" class="headerlink" title="消费请求"></a>消费请求</h5><p>ConsumeRequest 是 ConsumeMessageOrderlyService 的内部类，是一个 Runnable 任务对象</p>
<p>核心方法：</p>
<ul>
<li><p>run()：执行任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>final Object objLock</code>：获取本地锁对象</p>
</li>
<li><p><code>synchronized (objLock)</code>：本地队列锁，确保每个 MQ 的消费任务只有一个在执行，<strong>确保顺序消费</strong></p>
</li>
<li><p><code>if(.. || (this.processQueue.isLocked() &amp;&amp; !this.processQueue.isLockExpired())))</code>：当前队列持有分布式锁，并且锁未过期，持锁时间超过 30 秒算过期</p>
</li>
<li><p><code>final long beginTime</code>：消费开始时间</p>
</li>
<li><p><code>for (boolean continueConsume = true; continueConsume; )</code>：根据是否继续消费的标记判断是否继续</p>
</li>
<li><p><code>final int consumeBatchSize</code>：获取每次循环处理的消息数量，一般是 1</p>
</li>
<li><p><code>List&lt;MessageExt&gt; msgs = this...takeMessages(consumeBatchSize)</code>：到<strong>处理队列获取一批消息</strong></p>
</li>
<li><p><code>if (!msgs.isEmpty())</code>：获取到了待消费的消息</p>
<p><code>final ConsumeOrderlyContext context</code>：创建消费上下文对象</p>
<p><code>this.processQueue.getLockConsume().lock()</code>：<strong>获取 lockConsume 锁</strong>，与 RBL 线程同步使用</p>
<p><code>status = messageListener.consumeMessage(...)</code>：监听器处理消息 </p>
<p><code>this.processQueue.getLockConsume().unlock()</code>：<strong>释放 lockConsume 锁</strong></p>
<p><code>if (null == status)</code>：处理消息状态返回 null，设置状态为挂起当前队列</p>
<p><code>continueConsume = ...processConsumeResult()</code>：消费结果处理</p>
</li>
<li><p><code>else</code>：获取到的消息是空</p>
<p><code>continueConsume = false</code>：结束任务循环</p>
</li>
<li><p><code>else</code>：当前队列未持有分布式锁，或者锁过期</p>
<p><code>ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume()</code>：重新提交任务，根据是否获取到队列锁，选择延迟 10 毫秒或者 300 毫秒</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="生产消费-1"><a href="#生产消费-1" class="headerlink" title="生产消费"></a>生产消费</h3><p>生产流程：</p>
<ul>
<li>首先获取当前消息主题的发布信息，获取不到去 Namesrv 获取（默认有 TBW102），并将获取的到的路由数据转化为发布数据，<strong>创建 MQ 队列</strong>，客户端实例同样更新订阅数据，创建 MQ 队列，放入负载均衡服务 topicSubscribeInfoTable 中</li>
<li>然后从发布数据中选择一个 MQ 队列发送消息</li>
<li>Broker 端通过 SendMessageProcessor 对发送的消息进行持久化处理，存储到 CommitLog。将重试次数过多的消息加入<strong>死信队列</strong>，将延迟消息的主题和队列修改为调度主题和调度队列 ID</li>
<li>Broker 启动 ScheduleMessageService 服务会为每个延迟级别创建一个延迟任务，让延迟消息得到有效的处理，将到达交付时间的消息修改为原始主题的原始 ID 存入 CommitLog，消费者就可以进行消费了</li>
</ul>
<p>消费流程：</p>
<ul>
<li>首先通过负载均衡服务，将分配到当前消费者实例的 MQ 创建 PullRequest，并放入 PullMessageService 的本地阻塞队列内</li>
<li>PullMessageService 循环从阻塞队列获取请求对象，发起拉消息请求，并创建 PullCallback 回调对象，将正常拉取的消息<strong>提交到消费任务线程池</strong>，并设置请求的下一次拉取位点，重新放入阻塞队列，形成闭环</li>
<li>消费任务服务对消费失败的消息进行回退，回退失败的消息会再次提交消费任务重新消费</li>
<li>Broker 端对拉取消息的请求进行处理（processRequestCommand），查询成功将消息放入响应体，通过 Netty 写回客户端，当 <code>pullRequest.offset == queue.maxOffset</code> 说明该队列已经没有需要获取的消息，将请求放入长轮询集合等待有新消息</li>
<li>PullRequestHoldService 负责长轮询，每 5 秒遍历一次长轮询集合，将满足条件的 PullRequest 再次提交到线程池内处理</li>
</ul>
<hr>
<h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><h2 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="框架特征"><a href="#框架特征" class="headerlink" title="框架特征"></a>框架特征</h3><p>Zookeeper 是 Apache Hadoop 项目子项目，为分布式框架提供协调服务，是一个树形目录服务</p>
<p>Zookeeper 是基于观察者模式设计的分布式服务管理框架，负责存储和管理共享数据，接受观察者的注册监控，一旦这些数据的状态发生变化，Zookeeper 会通知观察者</p>
<ul>
<li>Zookeeper 是一个领导者（Leader），多个跟随者（Follower）组成的集群</li>
<li>集群中只要有半数以上节点存活就能正常服务，所以 Zookeeper 适合部署奇数台服务器</li>
<li><strong>全局数据一致</strong>，每个 Server 保存一份相同的数据副本，Client 无论连接到哪个 Server，数据都是一致</li>
<li>更新的请求顺序执行，来自同一个 Client 的请求按其发送顺序依次执行</li>
<li><strong>数据更新原子性</strong>，一次数据更新要么成功，要么失败</li>
<li>实时性，在一定的时间范围内，Client 能读到最新数据</li>
<li>心跳检测，会定时向各个服务提供者发送一个请求（实际上建立的是一个 Socket 长连接）</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84.png"></p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1to4y1C7gw">https://www.bilibili.com/video/BV1to4y1C7gw</a></p>
<hr>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>Zookeeper 提供的主要功能包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡、分布式锁等</p>
<ul>
<li><p>在分布式环境中，经常对应用&#x2F;服务进行统一命名，便于识别，例如域名相对于 IP 地址更容易被接收</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/service/www.baidu.com 		<span class="comment"># 节点路径</span></span><br><span class="line">192.168.1.1  192.168.1.2	<span class="comment"># 节点值</span></span><br></pre></td></tr></table></figure>

<p>如果在节点中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求，可以实现负载均衡</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">192.168.1.1  10	<span class="comment"># 次数</span></span><br><span class="line">192.168.1.1  15</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件同步可以通过 Zookeeper 实现，将配置信息写入某个 ZNode，其他客户端监视该节点，当节点数据被修改，通知各个客户端服务器</p>
</li>
<li><p>集群环境中，需要实时掌握每个集群节点的状态，可以将这些信息放入 ZNode，通过监控通知的机制实现</p>
</li>
<li><p>实现客户端实时观察服务器上下线的变化，通过心跳检测实现</p>
</li>
</ul>
<hr>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="安装搭建"><a href="#安装搭建" class="headerlink" title="安装搭建"></a>安装搭建</h3><p>安装步骤：</p>
<ul>
<li><p>安装 JDK</p>
</li>
<li><p>拷贝 apache-zookeeper-3.5.7-bin.tar.gz 安装包到 Linux 系统下，并解压到指定目录</p>
</li>
<li><p>conf 目录下的配置文件重命名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim zoo.cfg</span><br><span class="line"><span class="comment"># 修改内容</span></span><br><span class="line">dataDir=/home/seazean/SoftWare/zookeeper-3.5.7/zkData </span><br></pre></td></tr></table></figure>
</li>
<li><p>在对应目录创建 zkData 文件夹：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> zkData</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Zookeeper 中的配置文件 zoo.cfg 中参数含义解读： </p>
<ul>
<li>tickTime &#x3D; 2000：通信心跳时间，<strong>Zookeeper 服务器与客户端心跳</strong>时间，单位毫秒</li>
<li>initLimit &#x3D; 10：Leader 与 Follower 初始通信时限，初始连接时能容忍的最多心跳次数</li>
<li>syncLimit &#x3D; 5：Leader 与 Follower 同步通信时限，LF 通信时间超过 <code>syncLimit * tickTime</code>，Leader 认为 Follwer 下线</li>
<li>dataDir：保存 Zookeeper 中的数据目录，默认是 tmp目录，容易被 Linux 系统定期删除，所以建议修改</li>
<li>clientPort &#x3D; 2181：客户端连接端口，通常不做修改</li>
</ul>
<hr>
<h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>Linux 命令：</p>
<ul>
<li><p>启动 ZooKeeper 服务：<code>./zkServer.sh start</code></p>
</li>
<li><p>查看 ZooKeeper 服务：<code>./zkServer.sh status</code></p>
</li>
<li><p>停止 ZooKeeper 服务：<code>./zkServer.sh stop</code></p>
</li>
<li><p>重启 ZooKeeper 服务：<code>./zkServer.sh restart </code></p>
</li>
<li><p>查看进程是否启动：<code>jps</code></p>
</li>
</ul>
<hr>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>Linux 命令：</p>
<ul>
<li><p>连接 ZooKeeper 服务端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./zkCli.sh					<span class="comment"># 直接启动</span></span><br><span class="line">./zkCli.sh –server ip:port	<span class="comment"># 指定 host 启动</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>客户端命令：</p>
<ul>
<li><p>基础操作：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">quit						<span class="comment"># 停止连接</span></span><br><span class="line"><span class="built_in">help</span>						<span class="comment"># 查看命令帮助</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建命令：**<code>/</code> 代表根目录**</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">create /path value			<span class="comment"># 创建节点，value 可选</span></span><br><span class="line">create -e /path value		<span class="comment"># 创建临时节点</span></span><br><span class="line">create -s /path value		<span class="comment"># 创建顺序节点</span></span><br><span class="line">create -es /path value  	<span class="comment"># 创建临时顺序节点，比如node10000012 删除12后也会继续从13开始，只会增加</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查询命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /path					<span class="comment"># 显示指定目录下子节点</span></span><br><span class="line"><span class="built_in">ls</span> –s /path					<span class="comment"># 查询节点详细信息</span></span><br><span class="line"><span class="built_in">ls</span> –w /path					<span class="comment"># 监听子节点数量的变化</span></span><br><span class="line"><span class="built_in">stat</span> /path					<span class="comment"># 查看节点状态</span></span><br><span class="line">get –s /path				<span class="comment"># 查询节点详细信息</span></span><br><span class="line">get –w /path				<span class="comment"># 监听节点数据的变化</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 属性，分为当前节点的属性和子节点属性</span></span><br><span class="line">czxid: 节点被创建的事务ID, 是ZooKeeper中所有修改总的次序，每次修改都有唯一的 zxid，谁小谁先发生</span><br><span class="line">ctime: 被创建的时间戳</span><br><span class="line">mzxid: 最后一次被更新的事务ID </span><br><span class="line">mtime: 最后修改的时间戳</span><br><span class="line">pzxid: 子节点列表最后一次被更新的事务ID</span><br><span class="line">cversion: 子节点的变化号，修改次数</span><br><span class="line">dataversion: 节点的数据变化号，数据的变化次数</span><br><span class="line">aclversion: 节点的访问控制列表变化号</span><br><span class="line">ephemeralOwner: 用于临时节点，代表节点拥有者的 session <span class="built_in">id</span>，如果为持久节点则为0 </span><br><span class="line">dataLength: 节点存储的数据的长度 </span><br><span class="line">numChildren: 当前节点的子节点数量</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">delete /path				<span class="comment"># 删除节点</span></span><br><span class="line">deleteall /path				<span class="comment"># 递归删除节点</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>ZooKeeper 是一个树形目录服务，类似 Unix 的文件系统，每一个节点都被称为 ZNode，每个 ZNode 默认存储 1MB 的数据，节点上会保存数据和节点信息，每个 ZNode 都可以通过其路径唯一标识</p>
<p>节点可以分为四大类：</p>
<ul>
<li>PERSISTENT：持久化节点 </li>
<li>EPHEMERAL：临时节点，客户端和服务器端<strong>断开连接</strong>后，创建的节点删除</li>
<li>PERSISTENT_SEQUENTIAL：持久化顺序节点，创建 znode 时设置顺序标识，节点名称后会附加一个值，<strong>顺序号是一个单调递增的计数器</strong>，由父节点维护</li>
<li>EPHEMERAL_SEQUENTIAL：临时顺序节点</li>
</ul>
<p>注意：在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-%E8%8A%82%E7%82%B9%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.png"></p>
<hr>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><p>添加 Maven 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数一：连接地址</span></span><br><span class="line">    <span class="comment">// 参数二：会话超时时间</span></span><br><span class="line">    <span class="comment">// 参数三：监听器</span></span><br><span class="line">    <span class="type">ZooKeeper</span> <span class="variable">zkClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">&quot;192.168.3.128:2181&quot;</span>, <span class="number">20000</span>, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;监听处理函数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="集群介绍"><a href="#集群介绍" class="headerlink" title="集群介绍"></a>集群介绍</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>Zookeepe 集群三个角色：</p>
<ul>
<li><p>Leader 领导者：处理客户端<strong>事务请求</strong>，负责集群内部各服务器的调度</p>
</li>
<li><p>Follower 跟随者：处理客户端非事务请求，转发事务请求给 Leader 服务器，参与 Leader 选举投票</p>
</li>
<li><p>Observer 观察者：观察集群的最新状态的变化，并将这些状态进行同步；处理非事务性请求，事务性请求会转发给 Leader 服务器进行处理；不会参与任何形式的投票。只提供非事务性的服务，通常用于在不影响集群事务处理能力的前提下，提升集群的非事务处理能力（提高集群读的能力，但是也降低了集群选主的复杂程度）</p>
</li>
</ul>
<p>相关属性：</p>
<ul>
<li><p>SID：服务器 ID，用来唯一标识一台集群中的机器，和 myid 一致</p>
</li>
<li><p>ZXID：事务 ID，用来标识一次服务器状态的变更，在某一时刻集群中每台机器的 ZXID 值不一定完全一致，这和 ZooKeeper 服务器对于客户端更新请求的处理逻辑有关</p>
</li>
<li><p>Epoch：每个 Leader 任期的代号，同一轮选举投票过程中的该值是相同的，投完一次票就增加</p>
</li>
</ul>
<p>选举机制：半数机制，超过半数的投票就通过</p>
<ul>
<li><p>第一次启动选举规则：投票过半数时，服务器 ID 大的胜出</p>
</li>
<li><p>第二次启动选举规则：</p>
<ul>
<li>EPOCH 大的直接胜出</li>
<li>EPOCH 相同，事务 ID 大的胜出（事务 ID 越大，数据越新）</li>
<li>事务 ID 相同，服务器 ID 大的胜出</li>
</ul>
</li>
</ul>
<hr>
<h3 id="初次选举"><a href="#初次选举" class="headerlink" title="初次选举"></a>初次选举</h3><p>选举过程：</p>
<ul>
<li>服务器 1 启动，发起一次选举，服务器 1 投自己一票，票数不超过半数，选举无法完成，服务器 1 状态保持为 LOOKING</li>
<li>服务器 2 启动，再发起一次选举，服务器 1 和 2 分别投自己一票并<strong>交换选票信息</strong>，此时服务器 1 会发现服务器 2 的 SID 比自己投票推举的（服务器 1）大，更改选票为推举服务器 2。投票结果为服务器 1 票数 0 票，服务器 2 票数 2 票，票数不超过半数，选举无法完成，服务器 1、2 状态保持 LOOKING</li>
<li>服务器 3 启动，发起一次选举，此时服务器 1 和 2 都会更改选票为服务器 3，投票结果为服务器 3 票数 3 票，此时服务器 3 的票数已经超过半数，服务器 3 当选 Leader，服务器 1、2 更改状态为 FOLLOWING，服务器 3 更改状态为 LEADING</li>
<li>服务器 4 启动，发起一次选举，此时服务器 1、2、3 已经不是 LOOKING 状态，不会更改选票信息，交换选票信息结果后服务器 3 为 3 票，服务器 4 为 1 票，此时服务器 4 更改选票信息为服务器 3，并更改状态为 FOLLOWING</li>
<li>服务器 5 启动，同 4 一样</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-%E5%88%9D%E6%AC%A1%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6.png"></p>
<hr>
<h3 id="再次选举"><a href="#再次选举" class="headerlink" title="再次选举"></a>再次选举</h3><p>ZooKeeper 集群中的一台服务器出现以下情况之一时，就会开始进入 Leader 选举：</p>
<ul>
<li>服务器初始化启动</li>
<li>服务器运行期间无法和 Leader 保持连接</li>
</ul>
<p>当一台服务器进入 Leader 选举流程时，当前集群可能会处于以下两种状态：</p>
<ul>
<li><p>集群中本来就已经存在一个 Leader，服务器试图去选举 Leader 时会被告知当前服务器的 Leader 信息，对于该服务器来说，只需要和 Leader 服务器建立连接，并进行状态同步即可</p>
</li>
<li><p>集群中确实不存在 Leader，假设服务器 3 和 5 出现故障，开始进行 Leader 选举，SID 为 1、2、4 的机器投票情况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(EPOCH，ZXID，SID): (1, 8, 1), (1, 8, 2), (1, 7, 4)</span><br></pre></td></tr></table></figure>

<p>根据选举规则，服务器 2 胜出</p>
</li>
</ul>
<hr>
<h3 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h3><p>写操作就是事务请求，写入请求直接发送给 Leader 节点：Leader 会先将数据写入自身，同时通知其他 Follower 写入，<strong>当集群中有半数以上节点写入完成</strong>，Leader 节点就会响应客户端数据写入完成</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-写入请求Leader.png" style="zoom: 50%;">

<p>写入请求直接发送给 Follower 节点：Follower 没有写入权限，会将写请求转发给 Leader，Leader 将数据写入自身，通知其他 Follower 写入，当集群中有半数以上节点写入完成，Leader 会通知 Follower 写入完成，<strong>由 Follower 响应客户端数据写入完成</strong></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-写入请求Follower.png" style="zoom:50%;">





<hr>
<h2 id="底层协议"><a href="#底层协议" class="headerlink" title="底层协议"></a>底层协议</h2><h3 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h3><p>Paxos 算法：基于消息传递且具有高度容错特性的一致性算法</p>
<p>优点：快速正确的在一个分布式系统中对某个数据值达成一致，并且保证不论发生任何异常，都不会破坏整个系统的一致性</p>
<p>缺陷：在网络复杂的情况下，可能很久无法收敛，甚至陷入活锁的情况</p>
<hr>
<h3 id="ZAB"><a href="#ZAB" class="headerlink" title="ZAB"></a>ZAB</h3><h4 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h4><p>ZAB 协议借鉴了 Paxos 算法，是为 Zookeeper 设计的支持崩溃恢复的原子广播协议，基于该协议 Zookeeper 设计为只有一台客户端（Leader）负责处理外部的写事务请求，然后 Leader 将数据同步到其他 Follower 节点</p>
<p>Zab 协议包括两种基本的模式：消息广播、崩溃恢复</p>
<hr>
<h4 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h4><p>ZAB 协议针对事务请求的处理过程类似于一个<strong>两阶段提交</strong>过程：广播事务阶段、广播提交操作</p>
<ul>
<li>客户端发起写操作请求，Leader 服务器将请求转化为事务 Proposal 提案，同时为 Proposal 分配一个全局的 ID，即 ZXID</li>
<li>Leader 服务器为每个 Follower 分配一个单独的队列，将广播的 Proposal <strong>依次放到队列</strong>中去，根据 FIFO 策略进行消息发送</li>
<li>Follower 接收到 Proposal 后，将其以事务日志的方式写入本地磁盘中，写入成功后向 Leader 反馈一个 ACK 响应消息</li>
<li>Leader 接收到超过半数以上 Follower 的 ACK 响应消息后，即认为消息发送成功，可以发送 Commit 消息</li>
<li>Leader 向所有 Follower 广播 commit 消息，同时自身也会完成事务提交，Follower 接收到 Commit 后，将上一条事务提交</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-消息广播.png" style="zoom:67%;">

<p>两阶段提交模型可能因为 Leader 宕机带来数据不一致：</p>
<ul>
<li>Leader 发起一个事务 Proposal 后就宕机，Follower 都没有 Proposal</li>
<li>Leader 收到半数 ACK 宕机，没来得及向 Follower 发送 Commit</li>
</ul>
<hr>
<h4 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h4><p>Leader 服务器出现崩溃或者由于网络原因导致 Leader 服务器失去了与<strong>过半 Follower的联系</strong>，那么就会进入崩溃恢复模式，崩溃恢复主要包括两部分：Leader 选举和数据恢复</p>
<p>Zab 协议崩溃恢复要求满足以下两个要求：</p>
<ul>
<li>已经被 Leader 提交的提案 Proposal，必须最终被所有的 Follower 服务器正确提交</li>
<li>丢弃已经被 Leader 提出的，但是没有被提交的 Proposal</li>
</ul>
<p>Zab 协议需要保证选举出来的 Leader 需要满足以下条件：</p>
<ul>
<li>新选举的 Leader 不能包含未提交的 Proposal，即新 Leader 必须都是已经提交了 Proposal 的 Follower 节点</li>
<li>新选举的 Leader 节点含有<strong>最大的 ZXID</strong>，可以避免 Leader 服务器检查 Proposal 的提交和丢弃工作</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-Leader选举.png" style="zoom: 67%;">

<p>数据恢复阶段：</p>
<ul>
<li>完成 Leader 选举后，在正式开始工作之前（接收事务请求提出新的 Proposal），Leader 服务器会首先确认事务日志中的所有 Proposal 是否已经被集群中过半的服务器 Commit</li>
<li>Leader 服务器需要确保所有的 Follower 服务器能够接收到每一条事务的 Proposal，并且能将所有已经提交的事务 Proposal 应用到内存数据中，所以只有当 Follower 将所有尚未同步的事务 Proposal 都<strong>从 Leader 服务器上同步</strong>，并且应用到内存数据后，Leader 才会把该 Follower 加入到真正可用的 Follower 列表中</li>
</ul>
<hr>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>Zab 的事务编号 zxid 设计：</p>
<ul>
<li>zxid 是一个 64 位的数字，低 32 位是一个简单的单增计数器，针对客户端每一个事务请求，Leader 在产生新的 Proposal 事务时，都会对该计数器加 1，而高 32 位则代表了 Leader 周期的 epoch 编号</li>
<li>epoch 为当前集群所处的代或者周期，每次 Leader 变更后都会在 epoch 的基础上加 1，Follower 只服从 epoch 最高的 Leader 命令，所以旧的 Leader 崩溃恢复之后，其他 Follower 就不会继续追随</li>
<li>每次选举产生一个新的 Leader，就会从新 Leader 服务器上取出本地事务日志中最大编号 Proposal 的 zxid，从 zxid 中解析得到对应的 epoch 编号，然后再对其加 1 后作为新的 epoch 值，并将低 32 位数字归零，由 0 开始重新生成 zxid</li>
</ul>
<p>Zab 协议通过 epoch 编号来区分 Leader 变化周期，能够有效避免不同的 Leader 错误的使用了相同的 zxid 编号提出了不一样的 Proposal 的异常情况</p>
<p>Zab 数据同步过程：<strong>数据同步阶段要以 Leader 服务器为准</strong></p>
<ul>
<li>一个包含了上个 Leader 周期中尚未提交过的事务 Proposal 的服务器启动时，这台机器加入集群中会以 Follower 角色连上 Leader</li>
<li>Leader 会根据自己服务器上最后提交的 Proposal 和 Follower 服务器的 Proposal 进行比对，让 Follower 进行一个<strong>回退或者前进操作</strong>，到一个已经被集群中过半机器 Commit 的最新 Proposal（源码解析部分详解）</li>
</ul>
<hr>
<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p>CAP 理论指的是在一个分布式系统中，Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性）不能同时成立，ZooKeeper 保证的是 CP</p>
<ul>
<li>ZooKeeper 不能保证每次服务请求的可用性，在极端环境下可能会丢弃一些请求，消费者程序需要重新请求才能获得结果</li>
<li>进行 Leader 选举时<strong>集群都是不可用</strong></li>
</ul>
<p>CAP 三个基本需求，因为 P 是必须的，因此分布式系统选择就在 CP 或者 AP 中：</p>
<ul>
<li>一致性：指数据在多个副本之间是否能够保持数据一致的特性，当一个系统在数据一致的状态下执行更新操作后，也能保证系统的数据仍然处于一致的状态</li>
<li>可用性：指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果</li>
<li>分区容错性：分布式系统在遇到任何网络分区故障时，仍然能够保证对外提供服务，不会宕机，除非是整个网络环境都发生了故障</li>
</ul>
<hr>
<h2 id="监听机制"><a href="#监听机制" class="headerlink" title="监听机制"></a>监听机制</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>ZooKeeper 中引入了 Watcher 机制来实现了发布&#x2F;订阅功能，客户端注册监听目录节点，在特定事件触发时，ZooKeeper 会通知所有关注该事件的客户端，保证 ZooKeeper 保存的任何的数据的任何改变都能快速的响应到监听应用程序</p>
<p>监听命令：<strong>只能生效一次</strong>，接收一次通知，再次监听需要重新注册</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> –w /path					<span class="comment"># 监听【子节点数量】的变化</span></span><br><span class="line">get –w /path				<span class="comment"># 监听【节点数据】的变化</span></span><br></pre></td></tr></table></figure>

<p>工作流程：</p>
<ul>
<li>在主线程中创建 Zookeeper 客户端，这时就会创建<strong>两个线程</strong>，一个负责网络连接通信（connet），一个负责监听（listener）</li>
<li>通过 connect 线程将注册的监听事件发送给 Zookeeper</li>
<li>在 Zookeeper 的注册监听器列表中将注册的<strong>监听事件添加到列表</strong>中</li>
<li>Zookeeper 监听到有数据或路径变化，将消息发送给 listener 线程</li>
<li>listener 线程内部调用 process() 方法</li>
</ul>
<p>Curator 框架引入了 Cache 来实现对 ZooKeeper 服务端事件的监听，三种 Watcher：</p>
<ul>
<li>NodeCache：只是监听某一个特定的节点</li>
<li>PathChildrenCache：监控一个 ZNode 的子节点</li>
<li>TreeCache：可以监控整个树上的所有节点，类似于 PathChildrenCache 和 NodeCache 的组合</li>
</ul>
<hr>
<h3 id="监听案例"><a href="#监听案例" class="headerlink" title="监听案例"></a>监听案例</h3><h4 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h4><p>客户端实时监听服务器动态上下线</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-监听服务器状态.png" style="zoom:50%;">



<hr>
<h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><p>客户端：先启动客户端进行监听</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributeClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">connectString</span> <span class="operator">=</span> <span class="string">&quot;192.168.3.128:2181&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sessionTimeout</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DistributeClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DistributeClient</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1 获取zk连接</span></span><br><span class="line">        client.getConnect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 监听/servers下面子节点的增加和删除</span></span><br><span class="line">        client.getServerList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 业务逻辑</span></span><br><span class="line">        client.business();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">business</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getServerList</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line">        ArrayList&lt;String&gt; servers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取所有子节点，true 代表触发监听操作</span></span><br><span class="line">        List&lt;String&gt; children = zk.getChildren(<span class="string">&quot;/servers&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line">            <span class="comment">// 获取子节点的数据</span></span><br><span class="line">            <span class="type">byte</span>[] data = zk.getData(<span class="string">&quot;/servers/&quot;</span> + child, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            servers.add(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(servers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        zk = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(connectString, sessionTimeout, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">                getServerList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端：启动时需要 Program arguments</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributeServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">connectString</span> <span class="operator">=</span> <span class="string">&quot;192.168.3.128:2181&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sessionTimeout</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DistributeServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DistributeServer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取 zookeeper 连接</span></span><br><span class="line">        server.getConnect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2  注册服务器到 zk 集群，注意参数</span></span><br><span class="line">        server.register(args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 启动业务逻辑</span></span><br><span class="line">        server.business();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">business</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// OPEN_ACL_UNSAFE: ACL 开放</span></span><br><span class="line">        <span class="comment">// EPHEMERAL_SEQUENTIAL: 临时顺序节点</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">create</span> <span class="operator">=</span> zk.create(<span class="string">&quot;/servers/&quot;</span> + hostname, hostname.getBytes(),</span><br><span class="line">                                  ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        System.out.println(hostname + <span class="string">&quot; is online&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        zk = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(connectString, sessionTimeout, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent event)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>分布式锁可以实现在分布式系统中多个进程有序的访问该临界资源，多个进程之间不会相互干扰</p>
<p>核心思想：当客户端要获取锁，则创建节点，使用完锁，则删除该节点</p>
<ol>
<li><p>客户端获取锁时，在 &#x2F;locks 节点下创建<strong>临时顺序</strong>节点</p>
<ul>
<li>使用临时节点是为了防止当服务器或客户端宕机以后节点无法删除（持久节点），导致锁无法释放</li>
<li>使用顺序节点是为了系统自动编号排序，找最小的节点，防止客户端饥饿现象，保证公平</li>
</ul>
</li>
<li><p>获取 &#x2F;locks 目录的所有子节点，判断自己的<strong>子节点序号是否最小</strong>，成立则客户端获取到锁，使用完锁后将该节点删除</p>
</li>
<li><p>反之客户端需要找到比自己小的节点，<strong>对其注册事件监听器，监听删除事件</strong></p>
</li>
<li><p>客户端的 Watcher 收到删除事件通知，就会重新判断当前节点是否是子节点中序号最小，如果是则获取到了锁， 如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听</p>
</li>
</ol>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86.png"></p>
<hr>
<h3 id="Curator"><a href="#Curator" class="headerlink" title="Curator"></a>Curator</h3><p>Curator 实现分布式锁 API，在 Curator 中有五种锁方案：</p>
<ul>
<li><p>InterProcessSemaphoreMutex：分布式排它锁（非可重入锁）</p>
</li>
<li><p>InterProcessMutex：分布式可重入排它锁</p>
</li>
<li><p>InterProcessReadWriteLock：分布式读写锁</p>
</li>
<li><p>InterProcessMultiLock：将多个锁作为单个实体管理的容器</p>
</li>
<li><p>InterProcessSemaphoreV2：共享信号量</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuratorLock</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CuratorFramework <span class="title function_">getCuratorFramework</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 重试策略对象</span></span><br><span class="line">        <span class="type">ExponentialBackoffRetry</span> <span class="variable">policy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">3000</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 构建客户端</span></span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(<span class="string">&quot;192.168.3.128:2181&quot;</span>)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">2000</span>)	<span class="comment">// 连接超时时间</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">20000</span>)	<span class="comment">// 会话超时时间 单位ms</span></span><br><span class="line">                .retryPolicy(policy)		<span class="comment">// 重试策略</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动客户端</span></span><br><span class="line">        client.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;zookeeper 启动成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建分布式锁1</span></span><br><span class="line">        <span class="type">InterProcessMutex</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(getCuratorFramework(), <span class="string">&quot;/locks&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建分布式锁2</span></span><br><span class="line">        <span class="type">InterProcessMutex</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(getCuratorFramework(), <span class="string">&quot;/locks&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                lock1.acquire();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1 获取到锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                lock1.release();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1 释放锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                lock2.acquire();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2 获取到锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                lock2.release();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2 释放锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><p>服务端程序的入口 QuorumPeerMain</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">QuorumPeerMain</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QuorumPeerMain</span>();</span><br><span class="line">    main.initializeAndRun(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initializeAndRun 的工作：</p>
<ul>
<li><p>解析启动参数</p>
</li>
<li><p>提交周期任务，定时删除过期的快照</p>
</li>
<li><p>初始化通信模型，默认是 NIO 通信</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// QuorumPeerMain#runFromConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runFromConfig</span><span class="params">(QuorumPeerConfig config)</span> &#123;</span><br><span class="line">    <span class="comment">// 通信信组件初始化，默认是 NIO 通信</span></span><br><span class="line">    <span class="type">ServerCnxnFactory</span> <span class="variable">cnxnFactory</span> <span class="operator">=</span> ServerCnxnFactory.createFactory();</span><br><span class="line">    <span class="comment">// 初始化NIO 服务端socket，绑定2181 端口，可以接收客户端请求</span></span><br><span class="line">    cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 启动 zk</span></span><br><span class="line">    quorumPeer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 zookeeper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// QuorumPeer#start</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!getView().containsKey(myid)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;My id &quot;</span> + myid + <span class="string">&quot; not in the peer list&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 冷启动数据恢复，将快照中数据恢复到 DataTree</span></span><br><span class="line">    loadDataBase();</span><br><span class="line">    <span class="comment">// 启动通信工厂实例对象</span></span><br><span class="line">    startServerCnxnFactory();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        adminServer.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AdminServerException e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Problem starting AdminServer&quot;</span>, e);</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 准备选举环境</span></span><br><span class="line">    startLeaderElection();</span><br><span class="line">    <span class="comment">// 执行选举</span></span><br><span class="line">    <span class="built_in">super</span>.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h3><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>QuorumPeer#startLeaderElection 初始化选举环境：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startLeaderElection</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Looking 状态，需要选举</span></span><br><span class="line">        <span class="keyword">if</span> (getPeerState() == ServerState.LOOKING) &#123;</span><br><span class="line">            <span class="comment">// 选票组件: myid (serverid), zxid, epoch</span></span><br><span class="line">            <span class="comment">// 开始选票时，serverid 是自己，【先投自己】</span></span><br><span class="line">            currentVote = <span class="keyword">new</span> <span class="title class_">Vote</span>(myid, getLastLoggedZxid(), getCurrentEpoch());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (electionType == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            udpSocket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(getQuorumAddress().getPort());</span><br><span class="line">            <span class="comment">// 响应投票结果线程</span></span><br><span class="line">            responder = <span class="keyword">new</span> <span class="title class_">ResponderThread</span>();</span><br><span class="line">            responder.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建选举算法实例</span></span><br><span class="line">    <span class="built_in">this</span>.electionAlg = createElectionAlgorithm(electionType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// zk总的发送和接收队列准备好</span></span><br><span class="line"><span class="keyword">protected</span> Election <span class="title function_">createElectionAlgorithm</span><span class="params">(<span class="type">int</span> electionAlgorithm)</span>&#123;</span><br><span class="line">    <span class="comment">// 负责选举过程中的所有网络通信，创建各种队列和集合</span></span><br><span class="line">    <span class="type">QuorumCnxManager</span> <span class="variable">qcm</span> <span class="operator">=</span> createCnxnManager();</span><br><span class="line">    QuorumCnxManager.<span class="type">Listener</span> <span class="variable">listener</span> <span class="operator">=</span> qcm.listener;</span><br><span class="line">    <span class="keyword">if</span>(listener != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 启动监听线程, 调用 client = ss.accept()阻塞，等待处理请求</span></span><br><span class="line">        listener.start();</span><br><span class="line">        <span class="comment">// 准备好发送和接收队列准备</span></span><br><span class="line">        <span class="type">FastLeaderElection</span> <span class="variable">fle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastLeaderElection</span>(<span class="built_in">this</span>, qcm);</span><br><span class="line">        <span class="comment">// 启动选举线程，【WorkerSender 和 WorkerReceiver】</span></span><br><span class="line">        fle.start();</span><br><span class="line">        le = fle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="选举源码"><a href="#选举源码" class="headerlink" title="选举源码"></a>选举源码</h4><p>当 Zookeeper 启动后，首先都是 Looking 状态，通过选举让其中一台服务器成为 Leader</p>
<p>执行 <code>super.start()</code> 相当于执行 <code>QuorumPeer#run()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> LOOKING:</span><br><span class="line">        <span class="comment">// 进行选举，选举结束返回最终成为 Leader 胜选的那张选票</span></span><br><span class="line">        setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FastLeaderElection 类：</p>
<ul>
<li><p>lookForLeader：选举</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Vote <span class="title function_">lookForLeader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 正常启动中其他服务器都会向我发送一个投票，保存每个服务器的最新合法有效的投票</span></span><br><span class="line">    HashMap&lt;Long, Vote&gt; recvset = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Long, Vote&gt;();</span><br><span class="line">	<span class="comment">// 存储合法选举之外的投票结果</span></span><br><span class="line">    HashMap&lt;Long, Vote&gt; outofelection = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Long, Vote&gt;();</span><br><span class="line">	<span class="comment">// 一次选举的最大等待时间，默认值是0.2s</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">notTimeout</span> <span class="operator">=</span> finalizeWait;</span><br><span class="line">	<span class="comment">// 每发起一轮选举，logicalclock++,在没有合法的epoch 数据之前，都使用逻辑时钟代替</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">        <span class="comment">// 更新逻辑时钟，每进行一次选举，都需要更新逻辑时钟</span></span><br><span class="line">        logicalclock.incrementAndGet();</span><br><span class="line">        <span class="comment">// 更新选票(serverid， zxid, epoch）</span></span><br><span class="line">        updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 广播选票，把自己的选票发给其他服务器</span></span><br><span class="line">    sendNotifications();</span><br><span class="line">    <span class="comment">// 一轮一轮的选举直到选举成功</span></span><br><span class="line">    <span class="keyword">while</span> ((self.getPeerState() == ServerState.LOOKING) &amp;&amp; (!stop))&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sendNotifications：广播选票</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendNotifications</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历投票参与者，给每台服务器发送选票</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> sid : self.getCurrentAndNextConfigVoters()) &#123;</span><br><span class="line">		<span class="comment">// 创建发送选票</span></span><br><span class="line">        <span class="type">ToSend</span> <span class="variable">notmsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToSend</span>(...);</span><br><span class="line">        <span class="comment">// 把发送选票放入发送队列</span></span><br><span class="line">        sendqueue.offer(notmsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>FastLeaderElection 中有 WorkerSender 线程：</p>
<ul>
<li><p><code>ToSend m = sendqueue.poll(3000, TimeUnit.MILLISECONDS)</code>：<strong>阻塞获取要发送的选票</strong></p>
</li>
<li><p><code>process(m)</code>：处理要发送的选票</p>
<p><code>manager.toSend(m.sid, requestBuffer)</code>：发送选票</p>
<ul>
<li><p><code>if (this.mySid == sid)</code>：如果<strong>消息的接收者 sid 是自己</strong>，直接进入自己的 RecvQueue（自己投自己）</p>
</li>
<li><p><code>else</code>：如果接收者是其他服务器，创建对应的发送队列或者复用已经存在的发送队列，把消息放入该队列</p>
</li>
<li><p><code>connectOne(sid)</code>：建立连接</p>
<ul>
<li><p><code>sock.connect(electionAddr, cnxTO)</code>：建立与 sid 服务器的连接</p>
</li>
<li><p><code>initiateConnection(sock, sid)</code>：初始化连接</p>
<p><code>startConnection(sock, sid)</code>：创建并启动发送器线程和接收器线程</p>
<ul>
<li><code>dout = new DataOutputStream(buf)</code>：<strong>获取 Socket 输出流</strong>，向服务器发送数据</li>
<li><code>din = new DataInputStream(new BIS(sock.getInputStream())))</code>：通过输入流读取对方发送过来的选票</li>
<li><code>if (sid &gt; self.getId())</code>：接收者 sid 比我的大，没有资格给对方发送连接请求的，直接关闭自己的客户端</li>
<li><code>SendWorker sw</code>：初始化发送器，并启动发送器线程，线程 run 方法<ul>
<li><code>while (running &amp;&amp; !shutdown &amp;&amp; sock != null)</code>：连接没有断开就一直运行</li>
<li><code>ByteBuffer b = pollSendQueue()</code>：从发送队列 SendQueue 中获取发送消息</li>
<li><code>lastMessageSent.put(sid, b)</code>：更新对于 sid 这台服务器的最近一条消息</li>
<li><code>send(b)</code>：<strong>执行发送</strong></li>
</ul>
</li>
<li><code>RecvWorker rw</code>：初始化接收器，并启动接收器线程<ul>
<li><code>din.readFully(msgArray, 0, length)</code>：输入流接收消息</li>
<li><code>addToRecvQueue(new Message(messagg, sid))</code>：将消息放入接收消息 recvQueue 队列</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>FastLeaderElection 中有 WorkerReceiver 线程</p>
<ul>
<li><code>response = manager.pollRecvQueue()</code>：从 RecvQueue 中<strong>阻塞获取出选举投票消息</strong>（其他服务器发送过来的）</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-选举源码.png" style="zoom: 50%;">





<hr>
<h4 id="状态同步"><a href="#状态同步" class="headerlink" title="状态同步"></a>状态同步</h4><p>选举结束后，每个节点都需要根据角色更新自己的状态，Leader 更新状态为 Leader，其他节点更新状态为 Follower，整体流程：</p>
<ul>
<li>Follower 需要让 Leader 知道自己的状态 (sid, epoch, zxid)</li>
<li>Leader 接收到信息，<strong>根据信息构建新的 epoch</strong>，要返回对应的信息给 Follower，Follower 更新自己的 epoch</li>
<li>Leader 需要根据 Follower 的状态，确定何种方式的数据同步 DIFF、TRUNC、SNAP，就是要<strong>以 Leader 服务器数据为准</strong><ul>
<li>DIFF：Leader 提交的 zxid 比 Follower 的 zxid 大，发送 Proposal 给 Follower 提交执行</li>
<li>TRUNC：Follower 的 zxid 比leader 的 zxid 大，Follower 要进行回滚</li>
<li>SNAP：Follower 没有任何数据，直接全量同步</li>
</ul>
</li>
<li>执行数据同步，当 Leader 接收到超过半数 Follower 的 Ack 之后，进入正常工作状态，集群启动完成</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-同步源码.png" style="zoom:50%;">

<p>核心函数解析：</p>
<ul>
<li>Leader 更新状态入口：<code>Leader.lead()</code><ul>
<li><code>zk.loadData()</code>：恢复数据到内存</li>
<li><code>cnxAcceptor = new LearnerCnxAcceptor()</code>：启动通信组件<ul>
<li><code>s = ss.accept()</code>：等待其他 Follower 节点向 Leader 节点发送同步状态</li>
<li><code>LearnerHandler fh </code>：接收到 Follower 的请求，就创建 LearnerHandler 对象</li>
<li><code>fh.start()</code>：启动线程，通过 switch-case 语法判断接收的命令，执行相应的操作</li>
</ul>
</li>
</ul>
</li>
<li>Follower 更新状态入口：<code>Follower.followerLeader()</code><ul>
<li><code>QuorumServer leaderServer = findLeader()</code>：查找 Leader</li>
<li><code>connectToLeader(addr, hostname) </code>：与 Leader 建立连接</li>
<li><code>long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO)</code>：向 Leader 注册</li>
</ul>
</li>
</ul>
<hr>
<h4 id="主从工作"><a href="#主从工作" class="headerlink" title="主从工作"></a>主从工作</h4><p>Leader：主服务的工作流程</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-Leader%E5%90%AF%E5%8A%A8.png"></p>
<p>Follower：从服务的工作流程，核心函数为 <code>Follower#followLeader()</code></p>
<ul>
<li><p><code>readPacket(qp)</code>：读取信息</p>
</li>
<li><p><code>processPacket(qp)</code>：处理信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processPacket</span><span class="params">(QuorumPacket qp)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="keyword">switch</span> (qp.getType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> Leader.PING:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Leader.PROPOSAL:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Leader.COMMIT:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Leader.COMMITANDACTIVATE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Leader.UPTODATE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Leader.REVALIDATE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Leader.SYNC:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Zookeeper-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96.png"></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC</title>
    <url>/2022/01/01/Prog/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>进程：程序是静止的，进程实体的运行过程就是进程，是系统进行<strong>资源分配的基本单位</strong></p>
<span id="more"></span>

<p>进程的特征：并发性、异步性、动态性、独立性、结构性</p>
<p><strong>线程</strong>：线程是属于进程的，是一个基本的 CPU 执行单元，是程序执行流的最小单元。线程是进程中的一个实体，是系统<strong>独立调度的基本单位</strong>，线程本身不拥有系统资源，只拥有一点在运行中必不可少的资源，与同属一个进程的其他线程共享进程所拥有的全部资源</p>
<p>关系：一个进程可以包含多个线程，这就是多线程，比如看视频是进程，图画、声音、广告等就是多个线程</p>
<p>线程的作用：使多道程序更好的并发执行，提高资源利用率和系统吞吐量，增强操作系统的并发性能</p>
<p>并发并行：</p>
<ul>
<li>并行：在同一时刻，有多个指令在多个 CPU 上同时执行</li>
<li>并发：在同一时刻，有多个指令在单个 CPU 上交替执行</li>
</ul>
<p>同步异步：</p>
<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果返回，就能继续运行就是异步</li>
</ul>
<p>参考视频：<a href="https://www.bilibili.com/video/BV16J411h7Rd">https://www.bilibili.com/video/BV16J411h7Rd</a></p>
<p>笔记的整体结构依据视频编写，并随着学习的深入补充了很多知识</p>
<hr>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>线程进程对比：</p>
<ul>
<li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</p>
</li>
<li><p>进程拥有共享的资源，如内存空间等，供其<strong>内部的线程共享</strong></p>
</li>
<li><p>进程间通信较为复杂</p>
<p>同一台计算机的进程通信称为 IPC（Inter-process communication）</p>
<ul>
<li>信号量：信号量是一个计数器，用于多进程对共享数据的访问，解决同步相关的问题并避免竞争条件</li>
<li>共享存储：多个进程可以访问同一块内存空间，需要使用信号量用来同步对共享存储的访问</li>
<li>管道通信：管道是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件 pipe 文件，该文件同一时间只允许一个进程访问，所以只支持<strong>半双工通信</strong><ul>
<li>匿名管道（Pipes）：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信</li>
<li>命名管道（Names Pipes）：以磁盘文件的方式存在，可以实现本机任意两个进程通信，遵循 FIFO</li>
</ul>
</li>
<li>消息队列：内核中存储消息的链表，由消息队列标识符标识，能在不同进程之间提供<strong>全双工通信</strong>，对比管道：<ul>
<li>匿名管道存在于内存中的文件；命名管道存在于实际的磁盘介质或者文件系统；消息队列存放在内核中，只有在内核重启（操作系统重启）或者显示地删除一个消息队列时，该消息队列才被真正删除</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</li>
</ul>
</li>
</ul>
<p>不同计算机之间的<strong>进程通信</strong>，需要通过网络，并遵守共同的协议，例如 HTTP</p>
<ul>
<li>套接字：与其它通信机制不同的是，可用于不同机器间的互相通信</li>
</ul>
</li>
<li><p>线程通信相对简单，因为线程之间共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</p>
<p><strong>Java 中的通信机制</strong>：volatile、等待&#x2F;通知机制、join 方式、InheritableThreadLocal、MappedByteBuffer</p>
</li>
<li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p>
</li>
</ul>
<hr>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><p>Thread 创建线程方式：创建线程类，匿名内部类方式</p>
<ul>
<li><strong>start() 方法底层其实是给 CPU 注册当前线程，并且触发 run() 方法执行</strong></li>
<li>线程的启动必须调用 start() 方法，如果线程直接调用 run() 方法，相当于变成了普通类的执行，此时主线程将只有执行该线程</li>
<li>建议线程先创建子线程，主线程的任务放在之后，否则主线程（main）永远是先执行完</li>
</ul>
<p>Thread 构造器：</p>
<ul>
<li><code>public Thread()</code></li>
<li><code>public Thread(String name)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">       	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++ )&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main线程&quot;</span> + i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// main线程输出放在上面 就变成有先后顺序了，因为是 main 线程驱动的子线程运行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++ ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程输出：&quot;</span>+i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承 Thread 类的优缺点：</p>
<ul>
<li>优点：编码简单</li>
<li>缺点：线程类已经继承了 Thread 类无法继承其他类了，功能不能通过继承拓展（单继承的局限性）</li>
</ul>
<hr>
<h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><p>Runnable 创建线程方式：创建线程类，匿名内部类方式</p>
<p>Thread 的构造器：</p>
<ul>
<li><code>public Thread(Runnable target)</code></li>
<li><code>public Thread(Runnable target, String name)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target,<span class="string">&quot;1号线程&quot;</span>);</span><br><span class="line">		t1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);<span class="comment">//Thread-0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Thread 类本身也是实现了 Runnable 接口</strong>，Thread 类中持有 Runnable 的属性，执行线程 run 方法底层是调用 Runnable#run：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 底层调用的是 Runnable 的 run 方法</span></span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runnable 方式的优缺点：</p>
<ul>
<li><p>缺点：代码复杂一点。</p>
</li>
<li><p>优点：</p>
<ol>
<li><p>线程任务类只是实现了 Runnable 接口，可以继续继承其他类，避免了单继承的局限性</p>
</li>
<li><p>同一个线程任务对象可以被包装成多个线程对象</p>
</li>
<li><p>适合多个多个线程去共享同一个资源</p>
</li>
<li><p>实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立</p>
</li>
<li><p>线程池可以放入实现 Runnable 或 Callable 线程任务对象</p>
</li>
</ol>
</li>
</ul>
<p>​     </p>
<hr>
<h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><p>实现 Callable 接口：</p>
<ol>
<li>定义一个线程任务类实现 Callable 接口，申明线程执行的结果类型</li>
<li>重写线程任务类的 call 方法，这个方法可以直接返回执行的结果</li>
<li>创建一个 Callable 的线程任务对象</li>
<li>把 Callable 的线程任务对象<strong>包装成一个未来任务对象</strong></li>
<li>把未来任务对象包装成线程对象</li>
<li>调用线程的 start() 方法启动线程</li>
</ol>
<p><code>public FutureTask(Callable&lt;V&gt; callable)</code>：未来任务对象，在线程执行完后得到线程的执行结果</p>
<ul>
<li>FutureTask 就是 Runnable 对象，因为 <strong>Thread 类只能执行 Runnable 实例的任务对象</strong>，所以把 Callable 包装成未来任务对象</li>
<li>线程池部分详解了 FutureTask 的源码</li>
</ul>
<p><code>public V get()</code>：同步等待 task 执行完毕的结果，如果在线程中获取另一个线程执行结果，会阻塞等待，用于线程同步</p>
<ul>
<li>get() 线程会阻塞等待任务执行完成</li>
<li>run() 执行完后会把结果设置到 FutureTask  的一个成员变量，get() 线程可以获取到该变量的值</li>
</ul>
<p>优缺点：</p>
<ul>
<li>优点：同 Runnable，并且能得到线程执行的结果</li>
<li>缺点：编码复杂</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Callable</span> <span class="variable">call</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> task.get(); <span class="comment">// 获取call方法返回的结果（正常/异常结果）</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;  <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//重写线程任务类方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;-&gt;&quot;</span> + <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>Thread 类 API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void start()</td>
<td>启动一个新线程，Java虚拟机调用此线程的 run 方法</td>
</tr>
<tr>
<td>public void run()</td>
<td>线程启动后调用该方法</td>
</tr>
<tr>
<td>public void setName(String name)</td>
<td>给当前线程取名字</td>
</tr>
<tr>
<td>public void getName()</td>
<td>获取当前线程的名字<br>线程存在默认名称：子线程是 Thread-索引，主线程是 main</td>
</tr>
<tr>
<td>public static Thread currentThread()</td>
<td>获取当前线程对象，代码在哪个线程中执行</td>
</tr>
<tr>
<td>public static void sleep(long time)</td>
<td>让当前线程休眠多少毫秒再继续执行<br><strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次 CPU 竞争</td>
</tr>
<tr>
<td>public static native void yield()</td>
<td>提示线程调度器让出当前线程对 CPU 的使用</td>
</tr>
<tr>
<td>public final int getPriority()</td>
<td>返回此线程的优先级</td>
</tr>
<tr>
<td>public final void setPriority(int priority)</td>
<td>更改此线程的优先级，常用 1 5 10</td>
</tr>
<tr>
<td>public void interrupt()</td>
<td>中断这个线程，异常处理机制</td>
</tr>
<tr>
<td>public static boolean interrupted()</td>
<td>判断当前线程是否被打断，清除打断标记</td>
</tr>
<tr>
<td>public boolean isInterrupted()</td>
<td>判断当前线程是否被打断，不清除打断标记</td>
</tr>
<tr>
<td>public final void join()</td>
<td>等待这个线程结束</td>
</tr>
<tr>
<td>public final void join(long millis)</td>
<td>等待这个线程死亡 millis 毫秒，0 意味着永远等待</td>
</tr>
<tr>
<td>public final native boolean isAlive()</td>
<td>线程是否存活（还没有运行完毕）</td>
</tr>
<tr>
<td>public final void setDaemon(boolean on)</td>
<td>将此线程标记为守护线程或用户线程</td>
</tr>
</tbody></table>
<hr>
<h4 id="run-start"><a href="#run-start" class="headerlink" title="run start"></a>run start</h4><p>run：称为线程体，包含了要执行的这个线程的内容，方法运行结束，此线程随即终止。直接调用 run 是在主线程中执行了 run，没有启动新的线程，需要顺序执行</p>
<p>start：使用 start 是启动新的线程，此线程处于就绪（可运行）状态，通过新的线程间接执行 run 中的代码</p>
<p>说明：<strong>线程控制资源类</strong></p>
<p>run() 方法中的异常不能抛出，只能 try&#x2F;catch</p>
<ul>
<li>因为父类中没有抛出任何异常，子类不能比父类抛出更多的异常</li>
<li><strong>异常不能跨线程传播回 main() 中</strong>，因此必须在本地进行处理</li>
</ul>
<hr>
<h4 id="sleep-yield"><a href="#sleep-yield" class="headerlink" title="sleep yield"></a>sleep yield</h4><p>sleep：</p>
<ul>
<li>调用 sleep 会让当前线程从 <code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）</li>
<li>sleep() 方法的过程中，<strong>线程不会释放对象锁</strong></li>
<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>
<li>睡眠结束后的线程未必会立刻得到执行，需要抢占 CPU</li>
<li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li>
</ul>
<p>yield：</p>
<ul>
<li>调用 yield 会让提示线程调度器让出当前线程对 CPU 的使用</li>
<li>具体的实现依赖于操作系统的任务调度器</li>
<li><strong>会放弃 CPU 资源，锁资源不会释放</strong></li>
</ul>
<hr>
<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>public final void join()：等待这个线程结束</p>
<p>原理：调用者轮询检查线程 alive 状态，t1.join() 等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 调用者线程进入 thread 的 waitSet 等待, 直到当前线程运行结束</span></span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>join 方法是被 synchronized 修饰的，本质上是一个对象锁，其内部的 wait 方法调用也是释放锁的，但是<strong>释放的是当前的线程对象锁，而不是外面的锁</strong></p>
</li>
<li><p>当调用某个线程（t1）的 join 方法后，该线程（t1）抢占到 CPU 资源，就不再释放，直到线程执行完毕</p>
</li>
</ul>
<p>线程同步：</p>
<ul>
<li>join 实现线程同步，因为会阻塞等待另一个线程的结束，才能继续向下运行<ul>
<li>需要外部共享变量，不符合面向对象封装的思想</li>
<li>必须等待线程结束，不能配合线程池使用</li>
</ul>
</li>
<li>Future 实现（同步）：get() 方法阻塞等待执行结果<ul>
<li>main 线程接收结果</li>
<li>get 方法是让调用线程同步等待</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            r = <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();<span class="comment">//不等待线程执行结束，输出的10</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><h5 id="打断线程"><a href="#打断线程" class="headerlink" title="打断线程"></a>打断线程</h5><p><code>public void interrupt()</code>：打断这个线程，异常处理机制</p>
<p><code>public static boolean interrupted()</code>：判断当前线程是否被打断，打断返回 true，<strong>清除打断标记</strong>，连续调用两次一定返回 false</p>
<p><code>public boolean isInterrupted()</code>：判断当前线程是否被打断，不清除打断标记</p>
<p>打断的线程会发生上下文切换，操作系统会保存线程信息，抢占到 CPU 后会从中断的地方接着运行（打断不是停止）</p>
<ul>
<li><p>sleep、wait、join 方法都会让线程进入阻塞状态，打断线程<strong>会清空打断状态</strong>（false）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span> + t1.isInterrupted());<span class="comment">// 打断状态: &#123;&#125;false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打断正常运行的线程：不会清空打断状态（true）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> current.isInterrupted();</span><br><span class="line">            <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span> + interrupted);<span class="comment">//打断状态: &#123;&#125;true</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="打断-park"><a href="#打断-park" class="headerlink" title="打断 park"></a>打断 park</h5><p>park 作用类似 sleep，打断 park 线程，不会清空打断状态（true）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;打断状态：&quot;</span> + Thread.currentThread().isInterrupted());<span class="comment">//打断状态：true</span></span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果打断标记已经是 true, 则 park 会失效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LockSupport.park();</span><br><span class="line">System.out.println(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">LockSupport.park();<span class="comment">//失效，不会阻塞</span></span><br><span class="line">System.out.println(<span class="string">&quot;unpark...&quot;</span>);<span class="comment">//和上一个unpark同时执行</span></span><br></pre></td></tr></table></figure>

<p>可以修改获取打断状态方法，使用 <code>Thread.interrupted()</code>，清除打断标记</p>
<p>LockSupport 类在 同步 → park-un 详解</p>
<hr>
<h5 id="终止模式"><a href="#终止模式" class="headerlink" title="终止模式"></a>终止模式</h5><p>终止模式之两阶段终止模式：Two Phase Termination</p>
<p>目标：在一个线程 T1 中如何优雅终止线程 T2？优雅指的是给 T2 一个后置处理器</p>
<p>错误思想：</p>
<ul>
<li>使用线程对象的 stop() 方法停止线程：stop 方法会真正杀死线程，如果这时线程锁住了共享资源，当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</li>
<li>使用 System.exit(int) 方法停止线程：目的仅是停止一个线程，但这种做法会让整个程序都停止</li>
</ul>
<p>两阶段终止模式图示：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-两阶段终止模式.png" style="zoom: 67%;">

<p>打断线程可能在任何时间，所以需要考虑在任何时刻被打断的处理方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">TwoPhaseTermination</span> <span class="variable">tpt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoPhaseTermination</span>();</span><br><span class="line">        tpt.start();</span><br><span class="line">        Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">        tpt.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                    <span class="keyword">if</span> (thread.isInterrupted()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;后置处理&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);					<span class="comment">// 睡眠</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;执行监控记录&quot;</span>);	<span class="comment">// 在此被打断不会异常</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;		<span class="comment">// 在睡眠期间被打断，进入异常处理的逻辑</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        <span class="comment">// 重新设置打断标记，打断 sleep 会清除打断状态</span></span><br><span class="line">                        thread.interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h4><p><code>public final void setDaemon(boolean on)</code>：如果是 true ，将此线程标记为守护线程 </p>
<p>线程<strong>启动前</strong>调用此方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置该线程为守护线程</span></span><br><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>用户线程：平常创建的普通线程</p>
<p>守护线程：服务于用户线程，只要其它非守护线程运行结束了，即使守护线程代码没有执行完，也会强制结束。守护进程是<strong>脱离于终端并且在后台运行的进程</strong>，脱离终端是为了避免在执行的过程中的信息在终端上显示</p>
<p>说明：当运行的线程都是守护线程，Java 虚拟机将退出，因为普通线程执行完后，JVM 是守护线程，不会继续运行下去</p>
<p>常见的守护线程：</p>
<ul>
<li>垃圾回收器线程就是一种守护线程</li>
<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li>
</ul>
<hr>
<h4 id="不推荐"><a href="#不推荐" class="headerlink" title="不推荐"></a>不推荐</h4><p>不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁：</p>
<ul>
<li><p><code>public final void stop()</code>：停止线程运行</p>
<p>废弃原因：方法粗暴，除非可能执行 finally 代码块以及释放 synchronized 外，线程将直接被终止，如果线程持有 JUC 的互斥锁可能导致锁来不及释放，造成其他线程永远等待的局面</p>
</li>
<li><p><code>public final void suspend()</code>：<strong>挂起（暂停）线程运行</strong></p>
<p>废弃原因：如果目标线程在暂停时对系统资源持有锁，则在目标线程恢复之前没有线程可以访问该资源，如果<strong>恢复目标线程的线程</strong>在调用 resume 之前会尝试访问此共享资源，则会导致死锁</p>
</li>
<li><p><code>public final void resume()</code>：恢复线程运行</p>
</li>
</ul>
<hr>
<h3 id="线程原理"><a href="#线程原理" class="headerlink" title="线程原理"></a>线程原理</h3><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><p>Java Virtual Machine Stacks（Java 虚拟机栈）：每个线程启动后，虚拟机就会为其分配一块栈内存</p>
<ul>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
<p>线程上下文切换（Thread Context Switch）：一些原因导致 CPU 不再执行当前线程，转而执行另一个线程</p>
<ul>
<li>线程的 CPU 时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
<li>线程自己调用了 sleep、yield、wait、join、park 等方法</li>
</ul>
<p>程序计数器（Program Counter Register）：记住下一条 JVM 指令的执行地址，是线程私有的</p>
<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态（PCB 中），并恢复另一个线程的状态，包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</p>
<p>JVM 规范并没有限定线程模型，以 HotSopot 为例：</p>
<ul>
<li>Java 的线程是内核级线程（1:1 线程模型），每个 Java 线程都映射到一个操作系统原生线程，需要消耗一定的内核资源（堆栈）</li>
<li><strong>线程的调度是在内核态运行的，而线程中的代码是在用户态运行</strong>，所以线程切换（状态改变）会导致用户与内核态转换进行系统调用，这是非常消耗性能</li>
</ul>
<p>Java 中 main 方法启动的是一个进程也是一个主线程，main 方法里面的其他线程均为子线程，main 线程是这些线程的父线程</p>
<hr>
<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>线程调度指系统为线程分配处理器使用权的过程，方式有两种：协同式线程调度、抢占式线程调度（Java 选择）</p>
<p>协同式线程调度：线程的执行时间由线程本身控制</p>
<ul>
<li>优点：线程做完任务才通知系统切换到其他线程，相当于所有线程串行执行，不会出现线程同步问题</li>
<li>缺点：线程执行时间不可控，如果代码编写出现问题，可能导致程序一直阻塞，引起系统的奔溃</li>
</ul>
<p>抢占式线程调度：线程的执行时间由系统分配</p>
<ul>
<li>优点：线程执行时间可控，不会因为一个线程的问题而导致整体系统不可用</li>
<li>缺点：无法主动为某个线程多分配时间</li>
</ul>
<p>Java 提供了线程优先级的机制，优先级会提示（hint）调度器优先调度该线程，但这仅仅是一个提示，调度器可以忽略它。在线程的就绪状态时，如果 CPU 比较忙，那么优先级高的线程会获得更多的时间片，但 CPU 闲时，优先级几乎没作用</p>
<p>说明：并不能通过优先级来判断线程执行的先后顺序</p>
<hr>
<h4 id="未来优化"><a href="#未来优化" class="headerlink" title="未来优化"></a>未来优化</h4><p>内核级线程调度的成本较大，所以引入了更轻量级的协程。用户线程的调度由用户自己实现（一对多的线程模型），被设计为协同式调度，所以叫协程</p>
<ul>
<li>有栈协程：协程会完整的做调用栈的保护、恢复工作，所以叫有栈协程</li>
<li>无栈协程：本质上是一种有限状态机，状态保存在闭包里，比有栈协程更轻量，但是功能有限</li>
</ul>
<p>有栈协程中有一种特例叫纤程，在新并发模型中，一段纤程的代码被分为两部分，执行过程和调度器：</p>
<ul>
<li>执行过程：用于维护执行现场，保护、恢复上下文状态</li>
<li>调度器：负责编排所有要执行的代码顺序</li>
</ul>
<hr>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>进程的状态参考操作系统：创建态、就绪态、运行态、阻塞态、终止态</p>
<p>线程由生到死的完整过程（生命周期）：当线程被创建并启动以后，既不是一启动就进入了执行状态，也不是一直处于执行状态，在 API 中 <code>java.lang.Thread.State</code> 这个枚举中给出了六种线程状态：</p>
<table>
<thead>
<tr>
<th>线程状态</th>
<th>导致状态发生条件</th>
</tr>
</thead>
<tbody><tr>
<td>NEW（新建）</td>
<td>线程刚被创建，但是并未启动，还没调用 start 方法，只有线程对象，没有线程特征</td>
</tr>
<tr>
<td>Runnable（可运行）</td>
<td>线程可以在 Java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器，调用了 t.start() 方法：就绪（经典叫法）</td>
</tr>
<tr>
<td>Blocked（阻塞）</td>
<td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态</td>
</tr>
<tr>
<td>Waiting（无限等待）</td>
<td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态，进入这个状态后不能自动唤醒，必须等待另一个线程调用 notify 或者 notifyAll 方法才能唤醒</td>
</tr>
<tr>
<td>Timed Waiting （限期等待）</td>
<td>有几个方法有超时参数，调用将进入 Timed Waiting 状态，这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait</td>
</tr>
<tr>
<td>Teminated（结束）</td>
<td>run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡</td>
</tr>
</tbody></table>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E7%BA%BF%E7%A8%8B6%E7%A7%8D%E7%8A%B6%E6%80%81.png"></p>
<ul>
<li><p>NEW → RUNNABLE：当调用 t.start() 方法时，由 NEW → RUNNABLE</p>
</li>
<li><p>RUNNABLE &lt;–&gt; WAITING：</p>
<ul>
<li><p>调用 obj.wait() 方法时</p>
<p>调用 obj.notify()、obj.notifyAll()、t.interrupt()：</p>
<ul>
<li>竞争锁成功，t 线程从 WAITING → RUNNABLE</li>
<li>竞争锁失败，t 线程从 WAITING → BLOCKED</li>
</ul>
</li>
<li><p>当前线程调用 t.join() 方法，注意是当前线程在 t 线程对象的监视器上等待</p>
</li>
<li><p>当前线程调用 LockSupport.park() 方法</p>
</li>
</ul>
</li>
<li><p>RUNNABLE &lt;–&gt; TIMED_WAITING：调用 obj.wait(long n) 方法、当前线程调用 t.join(long n) 方法、当前线程调用 Thread.sleep(long n)</p>
</li>
<li><p>RUNNABLE &lt;–&gt; BLOCKED：t 线程用 synchronized(obj) 获取了对象锁时竞争失败</p>
</li>
</ul>
<hr>
<h3 id="查看线程"><a href="#查看线程" class="headerlink" title="查看线程"></a>查看线程</h3><p>Windows：</p>
<ul>
<li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li>
<li>tasklist 查看进程</li>
<li>taskkill 杀死进程</li>
</ul>
<p>Linux：</p>
<ul>
<li>ps -ef 查看所有进程</li>
<li>ps -fT -p <PID> 查看某个进程（PID）的所有线程</PID></li>
<li>kill 杀死进程</li>
<li>top 按大写 H 切换是否显示线程</li>
<li>top -H -p <PID> 查看某个进程（PID）的所有线程</PID></li>
</ul>
<p>Java：</p>
<ul>
<li>jps 命令查看所有 Java 进程</li>
<li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</PID></li>
<li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li>
</ul>
<hr>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界资源：一次仅允许一个进程使用的资源成为临界资源</p>
<p>临界区：访问临界资源的代码块</p>
<p>竞态条件：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p>
<p>一个程序运行多个线程是没有问题，多个线程读共享资源也没有问题，在多个线程对共享资源读写操作时发生指令交错，就会出现问题</p>
<p>为了避免临界区的竞态条件发生（解决线程安全问题）：</p>
<ul>
<li>阻塞式的解决方案：synchronized，lock</li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
<p>管程（monitor）：由局部于自己的若干公共变量和所有访问这些公共变量的过程所组成的软件模块，保证同一时刻只有一个进程在管程内活动，即管程内定义的操作在同一时刻只被一个进程调用（由编译器实现）</p>
<p><strong>synchronized：对象锁，保证了临界区内代码的原子性</strong>，采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其它线程获取这个对象锁时会阻塞，保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p>
<p>互斥和同步都可以采用 synchronized 关键字来完成，区别：</p>
<ul>
<li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li>
<li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li>
</ul>
<p>性能：</p>
<ul>
<li>线程安全，性能差</li>
<li>线程不安全性能好，假如开发中不会存在多线程安全问题，建议使用线程不安全的设计类</li>
</ul>
<hr>
<h3 id="syn-ed"><a href="#syn-ed" class="headerlink" title="syn-ed"></a>syn-ed</h3><h4 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h4><h5 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h5><p>锁对象：理论上可以是<strong>任意的唯一对象</strong></p>
<p>synchronized 是可重入、不公平的重量级锁</p>
<p>原则上：</p>
<ul>
<li>锁对象建议使用共享资源</li>
<li>在实例方法中使用 this 作为锁对象，锁住的 this 正好是共享资源</li>
<li>在静态方法中使用类名 .class 字节码作为锁对象，因为静态成员属于类，被所有实例对象共享，所以需要锁住类</li>
</ul>
<p>同步代码块格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">	<span class="comment">// 访问共享资源的核心代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//static修饰，则元素是属于类本身的，不属于对象  ，与类一起加载一次，只有一个</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                    counter++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                    counter--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>把出现线程安全问题的核心方法锁起来，每次只能一个线程进入访问</p>
<p>synchronized 修饰的方法的不具备继承性，所以子类是线程不安全的，如果子类的方法也被 synchronized 修饰，两个锁对象其实是一把锁，而且是<strong>子类对象作为锁</strong></p>
<p>用法：直接给方法加上一个修饰符 synchronized</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步方法</span></span><br><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123; </span><br><span class="line">	方法体；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步静态方法</span></span><br><span class="line">修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123; </span><br><span class="line">	方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步方法底层也是有锁对象的：</p>
<ul>
<li><p>如果方法是实例方法：同步方法默认用 this 作为的锁对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125; <span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果方法是静态方法：同步方法默认用类名 .class 作为的锁对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class) &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h5><p>线程八锁就是考察 synchronized 锁住的是哪个对象，直接百度搜索相关的实例</p>
<p>说明：主要关注锁住的对象是不是同一个</p>
<ul>
<li>锁住类对象，所有类的实例的方法都是安全的，类的所有实例都相当于同一把锁</li>
<li>锁住 this 对象，只有在当前实例对象的线程内是安全的，如果有多个实例就不安全</li>
</ul>
<p>线程不安全：因为锁住的不是同一个对象，线程 1 调用 a 方法锁住的类对象，线程 2 调用 b 方法锁住的 n2 对象，不是同一个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程安全：因为 n1 调用 a() 方法，锁住的是类对象，n2 调用 b() 方法，锁住的也是类对象，所以线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h4><h5 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h5><p>Monitor 被翻译为监视器或管程</p>
<p>每个 Java 对象都可以关联一个 Monitor 对象，Monitor 也是 class，其<strong>实例存储在堆中</strong>，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针，这就是重量级锁</p>
<ul>
<li><p>Mark Word 结构：最后两位是<strong>锁标志位</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor-MarkWord%E7%BB%93%E6%9E%8432%E4%BD%8D.png"></p>
</li>
<li><p>64 位虚拟机 Mark Word：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor-MarkWord%E7%BB%93%E6%9E%8464%E4%BD%8D.png"></p>
</li>
</ul>
<p>工作流程：</p>
<ul>
<li>开始时 Monitor 中 Owner 为 null</li>
<li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner，<strong>obj 对象的 Mark Word 指向 Monitor</strong>，把<strong>对象原有的 MarkWord 存入线程栈中的锁记录</strong>中（轻量级锁部分详解）<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor工作原理1.png" style="zoom:67%;"></li>
<li>在 Thread-2 上锁的过程，Thread-3、Thread-4、Thread-5 也执行 synchronized(obj)，就会进入 EntryList BLOCKED（双向链表）</li>
<li>Thread-2 执行完同步代码块的内容，根据 obj 对象头中 Monitor 地址寻找，设置 Owner 为空，把线程栈的锁记录中的对象头的值设置回 MarkWord</li>
<li>唤醒 EntryList 中等待的线程来竞争锁，竞争是<strong>非公平的</strong>，如果这时有新的线程想要获取锁，可能直接就抢占到了，阻塞队列的线程就会继续阻塞</li>
<li>WaitSet 中的 Thread-0，是以前获得过锁，但条件不满足进入 WAITING 状态的线程（wait-notify 机制）</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png"></p>
<p>注意：</p>
<ul>
<li>synchronized 必须是进入同一个对象的 Monitor 才有上述的效果</li>
<li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li>
</ul>
<hr>
<h5 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h5><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: 	<span class="keyword">new</span>				#<span class="number">2</span>		<span class="comment">// new Object</span></span><br><span class="line"><span class="number">3</span>: 	dup</span><br><span class="line"><span class="number">4</span>: 	invokespecial 	#<span class="number">1</span> 		<span class="comment">// invokespecial &lt;init&gt;:()V，非虚方法</span></span><br><span class="line"><span class="number">7</span>: 	astore_1 				<span class="comment">// lock引用 -&gt; lock</span></span><br><span class="line"><span class="number">8</span>: 	aload_1					<span class="comment">// lock （synchronized开始）</span></span><br><span class="line"><span class="number">9</span>: 	dup						<span class="comment">// 一份用来初始化，一份用来引用</span></span><br><span class="line"><span class="number">10</span>: astore_2 				<span class="comment">// lock引用 -&gt; slot 2</span></span><br><span class="line"><span class="number">11</span>: monitorenter 			<span class="comment">// 【将 lock对象 MarkWord 置为 Monitor 指针】</span></span><br><span class="line"><span class="number">12</span>: getstatic 		#<span class="number">3</span>		<span class="comment">// System.out</span></span><br><span class="line"><span class="number">15</span>: ldc 			#<span class="number">4</span>		<span class="comment">// &quot;ok&quot;</span></span><br><span class="line"><span class="number">17</span>: invokevirtual 	#<span class="number">5</span> 		<span class="comment">// invokevirtual println:(Ljava/lang/String;)V</span></span><br><span class="line"><span class="number">20</span>: aload_2 				<span class="comment">// slot 2(lock引用)</span></span><br><span class="line"><span class="number">21</span>: monitorexit 			<span class="comment">// 【将 lock对象 MarkWord 重置, 唤醒 EntryList】</span></span><br><span class="line"><span class="number">22</span>: goto <span class="number">30</span></span><br><span class="line"><span class="number">25</span>: astore_3 				<span class="comment">// any -&gt; slot 3</span></span><br><span class="line"><span class="number">26</span>: aload_2 				<span class="comment">// slot 2(lock引用)</span></span><br><span class="line"><span class="number">27</span>: monitorexit 			<span class="comment">// 【将 lock对象 MarkWord 重置, 唤醒 EntryList】</span></span><br><span class="line"><span class="number">28</span>: aload_3</span><br><span class="line"><span class="number">29</span>: athrow</span><br><span class="line"><span class="number">30</span>: <span class="keyword">return</span></span><br><span class="line">Exception table:</span><br><span class="line">    from to target type</span><br><span class="line">      <span class="number">12</span> <span class="number">22</span> <span class="number">25</span> 		any</span><br><span class="line">      <span class="number">25</span> <span class="number">28</span> <span class="number">25</span> 		any</span><br><span class="line">LineNumberTable: ...</span><br><span class="line">LocalVariableTable:</span><br><span class="line">    Start Length Slot Name Signature</span><br><span class="line">    	<span class="number">0</span> 	<span class="number">31</span> 		<span class="number">0</span> args [Ljava/lang/String;</span><br><span class="line">    	<span class="number">8</span> 	<span class="number">23</span> 		<span class="number">1</span> lock Ljava/lang/Object;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>通过异常 <strong>try-catch 机制</strong>，确保一定会被解锁</li>
<li>方法级别的 synchronized 不会在字节码指令中有所体现</li>
</ul>
<hr>
<h4 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h4><h5 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h5><p><strong>synchronized 是可重入、不公平的重量级锁</strong>，所以可以对其进行优化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁	<span class="comment">// 随着竞争的增加，只能锁升级，不能降级</span></span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png"></p>
<hr>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程之后重新获取该锁不再需要同步操作：</p>
<ul>
<li><p>当锁对象第一次被线程获得的时候进入偏向状态，标记为 101，同时<strong>使用 CAS 操作将线程 ID 记录到 Mark Word</strong>。如果 CAS 操作成功，这个线程以后进入这个锁相关的同步块，查看这个线程 ID 是自己的就表示没有竞争，就不需要再进行任何同步操作</p>
</li>
<li><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定或轻量级锁状态</p>
</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor-MarkWord结构64位.png" style="zoom: 67%;">

<p>一个对象创建时：</p>
<ul>
<li><p>如果开启了偏向锁（默认开启），那么对象创建后，MarkWord 值为 0x05 即最后 3 位为 101，thread、epoch、age 都为 0</p>
</li>
<li><p>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟。JDK 8 延迟 4s 开启偏向锁原因：在刚开始执行代码时，会有好多线程来抢锁，如果开偏向锁效率反而降低</p>
</li>
<li><p>当一个对象已经计算过 hashCode，就再也无法进入偏向状态了</p>
</li>
<li><p>添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</p>
</li>
</ul>
<p>撤销偏向锁的状态：</p>
<ul>
<li>调用对象的 hashCode：偏向锁的对象 MarkWord 中存储的是线程 id，调用 hashCode 导致偏向锁被撤销</li>
<li>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</li>
<li>调用 wait&#x2F;notify，需要申请 Monitor，进入 WaitSet</li>
</ul>
<p><strong>批量撤销</strong>：如果对象被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p>
<ul>
<li><p>批量重偏向：当撤销偏向锁阈值超过 20 次后，JVM 会觉得是不是偏向错了，于是在给这些对象加锁时重新偏向至加锁线程</p>
</li>
<li><p>批量撤销：当撤销偏向锁阈值超过 40 次后，JVM 会觉得自己确实偏向错了，根本就不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p>
</li>
</ul>
<hr>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>一个对象有多个线程要加锁，但加锁的时间是错开的（没有竞争），可以使用轻量级锁来优化，轻量级锁对使用者是透明的（不可见）</p>
<p>可重入锁：线程可以进入任何一个它已经拥有的锁所同步着的代码块，可重入锁最大的作用是<strong>避免死锁</strong></p>
<p>轻量级锁在没有竞争时（锁重入时），每次重入仍然需要执行 CAS 操作，Java 6 才引入的偏向锁来优化</p>
<p>锁重入实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">    	<span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建锁记录（Lock Record）对象，每个线程的<strong>栈帧</strong>都会包含一个锁记录的结构，存储锁定对象的 Mark Word</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%861.png"></p>
</li>
<li><p>让锁记录中 Object reference 指向锁住的对象，并尝试用 CAS 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</p>
</li>
<li><p>如果 CAS 替换成功，对象头中存储了锁记录地址和状态 00（轻量级锁） ，表示由该线程给对象加锁<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%862.png"></p>
</li>
<li><p>如果 CAS 失败，有两种情况：</p>
<ul>
<li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li>
<li>如果是线程自己执行了 synchronized 锁重入，就添加一条 Lock Record 作为重入的计数</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%863.png"></p>
</li>
<li><p>当退出 synchronized 代码块（解锁时）</p>
<ul>
<li>如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减 1</li>
<li>如果锁记录的值不为 null，这时使用 CAS <strong>将 Mark Word 的值恢复给对象头</strong><ul>
<li>成功，则解锁成功</li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h5><p>在尝试加轻量级锁的过程中，CAS 操作无法成功，可能是其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为<strong>重量级锁</strong></p>
<ul>
<li><p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%861.png"></p>
</li>
<li><p>Thread-1 加轻量级锁失败，进入锁膨胀流程：为 Object 对象申请 Monitor 锁，<strong>通过 Object 对象头获取到持锁线程</strong>，将 Monitor 的 Owner 置为 Thread-0，将 Object 的对象头指向重量级锁地址，然后自己进入 Monitor 的 EntryList BLOCKED</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%8E%9F%E7%90%862.png"></p>
</li>
<li><p>当 Thread-0 退出同步块解锁时，使用 CAS 将 Mark Word 的值恢复给对象头失败，这时进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</p>
</li>
</ul>
<hr>
<h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>重量级锁竞争时，尝试获取锁的线程不会立即阻塞，可以使用<strong>自旋</strong>（默认 10 次）来进行优化，采用循环的方式去尝试获取锁</p>
<p>注意：</p>
<ul>
<li>自旋占用 CPU 时间，单核 CPU 自旋就是浪费时间，因为同一时刻只能运行一个线程，多核 CPU 自旋才能发挥优势</li>
<li>自旋失败的线程会进入阻塞状态</li>
</ul>
<p>优点：不会进入阻塞状态，<strong>减少线程上下文切换的消耗</strong></p>
<p>缺点：当自旋的线程越来越多时，会不断的消耗 CPU 资源</p>
<p>自旋锁情况：</p>
<ul>
<li><p>自旋成功的情况：<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-自旋成功.png" style="zoom: 80%;"></p>
</li>
<li><p>自旋失败的情况：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-自旋失败.png" style="zoom:80%;"></li>
</ul>
<p>自旋锁说明：</p>
<ul>
<li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，比较智能</li>
<li>Java 7 之后不能控制是否开启自旋功能，由 JVM 控制</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手写自旋锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    <span class="comment">// 泛型装的是Thread，原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot; come in&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始自旋，期望值为null，更新值是当前线程</span></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, thread)) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">&quot; 正在自旋&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot; 自旋成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程使用完锁把引用变为null</span></span><br><span class="line">		atomicReference.compareAndSet(thread, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(thread.getName() + <span class="string">&quot; invoke unlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SpinLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//占有锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>); </span><br><span class="line"></span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让main线程暂停1秒，使得t1线程，先执行</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除，这是 JVM <strong>即时编译器的优化</strong></p>
<p>锁消除主要是通过<strong>逃逸分析</strong>来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除（同步消除：JVM 逃逸分析）</p>
<hr>
<h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>对相同对象多次加锁，导致线程发生多次重入，频繁的加锁操作就会导致性能损耗，可以使用锁粗化方式优化</p>
<p>如果虚拟机探测到一串的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部</p>
<ul>
<li><p>一些看起来没有加锁的代码，其实隐式的加了很多锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，转化为 StringBuffer 对象的连续 append() 操作，每个 append() 方法中都有一个同步块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">concatString</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，只需要加锁一次就可以</p>
<hr>
<h4 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h4><p>多把不相干的锁：一间大屋子有两个功能睡觉、学习，互不相干。现在一人要学习，一人要睡觉，如果只用一间屋子（一个对象锁）的话，那么并发度很低</p>
<p>将锁的粒度细分：</p>
<ul>
<li>好处，是可以增强并发度</li>
<li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li>
</ul>
<p>解决方法：准备多个对象锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BigRoom</span> <span class="variable">bigRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigRoom</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; bigRoom.study(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; bigRoom.sleep(); &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigRoom</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">studyRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">sleepRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sleepRoom) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sleeping 2 小时&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (studyRoom) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;study 1 小时&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h4><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><h6 id="形成"><a href="#形成" class="headerlink" title="形成"></a>形成</h6><p>死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放，由于线程被无限期地阻塞，因此程序不可能正常终止</p>
<p>Java 死锁产生的四个必要条件：</p>
<ol>
<li>互斥条件，即当资源被一个线程使用（占有）时，别的线程不能使用</li>
<li>不可剥夺条件，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放</li>
<li>请求和保持条件，即当资源请求者在请求其他的资源的同时保持对原有资源的占有</li>
<li>循环等待条件，即存在一个等待循环队列：p1 要 p2 的资源，p2 要 p1 的资源，形成了一个等待环路</li>
</ol>
<p>四个条件都成立的时候，便形成死锁。死锁情况下打破上述任何一个条件，便可让死锁消失</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resources1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resources2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 线程1：占用资源1 ，请求资源2</span></span><br><span class="line">            <span class="keyword">synchronized</span>(resources1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1已经占用了资源1，开始请求资源2&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);<span class="comment">//休息两秒，防止线程1直接运行完成。</span></span><br><span class="line">                <span class="comment">//2秒内线程2肯定可以锁住资源2</span></span><br><span class="line">                <span class="keyword">synchronized</span> (resources2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1已经占用了资源2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 线程2：占用资源2 ，请求资源1</span></span><br><span class="line">            <span class="keyword">synchronized</span>(resources2)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2已经占用了资源2，开始请求资源1&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resources1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2已经占用了资源1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;&#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h6 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h6><p>定位死锁的方法：</p>
<ul>
<li><p>使用 jps 定位进程 id，再用 <code>jstack id</code> 定位死锁，找到死锁的线程去查看源码，解决优化</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Thread-1&quot;</span> <span class="comment">#12 prio=5 os_prio=0 tid=0x000000001eb69000 nid=0xd40 waiting formonitor entry [0x000000001f54f000]</span></span><br><span class="line">	java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line"><span class="comment">#省略    </span></span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span> <span class="comment">#12 prio=5 os_prio=0 tid=0x000000001eb69000 nid=0xd40 waiting for monitor entry [0x000000001f54f000]</span></span><br><span class="line">	java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line"><span class="comment">#省略</span></span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">    waiting to lock monitor 0x000000000361d378 (object 0x000000076b5bf1c0, a java.lang.Object),</span><br><span class="line">    <span class="built_in">which</span> is held by <span class="string">&quot;Thread-0&quot;</span></span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">    waiting to lock monitor 0x000000000361e768 (object 0x000000076b5bf1d0, a java.lang.Object),</span><br><span class="line">    <span class="built_in">which</span> is held by <span class="string">&quot;Thread-1&quot;</span></span><br><span class="line">    </span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">    at thread.TestDeadLock.lambda$main<span class="variable">$1</span>(TestDeadLock.java:28)</span><br><span class="line">    - waiting to lock &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)</span><br><span class="line">    at thread.TestDeadLock$$Lambda<span class="variable">$2</span>/883049899.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">    at thread.TestDeadLock.lambda$main<span class="variable">$0</span>(TestDeadLock.java:15)</span><br><span class="line">    - waiting to lock &lt;0x000000076b5bf1d0&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x000000076b5bf1c0&gt; (a java.lang.Object)</span><br><span class="line">    at thread.TestDeadLock$$Lambda<span class="variable">$1</span>/495053715</span><br></pre></td></tr></table></figure>
</li>
<li><p>Linux 下可以通过 top 先定位到 CPU 占用高的 Java 进程，再利用 <code>top -Hp 进程id</code> 来定位是哪个线程，最后再用 jstack <pid>的输出来看各个线程栈</pid></p>
</li>
<li><p>避免死锁：避免死锁要注意加锁顺序</p>
</li>
<li><p>可以使用 jconsole 工具，在 <code>jdk\bin</code> 目录下</p>
</li>
</ul>
<hr>
<h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>活锁：指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程</p>
<p>两个线程互相改变对方的结束条件，最后谁也无法结束：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestLiveLock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                count--;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一count:&quot;</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程二count:&quot;</span>+ count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h5><p>饥饿：一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束</p>
<hr>
<h3 id="wait-ify"><a href="#wait-ify" class="headerlink" title="wait-ify"></a>wait-ify</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>需要获取对象锁后才可以调用 <code>锁对象.wait()</code>，notify 随机唤醒一个线程，notifyAll 唤醒所有线程去竞争 CPU</p>
<p>Object 类 API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>:唤醒正在等待对象监视器的单个线程。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>:唤醒正在等待对象监视器的所有线程。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span>:导致当前线程等待，直到另一个线程调用该对象的notify()方法或 notifyAll()方法。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span>:有时限的等待, 到n毫秒后结束等待，或是被唤醒</span><br></pre></td></tr></table></figure>

<p>说明：<strong>wait 是挂起线程，需要唤醒的都是挂起操作</strong>，阻塞线程可以自己去争抢锁，挂起的线程需要唤醒后去争抢锁</p>
<p>对比 sleep()：</p>
<ul>
<li>原理不同：sleep() 方法是属于 Thread 类，是线程用来控制自身流程的，使此线程暂停执行一段时间而把执行机会让给其他线程；wait() 方法属于 Object 类，用于线程间通信</li>
<li>对<strong>锁的处理机制</strong>不同：调用 sleep() 方法的过程中，线程不会释放对象锁，当调用 wait() 方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池（不释放锁其他线程怎么抢占到锁执行唤醒操作），但是都会释放 CPU</li>
<li>使用区域不同：wait() 方法必须放在<strong>同步控制方法和同步代码块（先获取锁）</strong>中使用，sleep() 方法则可以放在任何地方使用</li>
</ul>
<p>底层原理：</p>
<ul>
<li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li>
<li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li>
<li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li>
<li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，唤醒后并不意味者立刻获得锁，<strong>需要进入 EntryList 重新竞争</strong></li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Monitor%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png"></p>
<hr>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>虚假唤醒：notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程</p>
<p>解决方法：采用 notifyAll</p>
<p>notifyAll 仅解决某个线程的唤醒问题，使用 if + wait 判断仅有一次机会，一旦条件不成立，无法重新判断</p>
<p>解决方法：用 while + wait，当条件不成立，再次 wait</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;    <span class="comment">//有没有烟</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;<span class="comment">//while防止虚假唤醒</span></span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">if</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">if</span> (hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 这里能不能加 synchronized (room)？</span></span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">				<span class="comment">//log.debug(&quot;烟到了噢！&quot;);</span></span><br><span class="line">                log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">                room.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="park-un"><a href="#park-un" class="headerlink" title="park-un"></a>park-un</h3><p>LockSupport 是用来创建锁和其他同步类的<strong>线程原语</strong></p>
<p>LockSupport 类方法：</p>
<ul>
<li><code>LockSupport.park()</code>：暂停当前线程，挂起原语</li>
<li><code>LockSupport.unpark(暂停的线程对象)</code>：恢复某个线程的运行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);	<span class="comment">//1</span></span><br><span class="line">		Thread.sleep(<span class="number">1000</span>);<span class="comment">// Thread.sleep(3000)</span></span><br><span class="line">        <span class="comment">// 先 park 再 unpark 和先 unpark 再 park 效果一样，都会直接恢复线程的运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;park...&quot;</span>);	<span class="comment">//2</span></span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;resume...&quot;</span>);<span class="comment">//4</span></span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">   	Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;unpark...&quot;</span>);	<span class="comment">//3</span></span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LockSupport 出现就是为了增强 wait &amp; notify 的功能：</p>
<ul>
<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park、unpark 不需要</li>
<li>park &amp; unpark <strong>以线程为单位</strong>来阻塞和唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程</li>
<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify。类比生产消费，先消费发现有产品就消费，没有就等待；先生产就直接产生商品，然后线程直接消费</li>
<li>wait 会释放锁资源进入等待队列，<strong>park 不会释放锁资源</strong>，只负责阻塞当前线程，会释放 CPU</li>
</ul>
<p>原理：类似生产者消费者</p>
<ul>
<li>先 park：<ol>
<li>当前线程调用 Unsafe.park() 方法</li>
<li>检查 _counter ，本情况为 0，这时获得 _mutex 互斥锁</li>
<li>线程进入 _cond 条件变量挂起</li>
<li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li>
<li>唤醒 _cond 条件变量中的 Thread_0，Thread_0 恢复运行，设置 _counter 为 0</li>
</ol>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-park%E5%8E%9F%E7%90%861.png"></p>
<ul>
<li><p>先 unpark：</p>
<ol>
<li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li>
<li>当前线程调用 Unsafe.park() 方法</li>
<li>检查 _counter ，本情况为 1，这时线程无需挂起，继续运行，设置 _counter 为 0</li>
</ol>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-park%E5%8E%9F%E7%90%862.png"></p>
</li>
</ul>
<hr>
<h3 id="安全分析"><a href="#安全分析" class="headerlink" title="安全分析"></a>安全分析</h3><p>成员变量和静态变量：</p>
<ul>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了，根据它们的状态是否能够改变，分两种情况：<ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全问题</li>
</ul>
</li>
</ul>
<p>局部变量：</p>
<ul>
<li>局部变量是线程安全的</li>
<li>局部变量引用的对象不一定线程安全（逃逸分析）：<ul>
<li>如果该对象没有逃离方法的作用访问，它是线程安全的（每一个方法有一个栈帧）</li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全问题（暴露引用）</li>
</ul>
</li>
</ul>
<p>常见线程安全类：String、Integer、StringBuffer、Random、Vector、Hashtable、java.util.concurrent 包</p>
<ul>
<li><p>线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的</p>
</li>
<li><p><strong>每个方法是原子的，但多个方法的组合不是原子的</strong>，只能保证调用的方法内部安全：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"><span class="comment">// 线程1，线程2</span></span><br><span class="line"><span class="keyword">if</span>(table.get(<span class="string">&quot;key&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">	table.put(<span class="string">&quot;key&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>无状态类线程安全，就是没有成员变量的类</p>
<p>不可变类线程安全：String、Integer 等都是不可变类，<strong>内部的状态不可以改变</strong>，所以方法是线程安全</p>
<ul>
<li><p>replace 等方法底层是新建一个对象，复制过去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();	<span class="comment">// 线程不安全</span></span><br><span class="line"><span class="type">String</span> <span class="variable">S1</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;							<span class="comment">// 线程安全</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">S2</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;					<span class="comment">// 线程安全</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">D1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();						<span class="comment">// 线程不安全</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Date</span> <span class="variable">D2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();					<span class="comment">// 线程不安全，final让D2引用的对象不能变，但对象的内容可以变</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>抽象方法如果有参数，被重写后行为不确定可能造成线程不安全，被称之为外星方法：<code>public abstract foo(Student s);</code></p>
<hr>
<h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><h4 id="保护性暂停"><a href="#保护性暂停" class="headerlink" title="保护性暂停"></a>保护性暂停</h4><h5 id="单任务版"><a href="#单任务版" class="headerlink" title="单任务版"></a>单任务版</h5><p>Guarded Suspension，用在一个线程等待另一个线程的执行结果</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让它们关联同一个 GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GuardedObject</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObjectV2</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        object.complete(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>));</span><br><span class="line">    &#125;).start();</span><br><span class="line">    </span><br><span class="line">    <span class="type">Object</span> <span class="variable">response</span> <span class="operator">=</span> object.get(<span class="number">2500</span>);</span><br><span class="line">    <span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;can&#x27;t get response&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取结果</span></span><br><span class="line">    <span class="comment">//timeout :最大等待时间</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> millis)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 1) 记录最初时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 2) 已经经历的时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">timePassed</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> millis - timePassed;</span><br><span class="line">                log.debug(<span class="string">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);</span><br><span class="line">                <span class="comment">//经历时间超过最大等待时间退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;break...&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait(waitTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3) 如果提前被唤醒，这时已经经历的时间假设为 400</span></span><br><span class="line">                timePassed = System.currentTimeMillis() - begin;</span><br><span class="line">                log.debug(<span class="string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>,</span><br><span class="line">                        timePassed, response == <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 条件满足，通知等待线程</span></span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            log.debug(<span class="string">&quot;notify...&quot;</span>);</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="多任务版"><a href="#多任务版" class="headerlink" title="多任务版"></a>多任务版</h5><p>多任务版保护性暂停：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%89%88.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">People</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Postman</span>(id, id + <span class="string">&quot;号快递到了&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.People&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 收信</span></span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> Mailboxes.createGuardedObject();</span><br><span class="line">        log.debug(<span class="string">&quot;开始收信i d:&#123;&#125;&quot;</span>, guardedObject.getId());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">mail</span> <span class="operator">=</span> guardedObject.get(<span class="number">5000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;收到信id:&#123;&#125;，内容:&#123;&#125;&quot;</span>, guardedObject.getId(),mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Postman</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String mail;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> Mailboxes.getGuardedObject(id);</span><br><span class="line">        log.debug(<span class="string">&quot;开始送信i d:&#123;&#125;，内容:&#123;&#125;&quot;</span>, guardedObject.getId(),mail);</span><br><span class="line">        guardedObject.complete(mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Mailboxes</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生唯一的id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">generateId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title function_">getGuardedObject</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title function_">createGuardedObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">go</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>(generateId());</span><br><span class="line">        boxes.put(go.getId(), go);</span><br><span class="line">        <span class="keyword">return</span> go;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title function_">getIds</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="comment">//标识，Guarded Object</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;<span class="comment">//添加get set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="顺序输出"><a href="#顺序输出" class="headerlink" title="顺序输出"></a>顺序输出</h4><p>顺序输出 2  1 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125;</span></span><br><span class="line">            <span class="comment">// 当没有许可时，当前线程暂停运行；有许可时，用掉这个许可，当前线程恢复运行</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            <span class="comment">// 给线程 t1 发放『许可』（多次连续调用 unpark 只会发放一个『许可』）</span></span><br><span class="line">            LockSupport.unpark(t1);</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">500</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h4><p>连续输出 5 次 abc</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">day2_14</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AwaitSignal</span> <span class="variable">awaitSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignal</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">a</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">b</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">c</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;a&quot;</span>, a, b);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;b&quot;</span>, b, c);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignal.print(<span class="string">&quot;c&quot;</span>, c, a);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        awaitSignal.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignal.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AwaitSignal</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AwaitSignal</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//参数1：打印内容  参数二：条件变量  参数二：唤醒下一个</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, Condition condition, Condition next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.print(str);</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h3><h4 id="传统版"><a href="#传统版" class="headerlink" title="传统版"></a>传统版</h4><p>异步模式之生产者&#x2F;消费者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShareData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 同步代码块，加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断  防止虚假唤醒</span></span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待不能生产</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number);</span><br><span class="line">            <span class="comment">// 通知 唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 同步代码块，加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断 防止虚假唤醒</span></span><br><span class="line">            <span class="keyword">while</span>(number == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待不能消费</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t &quot;</span> + number);</span><br><span class="line">            <span class="comment">// 通知 唤醒</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TraditionalProducerConsumer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShareData</span> <span class="variable">shareData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareData</span>();</span><br><span class="line">        <span class="comment">// t1线程，生产</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            	shareData.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// t2线程，消费</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">				shareData.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h4><p>异步模式之生产者&#x2F;消费者：</p>
<ul>
<li>消费队列可以用来平衡生产和消费的线程资源，不需要产生结果和消费结果的线程一一对应</li>
<li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li>
<li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li>
<li>JDK 中各种阻塞队列，采用的就是这种模式</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                queue.put(<span class="keyword">new</span> <span class="title class_">Message</span>(id,<span class="string">&quot;值&quot;</span>+id));</span><br><span class="line">            &#125;, <span class="string">&quot;生产者&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息队列类，Java间线程之间通信</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//消息的队列集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;<span class="comment">//队列容量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取消息</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//检查队列是否为空</span></span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sout(Thread.currentThread().getName() + <span class="string">&quot;:队列为空，消费者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从队列的头部获取消息返回</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> list.removeFirst();</span><br><span class="line">            sout(Thread.currentThread().getName() + <span class="string">&quot;：已消费消息--&quot;</span> + message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存入消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="comment">//检查队列是否满</span></span><br><span class="line">            <span class="keyword">while</span> (list.size() == capacity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sout(Thread.currentThread().getName()+<span class="string">&quot;:队列为已满，生产者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将消息加入队列尾部</span></span><br><span class="line">            list.addLast(message);</span><br><span class="line">            sout(Thread.currentThread().getName() + <span class="string">&quot;:已生产消息--&quot;</span> + message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line">	<span class="comment">//get set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">consumer</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">producer</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line">    producer.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            queue.put(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    consumer.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待消费...&quot;</span>);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> queue.take();</span><br><span class="line">            System.out.println(<span class="string">&quot;结果为:&quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p>Java 内存模型是 Java Memory Model（JMM），本身是一种<strong>抽象的概念</strong>，实际上并不存在，描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p>
<p>JMM 作用：</p>
<ul>
<li>屏蔽各种硬件和操作系统的内存访问差异，实现让 Java 程序在各种平台下都能达到一致的内存访问效果</li>
<li>规定了线程和内存之间的一些关系</li>
</ul>
<p>根据 JMM 的设计，系统存在一个主内存（Main Memory），Java 中所有变量都存储在主存中，对于所有线程都是共享的；每条线程都有自己的工作内存（Working Memory），工作内存中保存的是主存中某些<strong>变量的拷贝</strong>，线程对所有变量的操作都是先对变量进行拷贝，然后在工作内存中进行，不能直接操作主内存中的变量；线程之间无法相互直接访问，线程间的通信（传递）必须通过主内存来完成</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png"></p>
<p>主内存和工作内存：</p>
<ul>
<li>主内存：计算机的内存，也就是经常提到的 8G 内存，16G 内存，存储所有共享变量的值</li>
<li>工作内存：存储该线程使用到的共享变量在主内存的的值的副本拷贝</li>
</ul>
<p><strong>JVM 和 JMM 之间的关系</strong>：JMM 中的主内存、工作内存与 JVM 中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来：</p>
<ul>
<li>主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域</li>
<li>从更低层次上说，主内存直接对应于物理硬件的内存，工作内存对应寄存器和高速缓存</li>
</ul>
<hr>
<h4 id="内存交互"><a href="#内存交互" class="headerlink" title="内存交互"></a>内存交互</h4><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作，每个操作都是<strong>原子</strong>的</p>
<p>非原子协定：没有被 volatile 修饰的 long、double 外，默认按照两次 32 位的操作</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-内存交互.png" style="zoom: 67%;">

<ul>
<li>lock：作用于主内存，将一个变量标识为被一个线程独占状态（对应 monitorenter）</li>
<li>unclock：作用于主内存，将一个变量从独占状态释放出来，释放后的变量才可以被其他线程锁定（对应 monitorexit）</li>
<li>read：作用于主内存，把一个变量的值从主内存传输到工作内存中</li>
<li>load：作用于工作内存，在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li>
<li>use：作用于工作内存，把工作内存中一个变量的值传递给<strong>执行引擎</strong>，每当遇到一个使用到变量的操作时都要使用该指令</li>
<li>assign：作用于工作内存，把从执行引擎接收到的一个值赋给工作内存的变量</li>
<li>store：作用于工作内存，把工作内存的一个变量的值传送到主内存中</li>
<li>write：作用于主内存，在 store 之后执行，把 store 得到的值放入主内存的变量中</li>
</ul>
<p>参考文章：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md</a></p>
<hr>
<h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</p>
<p>存在不可见问题的根本原因是由于缓存的存在，线程持有的是共享变量的副本，无法感知其他线程对于共享变量的更改，导致读取的值不是最新的。但是 final 修饰的变量是<strong>不可变</strong>的，就算有缓存，也不会存在不可见的问题</p>
<p>main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;	<span class="comment">//添加volatile</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    run = <span class="literal">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<ul>
<li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存</li>
<li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</li>
<li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BE%8B%E5%AD%90.png"></p>
<hr>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>原子性：不可分割，完整性，也就是说某个线程正在做某个具体业务时，中间不可以被分割，需要具体完成，要么同时成功，要么同时失败，保证指令不会受到线程上下文切换的影响 </p>
<p>定义原子操作的使用规则：</p>
<ol>
<li>不允许 read 和 load、store 和 write 操作之一单独出现，必须顺序执行，但是不要求连续</li>
<li>不允许一个线程丢弃 assign 操作，必须同步回主存</li>
<li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从工作内存同步会主内存中</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（assign 或者 load）的变量，即对一个变量实施 use 和 store 操作之前，必须先自行 assign 和 load 操作</li>
<li>一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一线程重复执行多次，多次执行 lock 后，只有<strong>执行相同次数的 unlock</strong> 操作，变量才会被解锁，<strong>lock 和 unlock 必须成对出现</strong></li>
<li>如果对一个变量执行 lock 操作，将会<strong>清空工作内存中此变量的值</strong>，在执行引擎使用这个变量之前需要重新从主存加载</li>
<li>如果一个变量事先没有被 lock 操作锁定，则不允许执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量</li>
<li>对一个变量执行 unlock 操作之前，必须<strong>先把此变量同步到主内存</strong>中（执行 store 和 write 操作）</li>
</ol>
<hr>
<h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>有序性：在本线程内观察，所有操作都是有序的；在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序</p>
<p>CPU 的基本工作是执行存储的指令序列，即程序，程序的执行过程实际上是不断地取出指令、分析指令、执行指令的过程，为了提高性能，编译器和处理器会对指令重排，一般分为以下三种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</span><br></pre></td></tr></table></figure>

<p>现代 CPU 支持多级指令流水线，几乎所有的冯•诺伊曼型计算机的 CPU，其工作都可以分为 5 个阶段：取指令、指令译码、执行指令、访存取数和结果写回，可以称之为<strong>五级指令流水线</strong>。CPU 可以在一个时钟周期内，同时运行五条指令的<strong>不同阶段</strong>（每个线程不同的阶段），本质上流水线技术并不能缩短单条指令的执行时间，但变相地提高了指令地吞吐率</p>
<p>处理器在进行重排序时，必须要考虑<strong>指令之间的数据依赖性</strong></p>
<ul>
<li>单线程环境也存在指令重排，由于存在依赖性，最终执行结果和代码顺序的结果一致</li>
<li>多线程环境中线程交替执行，由于编译器优化重排，会获取其他线程处在不同阶段的指令同时执行</li>
</ul>
<p>补充知识：</p>
<ul>
<li>指令周期是取出一条指令并执行这条指令的时间，一般由若干个机器周期组成</li>
<li>机器周期也称为 CPU 周期，一条指令的执行过程划分为若干个阶段（如取指、译码、执行等），每一阶段完成一个基本操作，完成一个基本操作所需要的时间称为机器周期</li>
<li>振荡周期指周期性信号作周期性重复变化的时间间隔</li>
</ul>
<hr>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><h5 id="缓存结构"><a href="#缓存结构" class="headerlink" title="缓存结构"></a>缓存结构</h5><p>在计算机系统中，CPU 高速缓存（CPU Cache，简称缓存）是用于减少处理器访问内存所需平均时间的部件；在存储体系中位于自顶向下的第二层，仅次于 CPU 寄存器；其容量远小于内存，但速度却可以接近处理器的频率</p>
<p>CPU 处理器速度远远大于在主内存中的，为了解决速度差异，在它们之间架设了多级缓存，如 L1、L2、L3 级别的缓存，这些缓存离 CPU 越近就越快，将频繁操作的数据缓存到这里，加快访问速度</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-CPU缓存结构.png" style="zoom: 50%;">

<table>
<thead>
<tr>
<th>从 CPU 到</th>
<th>大约需要的时钟周期</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>1 cycle (4GHz 的 CPU 约为 0.25ns)</td>
</tr>
<tr>
<td>L1</td>
<td>3~4 cycle</td>
</tr>
<tr>
<td>L2</td>
<td>10~20 cycle</td>
</tr>
<tr>
<td>L3</td>
<td>40~45 cycle</td>
</tr>
<tr>
<td>内存</td>
<td>120~240 cycle</td>
</tr>
</tbody></table>
<h5 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h5><p>当处理器发出内存访问请求时，会先查看缓存内是否有请求数据，如果存在（命中），则不用访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器</p>
<p>缓存之所以有效，主要因为程序运行时对内存的访问呈现局部性（Locality）特征。既包括空间局部性（Spatial Locality），也包括时间局部性（Temporal Locality），有效利用这种局部性，缓存可以达到极高的命中率</p>
<hr>
<h4 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h4><p><strong>缓存以缓存行 cache line 为单位</strong>，每个缓存行对应着一块内存，一般是 64 byte（8 个 long），在 CPU 从主存获取数据时，以 cache line 为单位加载，于是相邻的数据会一并加载到缓存中</p>
<p>缓存会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中，CPU 要保证数据的一致性，需要做到某个 CPU 核心更改了数据，其它 CPU 核心对应的<strong>整个缓存行必须失效</strong>，这就是伪共享</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-内存伪共享.png" style="zoom: 67%;">

<p>解决方法：</p>
<ul>
<li><p>padding：通过填充，让数据落在不同的 cache line 中</p>
</li>
<li><p>@Contended：原理参考 无锁 → Adder → 优化机制 → 伪共享</p>
</li>
</ul>
<p>Linux 查看 CPU 缓存行：</p>
<ul>
<li>命令：<code>cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size64</code></li>
<li>内存地址格式：[高位组标记] [低位索引] [偏移量]</li>
</ul>
<hr>
<h4 id="缓存一致"><a href="#缓存一致" class="headerlink" title="缓存一致"></a>缓存一致</h4><p>缓存一致性：当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一样</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-缓存一致性.png" style="zoom:80%;">

<p>MESI（Modified Exclusive Shared Or Invalid）是一种广泛使用的<strong>支持写回策略的缓存一致性协议</strong>，CPU 中每个缓存行（caceh line）使用 4 种状态进行标记（使用额外的两位 bit 表示)：</p>
<ul>
<li><p>M：被修改（Modified）</p>
<p>该缓存行只被缓存在该 CPU 的缓存中，并且是被修改过的，与主存中的数据不一致 (dirty)，该缓存行中的内存需要写回 (write back) 主存。该状态的数据再次被修改不会发送广播，因为其他核心的数据已经在第一次修改时失效一次</p>
<p>当被写回主存之后，该缓存行的状态会变成独享 (exclusive) 状态</p>
</li>
<li><p>E：独享的（Exclusive）</p>
<p>该缓存行只被缓存在该 CPU 的缓存中，是未被修改过的 (clear)，与主存中数据一致，修改数据不需要通知其他 CPU 核心，该状态可以在任何时刻有其它 CPU 读取该内存时变成共享状态 (shared)</p>
<p>当 CPU 修改该缓存行中内容时，该状态可以变成 Modified 状态</p>
</li>
<li><p>S：共享的（Shared）</p>
<p>该状态意味着该缓存行可能被多个 CPU 缓存，并且各个缓存中的数据与主存数据一致，当 CPU 修改该缓存行中，会向其它 CPU 核心广播一个请求，使该缓存行变成无效状态 (Invalid)，然后再更新当前 Cache 里的数据</p>
</li>
<li><p>I：无效的（Invalid）</p>
<p>该缓存是无效的，可能有其它 CPU 修改了该缓存行</p>
</li>
</ul>
<p>解决方法：各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，协议主要有 MSI、MESI 等</p>
<hr>
<h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><p>单核 CPU 处理器会自动保证基本内存操作的原子性</p>
<p>多核 CPU 处理器，每个 CPU 处理器内维护了一块内存，每个内核内部维护着一块缓存，当多线程并发读写时，就会出现缓存数据不一致的情况。处理器提供：</p>
<ul>
<li>总线锁定：当处理器要操作共享变量时，在 BUS 总线上发出一个 LOCK 信号，其他处理器就无法操作这个共享变量，该操作会导致大量阻塞，从而增加系统的性能开销（<strong>平台级别的加锁</strong>）</li>
<li>缓存锁定：当处理器对缓存中的共享变量进行了操作，其他处理器有嗅探机制，将各自缓存中的该共享变量的失效，读取时会重新从主内存中读取最新的数据，基于 MESI 缓存一致性协议来实现</li>
</ul>
<p>有如下两种情况处理器不会使用缓存锁定：</p>
<ul>
<li><p>当操作的数据跨多个缓存行，或没被缓存在处理器内部，则处理器会使用总线锁定</p>
</li>
<li><p>有些处理器不支持缓存锁定，比如：Intel 486 和 Pentium 处理器也会调用总线锁定</p>
</li>
</ul>
<p>总线机制：</p>
<ul>
<li><p>总线嗅探：每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是否过期了，当处理器发现自己的缓存对应的内存地址的数据被修改，就<strong>将当前处理器的缓存行设置为无效状态</strong>，当处理器对这个数据进行操作时，会重新从内存中把数据读取到处理器缓存中</p>
</li>
<li><p>总线风暴：当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心（<strong>写传播</strong>），CPU 需要每时每刻监听总线上的一切活动，但是不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件，不断的从主内存嗅探和 CAS 循环，无效的交互会导致总线带宽达到峰值；因此不要大量使用 volatile 关键字，使用 volatile、syschonized 都需要根据实际场景</p>
</li>
</ul>
<hr>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><p>volatile 是 Java 虚拟机提供的<strong>轻量级</strong>的同步机制（三大特性）</p>
<ul>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>保证有序性（禁止指令重排）</li>
</ul>
<p>性能：volatile 修饰的变量进行读操作与普通变量几乎没什么差别，但是写操作相对慢一些，因为需要在本地代码中插入很多内存屏障来保证指令不会发生乱序执行，但是开销比锁要小</p>
<p>synchronized 无法禁止指令重排和处理器优化，为什么可以保证有序性可见性</p>
<ul>
<li>加了锁之后，只能有一个线程获得到了锁，获得不到锁的线程就要阻塞，所以同一时间只有一个线程执行，相当于单线程，由于数据依赖性的存在，单线程的指令重排是没有问题的</li>
<li>线程加锁前，将<strong>清空工作内存</strong>中共享变量的值，使用共享变量时需要从主内存中重新读取最新的值；线程解锁前，必须把共享变量的最新值<strong>刷新到主内存</strong>中（JMM 内存交互章节有讲）</li>
</ul>
<hr>
<h4 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h4><p>volatile 修饰的变量，可以禁用指令重排</p>
<p>指令重排实例：</p>
<ul>
<li><p>example 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mySort</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11</span>;	<span class="comment">//语句1</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">12</span>;	<span class="comment">//语句2  谁先执行效果一样</span></span><br><span class="line">	x = x + <span class="number">5</span>;	<span class="comment">//语句3</span></span><br><span class="line">	y = x * x;	<span class="comment">//语句4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行顺序是：1 2 3 4、2 1 3 4、1 3 2 4</p>
<p>指令重排也有限制不会出现：4321，语句 4 需要依赖于 y 以及 x 的申明，因为存在数据依赖，无法首先执行</p>
</li>
<li><p>example 2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">    	r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">	num = <span class="number">2</span>;</span><br><span class="line">	ready = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况一：线程 1 先执行，ready &#x3D; false，结果为 r.r1 &#x3D; 1</p>
<p>情况二：线程 2 先执行 num &#x3D; 2，但还没执行 ready &#x3D; true，线程 1 执行，结果为 r.r1 &#x3D; 1</p>
<p>情况三：线程 2 先执行 ready &#x3D; true，线程 1 执行，进入 if 分支结果为 r.r1 &#x3D; 4</p>
<p>情况四：线程 2 执行 ready &#x3D; true，切换到线程 1，进入 if 分支为 r.r1 &#x3D; 0，再切回线程 2 执行 num &#x3D; 2，发生指令重排</p>
</li>
</ul>
<hr>
<h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><h5 id="缓存一致-1"><a href="#缓存一致-1" class="headerlink" title="缓存一致"></a>缓存一致</h5><p>使用 volatile 修饰的共享变量，总线会开启 <strong>CPU 总线嗅探机制</strong>来解决 JMM 缓存一致性问题，也就是共享变量在多线程中可见性的问题，实现 MESI 缓存一致性协议</p>
<p>底层是通过汇编 lock 前缀指令，共享变量加了 lock 前缀指令就会进行缓存锁定，在线程修改完共享变量后写回主存，其他的 CPU 核心上运行的线程根据总线嗅探机制会修改其共享变量为失效状态，读取时会重新从主内存中读取最新的数据</p>
<p>lock 前缀指令就相当于内存屏障，Memory Barrier（Memory Fence）</p>
<ul>
<li>对 volatile 变量的写指令后会加入写屏障</li>
<li>对 volatile 变量的读指令前会加入读屏障</li>
</ul>
<p>内存屏障有三个作用：</p>
<ul>
<li>确保对内存的读-改-写操作原子执行</li>
<li>阻止屏障两侧的指令重排序</li>
<li>强制把缓存中的脏数据写回主内存，让缓存行中相应的数据失效</li>
</ul>
<hr>
<h5 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h5><p>保证<strong>可见性</strong>：</p>
<ul>
<li><p>写屏障（sfence，Store Barrier）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读屏障（lfence，Load Barrier）保证在该屏障之后的，对共享变量的读取，从主存刷新变量值，加载的是主存中最新数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">    	r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-volatile保证可见性.png" style="zoom:67%;">
</li>
<li><p>全能屏障：mfence（modify&#x2F;mix Barrier），兼具 sfence 和 lfence 的功能</p>
</li>
</ul>
<p>保证<strong>有序性</strong>：</p>
<ul>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ul>
<p>不能解决指令交错：</p>
<ul>
<li><p>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证其他线程的读跑到写屏障之前</p>
</li>
<li><p>有序性的保证也只是保证了本线程内相关代码不被重排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">volatile</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;i++&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;i--&#125;);</span><br></pre></td></tr></table></figure>

<p>i++ 反编译后的指令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: iconst_1			<span class="comment">// 当int取值 -1~5 时，JVM采用iconst指令将常量压入栈中</span></span><br><span class="line"><span class="number">1</span>: istore_1			<span class="comment">// 将操作数栈顶数据弹出，存入局部变量表的 slot 1</span></span><br><span class="line"><span class="number">2</span>: iinc		<span class="number">1</span>, <span class="number">1</span>	</span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-volatile不能保证原子性.png" style="zoom:67%;"></li>
</ul>
<hr>
<h5 id="交互规则"><a href="#交互规则" class="headerlink" title="交互规则"></a>交互规则</h5><p>对于 volatile 修饰的变量：</p>
<ul>
<li>线程对变量的 use 与 load、read 操作是相关联的，所以变量使用前必须先从主存加载</li>
<li>线程对变量的 assign 与 store、write 操作是相关联的，所以变量使用后必须同步至主存</li>
<li>线程 1 和线程 2 谁先对变量执行 read 操作，就会先进行 write 操作，防止指令重排</li>
</ul>
<hr>
<h4 id="双端检锁"><a href="#双端检锁" class="headerlink" title="双端检锁"></a>双端检锁</h4><h5 id="检锁机制"><a href="#检锁机制" class="headerlink" title="检锁机制"></a>检锁机制</h5><p>Double-Checked Locking：双端检锁机制</p>
<p>DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入 volatile 可以禁止指令重排</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t2，这里的判断不是线程安全的</span></span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 这里是线程安全的判断，防止其他线程在当前线程等待锁的期间完成了初始化</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; </span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不锁 INSTANCE 的原因：</p>
<ul>
<li>INSTANCE 要重新赋值</li>
<li>INSTANCE 是 null，线程加锁之前需要获取对象的引用，设置对象头，null 没有引用</li>
</ul>
<p>实现特点： </p>
<ul>
<li>懒惰初始化</li>
<li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li>
<li>第一个 if 使用了 INSTANCE 变量，是在同步块之外，但在多线程环境下会产生问题</li>
</ul>
<hr>
<h5 id="DCL问题"><a href="#DCL问题" class="headerlink" title="DCL问题"></a>DCL问题</h5><p>getInstance 方法对应的字节码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: 	getstatic 		#<span class="number">2</span> 		<span class="comment">// Field INSTANCE:Ltest/Singleton;</span></span><br><span class="line"><span class="number">3</span>: 	ifnonnull 		<span class="number">37</span></span><br><span class="line"><span class="number">6</span>: 	ldc 			#<span class="number">3</span> 		<span class="comment">// class test/Singleton</span></span><br><span class="line"><span class="number">8</span>: 	dup</span><br><span class="line"><span class="number">9</span>: 	astore_0</span><br><span class="line"><span class="number">10</span>: monitorenter</span><br><span class="line"><span class="number">11</span>: getstatic 		#<span class="number">2</span> 		<span class="comment">// Field INSTANCE:Ltest/Singleton;</span></span><br><span class="line"><span class="number">14</span>: ifnonnull <span class="number">27</span></span><br><span class="line"><span class="number">17</span>: <span class="keyword">new</span> 			#<span class="number">3</span> 		<span class="comment">// class test/Singleton</span></span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line"><span class="number">21</span>: invokespecial 	#<span class="number">4</span> 		<span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">24</span>: putstatic 		#<span class="number">2</span> 		<span class="comment">// Field INSTANCE:Ltest/Singleton;</span></span><br><span class="line"><span class="number">27</span>: aload_0</span><br><span class="line"><span class="number">28</span>: monitorexit</span><br><span class="line"><span class="number">29</span>: goto <span class="number">37</span></span><br><span class="line"><span class="number">32</span>: astore_1</span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: monitorexit</span><br><span class="line"><span class="number">35</span>: aload_1</span><br><span class="line"><span class="number">36</span>: athrow</span><br><span class="line"><span class="number">37</span>: getstatic 		#<span class="number">2</span> 		<span class="comment">// Field INSTANCE:Ltest/Singleton;</span></span><br><span class="line"><span class="number">40</span>: areturn</span><br></pre></td></tr></table></figure>

<ul>
<li>17 表示创建对象，将对象引用入栈 </li>
<li>20 表示复制一份对象引用，引用地址</li>
<li>21 表示利用一个对象引用，调用构造方法初始化对象</li>
<li>24 表示利用一个对象引用，赋值给 static INSTANCE</li>
</ul>
<p><strong>步骤 21 和 24 之间不存在数据依赖关系</strong>，而且无论重排前后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的</p>
<ul>
<li>关键在于 0:getstatic 这行代码在 monitor 控制之外，可以越过 monitor 读取 INSTANCE 变量的值</li>
<li>当其他线程访问 INSTANCE 不为 null 时，由于 INSTANCE 实例未必已初始化，那么 t2 拿到的是将是一个未初始化完毕的单例返回，这就造成了线程安全的问题</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JMM-DCL%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98.png"></p>
<hr>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</p>
<p>引入 volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">SingletonDemo</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="ha-be"><a href="#ha-be" class="headerlink" title="ha-be"></a>ha-be</h3><p>happens-before 先行发生</p>
<p>Java 内存模型具备一些先天的“有序性”，即不需要通过任何同步手段（volatile、synchronized 等）就能够得到保证的安全，这个通常也称为 happens-before 原则，它是可见性与有序性的一套规则总结</p>
<p>不符合 happens-before 规则，JMM 并不能保证一个线程的可见性和有序性</p>
<ol>
<li><p>程序次序规则 (Program Order Rule)：一个线程内，逻辑上书写在前面的操作先行发生于书写在后面的操作 ，因为多个操作之间有先后依赖关系，则不允许对这些操作进行重排序</p>
</li>
<li><p>锁定规则 (Monitor Lock Rule)：一个 unlock 操作先行发生于后面（时间的先后）对同一个锁的 lock 操作，所以线程解锁 m 之前对变量的写（解锁前会刷新到主内存中），对于接下来对 m 加锁的其它线程对该变量的读可见</p>
</li>
<li><p><strong>volatile 变量规则</strong>  (Volatile Variable Rule)：对 volatile 变量的写操作先行发生于后面对这个变量的读</p>
</li>
<li><p>传递规则 (Transitivity)：具有传递性，如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C</p>
</li>
<li><p>线程启动规则 (Thread Start Rule)：Thread 对象的 start()方 法先行发生于此线程中的每一个操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//线程 start 前对变量的写，对该线程开始后对该变量的读可见</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;	System.out.println(x);	&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程中断规则 (Thread Interruption Rule)：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p>
</li>
<li><p>线程终止规则 (Thread Termination Rule)：线程中所有的操作都先行发生于线程的终止检测，可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行</p>
</li>
<li><p>对象终结规则（Finaizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始</p>
</li>
</ol>
<hr>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="终止模式-1"><a href="#终止模式-1" class="headerlink" title="终止模式"></a>终止模式</h4><p>终止模式之两阶段终止模式：停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span> &#123;</span><br><span class="line">    <span class="comment">// 监控线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread monitor;</span><br><span class="line">    <span class="comment">// 停止标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;后置处理&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 睡眠</span></span><br><span class="line">                    System.out.println(thread.getName() + <span class="string">&quot;执行监控记录&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   	System.out.println(<span class="string">&quot;被打断，退出睡眠&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">        monitor.interrupt();<span class="comment">// 让线程尽快退出Timed Waiting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">TwoPhaseTermination</span> <span class="variable">tpt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoPhaseTermination</span>();</span><br><span class="line">    tpt.start();</span><br><span class="line">    Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;停止监控&quot;</span>);</span><br><span class="line">    tpt.stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Balking"><a href="#Balking" class="headerlink" title="Balking"></a>Balking</h4><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorService</span> &#123;</span><br><span class="line">    <span class="comment">// 用来表示是否已经有线程已经在执行启动了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">starting</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;尝试启动监控线程...&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (starting) &#123;</span><br><span class="line">            	<span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            starting = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 真正启动监控线程...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待</p>
<p>例子：希望 doInit() 方法仅被调用一次，下面的实现出现的问题：</p>
<ul>
<li>当 t1 线程进入 init() 准备 doInit()，t2 线程进来，initialized 还为f alse，则 t2 就又初始化一次</li>
<li>volatile 适合一个线程写，其他线程读的情况，这个代码需要加锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVolatile</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	doInit();</span><br><span class="line">    	initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doInit</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>无锁编程：Lock Free</p>
<p>CAS 的全称是 Compare-And-Swap，是 <strong>CPU 并发原语</strong></p>
<ul>
<li>CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 类的各个方法，调用 UnSafe 类中的 CAS 方法，JVM 会实现出 CAS 汇编指令，这是一种完全依赖于硬件的功能，实现了原子操作</li>
<li>CAS 是一种系统原语，原语属于操作系统范畴，是由若干条指令组成 ，用于完成某个功能的一个过程，并且原语的执行必须是连续的，执行过程中不允许被中断，所以 CAS 是一条 CPU 的原子指令，不会造成数据不一致的问题，是线程安全的</li>
</ul>
<p>底层原理：CAS 的底层是 <code>lock cmpxchg</code> 指令（X86 架构），在单核和多核 CPU 下都能够保证比较交换的原子性</p>
<ul>
<li><p>程序是在单核处理器上运行，会省略 lock 前缀，单处理器自身会维护处理器内的顺序一致性，不需要 lock 前缀的内存屏障效果</p>
</li>
<li><p>程序是在多核处理器上运行，会为 cmpxchg 指令加上 lock 前缀。当某个核执行到带 lock 的指令时，CPU 会执行<strong>总线锁定或缓存锁定</strong>，将修改的变量写入到主存，这个过程不会被线程的调度机制所打断，保证了多个线程对内存操作的原子性</p>
</li>
</ul>
<p>作用：比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存的值一致为止</p>
<p>CAS 特点：</p>
<ul>
<li>CAS 体现的是<strong>无锁并发、无阻塞并发</strong>，线程不会陷入阻塞，线程不需要频繁切换状态（上下文切换，系统调用）</li>
<li>CAS 是基于乐观锁的思想</li>
</ul>
<p>CAS 缺点：</p>
<ul>
<li>循环时间长，开销大，因为执行的是循环操作，如果比较不成功一直在循环，最差的情况某个线程一直取到的值和预期值都不一样，就会无限循环导致饥饿，<strong>使用 CAS 线程数不要超过 CPU 的核心数</strong></li>
<li>只能保证一个共享变量的原子操作<ul>
<li>对于一个共享变量执行操作时，可以通过循环 CAS 的方式来保证原子操作</li>
<li>对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候<strong>只能用锁来保证原子性</strong></li>
</ul>
</li>
<li>引出来 ABA 问题</li>
</ul>
<hr>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>CAS 与 synchronized 总结：</p>
<ul>
<li>synchronized 是从悲观的角度出发：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程），因此 synchronized 也称之为悲观锁，ReentrantLock 也是一种悲观锁，性能较差</li>
<li>CAS 是从乐观的角度出发：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。<strong>如果别人修改过，则获取现在最新的值，如果别人没修改过，直接修改共享数据的值</strong>，CAS 这种机制也称之为乐观锁，综合性能较好</li>
</ul>
<hr>
<h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p>常见原子类：AtomicInteger、AtomicBoolean、AtomicLong</p>
<p>构造方法：</p>
<ul>
<li><code>public AtomicInteger()</code>：初始化一个默认值为 0 的原子型 Integer</li>
<li><code>public AtomicInteger(int initialValue)</code>：初始化一个指定值的原子型 Integer</li>
</ul>
<p>常用API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>public final int get()</td>
<td>获取 AtomicInteger 的值</td>
</tr>
<tr>
<td>public final int getAndIncrement()</td>
<td>以原子方式将当前值加 1，返回的是自增前的值</td>
</tr>
<tr>
<td>public final int incrementAndGet()</td>
<td>以原子方式将当前值加 1，返回的是自增后的值</td>
</tr>
<tr>
<td>public final int getAndSet(int value)</td>
<td>以原子方式设置为 newValue 的值，返回旧值</td>
</tr>
<tr>
<td>public final int addAndGet(int data)</td>
<td>以原子方式将输入的数值与实例中的值相加并返回<br>实例：AtomicInteger 里的 value</td>
</tr>
</tbody></table>
<hr>
<h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p><strong>AtomicInteger 原理</strong>：自旋锁  + CAS 算法</p>
<p>CAS 算法：有 3 个操作数（内存值 V， 旧的预期值 A，要修改的值 B）</p>
<ul>
<li>当旧的预期值 A &#x3D;&#x3D; 内存值 V   此时可以修改，将 V 改为 B</li>
<li>当旧的预期值 A !&#x3D;  内存值 V   此时不能修改，并重新获取现在的最新值，重新获取的动作就是自旋</li>
</ul>
<p>分析 getAndSet 方法：</p>
<ul>
<li><p>AtomicInteger：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * this: 		当前对象</span></span><br><span class="line"><span class="comment">    * valueOffset:	内存偏移量，内存地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="built_in">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>valueOffset：偏移量表示该变量值相对于当前对象地址的偏移，Unsafe 就是根据内存偏移地址获取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line"><span class="comment">//调用本地方法   --&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">objectFieldOffset</span><span class="params">(Field var1)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>unsafe 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// val1: AtomicInteger对象本身，var2: 该对象值得引用地址，var4: 需要变动的数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSetInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// var5: 用 var1 和 var2 找到的内存中的真实值</span></span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>var5：从主内存中拷贝到工作内存中的值（每次都要从主内存拿到最新的值到本地内存），然后执行 <code>compareAndSwapInt()</code> 再和主内存的值进行比较，假设方法返回 false，那么就一直执行 while 方法，直到期望的值和真实值一样，修改数据</p>
</li>
<li><p>变量 value 用 volatile 修饰，保证了多线程之间的内存可见性，避免线程从工作缓存中获取失效的变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value</span><br></pre></td></tr></table></figure>

<p><strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现比较并交换的效果</strong></p>
</li>
</ul>
<p>分析 getAndUpdate 方法：</p>
<ul>
<li><p>getAndUpdate：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndUpdate</span><span class="params">(IntUnaryOperator updateFunction)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();	<span class="comment">//当前值，cas的期望值</span></span><br><span class="line">        next = updateFunction.applyAsInt(prev);<span class="comment">//期望值更新到该值</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));<span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数式接口：可以自定义操作逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">a.getAndUpdate(i -&gt; i + <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>compareAndSet：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * this: 		当前对象</span></span><br><span class="line"><span class="comment">    * valueOffset:	内存偏移量，内存地址</span></span><br><span class="line"><span class="comment">    * expect:		期望的值</span></span><br><span class="line"><span class="comment">    * update: 		更新的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h4><p>原子引用：对 Object 进行原子操作，提供一种读和写都是原子性的对象引用变量</p>
<p>原子引用类：AtomicReference、AtomicStampedReference、AtomicMarkableReference</p>
<p>AtomicReference 类：</p>
<ul>
<li><p>构造方法：<code>AtomicReference&lt;T&gt; atomicReference = new AtomicReference&lt;T&gt;()</code></p>
</li>
<li><p>常用 API：</p>
<ul>
<li><code>public final boolean compareAndSet(V expectedValue, V newValue)</code>：CAS 操作</li>
<li><code>public final void set(V newValue)</code>：将值设置为 newValue </li>
<li><code>public final V get()</code>：返回当前值</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">33</span>, <span class="string">&quot;z3&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建原子引用包装类</span></span><br><span class="line">        AtomicReference&lt;Student&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置主内存共享变量为s1</span></span><br><span class="line">        atomicReference.set(s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较并交换，如果现在主物理内存的值为 z3，那么交换成 l4</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">44</span>, <span class="string">&quot;l4&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (atomicReference.compareAndSet(s1, s2)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(atomicReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//。。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h4><p>原子数组类：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p>
<p>AtomicIntegerArray 类方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   i		the index</span></span><br><span class="line"><span class="comment">* expect 	the expected value</span></span><br><span class="line"><span class="comment">* update 	the new value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="原子更新器"><a href="#原子更新器" class="headerlink" title="原子更新器"></a>原子更新器</h4><p>原子更新器类：AtomicReferenceFieldUpdater、AtomicIntegerFieldUpdater、AtomicLongFieldUpdater</p>
<p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常 <code>IllegalArgumentException: Must be volatile type</code></p>
<p>常用 API：</p>
<ul>
<li><code>static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; c, String fieldName)</code>：构造方法</li>
<li><code>abstract boolean compareAndSet(T obj, int expect, int update)</code>：CAS</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpdateDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> field;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicIntegerFieldUpdater</span> <span class="variable">fieldUpdater</span> <span class="operator">=</span> AtomicIntegerFieldUpdater</span><br><span class="line">            		.newUpdater(UpdateDemo.class, <span class="string">&quot;field&quot;</span>);</span><br><span class="line">        <span class="type">UpdateDemo</span> <span class="variable">updateDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateDemo</span>();</span><br><span class="line">        fieldUpdater.compareAndSet(updateDemo, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(updateDemo.field);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h4><p>原子累加器类：LongAdder、DoubleAdder、LongAccumulator、DoubleAccumulator </p>
<p>LongAdder 和 LongAccumulator 区别：</p>
<p>相同点：</p>
<ul>
<li>LongAddr 与 LongAccumulator 类都是使用非阻塞算法 CAS 实现的</li>
<li>LongAddr 类是 LongAccumulator 类的一个特例，只是 LongAccumulator 提供了更强大的功能，可以自定义累加规则，当accumulatorFunction 为 null 时就等价于 LongAddr</li>
</ul>
<p>不同点：</p>
<ul>
<li><p>调用 casBase 时，LongAccumulator 使用 function.applyAsLong(b &#x3D; base, x) 来计算，LongAddr 使用 casBase(b &#x3D; base, b + x) </p>
</li>
<li><p>LongAccumulator 类功能更加强大，构造方法参数中</p>
<ul>
<li>accumulatorFunction 是一个双目运算器接口，可以指定累加规则，比如累加或者相乘，其根据输入的两个参数返回一个计算值，LongAdder 内置累加规则</li>
<li>identity 则是 LongAccumulator 累加器的初始值，LongAccumulator 可以为累加器提供非0的初始值，而 LongAdder 只能提供默认的 0</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Adder"><a href="#Adder" class="headerlink" title="Adder"></a>Adder</h3><h4 id="优化机制"><a href="#优化机制" class="headerlink" title="优化机制"></a>优化机制</h4><p>LongAdder 是 Java8 提供的类，跟 AtomicLong 有相同的效果，但对 CAS 机制进行了优化，尝试使用分段 CAS 以及自动分段迁移的方式来大幅度提升多线程高并发执行 CAS 操作的性能</p>
<p>CAS 底层实现是在一个循环中不断地尝试修改目标值，直到修改成功。如果竞争不激烈修改成功率很高，否则失败率很高，失败后这些重复的原子性操作会耗费性能（导致大量线程<strong>空循环，自旋转</strong>）</p>
<p>优化核心思想：数据分离，将 AtomicLong 的<strong>单点的更新压力分担到各个节点，空间换时间</strong>，在低并发的时候直接更新，可以保障和 AtomicLong 的性能基本一致，而在高并发的时候通过分散减少竞争，提高了性能</p>
<p><strong>分段 CAS 机制</strong>：</p>
<ul>
<li>在发生竞争时，创建 Cell 数组用于将不同线程的操作离散（通过 hash 等算法映射）到不同的节点上</li>
<li>设置多个累加单元（会根据需要扩容，最大为 CPU 核数），Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1] 等，最后将结果汇总</li>
<li>在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能</li>
</ul>
<p><strong>自动分段迁移机制</strong>：某个 Cell 的 value 执行 CAS 失败，就会自动寻找另一个 Cell 分段内的 value 值进行 CAS 操作</p>
<hr>
<h4 id="伪共享-1"><a href="#伪共享-1" class="headerlink" title="伪共享"></a>伪共享</h4><p>Cell 为累加单元：数组访问索引是通过 Thread 里的 threadLocalRandomProbe 域取模实现的，这个域是 ThreadLocalRandom 更新的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Striped64.Cell</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    Cell(<span class="type">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    <span class="comment">// 用 cas 方式进行累加, prev 表示旧值, next 表示新值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">cas</span><span class="params">(<span class="type">long</span> prev, <span class="type">long</span> next)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, valueOffset, prev, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略不重要代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cell 是数组形式，<strong>在内存中是连续存储的</strong>，64 位系统中，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），每一个 cache line 为 64 字节，因此缓存行可以存下 2 个的 Cell 对象，当 Core-0 要修改 Cell[0]、Core-1 要修改 Cell[1]，无论谁修改成功都会导致当前缓存行失效，从而导致对方的数据失效，需要重新去主存获取，影响效率</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E4%BC%AA%E5%85%B1%E4%BA%AB1.png"></p>
<p>@sun.misc.Contended：防止缓存行伪共享，在使用此注解的对象或字段的前后各增加 128 字节大小的 padding，使用 2 倍于大多数硬件缓存行让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样就不会造成对方缓存行的失效</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E4%BC%AA%E5%85%B1%E4%BA%AB2.png"></p>
<hr>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>Striped64 类成员属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示当前计算机CPU数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors()</span><br><span class="line"><span class="comment">// 累加单元数组, 懒惰初始化</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"><span class="comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域，当 cells 扩容时，也会将数据写到 base 中</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"><span class="comment">// 在 cells 初始化或扩容时只能有一个线程执行, 通过 CAS 更新 cellsBusy 置为 1 来实现一个锁</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br></pre></td></tr></table></figure>

<p>工作流程：</p>
<ul>
<li><p>cells 占用内存是相对比较大的，是惰性加载的，在无竞争或者其他线程正在初始化 cells 数组的情况下，直接更新 base 域</p>
</li>
<li><p>在第一次发生竞争时（casBase 失败）会创建一个大小为 2 的 cells 数组，将当前累加的值包装为 Cell 对象，放入映射的槽位上</p>
</li>
<li><p>分段累加的过程中，如果当前线程对应的 cells 槽位为空，就会新建 Cell 填充，如果出现竞争，就会重新计算线程对应的槽位，继续自旋尝试修改</p>
</li>
<li><p>分段迁移后还出现竞争就会扩容 cells 数组长度为原来的两倍，然后 rehash，<strong>数组长度总是 2 的 n 次幂</strong>，默认最大为 CPU 核数，但是可以超过，如果核数是 6 核，数组最长是 8</p>
</li>
</ul>
<p>方法分析：</p>
<ul>
<li><p>LongAdder#add：累加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// as 为累加单元数组的引用，b 为基础值，v 表示期望值</span></span><br><span class="line">    <span class="comment">// m 表示 cells 数组的长度 - 1，a 表示当前线程命中的 cell 单元格</span></span><br><span class="line">    Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cells 不为空说明 cells 已经被初始化，线程发生了竞争，去更新对应的 cell 槽位</span></span><br><span class="line">    <span class="comment">// 进入 || 后的逻辑去更新 base 域，更新失败表示发生竞争进入条件</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="comment">// uncontended 为 true 表示 cell 没有竞争</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 条件一: true 说明 cells 未初始化，多线程写 base 发生竞争需要进行初始化 cells 数组</span></span><br><span class="line">        <span class="comment">//		  fasle 说明 cells 已经初始化，进行下一个条件寻找自己的 cell 去累加</span></span><br><span class="line">        <span class="comment">// 条件二: getProbe() 获取 hash 值，&amp; m 的逻辑和 HashMap 的逻辑相同，保证散列的均匀性</span></span><br><span class="line">        <span class="comment">// 		  true 说明当前线程对应下标的 cell 为空，需要创建 cell</span></span><br><span class="line">        <span class="comment">//        false 说明当前线程对应的 cell 不为空，进行下一个条件【将 x 值累加到对应的 cell 中】</span></span><br><span class="line">        <span class="comment">// 条件三: 有取反符号，false 说明 cas 成功，直接返回，true 说明失败，当前线程对应的 cell 有竞争</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">        	<span class="comment">// 【uncontended 在对应的 cell 上累加失败的时候才为 false，其余情况均为 true】</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Striped64#longAccumulate：cell 数组创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">							<span class="comment">// x  			null 			false | true</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn, <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// 当前线程还没有对应的 cell, 需要随机生成一个 hash 值用来将当前线程绑定到 cell</span></span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化 probe，获取 hash 值</span></span><br><span class="line">        ThreadLocalRandom.current(); </span><br><span class="line">        h = getProbe();	</span><br><span class="line">        <span class="comment">// 默认情况下 当前线程肯定是写入到了 cells[0] 位置，不把它当做一次真正的竞争</span></span><br><span class="line">        wasUncontended = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表示【扩容意向】，false 一定不会扩容，true 可能会扩容</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// as 表示cells引用，a 表示当前线程命中的 cell，n 表示 cells 数组长度，v 表示 期望值</span></span><br><span class="line">        Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">        <span class="comment">// 【CASE1】: 表示 cells 已经初始化了，当前线程应该将数据写入到对应的 cell 中</span></span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// CASE1.1: true 表示当前线程对应的索引下标的 Cell 为 null，需要创建 new Cell</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断 cellsBusy 是否被锁</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;   </span><br><span class="line">                    <span class="comment">// 创建 cell, 初始累加值为 x</span></span><br><span class="line">                    <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);  </span><br><span class="line">                    <span class="comment">// 加锁</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                        <span class="comment">// 创建成功标记，进入【创建 cell 逻辑】</span></span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;	</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Cell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                            <span class="comment">// 把当前 cells 数组赋值给 rs，并且不为 null</span></span><br><span class="line">                            <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                <span class="comment">// 再次判断防止其它线程初始化过该位置，当前线程再次初始化该位置会造成数据丢失</span></span><br><span class="line">                                <span class="comment">// 因为这里是线程安全的判断，进行的逻辑不会被其他线程影响</span></span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 把新创建的 cell 填充至当前位置</span></span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="literal">true</span>;	<span class="comment">// 表示创建完成</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;		<span class="comment">// 解锁</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)			<span class="comment">// true 表示创建完成，可以推出循环了</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// CASE1.2: 条件成立说明线程对应的 cell 有竞争, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">                wasUncontended = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// CASE 1.3: 当前线程 rehash 过，如果新命中的 cell 不为空，就尝试累加，false 说明新命中也有竞争</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// CASE 1.4: cells 长度已经超过了最大长度 CPU 内核的数量或者已经扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = <span class="literal">false</span>; 		<span class="comment">// 扩容意向改为false，【表示不能扩容了】</span></span><br><span class="line">            <span class="comment">// CASE 1.5: 更改扩容意向，如果 n &gt;= NCPU，这里就永远不会执行到，case1.4 永远先于 1.5 执行</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// CASE 1.6: 【扩容逻辑】，进行加锁</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 线程安全的检查，防止期间被其他线程扩容了</span></span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;     </span><br><span class="line">                        <span class="comment">// 扩容为以前的 2 倍</span></span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="comment">// 遍历移动值</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        <span class="comment">// 把扩容后的引用给 cells</span></span><br><span class="line">                        cells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;	<span class="comment">// 解锁</span></span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;	<span class="comment">// 扩容意向改为 false，表示不扩容了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重置当前线程 Hash 值，这就是【分段迁移机制】</span></span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【CASE2】: 运行到这说明 cells 还未初始化，as 为null</span></span><br><span class="line">        <span class="comment">// 判断是否没有加锁，没有加锁就用 CAS 加锁</span></span><br><span class="line">        <span class="comment">// 条件二判断是否其它线程在当前线程给 as 赋值之后修改了 cells，这里不是线程安全的判断</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="comment">// 初始化标志，开始 【初始化 cells 数组】</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">               	<span class="comment">// 再次判断 cells == as 防止其它线程已经提前初始化了，当前线程再次初始化导致丢失数据</span></span><br><span class="line">                <span class="comment">// 因为这里是【线程安全的，重新检查，经典 DCL】</span></span><br><span class="line">                <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];	<span class="comment">// 初始化数组大小为2</span></span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);	<span class="comment">// 填充线程对应的cell</span></span><br><span class="line">                    cells = rs;</span><br><span class="line">                    init = <span class="literal">true</span>;				<span class="comment">// 初始化成功，标记置为 true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;					<span class="comment">// 解锁啊</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;							<span class="comment">// 初始化成功直接跳出自旋</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 【CASE3】: 运行到这说明其他线程在初始化 cells，当前线程将值累加到 base，累加成功直接结束自旋</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x :</span><br><span class="line">                                    fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sum：获取最终结果通过 sum 整合，<strong>保证最终一致性，不保证强一致性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历 累加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h3><p>ABA 问题：当进行获取主内存值时，该内存值在写入主内存时已经被修改了 N 次，但是最终又改成原来的值</p>
<p>其他线程先把 A 改成 B 又改回 A，主线程<strong>仅能判断出共享变量的值与最初值 A 是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，这时 CAS 虽然成功，但是过程存在问题</p>
<ul>
<li><p>构造方法：</p>
<ul>
<li><code>public AtomicStampedReference(V initialRef, int initialStamp)</code>：初始值和初始版本号</li>
</ul>
</li>
<li><p>常用API：</p>
<ul>
<li><code> public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)</code>：期望引用和期望版本号都一致才进行 CAS 修改数据</li>
<li><code>public void set(V newReference, int newStamp)</code>：设置值和版本号</li>
<li><code>public V getReference()</code>：返回引用的值</li>
<li><code>public int getStamp()</code>：返回当前版本号</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    AtomicStampedReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">startStamp</span> <span class="operator">=</span> atomicReference.getStamp();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicReference.getStamp();</span><br><span class="line">        atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">        stamp = atomicReference.getStamp();</span><br><span class="line">        atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">200</span>, startStamp, startStamp + <span class="number">1</span>)) &#123;</span><br><span class="line">            System.out.println(atomicReference.getReference());<span class="comment">//100</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程修改失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>Unsafe 是 CAS 的核心类，由于 Java 无法直接访问底层系统，需要通过本地（Native）方法来访问</p>
<p>Unsafe 类存在 sun.misc 包，其中所有方法都是 native 修饰的，都是直接调用<strong>操作系统底层资源</strong>执行相应的任务，基于该类可以直接操作特定的内存数据，其内部方法操作类似 C 的指针</p>
<p>模拟实现原子整数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyAtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAtomicInteger</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (atomicInteger.compareAndSwap(<span class="number">20</span>)) &#123;</span><br><span class="line">        System.out.println(atomicInteger.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAtomicInteger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> VALUE_OFFSET;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Unsafe unsafe = Unsafe.getUnsafe()这样会报错，需要反射获取</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            UNSAFE = (Unsafe) theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 获取 value 属性的内存地址，value 属性指向该地址，直接设置该地址的值可以修改 value 的值</span></span><br><span class="line">            VALUE_OFFSET = UNSAFE.objectFieldOffset(</span><br><span class="line">                		   MyAtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAtomicInteger</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSwap</span><span class="params">(<span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="built_in">this</span>.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> update;</span><br><span class="line">            <span class="comment">//							当前对象  内存偏移量    期望值 更新值</span></span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, VALUE_OFFSET, prev, update)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;CAS成功&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFinal</span> &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: aload_0</span><br><span class="line"><span class="number">1</span>: invokespecial #<span class="number">1</span> <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">4</span>: aload_0</span><br><span class="line"><span class="number">5</span>: bipush <span class="number">20</span>		<span class="comment">// 将值直接放入栈中</span></span><br><span class="line"><span class="number">7</span>: putfield #<span class="number">2</span> 		<span class="comment">// Field a:I</span></span><br><span class="line">&lt;-- 写屏障</span><br><span class="line"><span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>final 变量的赋值通过 putfield 指令来完成，在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况</p>
<p>其他线程访问 final 修饰的变量<strong>会复制一份放入栈中</strong>，效率更高</p>
<hr>
<h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>不可变：如果一个对象不能够修改其内部状态（属性），那么就是不可变对象</p>
<p>不可变对象线程安全的，不存在并发修改和可见性问题，是另一种避免竞争的方式</p>
<p>String 类也是不可变的，该类和类中所有属性都是 final 的</p>
<ul>
<li><p>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</p>
</li>
<li><p>无写入方法（set）确保外部不能对内部属性进行修改</p>
</li>
<li><p>属性用 final 修饰保证了该属性是只读的，不能修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改 String 类数据时，会构造新字符串对象，生成新的 char[] value，通过<strong>创建副本对象来避免共享的方式称之为保护性拷贝</strong></p>
</li>
</ul>
<hr>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>无状态：成员变量保存的数据也可以称为状态信息，无状态就是没有成员变量</p>
<p>Servlet 为了保证其线程安全，一般不为 Servlet 设置成员变量，这种没有任何成员变量的类是线程安全的</p>
<hr>
<h3 id="Local"><a href="#Local" class="headerlink" title="Local"></a>Local</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>ThreadLocal 类用来提供线程内部的局部变量，这种变量在多线程环境下访问（通过 get 和 set 方法访问）时能保证各个线程的变量相对独立于其他线程内的变量，分配在堆内的 <strong>TLAB</strong> 中</p>
<p>ThreadLocal 实例通常来说都是 <code>private static</code> 类型的，属于一个线程的本地变量，用于关联线程和线程上下文。每个线程都会在 ThreadLocal 中保存一份该线程独有的数据，所以是线程安全的</p>
<p>ThreadLocal 作用：</p>
<ul>
<li><p>线程并发：应用在多线程并发的场景下</p>
</li>
<li><p>传递数据：通过 ThreadLocal 实现在同一线程不同函数或组件中传递公共变量，减少传递复杂度</p>
</li>
<li><p>线程隔离：每个线程的变量都是独立的，不会互相影响</p>
</li>
</ul>
<p>对比 synchronized：</p>
<table>
<thead>
<tr>
<th></th>
<th>synchronized</th>
<th>ThreadLocal</th>
</tr>
</thead>
<tbody><tr>
<td>原理</td>
<td>同步机制采用<strong>以时间换空间</strong>的方式，只提供了一份变量，让不同的线程排队访问</td>
<td>ThreadLocal 采用<strong>以空间换时间</strong>的方式，为每个线程都提供了一份变量的副本，从而实现同时访问而相不干扰</td>
</tr>
<tr>
<td>侧重点</td>
<td>多个线程之间访问资源的同步</td>
<td>多线程中让每个线程之间的数据相互隔离</td>
</tr>
</tbody></table>
<hr>
<h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ThreadLocal&lt;&gt;()</td>
<td>创建 ThreadLocal 对象</td>
</tr>
<tr>
<td>protected T initialValue()</td>
<td>返回当前线程局部变量的初始值</td>
</tr>
<tr>
<td>public void set( T value)</td>
<td>设置当前线程绑定的局部变量</td>
</tr>
<tr>
<td>public T get()</td>
<td>获取当前线程绑定的局部变量</td>
</tr>
<tr>
<td>public void remove()</td>
<td>移除当前线程绑定的局部变量</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程绑定的变量</span></span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="comment">// 变量content绑定到当前线程</span></span><br><span class="line">        tl.set(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 设置数据</span></span><br><span class="line">                    demo.setContent(Thread.currentThread().getName() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + demo.getContent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>ThreadLocal 适用于下面两种场景：</p>
<ul>
<li>每个线程需要有自己单独的实例</li>
<li>实例需要在多个方法中共享，但不希望被多线程共享</li>
</ul>
<p>ThreadLocal 方案有两个突出的优势： </p>
<ol>
<li>传递数据：保存每个线程绑定的数据，在需要的地方可以直接获取，避免参数直接传递带来的代码耦合问题</li>
<li>线程隔离：各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失</li>
</ol>
<p>ThreadLocal 用于数据连接的事务管理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcUtils</span> &#123;</span><br><span class="line">    <span class="comment">// ThreadLocal对象，将connection绑定在当前线程中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">    <span class="comment">// c3p0 数据库连接池对象属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ComboPooledDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//取出当前线程绑定的connection对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> tl.get();</span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果没有，则从连接池中取出</span></span><br><span class="line">            conn = ds.getConnection();</span><br><span class="line">            <span class="comment">//再将connection对象绑定到当前线程中，非常重要的操作</span></span><br><span class="line">            tl.set(conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 ThreadLocal 使 SimpleDateFormat 从独享变量变成单个线程变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDateUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;DateFormat&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> DateFormat <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">parse</span><span class="params">(String dateStr)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get().parse(dateStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">format</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get().format(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h5><p>JDK8 以前：每个 ThreadLocal 都创建一个 Map，然后用线程作为 Map 的 key，要存储的局部变量作为 Map 的 value，达到各个线程的局部变量隔离的效果。这种结构会造成 Map 结构过大和内存泄露，因为 Thread 停止后无法通过 key 删除对应的数据</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ThreadLocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84JDK8%E5%89%8D.png"></p>
<p>JDK8 以后：每个 Thread 维护一个 ThreadLocalMap，这个 Map 的 key 是 ThreadLocal 实例本身，value 是真正要存储的值</p>
<ul>
<li><strong>每个 Thread 线程内部都有一个 Map (ThreadLocalMap)</strong></li>
<li>Map 里面存储 ThreadLocal 对象（key）和线程的私有变量（value）</li>
<li>Thread 内部的 Map 是由 ThreadLocal 维护的，由 ThreadLocal 负责向 map 获取和设置线程的变量值</li>
<li>对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成副本的隔离，互不干扰</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ThreadLocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84JDK8%E5%90%8E.png"></p>
<p>JDK8 前后对比：</p>
<ul>
<li>每个 Map 存储的 Entry 数量会变少，因为之前的存储数量由 Thread 的数量决定，现在由 ThreadLocal 的数量决定，在实际编程当中，往往 ThreadLocal 的数量要少于 Thread 的数量</li>
<li>当 Thread 销毁之后，对应的 ThreadLocalMap 也会随之销毁，能减少内存的使用，<strong>防止内存泄露</strong></li>
</ul>
<hr>
<h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ul>
<li><p>Thread 类的相关属性：<strong>每一个线程持有一个 ThreadLocalMap 对象</strong>，存放由 ThreadLocal 和数据组成的 Entry 键值对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>计算 ThreadLocal 对象的哈希值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode()</span><br></pre></td></tr></table></figure>

<p>使用 <code>threadLocalHashCode &amp; (table.length - 1)</code> 计算当前 entry 需要存放的位置</p>
</li>
<li><p>每创建一个 ThreadLocal 对象就会使用 nextHashCode 分配一个 hash 值给这个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">nextHashCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>斐波那契数也叫黄金分割数，hash 的<strong>增量</strong>就是这个数字，带来的好处是 hash 分布非常均匀：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><p>方法都是线程安全的，因为 ThreadLocal 属于一个线程的，ThreadLocal 中的方法，逻辑都是获取当前线程维护的 ThreadLocalMap 对象，然后进行数据的增删改查，没有指定初始值的 threadlcoal 对象默认赋值为 null</p>
<ul>
<li><p>initialValue()：返回该线程局部变量的初始值</p>
<ul>
<li>延迟调用的方法，在执行 get 方法时才执行</li>
<li>该方法缺省（默认）实现直接返回一个 null</li>
<li>如果想要一个初始值，可以重写此方法， 该方法是一个 <code>protected</code> 的方法，为了让子类覆盖而设计的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>nextHashCode()：计算哈希值，ThreadLocal 的散列方式称之为<strong>斐波那契散列</strong>，每次获取哈希值都会加上 HASH_INCREMENT，这样做可以尽量避免 hash 冲突，让哈希值能均匀的分布在 2 的 n 次方的数组中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 哈希值自增一个 HASH_INCREMENT 数值</span></span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>set()：修改当前线程与当前 threadlocal 对象相关联的线程局部变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的 ThreadLocalMap 对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 判断 map 是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 调用 threadLocalMap.set 方法进行重写或者添加</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// map 为空，调用 createMap 进行 ThreadLocalMap 对象的初始化。参数1是当前线程，参数2是局部变量</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前线程 Thread 对应维护的 ThreadLocalMap </span></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建当前线程Thread对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    <span class="comment">// 【这里的 this 是调用此方法的 threadLocal】，创建一个新的 Map 并设置第一个数据</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>get()：获取当前线程与当前 ThreadLocal 对象相关联的线程局部变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 如果此map存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 以当前的 ThreadLocal 为 key，调用 getEntry 获取对应的存储实体 e</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 对 e 进行判空 </span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取存储实体 e 对应的 value值</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*有两种情况有执行当前代码</span></span><br><span class="line"><span class="comment">      第一种情况: map 不存在，表示此线程没有维护的 ThreadLocalMap 对象</span></span><br><span class="line"><span class="comment">      第二种情况: map 存在, 但是【没有与当前 ThreadLocal 关联的 entry】，就会设置为默认值 */</span></span><br><span class="line">    <span class="comment">// 初始化当前线程与当前 threadLocal 对象相关联的 value</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用initialValue获取初始化的值，此方法可以被子类重写, 如果不重写默认返回 null</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 判断 map 是否初始化过</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 存在则调用 map.set 设置此实体 entry，value 是默认的值</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 调用 createMap 进行 ThreadLocalMap 对象的初始化中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="comment">// 返回线程与当前 threadLocal 关联的局部变量</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>remove()：移除当前线程与当前 threadLocal 对象相关联的线程局部变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象中维护的 ThreadLocalMap 对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// map 存在则调用 map.remove，this时当前ThreadLocal，以this为key删除对应的实体</span></span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="LocalMap"><a href="#LocalMap" class="headerlink" title="LocalMap"></a>LocalMap</h4><h5 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h5><p>ThreadLocalMap 是 ThreadLocal 的内部类，没有实现 Map 接口，用独立的方式实现了 Map 的功能，其内部 Entry 也是独立实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化当前 map 内部散列表数组的初始长度 16</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放数据的table，数组长度必须是2的整次幂。</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组里面 entrys 的个数，可以用于判断 table 当前使用量是否超过阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行扩容的阈值，表使用量大于它的时候进行扩容。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold;</span><br></pre></td></tr></table></figure>

<p>存储结构 Entry：</p>
<ul>
<li>Entry 继承 WeakReference，key 是弱引用，目的是将 ThreadLocal 对象的生命周期和线程生命周期解绑</li>
<li>Entry 限制只能用 ThreadLocal 作为 key，key 为 null (entry.get() &#x3D;&#x3D; null) 意味着 key 不再被引用，entry 也可以从 table 中清除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="comment">// this.referent = referent = key;</span></span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法：延迟初始化的，线程第一次存储 threadLocal - value 时才会创建 threadLocalMap 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">// 初始化table，创建一个长度为16的Entry数组</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">    <span class="comment">// 【寻址算法】计算索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 创建 entry 对象，存放到指定位置的 slot 中</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">    <span class="comment">// 数据总量是 1</span></span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将阈值设置为 （当前数组长度 * 2）/ 3。</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h5 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h5><ul>
<li><p>set()：添加数据，ThreadLocalMap 使用<strong>线性探测法来解决哈希冲突</strong></p>
<ul>
<li><p>该方法会一直探测下一个地址，直到有空的地址后插入，若插入后 Map 数量超过阈值，数组会扩容为原来的 2 倍</p>
<p>假设当前 table 长度为16，计算出来 key 的 hash 值为 14，如果 table[14] 上已经有值，并且其 key 与当前 key 不一致，那么就发生了 hash 冲突，这个时候将 14 加 1 得到 15，取 table[15] 进行判断，如果还是冲突会回到 0，取 table[0]，以此类推，直到可以插入，可以把 Entry[]  table 看成一个<strong>环形数组</strong></p>
</li>
<li><p>线性探测法会出现<strong>堆积问题</strong>，可以采取平方探测法解决</p>
</li>
<li><p>在探测过程中 ThreadLocal 会复用 key 为 null 的脏 Entry 对象，并进行垃圾清理，防止出现内存泄漏</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取散列表</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 哈希寻址</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使用线性探测法向后查找元素，碰到 entry 为空时停止探测</span></span><br><span class="line">    <span class="keyword">for</span> (ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="comment">// 获取当前元素 key</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// ThreadLocal 对应的 key 存在，【直接覆盖之前的值】</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 【这两个条件谁先成立不一定，所以 replaceStaleEntry 中还需要判断 k == key 的情况】</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// key 为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，当前是【过期数据】</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 【碰到一个过期的 slot，当前数据复用该槽位，替换过期数据】</span></span><br><span class="line">            <span class="comment">// 这个方法还进行了垃圾清理动作，防止内存泄漏</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 逻辑到这说明碰到 slot == null 的位置，则在空元素的位置创建一个新的 Entry</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="comment">// 数量 + 1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 【做一次启发式清理】，如果没有清除任何 entry 并且【当前使用量达到了负载因子所定义，那么进行 rehash</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取【环形数组】的下一个索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="comment">// 索引越界后从 0 开始继续获取</span></span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在指定位置插入指定的数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value, <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取散列表</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line">	<span class="comment">// 探测式清理的开始下标，默认从当前 staleSlot 开始</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">    <span class="comment">// 以当前 staleSlot 开始【向前迭代查找】，找到索引靠前过期数据，找到以后替换 slotToExpunge 值</span></span><br><span class="line">    <span class="comment">// 【保证在一个区间段内，从最前面的过期数据开始清理】</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以 staleSlot 【向后去查找】，直到碰到 null 为止，还是线性探测</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">        <span class="comment">// 获取当前节点的 key</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">		<span class="comment">// 条件成立说明是【替换逻辑】</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="comment">// 因为本来要在 staleSlot 索引处插入该数据，现在找到了i索引处的key与数据一致</span></span><br><span class="line">            <span class="comment">// 但是 i 位置距离正确的位置更远，因为是向后查找，所以还是要在 staleSlot 位置插入当前 entry</span></span><br><span class="line">            <span class="comment">// 然后将 table[staleSlot] 这个过期数据放到当前循环到的 table[i] 这个位置，</span></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 条件成立说明向前查找过期数据并未找到过期的 entry，但 staleSlot 位置已经不是过期数据了，i 位置才是</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 【清理过期数据，expungeStaleEntry 探测式清理，cleanSomeSlots 启发式清理】</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 条件成立说明当前遍历的 entry 是一个过期数据，并且该位置前面也没有过期数据</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            <span class="comment">// 探测式清理过期数据的开始下标修改为当前循环的 index，因为 staleSlot 会放入要添加的数据</span></span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 向后查找过程中并未发现 k == key 的 entry，说明当前是一个【取代过期数据逻辑】</span></span><br><span class="line">    <span class="comment">// 删除原有的数据引用，防止内存泄露</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// staleSlot 位置添加数据，【上面的所有逻辑都不会更改 staleSlot 的值】</span></span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件成立说明除了 staleSlot 以外，还发现其它的过期 slot，所以要【开启清理数据的逻辑】</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-replaceStaleEntry%E6%B5%81%E7%A8%8B.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prevIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="comment">// 形成一个环绕式的访问，头索引越界后置为尾索引</span></span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getEntry()：ThreadLocal 的 get 方法以当前的 ThreadLocal 为 key，调用 getEntry 获取对应的存储实体 e</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="comment">// 哈希寻址</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 访问散列表中指定指定位置的 slot </span></span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="comment">// 条件成立，说明 slot 有值并且 key 就是要寻找的 key，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 进行线性探测</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线性探测寻址</span></span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取散列表</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始遍历，碰到 slot == null 的情况，搜索结束</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 获取当前 slot 中 entry 对象的 key</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 条件成立说明找到了，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">             <span class="comment">// 过期数据，【探测式过期数据回收】</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 更新 index 继续向后走</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        <span class="comment">// 获取下一个槽位中的 entry</span></span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 说明当前区段没有找到相应数据</span></span><br><span class="line">    <span class="comment">// 【因为存放数据是线性的向后寻找槽位，都是紧挨着的，不可能越过一个 空槽位 在后面放】，可以减少遍历的次数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>rehash()：触发一次全量清理，如果数组长度大于等于长度的 <code>2/3 * 3/4 = 1/2</code>，则进行 resize</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 清楚当前散列表内的【所有】过期的数据</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// threshold = len * 2 / 3，就是 2/3 * (1 - 1/4)</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 【遍历所有的槽位，清理过期数据】</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Entry <strong>数组为扩容为原来的 2 倍</strong> ，重新计算 key 的散列值，如果遇到 key 为 null 的情况，会将其 value 也置为 null，帮助 GC</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldLen</span> <span class="operator">=</span> oldTab.length;</span><br><span class="line">    <span class="comment">// 新数组的长度是老数组的二倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newLen</span> <span class="operator">=</span> oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> <span class="title class_">Entry</span>[newLen];</span><br><span class="line">    <span class="comment">// 统计新table中的entry数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 遍历老表，进行【数据迁移】</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        <span class="comment">// 访问老表的指定位置的 entry</span></span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> oldTab[j];</span><br><span class="line">        <span class="comment">// 条件成立说明老表中该位置有数据，可能是过期数据也可能不是</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="comment">// 过期数据</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                e.value = <span class="literal">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 非过期数据，在新表中进行哈希寻址</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 【线程探测】</span></span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                <span class="comment">// 将数据存放到新表合适的 slot 中</span></span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 设置下一次触发扩容的指标：threshold = len * 2 / 3;</span></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    <span class="comment">// 将扩容后的新表赋值给 threadLocalMap 内部散列表数组引用</span></span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>remove()：删除 Entry</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 哈希寻址</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="comment">// 找到了对应的 key</span></span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            <span class="comment">// 设置 key 为 null</span></span><br><span class="line">            e.clear();</span><br><span class="line">            <span class="comment">// 探测式清理</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="清理方法"><a href="#清理方法" class="headerlink" title="清理方法"></a>清理方法</h5><ul>
<li><p>探测式清理：沿着开始位置向后探测清理过期数据，沿途中碰到未过期数据则将此数据 rehash 在 table 数组中的定位，重定位后的元素理论上更接近 <code>i = entry.key &amp; (table.length - 1)</code>，让<strong>数据的排列更紧凑</strong>，会优化整个散列表查询性能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// table[staleSlot] 是一个过期数据，以这个位置开始继续向后查找过期数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取散列表和数组长度</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// help gc，先把当前过期的 entry 置空，在取消对 entry 的引用</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 数量-1</span></span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 从 staleSlot 开始向后遍历，直到碰到 slot == null 结束，【区间内清理过期数据】</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 当前 entry 是过期数据</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// help gc</span></span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前 entry 不是过期数据的逻辑，【rehash】</span></span><br><span class="line">            <span class="comment">// 重新计算当前 entry 对应的 index</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 条件成立说明当前 entry 存储时发生过 hash 冲突，向后偏移过了</span></span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                <span class="comment">// 当前位置置空</span></span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 以正确位置 h 开始，向后查找第一个可以存放 entry 的位置</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                <span class="comment">// 将当前元素放入到【距离正确位置更近的位置，有可能就是正确位置】</span></span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 slot = null 的槽位索引，图例是 7，这个索引代表【索引前面的区间已经清理完成垃圾了】</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ThreadLocal探测式清理1.png" style="zoom:67%;">

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ThreadLocal探测式清理2.png" style="zoom:67%;">
</li>
<li><p>启发式清理：向后循环扫描过期数据，发现过期数据调用探测式清理方法，如果连续几次的循环都没有发现过期数据，就停止扫描</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  i 表示启发式清理工作开始位置，一般是空 slot，n 一般传递的是 table.length </span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 表示启发式清理工作是否清除了过期数据</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 获取当前 map 的散列表引用</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 获取下一个索引，因为探测式返回的 slot 为 null</span></span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">        <span class="comment">// 条件成立说明是过期的数据，key 被 gc 了</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 【发现过期数据重置 n 为数组的长度】</span></span><br><span class="line">            n = len;</span><br><span class="line">            <span class="comment">// 表示清理过过期数据</span></span><br><span class="line">            removed = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 以当前过期的 slot 为开始节点 做一次探测式清理工作</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 假设 table 长度为 16</span></span><br><span class="line">        <span class="comment">// 16 &gt;&gt;&gt; 1 ==&gt; 8，8 &gt;&gt;&gt; 1 ==&gt; 4，4 &gt;&gt;&gt; 1 ==&gt; 2，2 &gt;&gt;&gt; 1 ==&gt; 1，1 &gt;&gt;&gt; 1 ==&gt; 0</span></span><br><span class="line">        <span class="comment">// 连续经过这么多次循环【没有扫描到过期数据】，就停止循环，扫描到空 slot 不算，因为不是过期数据</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回清除标记</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>参考视频：<a href="https://space.bilibili.com/457326371/">https://space.bilibili.com/457326371/</a></p>
<hr>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>Memory leak：内存泄漏是指程序中动态分配的堆内存由于某种原因未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果，内存泄漏的堆积终将导致内存溢出</p>
<ul>
<li><p>如果 key 使用强引用：使用完 ThreadLocal ，threadLocal Ref 被回收，但是 threadLocalMap 的 Entry 强引用了 threadLocal，造成 threadLocal 无法被回收，无法完全避免内存泄漏</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ThreadLocal内存泄漏强引用.png" style="zoom:67%;">
</li>
<li><p>如果 key 使用弱引用：使用完 ThreadLocal ，threadLocal Ref 被回收，ThreadLocalMap 只持有 ThreadLocal 的弱引用，所以threadlocal 也可以被回收，此时 Entry 中的 key &#x3D; null。但没有手动删除这个 Entry 或者 CurrentThread 依然运行，依然存在强引用链，value 不会被回收，而这块 value 永远不会被访问到，也会导致 value 内存泄漏</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ThreadLocal内存泄漏弱引用.png" style="zoom:67%;">
</li>
<li><p>两个主要原因：</p>
<ul>
<li>没有手动删除这个 Entry</li>
<li>CurrentThread 依然运行</li>
</ul>
</li>
</ul>
<p>根本原因：ThreadLocalMap 是 Thread的一个属性，<strong>生命周期跟 Thread 一样长</strong>，如果没有手动删除对应 Entry 就会导致内存泄漏</p>
<p>解决方法：使用完 ThreadLocal 中存储的内容后将它 remove 掉就可以</p>
<p>ThreadLocal 内部解决方法：在 ThreadLocalMap 中的 set&#x2F;getEntry 方法中，通过线性探测法对 key 进行判断，如果 key 为 null（ThreadLocal 为 null）会对 Entry 进行垃圾回收。所以<strong>使用弱引用比强引用多一层保障</strong>，就算不调用 remove，也有机会进行 GC</p>
<hr>
<h4 id="变量传递"><a href="#变量传递" class="headerlink" title="变量传递"></a>变量传递</h4><h5 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h5><p>父子线程：<strong>创建子线程的线程是父线程</strong>，比如实例中的 main 线程就是父线程</p>
<p>ThreadLocal 中存储的是线程的局部变量，如果想实现线程间局部变量传递可以使用 InheritableThreadLocal 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line">    threadLocal.set(<span class="string">&quot;父线程设置的值&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;子线程输出：&quot;</span> + threadLocal.get())).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子线程输出：父线程设置的值</span></span><br></pre></td></tr></table></figure>



<hr>
<h5 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h5><p>InheritableThreadLocal 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">childValue</span><span class="params">(T parentValue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现父子线程间的局部变量共享需要追溯到 Thread 对象的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name, <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                  // 该参数默认是 <span class="literal">true</span></span></span><br><span class="line"><span class="params">                  <span class="type">boolean</span> inheritThreadLocals)</span> &#123;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">parent</span> <span class="operator">=</span> currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断父线程（创建子线程的线程）的 inheritableThreadLocals 属性不为 null</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 复制父线程的 inheritableThreadLocals 属性，实现父子线程局部变量共享</span></span><br><span class="line">        <span class="built_in">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 【本质上还是创建 ThreadLocalMap，只是把父类中的可继承数据设置进去了】</span></span><br><span class="line"><span class="keyword">static</span> ThreadLocalMap <span class="title function_">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(parentMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取父线程的哈希表</span></span><br><span class="line">    Entry[] parentTable = parentMap.table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[len];</span><br><span class="line">	<span class="comment">// 【逐个复制父线程 ThreadLocalMap 中的数据】</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> parentTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用的是 InheritableThreadLocal#childValue(T parentValue)</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> key.childValue(e.value);</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 线性探测</span></span><br><span class="line">                <span class="keyword">while</span> (table[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                table[h] = c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考文章：<a href="https://blog.csdn.net/feichitianxia/article/details/110495764">https://blog.csdn.net/feichitianxia/article/details/110495764</a></p>
<hr>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>线程池：一个容纳多个线程的容器，容器中的线程可以重复使用，省去了频繁创建和销毁线程对象的操作</p>
<p>线程池作用：</p>
<ol>
<li>降低资源消耗，减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</li>
<li>提高响应速度，当任务到达时，如果有线程可以直接用，不会出现系统僵死</li>
<li>提高线程的可管理性，如果无限制的创建线程，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ol>
<p>线程池的核心思想：<strong>线程复用</strong>，同一个线程可以被重复使用，来处理多个任务</p>
<p>池化技术 (Pool) ：一种编程技巧，核心思想是资源复用，在请求量大时能优化应用性能，降低系统频繁建连的资源开销</p>
<hr>
<h3 id="阻塞队列-1"><a href="#阻塞队列-1" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>有界队列和无界队列：</p>
<ul>
<li><p>有界队列：有固定大小的队列，比如设定了固定大小的 LinkedBlockingQueue，又或者大小为 0</p>
</li>
<li><p>无界队列：没有设置固定大小的队列，这些队列可以直接入队，直到溢出（超过 Integer.MAX_VALUE），所以相当于无界</p>
</li>
</ul>
<p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：<strong>FIFO 队列</strong> </p>
<ul>
<li>ArrayBlockQueue：由数组结构组成的有界阻塞队列</li>
<li>LinkedBlockingQueue：由链表结构组成的无界（默认大小 Integer.MAX_VALUE）的阻塞队列</li>
<li>PriorityBlockQueue：支持优先级排序的无界阻塞队列</li>
<li>DelayedWorkQueue：使用优先级队列实现的延迟无界阻塞队列</li>
<li>SynchronousQueue：不存储元素的阻塞队列，每一个生产线程会阻塞到有一个 put 的线程放入元素为止</li>
<li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li>
<li>LinkedBlockingDeque：由链表结构组成的<strong>双向</strong>阻塞队列</li>
</ul>
<p>与普通队列（LinkedList、ArrayList等）的不同点在于阻塞队列中阻塞添加和阻塞删除方法，以及线程安全：</p>
<ul>
<li>阻塞添加 put()：当阻塞队列元素已满时，添加队列元素的线程会被阻塞，直到队列元素不满时才重新唤醒线程执行</li>
<li>阻塞删除 take()：在队列元素为空时，删除队列元素的线程将被阻塞，直到队列不为空再执行删除操作（一般会返回被删除的元素)</li>
</ul>
<hr>
<h4 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h4><table>
<thead>
<tr>
<th>方法类型</th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入（尾）</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除（头）</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查（队首元素）</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<ul>
<li>抛出异常组：<ul>
<li>当阻塞队列满时：在往队列中 add 插入元素会抛出 IIIegalStateException: Queue full</li>
<li>当阻塞队列空时：再往队列中 remove 移除元素，会抛出 NoSuchException</li>
</ul>
</li>
<li>特殊值组：<ul>
<li>插入方法：成功 true，失败 false</li>
<li>移除方法：成功返回出队列元素，队列没有就返回 null</li>
</ul>
</li>
<li>阻塞组：<ul>
<li>当阻塞队列满时，生产者继续往队列里 put 元素，队列会一直阻塞生产线程直到队列有空间 put 数据或响应中断退出</li>
<li>当阻塞队列空时，消费者线程试图从队列里 take 元素，队列会一直阻塞消费者线程直到队列中有可用元素</li>
</ul>
</li>
<li>超时退出：当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</li>
</ul>
<hr>
<h4 id="链表队列"><a href="#链表队列" class="headerlink" title="链表队列"></a>链表队列</h4><h5 id="入队出队"><a href="#入队出队" class="headerlink" title="入队出队"></a>入队出队</h5><p>LinkedBlockingQueue源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">			<span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 下列三种情况之一</span></span><br><span class="line"><span class="comment">        * - 真正的后继节点</span></span><br><span class="line"><span class="comment">        * - 自己, 发生在出队时</span></span><br><span class="line"><span class="comment">        * - null, 表示是没有后继节点, 是尾节点了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入队：<strong>尾插法</strong></p>
<ul>
<li><p>初始化链表 <code>last = head = new Node&lt;E&gt;(null)</code>，<strong>Dummy 节点用来占位</strong>，item 为 null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认是 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个节点入队：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> &#123;</span><br><span class="line">    <span class="comment">// 从右向左计算</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-LinkedBlockingQueue%E5%85%A5%E9%98%9F%E6%B5%81%E7%A8%8B.png"></p>
</li>
<li><p>再来一个节点入队 <code>last = last.next = node</code></p>
</li>
</ul>
<p>出队：<strong>出队头节点</strong>，FIFO</p>
<ul>
<li><p>出队源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    <span class="comment">// 获取临头节点</span></span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    <span class="comment">// 自己指向自己，help GC</span></span><br><span class="line">    h.next = h;</span><br><span class="line">    head = first;</span><br><span class="line">    <span class="comment">// 出队的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;</span><br><span class="line">    <span class="comment">// 【当前节点置为 Dummy 节点】</span></span><br><span class="line">    first.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>h = head</code> → <code>first = h.next</code> </p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-LinkedBlockingQueue%E5%87%BA%E9%98%9F%E6%B5%81%E7%A8%8B1.png"></p>
</li>
<li><p><code>h.next = h</code> → <code>head = first</code></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-LinkedBlockingQueue%E5%87%BA%E9%98%9F%E6%B5%81%E7%A8%8B2.png"></p>
<ul>
<li><code>first.item = null</code>：当前节点置为 Dummy 节点</li>
</ul>
</li>
</ul>
<hr>
<h5 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h5><p>用了两把锁和 dummy 节点：</p>
<ul>
<li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</li>
<li>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行<ul>
<li>消费者与消费者线程仍然串行</li>
<li>生产者与生产者线程仍然串行</li>
</ul>
</li>
</ul>
<p>线程安全分析：</p>
<ul>
<li><p>当节点总数大于 2 时（包括 dummy 节点），<strong>putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head 节点的线程安全</strong>，两把锁保证了入队和出队没有竞争</p>
</li>
<li><p>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</p>
</li>
<li><p>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于 put(阻塞) offer(非阻塞)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> putLock.newCondition();	<span class="comment">// 阻塞等待不满，说明已经满了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于 take(阻塞) poll(非阻塞)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> takeLock.newCondition();	<span class="comment">// 阻塞等待不空，说明已经是空的</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>入队出队：</p>
<ul>
<li><p>put 操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 把待添加的元素封装为 node 节点</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="comment">// 获取全局生产锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    <span class="comment">// count 用来维护元素计数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="comment">// 获取可打断锁，会抛出异常</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 队列满了等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">// 【等待队列不满时，就可以生产数据】，线程处于 Waiting</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有空位, 入队且计数加一，尾插法</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">// 返回自增前的数字</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// put 完队列还有空位, 唤醒其他生产 put 线程，唤醒一个减少竞争</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// c自增前是0，说明生产了一个元素，唤醒一个 take 线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 notEmpty.signal()，而不是 notEmpty.signalAll() 是为了减少竞争，因为只剩下一个元素</span></span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>take 操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="comment">// 获取全局消费锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    <span class="comment">// 可打断锁</span></span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 没有元素可以出队</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 【阻塞等待队列不空，就可以消费数据】，线程处于 Waiting</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出队，计数减一，FIFO，出队头节点</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        <span class="comment">// 返回自减前的数字</span></span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="comment">// 队列还有元素</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 唤醒一个消费take线程</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// c 是消费前的数据，消费前满了，消费一个后还剩一个空位，唤醒生产线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        <span class="comment">// 调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争</span></span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h5><p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较：</p>
<ul>
<li>Linked 支持有界，Array 强制有界</li>
<li>Linked 实现是链表，Array 实现是数组</li>
<li>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</li>
<li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</li>
<li>Linked 两把锁，Array 一把锁</li>
</ul>
<hr>
<h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><h5 id="成员属性-1"><a href="#成员属性-1" class="headerlink" title="成员属性"></a>成员属性</h5><p>SynchronousQueue 是一个不存储元素的 BlockingQueue，<strong>每一个生产者必须阻塞匹配到一个消费者</strong></p>
<p>成员变量：</p>
<ul>
<li><p>运行当前程序的平台拥有 CPU 的数量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPUS</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors()</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定超时时间后，当前线程最大自旋次数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有一个 CPU 时自旋次数为 0，所有程序都是串行执行，多核 CPU 时自旋 32 次是一个经验值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxTimedSpins</span> <span class="operator">=</span> (NCPUS &lt; <span class="number">2</span>) ? <span class="number">0</span> : <span class="number">32</span>;</span><br></pre></td></tr></table></figure>

<p>自旋的原因：线程挂起唤醒需要进行上下文切换，涉及到用户态和内核态的转变，是非常消耗资源的。自旋期间线程会一直检查自己的状态是否被匹配到，如果自旋期间被匹配到，那么直接就返回了，如果自旋次数达到某个指标后，还是会将当前线程挂起</p>
</li>
<li><p>未指定超时时间，当前线程最大自旋次数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxUntimedSpins</span> <span class="operator">=</span> maxTimedSpins * <span class="number">16</span>;	<span class="comment">// maxTimedSpins 的 16 倍</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指定超时限制的阈值，小于该值的线程不会被挂起：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">spinForTimeoutThreshold</span> <span class="operator">=</span> <span class="number">1000L</span>;	<span class="comment">// 纳秒</span></span><br></pre></td></tr></table></figure>

<p>超时时间设置的小于该值，就会被禁止挂起，阻塞再唤醒的成本太高，不如选择自旋空转</p>
</li>
<li><p>转换器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Transferer&lt;E&gt; transferer;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Transferer</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 参数一：可以为 null，null 时表示这个请求是一个 REQUEST 类型的请求，反之是一个 DATA 类型的请求</span></span><br><span class="line"><span class="comment">    * 参数二：如果为 true 表示指定了超时时间，如果为 false 表示不支持超时，会一直阻塞到匹配或者被打断</span></span><br><span class="line"><span class="comment">    * 参数三：超时时间限制，单位是纳秒</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    * 返回值：返回值如果不为 null 表示匹配成功，DATA 类型的请求返回当前线程 put 的数据</span></span><br><span class="line"><span class="comment">    * 	     如果返回 null，表示请求超时或被中断</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">abstract</span> E <span class="title function_">transfer</span><span class="params">(E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SynchronousQueue</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    <span class="comment">// fair 默认 false</span></span><br><span class="line">    <span class="comment">// 非公平模式实现的数据结构是栈，公平模式的数据结构是队列</span></span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> <span class="title class_">TransferQueue</span>&lt;E&gt;() : <span class="keyword">new</span> <span class="title class_">TransferStack</span>&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> transferer.transfer(e, <span class="literal">true</span>, <span class="number">0</span>) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> transferer.transfer(<span class="literal">null</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="非公实现"><a href="#非公实现" class="headerlink" title="非公实现"></a>非公实现</h5><p>TransferStack 是非公平的同步队列，因为所有的请求都被压入栈中，栈顶的元素会最先得到匹配，造成栈底的等待线程饥饿</p>
<p>TransferStack 类成员变量：</p>
<ul>
<li><p>请求类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示 Node 类型为请求类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REQUEST</span>    <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 表示 Node类 型为数据类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DATA</span>       <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 表示 Node 类型为匹配中类型</span></span><br><span class="line"><span class="comment">// 假设栈顶元素为 REQUEST-NODE，当前请求类型为 DATA，入栈会修改类型为 FULFILLING 【栈顶 &amp; 栈顶之下的一个node】</span></span><br><span class="line"><span class="comment">// 假设栈顶元素为 DATA-NODE，当前请求类型为 REQUEST，入栈会修改类型为 FULFILLING 【栈顶 &amp; 栈顶之下的一个node】</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FULFILLING</span> <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>栈顶元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> SNode head;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>内部类 SNode：</p>
<ul>
<li><p>成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SNode</span> &#123;</span><br><span class="line">    <span class="comment">// 指向下一个栈帧</span></span><br><span class="line">    <span class="keyword">volatile</span> SNode next; </span><br><span class="line">    <span class="comment">// 与当前 node 匹配的节点</span></span><br><span class="line">    <span class="keyword">volatile</span> SNode match;</span><br><span class="line">    <span class="comment">// 假设当前node对应的线程自旋期间未被匹配成功，那么node对应的线程需要挂起，</span></span><br><span class="line">    <span class="comment">// 挂起前 waiter 保存对应的线程引用，方便匹配成功后，被唤醒。</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据域，不为空表示当前 Node 对应的请求类型为 DATA 类型，反之则表示 Node 为 REQUEST 类型</span></span><br><span class="line">    Object item; </span><br><span class="line">    <span class="comment">// 表示当前Node的模式 【DATA/REQUEST/FULFILLING】</span></span><br><span class="line">    <span class="type">int</span> mode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SNode(Object item) &#123;</span><br><span class="line">    <span class="built_in">this</span>.item = item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置方法：设置 Node 对象的 next 字段，此处<strong>对 CAS 进行了优化</strong>，提升了 CAS 的效率</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">casNext</span><span class="params">(SNode cmp, SNode val)</span> &#123;</span><br><span class="line">    <span class="comment">//【优化：cmp == next】，可以提升一部分性能。 cmp == next 不相等，就没必要走 cas指令。</span></span><br><span class="line">    <span class="type">return</span> <span class="variable">cmp</span> <span class="operator">=</span>= next &amp;&amp; UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, nextOffset, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">tryMatch</span><span class="params">(SNode s)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前 node 尚未与任何节点发生过匹配，CAS 设置 match 字段为 s 节点，表示当前 node 已经被匹配</span></span><br><span class="line">    <span class="keyword">if</span> (match == <span class="literal">null</span> &amp;&amp; UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, matchOffset, <span class="literal">null</span>, s)) &#123;</span><br><span class="line">        <span class="comment">// 当前 node 如果自旋结束，会 park 阻塞，阻塞前将 node 对应的 Thread 保留到 waiter 字段</span></span><br><span class="line">        <span class="comment">// 获取当前 node 对应的阻塞线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">w</span> <span class="operator">=</span> waiter;</span><br><span class="line">        <span class="comment">// 条件成立说明 node 对应的 Thread 正在阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>) &#123;</span><br><span class="line">            waiter = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 使用 unpark 方式唤醒线程</span></span><br><span class="line">            LockSupport.unpark(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匹配成功返回 true</span></span><br><span class="line">    <span class="type">return</span> <span class="variable">match</span> <span class="operator">=</span>= s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取消节点的方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tryCancel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// match 字段指向自己，表示这个 node 是取消状态，取消状态的 node，最终会被强制移除出栈</span></span><br><span class="line">    UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, matchOffset, <span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">return</span> <span class="variable">match</span> <span class="operator">=</span>= <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>TransferStack 类成员方法：</p>
<ul>
<li><p>snode()：填充节点方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> SNode <span class="title function_">snode</span><span class="params">(SNode s, Object e, SNode next, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 引用指向空时，snode 方法会创建一个 SNode 对象 </span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span>) s = <span class="keyword">new</span> <span class="title class_">SNode</span>(e);</span><br><span class="line">    <span class="comment">// 填充数据</span></span><br><span class="line">    s.mode = mode;</span><br><span class="line">    s.next = next;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>transfer()：核心方法，请求匹配出栈，不匹配阻塞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E <span class="title function_">transfer</span><span class="params">(E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> &#123;</span><br><span class="line">	<span class="comment">// 包装当前线程的 node</span></span><br><span class="line">    <span class="type">SNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 根据元素判断当前的请求类型</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mode</span> <span class="operator">=</span> (e == <span class="literal">null</span>) ? REQUEST : DATA;</span><br><span class="line">	<span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取栈顶指针</span></span><br><span class="line">        <span class="type">SNode</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="comment">// 【CASE1】：当前栈为空或者栈顶 node 模式与当前请求模式一致无法匹配，做入栈操作</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="literal">null</span> || h.mode == mode) &#123;</span><br><span class="line">            <span class="comment">// 当前请求是支持超时的，但是 nanos &lt;= 0 说明这个请求不支持 “阻塞等待”</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="comment">// 栈顶元素是取消状态</span></span><br><span class="line">                <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.isCancelled())</span><br><span class="line">                    <span class="comment">// 栈顶出栈，设置新的栈顶</span></span><br><span class="line">                    casHead(h, h.next);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 表示【匹配失败】</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 入栈</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">                <span class="comment">// 等待被匹配的逻辑，正常情况返回匹配的节点；取消情况返回当前节点，就是 s</span></span><br><span class="line">                <span class="type">SNode</span> <span class="variable">m</span> <span class="operator">=</span> awaitFulfill(s, timed, nanos);</span><br><span class="line">                <span class="comment">// 说明当前 node 是【取消状态】</span></span><br><span class="line">                <span class="keyword">if</span> (m == s) &#123; </span><br><span class="line">                    <span class="comment">// 将取消节点出栈</span></span><br><span class="line">                    clean(s);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行到这说明【匹配成功】了</span></span><br><span class="line">                <span class="comment">// 栈顶有节点并且 匹配节点还未出栈，需要协助出栈</span></span><br><span class="line">                <span class="keyword">if</span> ((h = head) != <span class="literal">null</span> &amp;&amp; h.next == s)</span><br><span class="line">                    casHead(h, s.next);</span><br><span class="line">                <span class="comment">// 当前 node 模式为 REQUEST 类型，返回匹配节点的 m.item 数据域</span></span><br><span class="line">                <span class="comment">// 当前 node 模式为 DATA 类型：返回 node.item 数据域，当前请求提交的数据 e</span></span><br><span class="line">                <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 【CASE2】：逻辑到这说明请求模式不一致，如果栈顶不是 FULFILLING 说明没被其他节点匹配，【当前可以匹配】</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123;</span><br><span class="line">            <span class="comment">// 头节点是取消节点，match 指向自己，协助出栈</span></span><br><span class="line">            <span class="keyword">if</span> (h.isCancelled())</span><br><span class="line">                casHead(h, h.next);</span><br><span class="line">            <span class="comment">// 入栈当前请求的节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">                    <span class="comment">// m 是 s 的匹配的节点</span></span><br><span class="line">                    <span class="type">SNode</span> <span class="variable">m</span> <span class="operator">=</span> s.next;</span><br><span class="line">                    <span class="comment">// m 节点在 awaitFulfill 方法中被中断，clean 了自己</span></span><br><span class="line">                    <span class="keyword">if</span> (m == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 清空栈</span></span><br><span class="line">                        casHead(s, <span class="literal">null</span>);</span><br><span class="line">                        s = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 返回到外层自旋中</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 获取匹配节点的下一个节点</span></span><br><span class="line">                    <span class="type">SNode</span> <span class="variable">mn</span> <span class="operator">=</span> m.next;</span><br><span class="line">                    <span class="comment">// 尝试匹配，【匹配成功】，则将 fulfilling 和 m 一起出栈，并且唤醒被匹配的节点的线程</span></span><br><span class="line">                    <span class="keyword">if</span> (m.tryMatch(s)) &#123;</span><br><span class="line">                        casHead(s, mn);</span><br><span class="line">                        <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 匹配失败，出栈 m</span></span><br><span class="line">                        s.casNext(m, mn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 【CASE3】：栈顶模式为 FULFILLING 模式，表示【栈顶和栈顶下面的节点正在发生匹配】，当前请求需要做协助工作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// h 表示的是 fulfilling 节点，m 表示 fulfilling 匹配的节点</span></span><br><span class="line">            <span class="type">SNode</span> <span class="variable">m</span> <span class="operator">=</span> h.next;</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 清空栈</span></span><br><span class="line">                casHead(h, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">SNode</span> <span class="variable">mn</span> <span class="operator">=</span> m.next;</span><br><span class="line">                <span class="comment">// m 和 h 匹配，唤醒 m 中的线程</span></span><br><span class="line">                <span class="keyword">if</span> (m.tryMatch(h))</span><br><span class="line">                    casHead(h, mn);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    h.casNext(m, mn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>awaitFulfill()：阻塞当前线程等待被匹配，返回匹配的节点，或者被取消的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SNode <span class="title function_">awaitFulfill</span><span class="params">(SNode s, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> &#123;</span><br><span class="line">    <span class="comment">// 等待的截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">w</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 表示当前请求线程在下面的 for(;;) 自旋检查的次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> (shouldSpin(s) ? (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 自旋检查逻辑：是否匹配、是否超时、是否被中断</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 当前线程收到中断信号，需要设置 node 状态为取消状态</span></span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">            s.tryCancel();</span><br><span class="line">        <span class="comment">// 获取与当前 s 匹配的节点</span></span><br><span class="line">        <span class="type">SNode</span> <span class="variable">m</span> <span class="operator">=</span> s.match;</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 可能是正常的匹配的，也可能是取消的</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        <span class="comment">// 执行了超时限制就判断是否超时</span></span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">// 【超时了，取消节点】</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                s.tryCancel();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明当前线程还可以进行自旋检查</span></span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 自旋一次 递减 1</span></span><br><span class="line">            spins = shouldSpin(s) ? (spins - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 说明没有自旋次数了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//【把当前 node 对应的 Thread 保存到 node.waiter 字段中，要阻塞了】</span></span><br><span class="line">            s.waiter = w;</span><br><span class="line">        <span class="comment">// 没有超时限制直接阻塞</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// nanos &gt; 1000 纳秒的情况下，才允许挂起当前线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">shouldSpin</span><span class="params">(SNode s)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取栈顶</span></span><br><span class="line">    <span class="type">SNode</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 条件一成立说明当前 s 就是栈顶，允许自旋检查</span></span><br><span class="line">    <span class="comment">// 条件二成立说明当前 s 节点自旋检查期间，又来了一个与当前 s 节点匹配的请求，双双出栈后条件会成立</span></span><br><span class="line">    <span class="comment">// 条件三成立前提当前 s 不是栈顶元素，并且当前栈顶正在匹配中，这种状态栈顶下面的元素，都允许自旋检查</span></span><br><span class="line">    <span class="keyword">return</span> (h == s || h == <span class="literal">null</span> || isFulfilling(h.mode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>clear()：指定节点出栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">clean</span><span class="params">(SNode s)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空数据域和关联线程</span></span><br><span class="line">    s.item = <span class="literal">null</span>;</span><br><span class="line">    s.waiter = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 获取取消节点的下一个节点</span></span><br><span class="line">    <span class="type">SNode</span> <span class="variable">past</span> <span class="operator">=</span> s.next;</span><br><span class="line">    <span class="comment">// 判断后继节点是不是取消节点，是就更新 past</span></span><br><span class="line">    <span class="keyword">if</span> (past != <span class="literal">null</span> &amp;&amp; past.isCancelled())</span><br><span class="line">        past = past.next;</span><br><span class="line"></span><br><span class="line">    SNode p;</span><br><span class="line">    <span class="comment">// 从栈顶开始向下检查，【将栈顶开始向下的 取消状态 的节点全部清理出去】，直到碰到 past 或者不是取消状态为止</span></span><br><span class="line">    <span class="keyword">while</span> ((p = head) != <span class="literal">null</span> &amp;&amp; p != past &amp;&amp; p.isCancelled())</span><br><span class="line">        <span class="comment">// 修改的是内存地址对应的值，p 指向该内存地址所以数据一直在变化</span></span><br><span class="line">        casHead(p, p.next);</span><br><span class="line">	<span class="comment">// 说明中间遇到了不是取消状态的节点，继续迭代下去</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p != past) &#123;</span><br><span class="line">        <span class="type">SNode</span> <span class="variable">n</span> <span class="operator">=</span> p.next;</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="literal">null</span> &amp;&amp; n.isCancelled())</span><br><span class="line">            p.casNext(n, n.next);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="公平实现"><a href="#公平实现" class="headerlink" title="公平实现"></a>公平实现</h5><p>TransferQueue 是公平的同步队列，采用 FIFO 的队列实现，请求节点与队尾模式不同，需要与队头发生匹配</p>
<p>TransferQueue 类成员变量：</p>
<ul>
<li><p>指向队列的 dummy 节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指向队列的尾节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;</span><br></pre></td></tr></table></figure>
</li>
<li><p>被清理节点的前驱节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode cleanMe;</span><br></pre></td></tr></table></figure>

<p>入队操作是两步完成的，第一步是 t.next &#x3D; newNode，第二步是 tail &#x3D; newNode，所以队尾节点出队，是一种非常特殊的情况</p>
</li>
</ul>
<p>TransferQueue 内部类：</p>
<ul>
<li><p>QNode：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">    <span class="comment">// 指向当前节点的下一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> QNode next;</span><br><span class="line">    <span class="comment">// 数据域，Node 代表的是 DATA 类型 item 表示数据，否则 Node 代表的 REQUEST 类型，item == null</span></span><br><span class="line">    <span class="keyword">volatile</span> Object item;</span><br><span class="line">    <span class="comment">// 假设当前 node 对应的线程自旋期间未被匹配成功，那么 node 对应的线程需要挂起，</span></span><br><span class="line">    <span class="comment">// 挂起前 waiter 保存对应的线程引用，方便匹配成功后被唤醒。</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="comment">// true 当前 Node 是一个 DATA 类型，false 表示当前 Node 是一个 REQUEST 类型</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> isData;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构建方法</span></span><br><span class="line">    QNode(Object item, <span class="type">boolean</span> isData) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">        <span class="built_in">this</span>.isData = isData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试取消当前 node，取消状态的 node 的 item 域指向自己</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tryCancel</span><span class="params">(Object cmp)</span> &#123;</span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, itemOffset, cmp, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前 node 是否为取消状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">item</span> <span class="operator">=</span>= <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前节点是否 “不在” 队列内，当 next 指向自己时，说明节点已经出队。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isOffList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">next</span> <span class="operator">=</span>= <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>TransferQueue 类成员方法：</p>
<ul>
<li><p>设置头尾节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">advanceHead</span><span class="params">(QNode h, QNode nh)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置头指针指向新的节点，</span></span><br><span class="line">    <span class="keyword">if</span> (h == head &amp;&amp; UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, headOffset, h, nh))</span><br><span class="line">        <span class="comment">// 老的头节点出队</span></span><br><span class="line">        h.next = h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">advanceTail</span><span class="params">(QNode t, QNode nt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tail == t)</span><br><span class="line">        <span class="comment">// 更新队尾节点为新的队尾</span></span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, tailOffset, t, nt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>transfer()：核心方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E <span class="title function_">transfer</span><span class="params">(E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> &#123;</span><br><span class="line">    <span class="comment">// s 指向当前请求对应的 node</span></span><br><span class="line">    <span class="type">QNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 是否是 DATA 类型的请求</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isData</span> <span class="operator">=</span> (e != <span class="literal">null</span>);</span><br><span class="line">	<span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span> || h == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// head 和 tail 同时指向 dummy 节点，说明是空队列</span></span><br><span class="line">        <span class="comment">// 队尾节点与当前请求类型是一致的情况，说明阻塞队列中都无法匹配，</span></span><br><span class="line">        <span class="keyword">if</span> (h == t || t.isData == isData) &#123;</span><br><span class="line">            <span class="comment">// 获取队尾 t 的 next 节点</span></span><br><span class="line">            <span class="type">QNode</span> <span class="variable">tn</span> <span class="operator">=</span> t.next;</span><br><span class="line">            <span class="comment">// 多线程环境中其他线程可能修改尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 已经有线程入队了，更新 tail</span></span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="literal">null</span>) &#123;</span><br><span class="line">                advanceTail(t, tn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 允许超时，超时时间小于 0，这种方法不支持阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 创建 node 的逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> <span class="title class_">QNode</span>(e, isData);</span><br><span class="line">            <span class="comment">// 将 node 添加到队尾</span></span><br><span class="line">            <span class="keyword">if</span> (!t.casNext(<span class="literal">null</span>, s))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 更新队尾指针</span></span><br><span class="line">            advanceTail(t, s);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当前节点 等待匹配....</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> awaitFulfill(s, e, timed, nanos);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 说明【当前 node 状态为 取消状态】，需要做出队逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (x == s) &#123;</span><br><span class="line">                clean(t, s);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 说明当前 node 仍然在队列内，匹配成功，需要做出队逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (!s.isOffList()) &#123;</span><br><span class="line">                <span class="comment">// t 是当前 s 节点的前驱节点，判断 t 是不是头节点，是就更新 dummy 节点为 s 节点</span></span><br><span class="line">                advanceHead(t, s);</span><br><span class="line">                <span class="comment">// s 节点已经出队，所以需要把它的 item 域设置为它自己，表示它是个取消状态</span></span><br><span class="line">                <span class="keyword">if</span> (x != <span class="literal">null</span>)</span><br><span class="line">                    s.item = s;</span><br><span class="line">                s.waiter = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="literal">null</span>) ? (E)x : e;</span><br><span class="line">		<span class="comment">// 队尾节点与当前请求节点【互补匹配】</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// h.next 节点，【请求节点与队尾模式不同，需要与队头发生匹配】，TransferQueue 是一个【公平模式】</span></span><br><span class="line">            <span class="type">QNode</span> <span class="variable">m</span> <span class="operator">=</span> h.next;</span><br><span class="line">            <span class="comment">// 并发导致其他线程修改了队尾节点，或者已经把 head.next 匹配走了</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail || m == <span class="literal">null</span> || h != head)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 获取匹配节点的数据域保存到 x</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> m.item;</span><br><span class="line">            <span class="comment">// 判断是否匹配成功</span></span><br><span class="line">            <span class="keyword">if</span> (isData == (x != <span class="literal">null</span>) ||</span><br><span class="line">                x == m ||</span><br><span class="line">                !m.casItem(x, e)) &#123;</span><br><span class="line">                advanceHead(h, m);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 【匹配完成】，将头节点出队，让这个新的头结点成为 dummy 节点</span></span><br><span class="line">            advanceHead(h, m);</span><br><span class="line">            <span class="comment">// 唤醒该匹配节点的线程</span></span><br><span class="line">            LockSupport.unpark(m.waiter);</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="literal">null</span>) ? (E)x : e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>awaitFulfill()：阻塞当前线程等待被匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">awaitFulfill</span><span class="params">(QNode s, E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> &#123;</span><br><span class="line">    <span class="comment">// 表示等待截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">w</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 自选检查的次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> ((head.next == s) ? (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 被打断就取消节点</span></span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">            s.tryCancel(e);</span><br><span class="line">        <span class="comment">// 获取当前 Node 数据域</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> s.item;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前请求为 DATA 模式时：e 请求带来的数据</span></span><br><span class="line">        <span class="comment">// s.item 修改为 this，说明当前 QNode 对应的线程 取消状态</span></span><br><span class="line">        <span class="comment">// s.item 修改为 null 表示已经有匹配节点了，并且匹配节点拿走了 item 数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前请求为 REQUEST 模式时：e == null</span></span><br><span class="line">        <span class="comment">// s.item 修改为 this，说明当前 QNode 对应的线程 取消状态</span></span><br><span class="line">        <span class="comment">// s.item != null 且 item != this  表示当前 REQUEST 类型的 Node 已经匹配到 DATA 了 </span></span><br><span class="line">        <span class="keyword">if</span> (x != e)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="comment">// 超时检查</span></span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                s.tryCancel(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自旋次数减一</span></span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)</span><br><span class="line">            --spins;</span><br><span class="line">        <span class="comment">// 没有自旋次数了，把当前线程封装进去 waiter</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="literal">null</span>)</span><br><span class="line">            s.waiter = w;</span><br><span class="line">        <span class="comment">// 阻塞</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="操作Pool"><a href="#操作Pool" class="headerlink" title="操作Pool"></a>操作Pool</h3><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h5><p>存放线程的容器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br></pre></td></tr></table></figure>

<p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<p>参数介绍：</p>
<ul>
<li><p>corePoolSize：核心线程数，定义了最小可以同时运行的线程数量</p>
</li>
<li><p>maximumPoolSize：最大线程数，当队列中存放的任务达到队列容量时，当前可以同时运行的数量变为最大线程数，创建线程并立即执行最新的任务，与核心线程数之间的差值又叫救急线程数</p>
</li>
<li><p>keepAliveTime：救急线程最大存活时间，当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等到 <code>keepAliveTime</code> 时间超过销毁</p>
</li>
<li><p>unit：<code>keepAliveTime</code> 参数的时间单位</p>
</li>
<li><p>workQueue：阻塞队列，存放被提交但尚未被执行的任务</p>
</li>
<li><p>threadFactory：线程工厂，创建新线程时用到，可以为线程创建时起名字</p>
</li>
<li><p>handler：拒绝策略，线程到达最大线程数仍有新任务时会执行拒绝策略</p>
<p>RejectedExecutionHandler 下有 4 个实现类：</p>
<ul>
<li>AbortPolicy：让调用者抛出 RejectedExecutionException 异常，<strong>默认策略</strong></li>
<li>CallerRunsPolicy：让调用者运行的调节机制，将某些任务回退到调用者，从而降低新任务的流量</li>
<li>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常</li>
<li>DiscardOldestPolicy：放弃队列中最早的任务，把当前任务加入队列中尝试再次提交当前任务</li>
</ul>
<p>补充：其他框架拒绝策略</p>
<ul>
<li>Dubbo：在抛出 RejectedExecutionException 异常前记录日志，并 dump 线程栈信息，方便定位问题</li>
<li>Netty：创建一个新线程来执行任务</li>
<li>ActiveMQ：带超时等待（60s）尝试放入队列</li>
<li>PinPoint：它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li>
</ul>
</li>
</ul>
<p>工作原理：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<ol>
<li><p>创建线程池，这时没有创建线程（<strong>懒惰</strong>），等待提交过来的任务请求，调用 execute 方法才会创建线程</p>
</li>
<li><p>当调用 execute() 方法添加一个请求任务时，线程池会做如下判断：</p>
<ul>
<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务</li>
<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列</li>
<li>如果这时队列满了且正在运行的线程数量还小于 maximumPoolSize，那么会创建非核心线程<strong>立刻运行这个任务</strong>，对于阻塞队列中的任务不公平。这是因为创建每个 Worker（线程）对象会绑定一个初始任务，启动 Worker 时会优先执行</li>
<li>如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和<strong>拒绝策略</strong>来执行</li>
</ul>
</li>
<li><p>当一个线程完成任务时，会从队列中取下一个任务来执行</p>
</li>
<li><p>当一个线程空闲超过一定的时间（keepAliveTime）时，线程池会判断：如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉，所以线程池的所有任务完成后最终会收缩到 corePoolSize 大小</p>
</li>
</ol>
<p>图片来源：<a href="https://space.bilibili.com/457326371/">https://space.bilibili.com/457326371/</a></p>
<hr>
<h5 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h5><p>Executors 提供了四种线程池的创建：newCachedThreadPool、newFixedThreadPool、newSingleThreadExecutor、newScheduledThreadPool</p>
<ul>
<li><p>newFixedThreadPool：创建一个拥有 n 个线程的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间</li>
<li>LinkedBlockingQueue 是一个单向链表实现的阻塞队列，默认大小为 <code>Integer.MAX_VALUE</code>，也就是无界队列，可以放任意数量的任务，在任务比较多的时候会导致 OOM（内存溢出）</li>
<li>适用于任务量已知，相对耗时的长期任务</li>
</ul>
</li>
<li><p>newCachedThreadPool：创建一个可扩容的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>核心线程数是 0， 最大线程数是 29 个 1，全部都是救急线程（60s 后可以回收），可能会创建大量线程，从而导致 <strong>OOM</strong></p>
</li>
<li><p>SynchronousQueue 作为阻塞队列，没有容量，对于每一个 take 的线程会阻塞直到有一个 put 的线程放入元素为止（类似一手交钱、一手交货）</p>
</li>
<li><p>适合任务数比较密集，但每个任务执行时间较短的情况</p>
</li>
</ul>
</li>
<li><p>newSingleThreadExecutor：创建一个只有 1 个线程的单线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>保证所有任务按照<strong>指定顺序执行</strong>，线程数固定为 1，任务数多于 1 时会放入无界队列排队，任务执行完毕，这唯一的线程也不会被释放</li>
</ul>
</li>
</ul>
<p>对比：</p>
<ul>
<li><p>创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，线程池会新建一个线程，保证池的正常工作</p>
</li>
<li><p>Executors.newSingleThreadExecutor() 线程个数始终为 1，不能修改。FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法</p>
<p>原因：父类不能直接调用子类中的方法，需要反射或者创建对象的方式，可以调用子类静态方法</p>
</li>
<li><p>Executors.newFixedThreadPool(1) 初始时为 1，可以修改。对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</p>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-newSingleThreadExecutor.png"></p>
<hr>
<h5 id="开发要求"><a href="#开发要求" class="headerlink" title="开发要求"></a>开发要求</h5><p>阿里巴巴 Java 开发手册要求：</p>
<ul>
<li><p><strong>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</strong></p>
<ul>
<li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题</li>
<li>如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者过度切换的问题</li>
</ul>
</li>
<li><p>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式更加明确线程池的运行规则，规避资源耗尽的风险</p>
<p>Executors 返回的线程池对象弊端如下：</p>
<ul>
<li>FixedThreadPool 和 SingleThreadPool：请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM</li>
<li>CacheThreadPool 和 ScheduledThreadPool：允许创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，导致 OOM</li>
</ul>
</li>
</ul>
<p>创建多大容量的线程池合适？</p>
<ul>
<li><p>一般来说池中<strong>总线程数是核心池线程数量两倍</strong>，确保当核心池有线程停止时，核心池外有线程进入核心池</p>
</li>
<li><p>过小会导致程序不能充分地利用系统资源、容易导致饥饿</p>
</li>
<li><p>过大会导致更多的线程上下文切换，占用更多内存</p>
<p>上下文切换：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态，任务从保存到再加载的过程就是一次上下文切换</p>
</li>
</ul>
<p>核心线程数常用公式：</p>
<ul>
<li><p><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的是 CPU 资源，可以将核心线程数设置为 N (CPU 核心数) + 1，比 CPU 核心数多出来的一个线程是为了防止线程发生缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 某个核心就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间</p>
<p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如在内存中对大量数据进行分析</p>
</li>
<li><p><strong>I&#x2F;O 密集型任务：</strong> 这种系统 CPU 处于阻塞状态，用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用，因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N 或 CPU 核数&#x2F; (1-阻塞系数)，阻塞系数在 0.8~0.9 之间</p>
<p>IO 密集型就是涉及到网络读取，文件读取此类任务 ，特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上</p>
</li>
</ul>
<hr>
<h4 id="提交方法"><a href="#提交方法" class="headerlink" title="提交方法"></a>提交方法</h4><p>ExecutorService 类 API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void execute(Runnable command)</td>
<td>执行任务（Executor 类 API）</td>
</tr>
<tr>
<td>Future&lt;?&gt; submit(Runnable task)</td>
<td>提交任务 task()</td>
</tr>
<tr>
<td>Future submit(Callable<T> task)</T></td>
<td>提交任务 task，用返回值 Future 获得任务执行结果</td>
</tr>
<tr>
<td>List&lt;Future<T>&gt; invokeAll(Collection&lt;? extends Callable<T>&gt; tasks)</T></T></td>
<td>提交 tasks 中所有任务</td>
</tr>
<tr>
<td>List&lt;Future<T>&gt; invokeAll(Collection&lt;? extends Callable<T>&gt; tasks, long timeout, TimeUnit unit)</T></T></td>
<td>提交 tasks 中所有任务，超时时间针对所有task，超时会取消没有执行完的任务，并抛出超时异常</td>
</tr>
<tr>
<td>T invokeAny(Collection&lt;? extends Callable<T>&gt; tasks)</T></td>
<td>提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</td>
</tr>
</tbody></table>
<p>execute 和 submit 都属于线程池的方法，对比：</p>
<ul>
<li><p>execute 只能执行 Runnable 类型的任务，没有返回值； submit 既能提交 Runnable 类型任务也能提交 Callable 类型任务，底层是<strong>封装成 FutureTask，然后调用 execute 执行</strong></p>
</li>
<li><p>execute 会直接抛出任务执行时的异常，submit 会吞掉异常，可通过 Future 的 get 方法将任务执行时的异常重新抛出</p>
</li>
</ul>
<hr>
<h4 id="关闭方法"><a href="#关闭方法" class="headerlink" title="关闭方法"></a>关闭方法</h4><p>ExecutorService 类 API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void shutdown()</td>
<td>线程池状态变为 SHUTDOWN，等待任务执行完后关闭线程池，不会接收新任务，但已提交任务会执行完，而且也可以添加线程（不绑定ren’wu）</td>
</tr>
<tr>
<td>List<Runnable> shutdownNow()</Runnable></td>
<td>线程池状态变为 STOP，用 interrupt 中断正在执行的任务，直接关闭线程池，不会接收新任务，会将队列中的任务返回</td>
</tr>
<tr>
<td>boolean isShutdown()</td>
<td>不在 RUNNING 状态的线程池，此执行者已被关闭，方法返回 true</td>
</tr>
<tr>
<td>boolean isTerminated()</td>
<td>线程池状态是否是 TERMINATED，如果所有任务在关闭后完成，返回 true</td>
</tr>
<tr>
<td>boolean awaitTermination(long timeout, TimeUnit unit)</td>
<td>调用 shutdown 后，由于调用线程不会等待所有任务运行结束，如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</td>
</tr>
</tbody></table>
<hr>
<h4 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h4><p>execute 会直接抛出任务执行时的异常，submit 会吞掉异常，有两种处理方法</p>
<p>方法 1：主动捉异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>方法 2：使用 Future 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">Future&lt;?&gt; future = pool.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h4><p>ThreadPoolExecutor 使用 int 的<strong>高 3 位来表示线程池状态，低 29 位表示线程数量</strong>。这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 CAS 原子操作进行赋值</p>
<ul>
<li><p>状态表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高3位：表示当前线程池运行状态，除去高3位之后的低位：表示当前线程池中所拥有的线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 表示在 ctl 中，低 COUNT_BITS 位，是用于存放当前线程数量的位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 低 COUNT_BITS 位所能表达的最大数值，000 11111111111111111111 =&gt; 5亿多</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png"></p>
</li>
<li><p>四种状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 111 000000000000000000，转换成整数后其实就是一个【负数】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 000 000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 001 000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 010 000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 011 000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>状态</th>
<th>高3位</th>
<th>接收新任务</th>
<th>处理阻塞任务队列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>111</td>
<td>Y</td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>000</td>
<td>N</td>
<td>Y</td>
<td>不接收新任务，但处理阻塞队列剩余任务</td>
</tr>
<tr>
<td>STOP</td>
<td>001</td>
<td>N</td>
<td>N</td>
<td>中断正在执行的任务，并抛弃阻塞队列任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>010</td>
<td>-</td>
<td>-</td>
<td>任务全执行完毕，活动线程为 0 即将进入终结</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>011</td>
<td>-</td>
<td>-</td>
<td>终止状态</td>
</tr>
</tbody></table>
</li>
<li><p>获取当前线程池运行状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ~CAPACITY = ~000 11111111111111111111 = 111 000000000000000000000（取反）</span></span><br><span class="line"><span class="comment">// c == ctl = 111 000000000000000000111</span></span><br><span class="line"><span class="comment">// 111 000000000000000000111</span></span><br><span class="line"><span class="comment">// 111 000000000000000000000</span></span><br><span class="line"><span class="comment">// 111 000000000000000000000	获取到了运行状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前线程池线程数量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        c = 111 000000000000000000111</span></span><br><span class="line"><span class="comment">// CAPACITY = 000 111111111111111111111</span></span><br><span class="line"><span class="comment">//            000 000000000000000000111 =&gt; 7</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重置当前线程池状态 ctl：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rs 表示线程池状态，wc 表示当前线程池中 worker（线程）数量，相与以后就是合并后的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较当前线程池 ctl 所表示的状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较当前线程池 ctl 所表示的状态，是否小于某个状态 s</span></span><br><span class="line"><span class="comment">// 状态对比：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateLessThan</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123; <span class="keyword">return</span> c &lt; s; &#125;</span><br><span class="line"><span class="comment">// 比较当前线程池 ctl 所表示的状态，是否大于等于某个状态s</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateAtLeast</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123; <span class="keyword">return</span> c &gt;= s; &#125;</span><br><span class="line"><span class="comment">// 小于 SHUTDOWN 的一定是 RUNNING，SHUTDOWN == 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &lt; SHUTDOWN; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置线程池 ctl：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 CAS 方式 让 ctl 值 +1 ，成功返回 true, 失败返回 false</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndIncrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 CAS 方式 让 ctl 值 -1 ，成功返回 true, 失败返回 false</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndDecrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 ctl 值减一，do while 循环会一直重试，直到成功为止</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">decrementWorkerCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (!compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="成员属性-2"><a href="#成员属性-2" class="headerlink" title="成员属性"></a>成员属性</h4><p>成员变量</p>
<ul>
<li><p>线程池中存放 Worker 的容器：线程池没有初始化，直接往池中加线程即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程全局锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加减少 worker 或者时修改线程池运行状态需要持有 mainLock</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>可重入锁的条件变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当外部线程调用 awaitTermination() 方法时，会等待当前线程池状态为 Termination 为止</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">termination</span> <span class="operator">=</span> mainLock.newCondition()</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程池相关参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> corePoolSize;				<span class="comment">// 核心线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> maximumPoolSize;			<span class="comment">// 线程池最大线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> keepAliveTime;			<span class="comment">// 空闲线程存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;	<span class="comment">// 创建线程时使用的线程工厂，默认是 DefaultThreadFactory</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<span class="comment">// 【超过核心线程提交任务就放入 阻塞队列】</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;	<span class="comment">// 拒绝策略，juc包提供了4中方式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">defaultHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>();<span class="comment">// 默认策略</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>记录线程池相关属性的数值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> largestPoolSize;		<span class="comment">// 记录线程池生命周期内线程数最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> completedTaskCount;	<span class="comment">// 记录线程池所完成任务总数，当某个 worker 退出时将完成的任务累加到该属性</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>控制<strong>核心线程数量内的线程是否可以被回收</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// false（默认）代表不可以，为 true 时核心线程空闲超过 keepAliveTime 也会被回收</span></span><br><span class="line"><span class="comment">// allowCoreThreadTimeOut(boolean value) 方法可以设置该值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> allowCoreThreadTimeOut;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>内部类：</p>
<ul>
<li><p>Worker 类：<strong>每个 Worker 对象会绑定一个初始任务</strong>，启动 Worker 时优先执行，这也是造成线程池不公平的原因。Worker 继承自 AQS，本身具有锁的特性，采用独占锁模式，state &#x3D; 0 表示未被占用，&gt; 0 表示被占用，&lt; 0 表示初始状态不能被抢锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">final</span> Thread thread;			<span class="comment">// worker 内部封装的工作线程</span></span><br><span class="line">    Runnable firstTask;				<span class="comment">// worker 第一个执行的任务，普通的 Runnable 实现类或者是 FutureTask</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;	<span class="comment">// 记录当前 worker 所完成任务数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">// 设置AQS独占模式为初始化中状态，这个状态不能被抢占锁</span></span><br><span class="line">       	setState(-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// firstTask不为空时，当worker启动后，内部线程会优先执行firstTask，执行完后会到queue中去获取下个任务</span></span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 使用线程工厂创建一个线程，并且【将当前worker指定为Runnable】，所以thread启动时会调用 worker.run()</span></span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【不可重入锁】</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">    <span class="comment">// 将当前 worker 指定为 thread 的执行方法，线程调用 start 会调用 r.run()</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r, namePrefix + threadNumber.getAndIncrement(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">        t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">        t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拒绝策略相关的内部类</p>
</li>
</ul>
<hr>
<h4 id="成员方法-2"><a href="#成员方法-2" class="headerlink" title="成员方法"></a>成员方法</h4><h5 id="提交方法-1"><a href="#提交方法-1" class="headerlink" title="提交方法"></a>提交方法</h5><ul>
<li><p>AbstractExecutorService#submit()：提交任务，<strong>把 Runnable 或 Callable 任务封装成 FutureTask 执行</strong>，可以通过方法返回的任务对象，调用 get 阻塞获取任务执行的结果或者异常，源码分析在笔记的 Future 部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="comment">// 空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 把 Runnable 封装成未来任务对象，执行结果就是 null，也可以通过参数指定 FutureTask#get 返回数据</span></span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 执行方法</span></span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 把 Callable 封装成未来任务对象</span></span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    <span class="comment">// 执行方法</span></span><br><span class="line">    execute(ftask);	</span><br><span class="line">    <span class="comment">// 返回未来任务对象，用来获取返回值</span></span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> &#123;</span><br><span class="line">    <span class="comment">// Runnable 封装成 FutureTask，【指定返回值】</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> &#123;</span><br><span class="line">    <span class="comment">// Callable 直接封装成 FutureTask</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>execute()：执行任务，<strong>但是没有返回值，没办法获取任务执行结果</strong>，出现异常会直接抛出任务执行时的异常。根据线程池中的线程数，选择添加任务时的处理方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command 可以是普通的 Runnable 实现类，也可以是 FutureTask，不能是 Callable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="comment">// 非空判断</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  	<span class="comment">// 获取 ctl 最新值赋值给 c，ctl 高 3 位表示线程池状态，低位表示当前线程池线程数量。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 【1】当前线程数量小于核心线程数，此次提交任务直接创建一个新的 worker，线程池中多了一个新的线程</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// addWorker 为创建线程的过程，会创建 worker 对象并且将 command 作为 firstTask，优先执行</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行到这条语句，说明 addWorker 一定是失败的，存在并发现象或者线程池状态被改变，重新获取状态</span></span><br><span class="line">        <span class="comment">// SHUTDOWN 状态下也有可能创建成功，前提 firstTask == null 而且当前 queue 不为空（特殊情况）</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【2】执行到这说明当前线程数量已经达到核心线程数量 或者 addWorker 失败</span></span><br><span class="line">    <span class="comment">// 	判断当前线程池是否处于running状态，成立就尝试将 task 放入到 workQueue 中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 条件一成立说明线程池状态被外部线程给修改了，可能是执行了 shutdown() 方法，该状态不能接收新提交的任务</span></span><br><span class="line">        <span class="comment">// 所以要把刚提交的任务删除，删除成功说明提交之后线程池中的线程还未消费（处理）该任务</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 任务出队成功，走拒绝策略</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 执行到这说明线程池是 running 状态，获取线程池中的线程数量，判断是否是 0</span></span><br><span class="line">        <span class="comment">// 【担保机制】，保证线程池在 running 状态下，最起码得有一个线程在工作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【3】offer失败说明queue满了</span></span><br><span class="line">    <span class="comment">// 如果线程数量尚未达到 maximumPoolSize，会创建非核心 worker 线程直接执行 command，【这也是不公平的原因】</span></span><br><span class="line">    <span class="comment">// 如果当前线程数量达到 maximumPoolSiz，这里 addWorker 也会失败，走拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="添加线程"><a href="#添加线程" class="headerlink" title="添加线程"></a>添加线程</h5><ul>
<li><p>prestartAllCoreThreads()：<strong>提前预热</strong>，创建所有的核心线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">prestartAllCoreThreads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (addWorker(<span class="literal">null</span>, <span class="literal">true</span>))</span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>addWorker()：<strong>添加线程到线程池</strong>，返回 true 表示创建 Worker 成功，且线程启动。首先判断线程池是否允许添加线程，允许就让线程数量 + 1，然后去创建 Worker 加入线程池</p>
<p>注意：SHUTDOWN 状态也能添加线程，但是要求新加的 Woker 没有 firstTask，而且当前 queue 不为空，所以创建一个线程来帮助线程池执行队列中的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// core == true 表示采用核心线程数量限制，false 表示采用 maximumPoolSize</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    <span class="comment">// 自旋【判断当前线程池状态是否允许创建线程】，允许就设置线程数量 + 1</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取 ctl 的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 获取当前线程池运行状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);	</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断当前线程池状态【是否允许添加线程】</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前线程池是 SHUTDOWN 状态，但是队列里面还有任务尚未处理完，需要处理完 queue 中的任务</span></span><br><span class="line">        <span class="comment">// 【不允许再提交新的 task，所以 firstTask 为空，但是可以继续添加 worker】</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取线程池中线程数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="comment">// 条件一一般不成立，CAPACITY是5亿多，根据 core 判断使用哪个大小限制线程数量，超过了返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 记录线程数量已经加 1，类比于申请到了一块令牌，条件失败说明其他线程修改了数量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="comment">// 申请成功，跳出了 retry 这个 for 自旋</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// CAS 失败，没有成功的申请到令牌</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">            <span class="comment">// 判断当前线程池状态是否发生过变化，被其他线程修改了，可能其他线程调用了 shutdown() 方法</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="comment">// 返回外层循环检查是否能创建线程，在 if 语句中返回 false</span></span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【令牌申请成功，开始创建线程】</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 运行标记，表示创建的 worker 是否已经启动，false未启动  true启动</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 添加标记，表示创建的 worker 是否添加到池子中了，默认false未添加，true是添加。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 【创建 Worker，底层通过线程工厂 newThread 方法创建执行线程，指定了首先执行的任务】</span></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="comment">// 将新创建的 worker 节点中的线程赋值给 t</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="comment">// 这里的判断为了防止 程序员自定义的 ThreadFactory 实现类有 bug，创造不出线程</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            <span class="comment">// 加互斥锁，要添加 worker 了</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取最新线程池运行状态保存到 rs</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">				<span class="comment">// 判断线程池是否为RUNNING状态，不是再【判断当前是否为SHUTDOWN状态且firstTask为空，特殊情况】</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 当线程start后，线程isAlive会返回true，这里还没开始启动线程，如果被启动了就需要报错</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//【将新建的 Worker 添加到线程池中】</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">					<span class="comment">// 当前池中的线程数量是一个新高，更新 largestPoolSize</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    <span class="comment">// 添加标记置为 true</span></span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 解锁啊</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加成功就【启动线程执行任务】</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// Thread 类中持有 Runnable 任务对象，调用的是 Runnable 的 run ，也就是 FutureTask</span></span><br><span class="line">                t.start();</span><br><span class="line">                <span class="comment">// 运行标记置为 true</span></span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果启动线程失败，做清理工作</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新创建的线程是否启动</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>addWorkerFailed()：清理任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWorkerFailed</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    <span class="comment">// 持有线程池全局锁，因为操作的是线程池相关的东西</span></span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//条件成立需要将 worker 在 workers 中清理出去。</span></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        <span class="comment">// 将线程池计数 -1，相当于归还令牌。</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">// 尝试停止线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放线程池全局锁。</span></span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h5><ul>
<li><p>Worker#run：Worker 实现了 Runnable 接口，当线程启动时，会调用 Worker 的 run() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ThreadPoolExecutor#runWorker()</span></span><br><span class="line">    runWorker(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>runWorker()：线程启动就要<strong>执行任务</strong>，会一直 while 循环获取任务并执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();	</span><br><span class="line">    <span class="comment">// 获取 worker 的 firstTask</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    <span class="comment">// 引用置空，【防止复用该线程时重复执行该任务】</span></span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 初始化 worker 时设置 state = -1，表示不允许抢占锁</span></span><br><span class="line">    <span class="comment">// 这里需要设置 state = 0 和 exclusiveOwnerThread = null，开始独占模式抢锁</span></span><br><span class="line">    w.unlock();</span><br><span class="line">    <span class="comment">// true 表示发生异常退出，false 表示正常退出。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// firstTask 不是 null 就直接运行，否则去 queue 中获取任务</span></span><br><span class="line">        <span class="comment">// 【getTask 如果是阻塞获取任务，会一直阻塞在take方法，直到获取任务，不会走返回null的逻辑】</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// worker 加锁，shutdown 时会判断当前 worker 状态，【根据独占锁状态判断是否空闲】</span></span><br><span class="line">            w.lock();</span><br><span class="line">            </span><br><span class="line">			<span class="comment">// 说明线程池状态大于 STOP，目前处于 STOP/TIDYING/TERMINATION，此时给线程一个中断信号</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 <span class="comment">// 说明线程处于 RUNNING 或者 SHUTDOWN 状态，清除打断标记</span></span><br><span class="line">                 (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                <span class="comment">// 中断线程，设置线程的中断标志位为 true</span></span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 钩子方法，【任务执行的前置处理】</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 【执行任务】</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">                 	<span class="comment">//.....</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 钩子方法，【任务执行的后置处理】</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;		<span class="comment">// 将局部变量task置为null，代表任务执行完成</span></span><br><span class="line">                w.completedTasks++;	<span class="comment">// 更新worker完成任务数量</span></span><br><span class="line">                w.unlock();			<span class="comment">// 解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// getTask()方法返回null时会走到这里，表示queue为空并且线程空闲超过保活时间，【当前线程执行退出逻辑】</span></span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;	</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 正常退出 completedAbruptly = false</span></span><br><span class="line">       	<span class="comment">// 异常退出 completedAbruptly = true，【从 task.run() 内部抛出异常】时，跳到这一行</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>unlock()：重置锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123; release(<span class="number">1</span>); &#125;</span><br><span class="line"><span class="comment">// 外部不会直接调用这个方法 这个方法是 AQS 内调用的，外部调用 unlock 时触发此方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    setExclusiveOwnerThread(<span class="literal">null</span>);		<span class="comment">// 设置持有者为 null</span></span><br><span class="line">    setState(<span class="number">0</span>);						<span class="comment">// 设置 state = 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getTask()：获取任务，线程空闲时间超过 keepAliveTime 就会被回收，判断的依据是<strong>当前线程阻塞获取任务超过保活时间</strong>，方法返回 null 就代表当前线程要被回收了，返回到 runWorker 执行线程退出逻辑。线程池具有担保机制，对于 RUNNING 状态下的超时回收，要保证线程池中最少有一个线程运行，或者任务阻塞队列已经是空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 超时标记，表示当前线程获取任务是否超时，true 表示已超时</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 获取线程池当前运行状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 【tryTerminate】打断线程后执行到这，此时线程池状态为STOP或者线程池状态为SHUTDOWN并且队列已经是空</span></span><br><span class="line">        <span class="comment">// 所以下面的 if 条件一定是成立的，可以直接返回 null，线程就应该退出了</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// 使用 CAS 自旋的方式让 ctl 值 -1</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 获取线程池中的线程数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程没有明确的区分谁是核心或者非核心线程，是根据当前池中的线程数量判断</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// timed = false 表示当前这个线程 获取task时不支持超时机制的，当前线程会使用 queue.take() 阻塞获取</span></span><br><span class="line">        <span class="comment">// timed = true 表示当前这个线程 获取task时支持超时机制，使用 queue.poll(xxx,xxx) 超时获取</span></span><br><span class="line">        <span class="comment">// 条件一代表允许回收核心线程，那就无所谓了，全部线程都执行超时回收</span></span><br><span class="line">        <span class="comment">// 条件二成立说明线程数量大于核心线程数，当前线程认为是非核心线程，有保活时间，去超时获取任务</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 如果线程数量是否超过最大线程数，直接回收</span></span><br><span class="line">        <span class="comment">// 如果当前线程【允许超时回收并且已经超时了】，就应该被回收了，由于【担保机制】还要做判断：</span></span><br><span class="line">        <span class="comment">// 	  wc &gt; 1 说明线程池还用其他线程，当前线程可以直接回收</span></span><br><span class="line">        <span class="comment">//    workQueue.isEmpty() 前置条件是 wc = 1，【如果当前任务队列也是空了，最后一个线程就可以退出】</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// 使用 CAS 机制将 ctl 值 -1 ,减 1 成功的线程，返回 null，代表可以退出</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据当前线程是否需要超时回收，【选择从队列获取任务的方法】是超时获取或者阻塞获取</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();</span><br><span class="line">            <span class="comment">// 获取到任务返回任务，【阻塞获取会阻塞到获取任务为止】，不会返回 null</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 获取任务为 null 说明超时了，将超时标记设置为 true，下次自旋时返 null</span></span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 阻塞线程被打断后超时标记置为 false，【说明被打断不算超时】，要继续获取，直到超时或者获取到任务</span></span><br><span class="line">            <span class="comment">// 如果线程池 SHUTDOWN 状态下的打断，会在循环获取任务前判断，返回 null</span></span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>processWorkerExit()：<strong>线程退出线程池</strong>，也有担保机制，保证队列中的任务被执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常退出 completedAbruptly = false，异常退出为 true</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">    <span class="comment">// 条件成立代表当前 worker 是发生异常退出的，task 任务执行过程中向上抛出异常了</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) </span><br><span class="line">        <span class="comment">// 从异常时到这里 ctl 一直没有 -1，需要在这里 -1</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前 worker 完成的 task 数量，汇总到线程池的 completedTaskCount</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">		<span class="comment">// 将 worker 从线程池中移除</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();	<span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 尝试停止线程池，唤醒下一个线程</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 线程池不是停止状态就应该有线程运行【担保机制】</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="comment">// 正常退出的逻辑，是对空闲线程回收，不是执行出错</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">// 根据是否回收核心线程确定【线程池中的线程数量最小值】</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="comment">// 最小值为 0，但是线程队列不为空，需要一个线程来完成任务担保机制</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; !workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 线程池中的线程数量大于最小值可以直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行 task 时发生异常，有个线程因为异常终止了，需要添加</span></span><br><span class="line">        <span class="comment">// 或者线程池中的数量小于最小值，这里要创建一个新 worker 加进线程池</span></span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="停止方法"><a href="#停止方法" class="headerlink" title="停止方法"></a>停止方法</h5><ul>
<li><p>shutdown()：停止线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    <span class="comment">// 获取线程池全局锁</span></span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 设置线程池状态为 SHUTDOWN，如果线程池状态大于 SHUTDOWN，就不会设置直接返回</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">// 空方法，子类可以扩展</span></span><br><span class="line">        onShutdown(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放线程池全局锁</span></span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>interruptIdleWorkers()：shutdown 方法会<strong>中断所有空闲线程</strong>，根据是否可以获取 AQS 独占锁判断是否处于工作状态。线程之所以空闲是因为阻塞队列没有任务，不会中断正在运行的线程，所以 shutdown 方法会让所有的任务执行完毕</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// onlyOne == true 说明只中断一个线程 ，false 则中断所有线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptIdleWorkers</span><span class="params">(<span class="type">boolean</span> onlyOne)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    / /持有全局锁</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历所有 worker</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            <span class="comment">// 获取当前 worker 的线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">            <span class="comment">// 条件一成立：说明当前迭代的这个线程尚未中断</span></span><br><span class="line">            <span class="comment">// 条件二成立：说明【当前worker处于空闲状态】，阻塞在poll或者take，因为worker执行task时是要加锁的</span></span><br><span class="line">            <span class="comment">//           每个worker有一个独占锁，w.tryLock()尝试加锁，加锁成功返回 true</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 中断线程，处于 queue 阻塞的线程会被唤醒，进入下一次自旋，返回 null，执行退出相逻辑</span></span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放worker的独占锁</span></span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// false，代表中断所有的线程</span></span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放全局锁</span></span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>shutdownNow()：直接关闭线程池，不会等待任务执行完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 返回值引用</span></span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    <span class="comment">// 获取线程池全局锁</span></span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 设置线程池状态为STOP</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断线程池中【所有线程】</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 从阻塞队列中导出未处理的task</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="comment">// 返回当前任务队列中 未处理的任务。</span></span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>tryTerminate()：设置为 TERMINATED 状态 if either (SHUTDOWN and pool and queue empty) or (STOP and pool empty)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取 ctl 的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 线程池正常，或者有其他线程执行了状态转换的方法，当前线程直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) || runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            <span class="comment">// 线程池是 SHUTDOWN 并且任务队列不是空，需要去处理队列中的任务</span></span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行到这里说明线程池状态为 STOP 或者线程池状态为 SHUTDOWN 并且队列已经是空</span></span><br><span class="line">        <span class="comment">// 判断线程池中线程的数量</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 【中断一个空闲线程】，在 queue.take() | queue.poll() 阻塞空闲</span></span><br><span class="line">            <span class="comment">// 唤醒后的线程会在getTask()方法返回null，</span></span><br><span class="line">            <span class="comment">// 执行 processWorkerExit 退出逻辑时会再次调用 tryTerminate() 唤醒下一个空闲线程</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 池中的线程数量为 0 来到这里</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        <span class="comment">// 加全局锁</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置线程池状态为 TIDYING 状态，线程数量为 0</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 结束线程池</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 设置线程池状态为TERMINATED状态。</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    <span class="comment">// 【唤醒所有调用 awaitTermination() 方法的线程】</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// 释放线程池全局锁</span></span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><h5 id="线程使用"><a href="#线程使用" class="headerlink" title="线程使用"></a>线程使用</h5><p>FutureTask 未来任务对象，继承 Runnable、Future 接口，用于包装 Callable 对象，实现任务的提交</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    FutureTask&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();	<span class="comment">//启动线程</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> task.get();	<span class="comment">//获取返回任务数据</span></span><br><span class="line">    System.out.println(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.callable = callable;	<span class="comment">// 属性注入</span></span><br><span class="line">    <span class="built_in">this</span>.state = NEW; 			<span class="comment">// 任务状态设置为 new</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span> &#123;</span><br><span class="line">    <span class="comment">// 适配器模式</span></span><br><span class="line">    <span class="built_in">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="built_in">this</span>.state = NEW;       </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title function_">callable</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 使用装饰者模式将 runnable 转换成 callable 接口，外部线程通过 get 获取</span></span><br><span class="line">    <span class="comment">// 当前任务执行结果时，结果可能为 null 也可能为传进来的值，【传进来什么返回什么】</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">final</span> T result;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        <span class="built_in">this</span>.task = task;</span><br><span class="line">        <span class="built_in">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实则调用 Runnable#run 方法</span></span><br><span class="line">        task.run();</span><br><span class="line">        <span class="comment">// 返回值为构造 FutureTask 对象时传入的返回值或者是 null</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h5 id="成员属性-3"><a href="#成员属性-3" class="headerlink" title="成员属性"></a>成员属性</h5><p>FutureTask 类的成员属性：</p>
<ul>
<li><p>任务状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示当前task状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="comment">// 当前任务尚未执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW</span>          <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 当前任务正在结束，尚未完全结束，一种临界状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPLETING</span>   <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 当前任务正常结束</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL</span>       <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 当前任务执行过程中发生了异常，内部封装的 callable.run() 向上抛出异常了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCEPTIONAL</span>  <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 当前任务被取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span>    <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 当前任务中断中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTING</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 当前任务已中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTED</span>  <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>任务对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;	<span class="comment">// Runnable 使用装饰者模式伪装成 Callable</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>存储任务执行的结果</strong>，这是 run 方法返回值是 void 也可以获取到执行结果的原因：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常情况下：任务正常执行结束，outcome 保存执行结果，callable 返回值</span></span><br><span class="line"><span class="comment">// 非正常情况：callable 向上抛出异常，outcome 保存异常</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; </span><br></pre></td></tr></table></figure>
</li>
<li><p>执行当前任务的线程对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;	<span class="comment">// 当前任务被线程执行期间，保存当前执行任务的线程对象引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>线程阻塞队列的头节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会有很多线程去 get 当前任务的结果，这里使用了一种数据结构头插头取（类似栈）的一个队列来保存所有的 get 线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WaitNode</span> &#123;</span><br><span class="line">    <span class="comment">// 单向链表</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="成员方法-3"><a href="#成员方法-3" class="headerlink" title="成员方法"></a>成员方法</h5><p>FutureTask 类的成员方法：</p>
<ul>
<li><p><strong>FutureTask#run</strong>：任务执行入口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//条件一：成立说明当前 task 已经被执行过了或者被 cancel 了，非 NEW 状态的任务，线程就不需要处理了</span></span><br><span class="line">    <span class="comment">//条件二：线程是 NEW 状态，尝试设置当前任务对象的线程是当前线程，设置失败说明其他线程抢占了该任务，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset, <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行到这里，当前 task 一定是 NEW 状态，而且【当前线程也抢占 task 成功】</span></span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="comment">// 判断任务是否为空，防止空指针异常；判断 state 状态，防止外部线程在此期间 cancel 掉当前任务</span></span><br><span class="line">        <span class="comment">// 【因为 task 的执行者已经设置为当前线程，所以这里是线程安全的】</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="comment">// true 表示 callable.run 代码块执行成功 未抛出异常</span></span><br><span class="line">            <span class="comment">// false 表示 callable.run 代码块执行失败 抛出异常</span></span><br><span class="line">            <span class="type">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 【调用自定义的方法，执行结果赋值给 result】</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                <span class="comment">// 没有出现异常</span></span><br><span class="line">                ran = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 出现异常，返回值置空，ran 置为 false</span></span><br><span class="line">                result = <span class="literal">null</span>;</span><br><span class="line">                ran = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 设置返回的异常</span></span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 代码块执行正常</span></span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                <span class="comment">// 设置返回的结果</span></span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 任务执行完成，取消线程的引用，help GC</span></span><br><span class="line">        runner = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="comment">// 判断任务是不是被中断</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            <span class="comment">// 执行中断处理方法</span></span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask#set：设置正常返回值，首先将任务状态设置为 COMPLETING 状态代表完成中，逻辑执行完设置为 NORMAL 状态代表任务正常执行完成，最后唤醒 get() 阻塞线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(V v)</span> &#123;</span><br><span class="line">    <span class="comment">// CAS 方式设置当前任务状态为完成中，设置失败说明其他线程取消了该任务</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        <span class="comment">// 【将结果赋值给 outcome】</span></span><br><span class="line">        outcome = v;</span><br><span class="line">        <span class="comment">// 将当前任务状态修改为 NORMAL 正常结束状态。</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, NORMAL);</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask#setException：设置异常返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setException</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        <span class="comment">// 赋值给返回结果，用来向上层抛出来的异常</span></span><br><span class="line">        outcome = t;</span><br><span class="line">        <span class="comment">// 将当前任务的状态 修改为 EXCEPTIONAL</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, EXCEPTIONAL);</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask#finishCompletion：<strong>唤醒 get() 阻塞线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">finishCompletion</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历所有的等待的节点，q 指向头节点</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="literal">null</span>;) &#123;</span><br><span class="line">        <span class="comment">// 使用cas设置 waiters 为 null，防止外部线程使用cancel取消当前任务，触发finishCompletion方法重复执行</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset, q, <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 自旋</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 获取当前 WaitNode 节点封装的 thread</span></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> q.thread;</span><br><span class="line">                <span class="comment">// 当前线程不为 null，唤醒当前 get() 等待获取数据的线程</span></span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="literal">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取当前节点的下一个节点</span></span><br><span class="line">                <span class="type">WaitNode</span> <span class="variable">next</span> <span class="operator">=</span> q.next;</span><br><span class="line">                <span class="comment">// 当前节点是最后一个节点了</span></span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 断开链表</span></span><br><span class="line">                q.next = <span class="literal">null</span>; <span class="comment">// help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    done();</span><br><span class="line">    callable = <span class="literal">null</span>;	<span class="comment">// help GC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask#handlePossibleCancellationInterrupt：任务中断处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePossibleCancellationInterrupt</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">        <span class="comment">// 中断状态中</span></span><br><span class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">            <span class="comment">// 等待中断完成</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>FutureTask#get</strong>：获取任务执行的返回值，执行 run 和 get 的不是同一个线程，一般有多个线程 get，只有一个线程 run</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="comment">// 获取当前任务状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="comment">// 条件成立说明任务还没执行完成</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        <span class="comment">// 返回 task 当前状态，可能当前线程在里面已经睡了一会</span></span><br><span class="line">        s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask#awaitDone：<strong>get 线程封装成 WaitNode 对象进入阻塞队列阻塞等待</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">awaitDone</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 0 不带超时</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// 引用当前线程，封装成 WaitNode 对象</span></span><br><span class="line">    <span class="type">WaitNode</span> <span class="variable">q</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 表示当前线程 waitNode 对象，是否进入阻塞队列</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">queued</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 【三次自旋开始休眠】</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 判断当前 get() 线程是否被打断，打断返回 true，清除打断标记</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// 当前线程对应的等待 node 出队，</span></span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 获取任务状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="comment">// 条件成立说明当前任务执行完成已经有结果了</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="comment">// 条件成立说明已经为当前线程创建了 WaitNode，置空 help GC</span></span><br><span class="line">            <span class="keyword">if</span> (q != <span class="literal">null</span>)</span><br><span class="line">                q.thread = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 返回当前的状态</span></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 条件成立说明当前任务接近完成状态，这里让当前线程释放一下 cpu ，等待进行下一次抢占 cpu</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) </span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="comment">// 【第一次自旋】，当前线程还未创建 WaitNode 对象，此时为当前线程创建 WaitNode对象</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="literal">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">        <span class="comment">// 【第二次自旋】，当前线程已经创建 WaitNode 对象了，但是node对象还未入队</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">// waiters 指向队首，让当前 WaitNode 成为新的队首，【头插法】，失败说明其他线程修改了新的队首</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset, q.next = waiters, q);</span><br><span class="line">        <span class="comment">// 【第三次自旋】，会到这里，或者 else 内</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 阻塞指定的时间</span></span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 条件成立：说明需要阻塞</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 【当前 get 操作的线程被 park 阻塞】，除非有其它线程将唤醒或者将当前线程中断</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask#report：封装运行结果，可以获取 run() 方法中设置的成员变量 outcome，<strong>这是 run 方法的返回值是 void 也可以获取到任务执行的结果的原因</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">report</span><span class="params">(<span class="type">int</span> s)</span> <span class="keyword">throws</span> ExecutionException &#123;</span><br><span class="line">    <span class="comment">// 获取执行结果，是在一个 futuretask 对象中的属性，可以直接获取</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> outcome;</span><br><span class="line">    <span class="comment">// 当前任务状态正常结束</span></span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;	<span class="comment">// 直接返回 callable 的逻辑结果</span></span><br><span class="line">    <span class="comment">// 当前任务被取消或者中断</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();		<span class="comment">// 抛出异常</span></span><br><span class="line">    <span class="comment">// 执行到这里说明自定义的 callable 中的方法有异常，使用 outcome 上层抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutionException</span>((Throwable)x);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>FutureTask#cancel：任务取消，打断正在执行该任务的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span> &#123;</span><br><span class="line">    <span class="comment">// 条件一：表示当前任务处于运行中或者处于线程池任务队列中</span></span><br><span class="line">    <span class="comment">// 条件二：表示修改状态，成功可以去执行下面逻辑，否则返回 false 表示 cancel 失败</span></span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">          UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW,</span><br><span class="line">                                   mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果任务已经被执行，是否允许打断</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取执行当前 FutureTask 的线程</span></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 打断执行的线程</span></span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 设置任务状态为【中断完成】</span></span><br><span class="line">                UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 唤醒所有 get() 阻塞的线程</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>Timer 实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">    <span class="type">TimerTask</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task 1&quot;</span>);</span><br><span class="line">            <span class="comment">//int i = 1 / 0;//任务一的出错会导致任务二无法执行</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">TimerTask</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task 2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line">	<span class="comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此任务1的延时，影响了任务2的执行</span></span><br><span class="line">    timer.schedule(task1, <span class="number">1000</span>);<span class="comment">//17:45:56 c.ThreadPool [Timer-0] - task 1</span></span><br><span class="line">    timer.schedule(task2, <span class="number">1000</span>);<span class="comment">//17:45:58 c.ThreadPool [Timer-0] - task 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Scheduled"><a href="#Scheduled" class="headerlink" title="Scheduled"></a>Scheduled</h4><p>任务调度线程池 ScheduledThreadPoolExecutor 继承 ThreadPoolExecutor：</p>
<ul>
<li>使用内部类 ScheduledFutureTask 封装任务</li>
<li>使用内部类 DelayedWorkQueue 作为线程池队列</li>
<li>重写 onShutdown 方法去处理 shutdown 后的任务</li>
<li>提供 decorateTask 方法作为 ScheduledFutureTask 的修饰方法，以便开发者进行扩展</li>
</ul>
<p>构造方法：<code>Executors.newScheduledThreadPool(int corePoolSize)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 最大线程数固定为 Integer.MAX_VALUE，保活时间 keepAliveTime 固定为 0</span></span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="comment">// 阻塞队列是 DelayedWorkQueue</span></span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用 API：</p>
<ul>
<li><code>ScheduledFuture&lt;?&gt; schedule(Runnable/Callable&lt;V&gt;, long delay, TimeUnit u)</code>：延迟执行任务</li>
<li><code>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable/Callable&lt;V&gt;, long initialDelay, long period, TimeUnit unit)</code>：定时执行周期任务，不考虑执行的耗时，参数为初始延迟时间、间隔时间、单位</li>
<li><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable/Callable&lt;V&gt;, long initialDelay, long delay, TimeUnit unit)</code>：定时执行周期任务，考虑执行的耗时，参数为初始延迟时间、间隔时间、单位</li>
</ul>
<p>基本使用：</p>
<ul>
<li><p>延迟任务，但是出现异常并不会在控制台打印，也不会影响其他线程的执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">// 线程池大小为1时也是串行执行</span></span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 添加两个任务，都在 1s 后同时执行</span></span><br><span class="line">    executor.schedule(() -&gt; &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;任务1，执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">//int i = 1 / 0;</span></span><br><span class="line">    	<span class="keyword">try</span> &#123; Thread.sleep(<span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    executor.schedule(() -&gt; &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;任务2，执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定时任务 scheduleAtFixedRate：<strong>一次任务的启动到下一次任务的启动</strong>之间只要大于等于间隔时间，抢占到 CPU 就会立即执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;start...&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    </span><br><span class="line">    pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;running...&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*start...Sat Apr 24 18:08:12 CST 2021</span></span><br><span class="line"><span class="comment">running...Sat Apr 24 18:08:13 CST 2021</span></span><br><span class="line"><span class="comment">running...Sat Apr 24 18:08:15 CST 2021</span></span><br><span class="line"><span class="comment">running...Sat Apr 24 18:08:17 CST 2021</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定时任务 scheduleWithFixedDelay：<strong>一次任务的结束到下一次任务的启动之间</strong>等于间隔时间，抢占到 CPU 就会立即执行，这个方法才是真正的设置两个任务之间的间隔</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;start...&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    </span><br><span class="line">    pool.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;running...&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*start...Sat Apr 24 18:11:41 CST 2021</span></span><br><span class="line"><span class="comment">running...Sat Apr 24 18:11:42 CST 2021</span></span><br><span class="line"><span class="comment">running...Sat Apr 24 18:11:45 CST 2021</span></span><br><span class="line"><span class="comment">running...Sat Apr 24 18:11:48 CST 2021</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="成员属性-4"><a href="#成员属性-4" class="headerlink" title="成员属性"></a>成员属性</h4><h5 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h5><ul>
<li><p>shutdown 后是否继续执行周期任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> continueExistingPeriodicTasksAfterShutdown;</span><br></pre></td></tr></table></figure>
</li>
<li><p>shutdown 后是否继续执行延迟任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">executeExistingDelayedTasksAfterShutdown</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消方法是否将该任务从队列中移除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认 false，不移除，等到线程拿到任务之后抛弃</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">removeOnCancel</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>任务的序列号，可以用来比较优先级：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">sequencer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="延迟任务"><a href="#延迟任务" class="headerlink" title="延迟任务"></a>延迟任务</h5><p>ScheduledFutureTask 继承 FutureTask，实现 RunnableScheduledFuture 接口，具有延迟执行的特点，覆盖 FutureTask 的 run 方法来实现对<strong>延时执行、周期执行</strong>的支持。对于延时任务调用 FutureTask#run，而对于周期性任务则调用 FutureTask#runAndReset 并且在成功之后根据 fixed-delay&#x2F;fixed-rate 模式来设置下次执行时间并重新将任务塞到工作队列</p>
<p>在调度线程池中无论是 runnable 还是 callable，无论是否需要延迟和定时，所有的任务都会被封装成 ScheduledFutureTask</p>
<p>成员变量：</p>
<ul>
<li><p>任务序列号：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> sequenceNumber;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> time;			<span class="comment">// 任务可以被执行的时间，交付时间，以纳秒表示</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> period;	<span class="comment">// 0 表示非周期任务，正数表示 fixed-rate 模式的周期，负数表示 fixed-delay 模式</span></span><br></pre></td></tr></table></figure>

<p>fixed-rate：两次开始启动的间隔，fixed-delay：一次执行结束到下一次开始启动</p>
</li>
<li><p>实际的任务对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RunnableScheduledFuture&lt;V&gt; outerTask = <span class="built_in">this</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>任务在队列数组中的索引下标：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DelayedWorkQueue 底层使用的数据结构是最小堆，记录当前任务在堆中的索引，-1 代表删除</span></span><br><span class="line"><span class="type">int</span> heapIndex;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>成员方法：</p>
<ul>
<li><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="type">long</span> ns, <span class="type">long</span> period) &#123;</span><br><span class="line">    <span class="built_in">super</span>(r, result);</span><br><span class="line">    <span class="comment">// 任务的触发时间</span></span><br><span class="line">    <span class="built_in">this</span>.time = ns;</span><br><span class="line">    <span class="comment">// 任务的周期，多长时间执行一次</span></span><br><span class="line">    <span class="built_in">this</span>.period = period;</span><br><span class="line">    <span class="comment">// 任务的序号</span></span><br><span class="line">    <span class="built_in">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>compareTo()：ScheduledFutureTask 根据执行时间 time 正序排列，如果执行时间相同，在按照序列号 sequenceNumber 正序排列，任务需要放入 DelayedWorkQueue，延迟队列中使用该方法按照从小到大进行排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed other)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="built_in">this</span>) <span class="comment">// compare zero if same object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">        <span class="comment">// 类型强转</span></span><br><span class="line">        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span><br><span class="line">        <span class="comment">// 比较者 - 被比较者的执行时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">diff</span> <span class="operator">=</span> time - x.time;</span><br><span class="line">        <span class="comment">// 比较者先执行</span></span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 被比较者先执行</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 比较者的序列号小</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不是 ScheduledFutureTask 类型时，根据延迟时间排序</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">diff</span> <span class="operator">=</span> getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);</span><br><span class="line">    <span class="keyword">return</span> (diff &lt; <span class="number">0</span>) ? -<span class="number">1</span> : (diff &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>run()：执行任务，非周期任务直接完成直接结束，<strong>周期任务执行完后会设置下一次的执行时间，重新放入线程池的阻塞队列</strong>，如果线程池中的线程数量少于核心线程，就会添加 Worker 开启新线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 是否周期性，就是判断 period 是否为 0</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">periodic</span> <span class="operator">=</span> isPeriodic();</span><br><span class="line">    <span class="comment">// 根据是否是周期任务检查当前状态能否执行任务，不能执行就取消任务</span></span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">        cancel(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 非周期任务，直接调用 FutureTask#run 执行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        ScheduledFutureTask.<span class="built_in">super</span>.run();</span><br><span class="line">    <span class="comment">// 周期任务的执行，返回 true 表示执行成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="built_in">super</span>.runAndReset()) &#123;</span><br><span class="line">        <span class="comment">// 设置周期任务的下一次执行时间</span></span><br><span class="line">        setNextRunTime();</span><br><span class="line">        <span class="comment">// 任务的下一次执行安排，如果当前线程池状态可以执行周期任务，加入队列，并开启新线程</span></span><br><span class="line">        reExecutePeriodic(outerTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>周期任务正常完成后<strong>任务的状态不会变化</strong>，依旧是 NEW，不会设置 outcome 属性。但是如果本次任务执行出现异常，会进入 setException 方法将任务状态置为异常，把异常保存在 outcome 中，方法返回 false，后续的该任务将不会再周期的执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">runAndReset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 任务不是新建的状态了，或者被别的线程执行了，直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset, <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ran</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; s == NEW) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行方法，没有返回值</span></span><br><span class="line">                c.call();</span><br><span class="line">                ran = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 出现异常，把任务设置为异常状态，唤醒所有的 get 阻塞线程</span></span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 执行完成把执行线程引用置为 null</span></span><br><span class="line">        runner = <span class="literal">null</span>;</span><br><span class="line">        s = state;</span><br><span class="line">        <span class="comment">// 如果线程被中断进行中断处理</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果正常执行，返回 true，并且任务状态没有被取消</span></span><br><span class="line">    <span class="keyword">return</span> ran &amp;&amp; s == NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任务下一次的触发时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setNextRunTime</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">p</span> <span class="operator">=</span> period;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// fixed-rate 模式，【时间设置为上一次执行任务的时间 + p】，两次任务执行的时间差</span></span><br><span class="line">        time += p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// fixed-delay 模式，下一次执行时间是【当前这次任务结束的时间（就是现在） + delay 值】</span></span><br><span class="line">        time = triggerTime(-p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>reExecutePeriodic()<strong>：准备任务的下一次执行，重新放入阻塞任务队列</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ScheduledThreadPoolExecutor#reExecutePeriodic</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">reExecutePeriodic</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (canRunInCurrentRunState(<span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// 【放入任务队列】</span></span><br><span class="line">        <span class="built_in">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="comment">// 如果提交完任务之后，线程池状态变为了 shutdown 状态，需要再次检查是否可以执行，</span></span><br><span class="line">        <span class="comment">// 如果不能执行且任务还在队列中未被取走，则取消任务</span></span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(<span class="literal">true</span>) &amp;&amp; remove(task))</span><br><span class="line">            task.cancel(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 当前线程池状态可以执行周期任务，加入队列，并【根据线程数量是否大于核心线程数确定是否开启新线程】</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cancel()：取消任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用父类 FutureTask#cancel 来取消任务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">cancelled</span> <span class="operator">=</span> <span class="built_in">super</span>.cancel(mayInterruptIfRunning);</span><br><span class="line">    <span class="comment">// removeOnCancel 用于控制任务取消后是否应该从阻塞队列中移除</span></span><br><span class="line">    <span class="keyword">if</span> (cancelled &amp;&amp; removeOnCancel &amp;&amp; heapIndex &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 从等待队列中删除该任务，并调用 tryTerminate() 判断是否需要停止线程池</span></span><br><span class="line">        remove(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> cancelled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h5><p>DelayedWorkQueue 是支持延时获取元素的阻塞队列，内部采用优先队列 PriorityQueue（小根堆、满二叉树）存储元素</p>
<p>其他阻塞队列存储节点的数据结构大都是链表，<strong>延迟队列是数组</strong>，所以延迟队列出队头元素后需要<strong>让其他元素（尾）替换到头节点</strong>，防止空指针异常</p>
<p>成员变量：</p>
<ul>
<li><p>容量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;			<span class="comment">// 初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;									<span class="comment">// 节点数量</span></span><br><span class="line"><span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue = </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RunnableScheduledFuture</span>&lt;?&gt;[INITIAL_CAPACITY];	<span class="comment">// 存放节点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();	<span class="comment">// 控制并发</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">available</span> <span class="operator">=</span> lock.newCondition();<span class="comment">// 条件队列</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>阻塞等待头节点的线程：线程池内的某个线程去 take() 获取任务时，如果延迟队列顶层节点不为 null（队列内有任务），但是节点任务还不到触发时间，线程就去检查<strong>队列的 leader字段</strong>是否被占用</p>
<ul>
<li>如果未被占用，则当前线程占用该字段，然后当前线程到 available 条件队列指定超时时间 <code>堆顶任务.time - now()</code> 挂起</li>
<li>如果被占用，当前线程直接到 available 条件队列不指定超时时间的挂起</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// leader 在 available 条件队列内是首元素，它超时之后会醒过来，然后再次将堆顶元素获取走，获取走之后，take()结束之前，会调用是 available.signal() 唤醒下一个条件队列内的等待者，然后释放 lock，下一个等待者被唤醒后去到 AQS 队列，做 acquireQueue(node) 逻辑</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Thread</span> <span class="variable">leader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>成员方法</p>
<ul>
<li><p>offer()：插入节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Runnable x)</span> &#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;</span><br><span class="line">    <span class="comment">// 队列锁，增加删除数据时都要加锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="comment">// 队列数量大于存放节点的数组长度，需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">            <span class="comment">// 扩容为原来长度的 1.5 倍</span></span><br><span class="line">            grow();</span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当前是第一个要插入的节点</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">            <span class="comment">// 修改 ScheduledFutureTask 的 heapIndex 属性，表示该对象在队列里的下标</span></span><br><span class="line">            setIndex(e, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 向上调整元素的位置，并更新 heapIndex </span></span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况1：当前任务是第一个加入到 queue 内的任务，所以在当前任务加入到 queue 之前，take() 线程会直接</span></span><br><span class="line">        <span class="comment">//		到 available 队列不设置超时的挂起，并不会去占用 leader 字段，这时需会唤醒一个线程 让它去消费</span></span><br><span class="line">       	<span class="comment">// 情况2：当前任务【优先级最高】，原堆顶任务可能还未到触发时间，leader 线程设置超时的在 available 挂起</span></span><br><span class="line">        <span class="comment">//		原先的 leader 等待的是原先的头节点，所以 leader 已经无效，需要将 leader 线程唤醒，</span></span><br><span class="line">        <span class="comment">//		唤醒之后它会检查堆顶，如果堆顶任务可以被消费，则直接获取走，否则继续成为 leader 等待新堆顶任务</span></span><br><span class="line">        <span class="keyword">if</span> (queue[<span class="number">0</span>] == e) &#123;</span><br><span class="line">            <span class="comment">// 将 leader 设置为 null</span></span><br><span class="line">            leader = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 直接随便唤醒等待头结点的阻塞线程</span></span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入新节点后对堆进行调整，进行节点上移，保持其特性【节点的值小于子节点的值】，小顶堆</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父节点，就是堆排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; e = queue[parent];</span><br><span class="line">        <span class="comment">// key 和父节点比，如果大于父节点可以直接返回，否则就继续上浮</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        setIndex(e, k);</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">    setIndex(key, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>poll()：非阻塞获取头结点，<strong>获取执行时间最近并且可以执行的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非阻塞获取</span></span><br><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; poll() &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取队头节点，因为是小顶堆</span></span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 头结点为空或者的延迟时间没到返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 头结点达到延迟时间，【尾节点成为替代节点下移调整堆结构】，返回头结点</span></span><br><span class="line">            <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123;</span><br><span class="line">    <span class="comment">// 获取尾索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> --size;</span><br><span class="line">    <span class="comment">// 获取尾节点</span></span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; x = queue[s];</span><br><span class="line">    <span class="comment">// 将堆结构最后一个节点占用的 slot 设置为 null，因为该节点要尝试升级成堆顶，会根据特性下调</span></span><br><span class="line">    queue[s] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// s == 0 说明 当前堆结构只有堆顶一个节点，此时不需要做任何的事情</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 从索引处 0 开始向下调整</span></span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line">    <span class="comment">// 出队的元素索引设置为 -1</span></span><br><span class="line">    setIndex(f, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>take()：阻塞获取头节点，读取当前堆中最小的也就是触发时间最近的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 保证线程安全</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 头节点</span></span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 等待队列不空，直至有任务通过 offer 入队并唤醒</span></span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取头节点的延迟时间是否到时</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 到达触发时间，获取头节点并调整堆，重新选择延迟时间最小的节点放入头部</span></span><br><span class="line">                    <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 逻辑到这说明头节点的延迟时间还没到</span></span><br><span class="line">                first = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 说明有 leader 线程在等待获取头节点，当前线程直接去阻塞等待</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="literal">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 没有 leader 线程，【当前线程作为leader线程，并设置头结点的延迟时间作为阻塞时间】</span></span><br><span class="line">                    <span class="type">Thread</span> <span class="variable">thisThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 在条件队列 available 使用带超时的挂起（堆顶任务.time - now() 纳秒值..）</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                        <span class="comment">// 到达阻塞时间时，当前线程会从这里醒来来</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// t堆顶更新，leader 置为 null，offer 方法释放锁后，</span></span><br><span class="line">                        <span class="comment">// 有其它线程通过 take/poll 拿到锁,读到 leader == null，然后将自身更新为leader。</span></span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            <span class="comment">// leader 置为 null 用以接下来判断是否需要唤醒后继线程</span></span><br><span class="line">                            leader = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 没有 leader 线程，头结点不为 null，唤醒阻塞获取头节点的线程，</span></span><br><span class="line">        <span class="comment">// 【如果没有这一步，就会出现有了需要执行的任务，但是没有线程去执行】</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="literal">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="literal">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>remove()：删除节点，堆移除一个元素的时间复杂度是 O(log n)，<strong>延迟任务维护了 heapIndex</strong>，直接访问的时间复杂度是 O(1)，从而可以更快的移除元素，任务在队列中被取消后会进入该逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 查找对象在队列数组中的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexOf(x);</span><br><span class="line">        <span class="comment">// 节点不存在，返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">// 修改元素的 heapIndex，-1 代表删除</span></span><br><span class="line">        setIndex(queue[i], -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 尾索引是长度-1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> --size;</span><br><span class="line">        <span class="comment">// 尾节点作为替代节点</span></span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; replacement = queue[s];</span><br><span class="line">        queue[s] = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// s == i 说明头节点就是尾节点，队列空了</span></span><br><span class="line">        <span class="keyword">if</span> (s != i) &#123;</span><br><span class="line">            <span class="comment">// 向下调整</span></span><br><span class="line">            siftDown(i, replacement);</span><br><span class="line">            <span class="comment">// 说明没发生调整</span></span><br><span class="line">            <span class="keyword">if</span> (queue[i] == replacement)</span><br><span class="line">                <span class="comment">// 上移和下移不可能同时发生，替代节点大于子节点时下移，否则上移</span></span><br><span class="line">                siftUp(i, replacement);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="成员方法-4"><a href="#成员方法-4" class="headerlink" title="成员方法"></a>成员方法</h4><h5 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h5><ul>
<li><p>schedule()：延迟执行方法，并指定执行的时间，默认是当前时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="comment">// 以零延时任务的形式实现</span></span><br><span class="line">    schedule(command, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="type">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span> || unit == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 没有做任何操作，直接将 task 返回，该方法主要目的是用于子类扩展，并且【根据延迟时间设置任务触发的时间点】</span></span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command, <span class="keyword">new</span> <span class="title class_">ScheduledFutureTask</span>&lt;Void&gt;(</span><br><span class="line">        											command, <span class="literal">null</span>, triggerTime(delay, unit)));</span><br><span class="line">    <span class="comment">// 延迟执行</span></span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回【当前时间 + 延迟时间】，就是触发当前任务执行的时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">triggerTime</span><span class="params">(<span class="type">long</span> delay, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置触发的时间</span></span><br><span class="line">    <span class="keyword">return</span> triggerTime(unit.toNanos((delay &lt; <span class="number">0</span>) ? <span class="number">0</span> : delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="title function_">triggerTime</span><span class="params">(<span class="type">long</span> delay)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 delay &lt; Long.Max_VALUE/2，则下次执行时间为当前时间 +delay</span></span><br><span class="line">    <span class="comment">// 否则为了避免队列中出现由于溢出导致的排序紊乱,需要调用overflowFree来修正一下delay</span></span><br><span class="line">    <span class="keyword">return</span> now() + ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) ? delay : overflowFree(delay));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>overflowFree 的原因：如果某个任务的 delay 为负数，说明当前可以执行（其实早该执行了）。阻塞队列中维护任务顺序是基于 compareTo 比较的，比较两个任务的顺序会用 time 相减。那么可能出现一个 delay 为正数减去另一个为负数的 delay，结果上溢为负数，则会导致 compareTo 产生错误的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">overflowFree</span><span class="params">(<span class="type">long</span> delay)</span> &#123;</span><br><span class="line">    <span class="type">Delayed</span> <span class="variable">head</span> <span class="operator">=</span> (Delayed) <span class="built_in">super</span>.getQueue().peek();</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">headDelay</span> <span class="operator">=</span> head.getDelay(NANOSECONDS);</span><br><span class="line">        <span class="comment">// 判断一下队首的delay是不是负数，如果是正数就不用管，怎么减都不会溢出</span></span><br><span class="line">        <span class="comment">// 否则拿当前 delay 减去队首的 delay 来比较看，如果不出现上溢，排序不会乱</span></span><br><span class="line">		<span class="comment">// 不然就把当前 delay 值给调整为 Long.MAX_VALUE + 队首 delay</span></span><br><span class="line">        <span class="keyword">if</span> (headDelay &lt; <span class="number">0</span> &amp;&amp; (delay - headDelay &lt; <span class="number">0</span>))</span><br><span class="line">            delay = Long.MAX_VALUE + headDelay;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>scheduleAtFixedRate()：定时执行，一次任务的启动到下一次任务的启动的间隔</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="type">long</span> initialDelay, <span class="type">long</span> period,</span><br><span class="line">                                              TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span> || unit == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">// 任务封装，【指定初始的延迟时间和周期时间】</span></span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =<span class="keyword">new</span> <span class="title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="literal">null</span>,</span><br><span class="line">                                      triggerTime(initialDelay, unit), unit.toNanos(period));</span><br><span class="line">    <span class="comment">// 默认返回本身</span></span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    <span class="comment">// 开始执行这个任务</span></span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>scheduleWithFixedDelay()：定时执行，一次任务的结束到下一次任务的启动的间隔</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="type">long</span> initialDelay, <span class="type">long</span> delay,</span><br><span class="line">                                                 TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span> || unit == <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">// 任务封装，【指定初始的延迟时间和周期时间】，周期时间为 - 表示是 fixed-delay 模式</span></span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft = <span class="keyword">new</span> <span class="title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="literal">null</span>,</span><br><span class="line">                                      triggerTime(initialDelay, unit), unit.toNanos(-delay));</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="运行任务"><a href="#运行任务" class="headerlink" title="运行任务"></a>运行任务</h5><ul>
<li><p>delayedExecute()：<strong>校验线程池状态</strong>，延迟或周期性任务的主要执行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;</span><br><span class="line">    <span class="comment">// 线程池是 SHUTDOWN 状态，需要执行拒绝策略</span></span><br><span class="line">    <span class="keyword">if</span> (isShutdown())</span><br><span class="line">        reject(task);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 把当前任务放入阻塞队列，因为需要【获取执行时间最近的】，当前任务需要比较</span></span><br><span class="line">        <span class="built_in">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="comment">// 线程池状态为 SHUTDOWN 并且不允许执行任务了，就从队列删除该任务，并设置任务的状态为取消状态</span></span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task))</span><br><span class="line">            task.cancel(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 可以执行</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ensurePrestart()：<strong>开启线程执行任务</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor#ensurePrestart</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">ensurePrestart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(ctl.get());</span><br><span class="line">    <span class="comment">// worker数目小于corePoolSize，则添加一个worker。</span></span><br><span class="line">    <span class="keyword">if</span> (wc &lt; corePoolSize)</span><br><span class="line">        <span class="comment">// 第二个参数 true 表示采用核心线程数量限制，false 表示采用 maximumPoolSize</span></span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// corePoolSize = 0的情况，至少开启一个线程，【担保机制】</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wc == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>canRunInCurrentRunState()：任务运行时都会被调用以校验当前状态是否可以运行任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">canRunInCurrentRunState</span><span class="params">(<span class="type">boolean</span> periodic)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据是否是周期任务判断，在线程池 shutdown 后是否继续执行该任务，默认非周期任务是继续执行的</span></span><br><span class="line">    <span class="keyword">return</span> isRunningOrShutdown(periodic ? continueExistingPeriodicTasksAfterShutdown :</span><br><span class="line">                               executeExistingDelayedTasksAfterShutdown);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>onShutdown()：删除并取消工作队列中的不需要再执行的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">onShutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = <span class="built_in">super</span>.getQueue();</span><br><span class="line">    <span class="comment">// shutdown 后是否仍然执行延时任务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">keepDelayed</span> <span class="operator">=</span> getExecuteExistingDelayedTasksAfterShutdownPolicy();</span><br><span class="line">    <span class="comment">// shutdown 后是否仍然执行周期任务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">keepPeriodic</span> <span class="operator">=</span> getContinueExistingPeriodicTasksAfterShutdownPolicy();</span><br><span class="line">    <span class="comment">// 如果两者皆不可，则对队列中【所有任务】调用 cancel 取消并清空队列</span></span><br><span class="line">    <span class="keyword">if</span> (!keepDelayed &amp;&amp; !keepPeriodic) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object e : q.toArray())</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture&lt;?&gt;)</span><br><span class="line">                ((RunnableScheduledFuture&lt;?&gt;) e).cancel(<span class="literal">false</span>);</span><br><span class="line">        q.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object e : q.toArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture) &#123;</span><br><span class="line">                RunnableScheduledFuture&lt;?&gt; t = (RunnableScheduledFuture&lt;?&gt;)e;</span><br><span class="line">                <span class="comment">// 不需要执行的任务删除并取消，已经取消的任务也需要从队列中删除</span></span><br><span class="line">                <span class="keyword">if</span> ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) ||</span><br><span class="line">                    t.isCancelled()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (q.remove(t))</span><br><span class="line">                        t.cancel(<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为任务被从队列中清理掉，所以需要调用 tryTerminate 尝试【改变线程池的状态】</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>Fork&#x2F;Join：线程池的实现，体现是分治思想，适用于能够进行任务拆分的 CPU 密集型运算，用于<strong>并行计算</strong></p>
<p>任务拆分：将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列都可以用分治思想进行求解</p>
<ul>
<li><p>Fork&#x2F;Join 在<strong>分治的基础上加入了多线程</strong>，把每个任务的分解和合并交给不同的线程来完成，提升了运算效率</p>
</li>
<li><p>ForkJoin 使用 ForkJoinPool 来启动，是一个特殊的线程池，默认会创建与 CPU 核心数大小相同的线程池</p>
</li>
<li><p>任务有返回值继承 RecursiveTask，没有返回值继承 RecursiveAction</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>);</span><br><span class="line">    System.out.println(pool.invoke(<span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">5</span>)));</span><br><span class="line">    <span class="comment">//拆分  5 + MyTask(4) --&gt; 4 + MyTask(3) --&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1~ n 之间整数的和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyTask&#123;&quot;</span> + <span class="string">&quot;n=&quot;</span> + n + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 n 已经为 1，可以求得结果了</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将任务进行拆分(fork)</span></span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(n - <span class="number">1</span>);</span><br><span class="line">        t1.fork();</span><br><span class="line">        <span class="comment">// 合并(join)结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> n + t1.join();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续拆分优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AddTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="type">int</span> begin;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddTask</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + begin + <span class="string">&quot;,&quot;</span> + end + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 5, 5</span></span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4, 5  防止多余的拆分  提高效率</span></span><br><span class="line">        <span class="keyword">if</span> (end - begin == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> end + begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1 5</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (end + begin) / <span class="number">2</span>; <span class="comment">// 3</span></span><br><span class="line">        <span class="type">AddTask</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask</span>(begin, mid); <span class="comment">// 1,3</span></span><br><span class="line">        t1.fork();</span><br><span class="line">        <span class="type">AddTask</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask</span>(mid + <span class="number">1</span>, end); <span class="comment">// 4,5</span></span><br><span class="line">        t2.fork();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> t1.join() + t2.join();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ForkJoinPool 实现了<strong>工作窃取算法</strong>来提高 CPU 的利用率：</p>
<ul>
<li>每个线程都维护了一个<strong>双端队列</strong>，用来存储需要执行的任务</li>
<li>工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行</li>
<li>窃取的必须是<strong>最晚的任务</strong>，避免和队列所属线程发生竞争，但是队列中只有一个任务时还是会发生竞争</li>
</ul>
<hr>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>享元模式（Flyweight pattern）： 用于减少创建对象的数量，以减少内存占用和提高性能，这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式</p>
<p>异步模式：让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务，也可将其归类为分工模式，典型实现就是线程池</p>
<p>工作机制：享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象</p>
<p>自定义连接池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Pool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pool</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> pool.borrow();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            pool.free(con);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pool</span> &#123;</span><br><span class="line">    <span class="comment">//连接池的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poolSize;</span><br><span class="line">    <span class="comment">//连接对象的数组</span></span><br><span class="line">    <span class="keyword">private</span> Connection[] connections;</span><br><span class="line">    <span class="comment">//连接状态数组 0表示空闲  1表示繁忙</span></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray states;  <span class="comment">//int[] -&gt; AtomicIntegerArray</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pool</span><span class="params">(<span class="type">int</span> poolSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.poolSize = poolSize;</span><br><span class="line">        <span class="built_in">this</span>.connections = <span class="keyword">new</span> <span class="title class_">Connection</span>[poolSize];</span><br><span class="line">        <span class="built_in">this</span>.states = <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[poolSize]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            connections[i] = <span class="keyword">new</span> <span class="title class_">MockConnection</span>(<span class="string">&quot;连接&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用连接</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">borrow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (states.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (states.compareAndSet(i, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; borrow &quot;</span> +  connections[i]);</span><br><span class="line">                        <span class="keyword">return</span> connections[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有空闲连接，当前线程等待</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; wait...&quot;</span>);</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归还连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Connection con)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connections[i] == con) &#123;<span class="comment">//判断是否是同一个对象</span></span><br><span class="line">                states.set(i, <span class="number">0</span>);<span class="comment">//不用cas的原因是只会有一个线程使用该连接</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; free &quot;</span> + con);</span><br><span class="line">                    <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MockConnection</span> <span class="keyword">implements</span> <span class="title class_">Connection</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h2><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>AQS：AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架，许多同步类实现都依赖于该同步器</p>
<p>AQS 用状态属性来表示资源的状态（分<strong>独占模式和共享模式</strong>），子类需要定义如何维护这个状态，控制如何获取锁和释放锁</p>
<ul>
<li>独占模式是只有一个线程能够访问资源，如 ReentrantLock</li>
<li>共享模式允许多个线程访问资源，如 Semaphore，ReentrantReadWriteLock 是组合式</li>
</ul>
<p>AQS 核心思想：</p>
<ul>
<li><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置锁定状态</p>
</li>
<li><p>请求的共享资源被占用，AQS 用队列实现线程阻塞等待以及被唤醒时锁分配的机制，将暂时获取不到锁的线程加入到队列中</p>
<p>CLH 是一种基于单向链表的<strong>高性能、公平的自旋锁</strong>，AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-AQS原理图.png" style="zoom: 80%;"></li>
</ul>
<hr>
<h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><p>设计原理：</p>
<ul>
<li><p>获取锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(state 状态不允许获取) &#123;	<span class="comment">// tryAcquire(arg)</span></span><br><span class="line">    <span class="keyword">if</span>(队列中还没有此线程) &#123;</span><br><span class="line">        入队并阻塞 park</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">当前线程出队</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(state 状态允许了) &#123;	<span class="comment">// tryRelease(arg)</span></span><br><span class="line">	恢复阻塞的线程(s) unpark</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>AbstractQueuedSynchronizer 中 state 设计：</p>
<ul>
<li><p>state 使用了 32bit int 来维护同步状态，独占模式 0 表示未加锁状态，大于 0 表示已经加锁状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure>
</li>
<li><p>state <strong>使用 volatile 修饰配合 cas</strong> 保证其修改时的原子性</p>
</li>
<li><p>state 表示<strong>线程重入的次数（独占模式）或者剩余许可数（共享模式）</strong></p>
</li>
<li><p>state API：</p>
<ul>
<li><code>protected final int getState()</code>：获取 state 状态</li>
<li><code>protected final void setState(int newState)</code>：设置 state 状态</li>
<li><code>protected final boolean compareAndSetState(int expect,int update)</code>：<strong>CAS</strong> 安全设置 state</li>
</ul>
</li>
</ul>
<p>封装线程的 Node 节点中 waitstate 设计：</p>
<ul>
<li><p>使用 <strong>volatile 修饰配合 CAS</strong> 保证其修改时的原子性</p>
</li>
<li><p>表示 Node 节点的状态，有以下几种状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认为 0</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"><span class="comment">// 由于超时或中断，此节点被取消，不会再改变状态</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 此节点后面的节点已（或即将）被阻止（通过park），【当前节点在释放或取消时必须唤醒后面的节点】</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 此节点当前在条件队列中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line"><span class="comment">// 将releaseShared传播到其他节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>阻塞恢复设计：</p>
<ul>
<li>使用 park &amp; unpark 来实现线程的暂停和恢复，因为命令的先后顺序不影响结果</li>
<li>park &amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细</li>
<li>park 线程可以通过 interrupt 打断</li>
</ul>
<p>队列设计：</p>
<ul>
<li><p>使用了 FIFO 先入先出队列，并不支持优先级队列，<strong>同步队列是双向链表，便于出队入队</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头结点，指向哑元节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="comment">// 阻塞队列的尾节点，阻塞队列不包含头结点，从 head.next → tail 认为是阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 枚举：共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">// 枚举：独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// node 需要构建成 FIFO 队列，prev 指向前继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// next 指向后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 当前 node 封装的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">// 条件队列是单向链表，只有后继指针，条件队列使用该属性</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-AQS%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1.png"></p>
</li>
<li><p>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet，<strong>条件队列是单向链表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// 指向条件队列的第一个 node 节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">// 指向条件队列的最后一个 node 节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="模板对象"><a href="#模板对象" class="headerlink" title="模板对象"></a>模板对象</h4><p>同步器的设计是基于模板方法模式，该模式是基于继承的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码</p>
<ul>
<li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，这些模板方法会调用使用者重写的方法</li>
</ul>
<p>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isHeldExclusively()		<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它</span></span><br><span class="line">tryAcquire(<span class="type">int</span>)			<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false</span></span><br><span class="line">tryRelease(<span class="type">int</span>)			<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false</span></span><br><span class="line">tryAcquireShared(<span class="type">int</span>)	<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功但没有剩余可用资源；正数表示成功且有剩余资源</span></span><br><span class="line">tryReleaseShared(<span class="type">int</span>)	<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code></li>
<li>这些方法的实现必须是内部线程安全的</li>
<li>AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用</li>
</ul>
<hr>
<h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>自定义一个不可重入锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="comment">//独占锁 不可重入</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MySync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 加上锁 设置 owner 为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span>   <span class="comment">//解锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);<span class="comment">//volatile 修饰的变量放在后面，防止指令重排</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span>   <span class="comment">//是否持有独占锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MySync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//加锁（不成功进入等待队列等待）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//加锁 可打断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//尝试加锁，尝试一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//尝试加锁，带超时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//解锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//条件变量</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="Re-Lock"><a href="#Re-Lock" class="headerlink" title="Re-Lock"></a>Re-Lock</h3><h4 id="锁对比"><a href="#锁对比" class="headerlink" title="锁对比"></a>锁对比</h4><p>ReentrantLock 相对于 synchronized 具备如下特点：</p>
<ol>
<li>锁的实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的</li>
<li>性能：新版本 Java 对 synchronized 进行了很多优化，synchronized 与 ReentrantLock 大致相同</li>
<li>使用：ReentrantLock 需要手动解锁，synchronized 执行完代码块自动解锁</li>
<li><strong>可中断</strong>：ReentrantLock 可中断，而 synchronized 不行</li>
<li><strong>公平锁</strong>：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁<ul>
<li>ReentrantLock 可以设置公平锁，synchronized 中的锁是非公平的</li>
<li>不公平锁的含义是阻塞队列内公平，队列外非公平</li>
</ul>
</li>
<li>锁超时：尝试获取锁，超时获取不到直接放弃，不进入阻塞队列<ul>
<li>ReentrantLock 可以设置超时时间，synchronized 会一直等待</li>
</ul>
</li>
<li>锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象，更细粒度的唤醒线程</li>
<li>两者都是可重入锁</li>
</ol>
<hr>
<h4 id="使用锁-1"><a href="#使用锁-1" class="headerlink" title="使用锁"></a>使用锁</h4><p>构造方法：<code>ReentrantLock lock = new ReentrantLock();</code></p>
<p>ReentrantLock 类 API：</p>
<ul>
<li><p><code>public void lock()</code>：获得锁</p>
<ul>
<li><p>如果锁没有被另一个线程占用，则将锁定计数设置为 1</p>
</li>
<li><p>如果当前线程已经保持锁定，则保持计数增加 1 </p>
</li>
<li><p>如果锁被另一个线程保持，则当前线程被禁用线程调度，并且在锁定已被获取之前处于休眠状态</p>
</li>
</ul>
</li>
<li><p><code>public void unlock()</code>：尝试释放锁</p>
<ul>
<li>如果当前线程是该锁的持有者，则保持计数递减</li>
<li>如果保持计数现在为零，则锁定被释放</li>
<li>如果当前线程不是该锁的持有者，则抛出异常</li>
</ul>
</li>
</ul>
<p>基本语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="comment">// 释放锁</span></span><br><span class="line">	reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><h5 id="基本使用-3"><a href="#基本使用-3" class="headerlink" title="基本使用"></a>基本使用</h5><p>构造方法：<code>ReentrantLock lock = new ReentrantLock(true)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 默认是不公平的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：公平锁一般没有必要，会降低并发度</p>
<hr>
<h5 id="非公原理"><a href="#非公原理" class="headerlink" title="非公原理"></a>非公原理</h5><h6 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h6><p>NonfairSync 继承自 AQS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>没有竞争：ExclusiveOwnerThread 属于 Thread-0，state 设置为 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.NonfairSync#lock</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示【获得了独占锁】</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 设置当前线程为独占线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);<span class="comment">//失败进入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一个竞争出现：Thread-1 执行，CAS 尝试将 state 由 0 改为 1，结果失败（第一次），进入 acquire 逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer#acquire</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// tryAcquire 尝试获取锁失败时, 会调用 addWaiter 将当前线程封装成node入队，acquireQueued 阻塞当前线程，</span></span><br><span class="line">    <span class="comment">// acquireQueued 返回 true 表示挂起过程中线程被中断唤醒过，false 表示未被中断过</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">// 如果线程被中断了逻辑来到这，完成一次真正的打断效果</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ReentrantLock-非公平锁1.png" style="zoom:80%;">

<ul>
<li><p>进入 tryAcquire 尝试获取锁逻辑，这时 state 已经是1，结果仍然失败（第二次），加锁成功有两种情况：</p>
<ul>
<li>当前 AQS 处于无锁状态</li>
<li>加锁线程就是当前线程，说明发生了锁重入</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.NonfairSync#tryAcquire</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抢占成功返回 true，抢占失败返回 false</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// state 值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 条件成立说明当前处于【无锁状态】</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果还没有获得锁，尝试用cas获得，这里体现非公平性: 不去检查 AQS 队列是否有阻塞线程直接获取锁        </span></span><br><span class="line">    	<span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 获取锁成功设置当前线程为独占锁线程。</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;    </span><br><span class="line">	&#125;    </span><br><span class="line">   	<span class="comment">// 如果已经有线程获得了锁, 独占锁线程还是当前线程, 表示【发生了锁重入】</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 更新锁重入的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="comment">// 越界判断，当重入的深度很深时，会导致 nextc &lt; 0，int值达到最大之后再 + 1 变负数</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 更新 state 的值，这里不使用 cas 是因为当前线程正在持有锁，所以这里的操作相当于在一个管程内</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来进入 addWaiter 逻辑，构造 Node 队列，前置条件是当前线程获取锁失败，说明有线程占用了锁</p>
<ul>
<li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认<strong>正常状态</strong></li>
<li>Node 的创建是懒惰的，其中第一个 Node 称为 <strong>Dummy（哑元）或哨兵</strong>，用来占位，并不关联线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer#addWaiter，返回当前线程的 node 节点</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式   </span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">// 快速入队，如果 tail 不为 null，说明存在阻塞队列</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将当前节点的前驱节点指向 尾节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 通过 cas 将 Node 对象加入 AQS 队列，成为尾节点，【尾插法】</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;<span class="comment">// 双向链表</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始时队列为空，或者 CAS 失败进入这里</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer#enq</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 自旋入队，必须入队成功才结束循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 说明当前锁被占用，且当前线程可能是【第一个获取锁失败】的线程，【还没有建立队列】</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置一个【哑元节点】，头尾指针都指向该节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 自旋到这，普通入队方式，首先赋值尾节点的前驱节点【尾插法】</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// 【在设置完尾节点后，才更新的原始尾节点的后继节点，所以此时从前往后遍历会丢失尾节点】</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                <span class="comment">//【此时 t.next  = null，并且这里已经 CAS 结束，线程并不是安全的】</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;	<span class="comment">// 返回当前 node 的前驱节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ReentrantLock-非公平锁2.png" style="zoom:80%;">
</li>
<li><p>线程节点加入阻塞队列成功，进入 AbstractQueuedSynchronizer#acquireQueued 逻辑阻塞线程</p>
<ul>
<li><p>acquireQueued 会在一个自旋中不断尝试获得锁，失败后进入 park 阻塞</p>
</li>
<li><p>如果当前线程是在 head 节点后，会再次 tryAcquire 尝试获取锁，state 仍为 1 则失败（第三次）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// true 表示当前线程抢占锁失败，false 表示成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 中断标记，表示当前线程是否被中断</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获得当前线程节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 前驱节点是 head, FIFO 队列的特性表示轮到当前线程可以去获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 获取成功, 设置当前线程自己的 node 为 head</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="comment">// 表示抢占锁成功</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 返回当前线程是否被中断</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否应当 park，返回 false 后需要新一轮的循环，返回 true 进入条件二阻塞线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 条件二返回结果是当前线程是否被打断，没有被打断返回 false 不进入这里的逻辑</span></span><br><span class="line">                <span class="comment">// 【就算被打断了，也会继续循环，并不会返回】</span></span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 【可打断模式下才会进入该逻辑】</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>进入 shouldParkAfterFailedAcquire 逻辑，<strong>将前驱 node 的 waitStatus 改为 -1</strong>，返回 false；waitStatus 为 -1 的节点用来唤醒下一个节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="comment">// 表示前置节点是个可以唤醒当前节点的节点，返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 前置节点的状态处于取消状态，需要【删除前面所有取消的节点】, 返回到外层循环重试</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 获取到非取消的节点，连接上当前节点</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">    <span class="comment">// 默认情况下 node 的 waitStatus 是 0，进入这里的逻辑</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 【设置上一个节点状态为 Node.SIGNAL】，返回外层循环重试</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回不应该 park，再次尝试一次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，这时 state 仍为 1 获取失败（第四次）</li>
<li>当再次进入 shouldParkAfterFailedAcquire 时，这时其前驱 node 的 waitStatus 已经是 -1 了，返回 true</li>
<li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 阻塞当前线程，如果打断标记已经是 true, 则 park 会失效</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 判断当前线程是否被打断，清除打断标记</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再有多个线程经历竞争失败后：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ReentrantLock-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%813.png"></p>
</li>
</ul>
<hr>
<h6 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h6><p>ReentrantLock#unlock：释放锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread-0 释放锁，进入 release 流程</p>
<ul>
<li><p>进入 tryRelease，设置 exclusiveOwnerThread 为 null，state &#x3D; 0</p>
</li>
<li><p>当前队列不为 null，并且 head 的 waitStatus &#x3D; -1，进入 unparkSuccessor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer#release</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试释放锁，tryRelease 返回 true 表示当前线程已经【完全释放锁，重入的释放了】</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 队列头节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 头节点什么时候是空？没有发生锁竞争，没有竞争线程创建哑元节点</span></span><br><span class="line">        <span class="comment">// 条件成立说明阻塞队列有等待线程，需要唤醒 head 节点后面的线程</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.Sync#tryRelease</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// 减去释放的值，可能重入</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">// 如果当前线程不是持有锁的线程直接报错</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="comment">// 是否已经完全释放锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 支持锁重入, 只有 state 减为 0, 才完全释放锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程就是持有锁线程，所以可以直接更新锁，不需要使用 CAS</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入 AbstractQueuedSynchronizer#unparkSuccessor 方法，唤醒当前节点的后继节点</p>
<ul>
<li>找到队列中距离 head 最近的一个没取消的 Node，unpark 恢复其运行，本例中即为 Thread-1</li>
<li>回到 Thread-1 的 acquireQueued 流程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前节点的状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;    </span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)        </span><br><span class="line">        <span class="comment">// 【尝试重置状态为 0】，因为当前节点要完成对后续节点的唤醒任务了，不需要 -1 了</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);    </span><br><span class="line">    <span class="comment">// 找到需要 unpark 的节点，当前节点的下一个    </span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;    </span><br><span class="line">    <span class="comment">// 已取消的节点不能唤醒，需要找到距离头节点最近的非取消的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// AQS 队列【从后至前】找需要 unpark 的节点，直到 t == 当前的 node 为止，找不到就不唤醒了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="comment">// 说明当前线程状态需要被唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 置换引用</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【找到合适的可以被唤醒的 node，则唤醒线程】</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从后向前的唤醒的原因</strong>：enq 方法中，节点是尾插法，首先赋值的是尾节点的前驱节点，此时前驱节点的 next 并没有指向尾节点，从前遍历会丢失尾节点</p>
</li>
<li><p>唤醒的线程会从 park 位置开始执行，如果加锁成功（没有竞争），会设置</p>
<ul>
<li>exclusiveOwnerThread 为 Thread-1，state &#x3D; 1</li>
<li>head 指向刚刚 Thread-1 所在的 Node，该 Node 会清空 Thread</li>
<li>原本的 head 因为从链表断开，而可被垃圾回收（图中有错误，原来的头节点的 waitStatus 被改为 0 了）</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ReentrantLock-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%814.png"></p>
</li>
<li><p>如果这时有其它线程来竞争<strong>（非公平）</strong>，例如这时有 Thread-4 来了并抢占了锁</p>
<ul>
<li>Thread-4 被设置为 exclusiveOwnerThread，state &#x3D; 1</li>
<li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ReentrantLock-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%815.png"></p>
</li>
</ul>
<hr>
<h5 id="公平原理"><a href="#公平原理" class="headerlink" title="公平原理"></a>公平原理</h5><p>与非公平锁主要区别在于 tryAcquire 方法：先检查 AQS 队列中是否有前驱节点，没有才去 CAS 竞争</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有(false)才去竞争</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 锁重入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    Node s;    </span><br><span class="line">    <span class="comment">// 头尾指向一个节点，链表为空，返回false</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        <span class="comment">// 头尾之间有节点，判断头节点的下一个是不是空</span></span><br><span class="line">        <span class="comment">// 不是空进入最后的判断，第二个节点的线程是否是本线程，不是返回 true，表示当前节点有前驱节点</span></span><br><span class="line">        ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><p>可重入是指同一个线程如果首次获得了这把锁，那么它是这把锁的拥有者，因此有权利再次获取这把锁，如果不可重入锁，那么第二次获得锁时，自己也会被锁挡住，直接造成死锁</p>
<p>源码解析参考：<code>nonfairTryAcquire(int acquires)) </code> 和 <code>tryRelease(int releases)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; execute method1&quot;</span>);</span><br><span class="line">        method2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; execute method2&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Lock 方法加两把锁会是什么情况呢？</p>
<ul>
<li>加锁两次解锁两次：正常执行</li>
<li>加锁两次解锁一次：程序直接卡死，线程不能出来，也就说明<strong>申请几把锁，最后需要解除几把锁</strong></li>
<li>加锁一次解锁两次：运行程序会直接报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getLock</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t get Lock&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="comment">//lock.unlock();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><h5 id="基本使用-4"><a href="#基本使用-4" class="headerlink" title="基本使用"></a>基本使用</h5><p><code>public void lockInterruptibly()</code>：获得可打断的锁</p>
<ul>
<li>如果没有竞争此方法就会获取 lock 对象锁</li>
<li>如果有竞争就进入阻塞队列，可以被其他线程用 interrupt 打断</li>
</ul>
<p>注意：如果是不可中断模式，那么即使使用了 interrupt 也不会让等待状态中的线程中断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;    </span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();    </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        </span><br><span class="line">        <span class="keyword">try</span> &#123;            </span><br><span class="line">            System.out.println(<span class="string">&quot;尝试获取锁&quot;</span>);            </span><br><span class="line">            lock.lockInterruptibly();        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            </span><br><span class="line">            System.out.println(<span class="string">&quot;没有获取到锁，被打断，直接返回&quot;</span>);            </span><br><span class="line">            <span class="keyword">return</span>;        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">try</span> &#123;            </span><br><span class="line">            System.out.println(<span class="string">&quot;获取到锁&quot;</span>);        </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;            </span><br><span class="line">            lock.unlock();        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);    </span><br><span class="line">    lock.lock();    </span><br><span class="line">    t1.start();    </span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);    </span><br><span class="line">    System.out.println(<span class="string">&quot;主线程进行打断锁&quot;</span>);    </span><br><span class="line">    t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h5><ul>
<li><p>不可打断模式：即使它被打断，仍会驻留在 AQS 阻塞队列中，一直要<strong>等到获得锁后才能得知自己被打断</strong>了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;    </span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<span class="comment">//阻塞等待        </span></span><br><span class="line">        <span class="comment">// 如果acquireQueued返回true，打断状态 interrupted = true        </span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 知道自己被打断了，需要重新产生一次中断完成中断效果</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;    </span><br><span class="line">    <span class="keyword">try</span> &#123;        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;        </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;            </span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();            </span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;                </span><br><span class="line">                setHead(node);                </span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC                </span></span><br><span class="line">                failed = <span class="literal">false</span>;                </span><br><span class="line">                <span class="comment">// 还是需要获得锁后, 才能返回打断状态</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;            </span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())&#123;</span><br><span class="line">                <span class="comment">// 条件二中判断当前线程是否被打断，被打断返回true，设置中断标记为 true，【获取锁后返回】</span></span><br><span class="line">                interrupted = <span class="literal">true</span>;  </span><br><span class="line">            &#125;                  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;    </span><br><span class="line">     <span class="comment">// 阻塞当前线程，如果打断标记已经是 true, 则 park 会失效</span></span><br><span class="line">     LockSupport.park(<span class="built_in">this</span>);    </span><br><span class="line">     <span class="comment">// 判断当前线程是否被打断，清除打断标记，被打断返回true</span></span><br><span class="line">     <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可打断模式：AbstractQueuedSynchronizer#acquireInterruptibly，<strong>被打断后会直接抛出异常</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    </span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 被其他线程打断了直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        <span class="comment">// 没获取到锁，进入这里</span></span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 返回封装当前线程的节点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 【在 park 过程中如果被 interrupt 会抛出异常】, 而不会再次进入循环获取锁后才完成打断效果</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 抛出异常前会进入这里</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">// 取消当前线程的节点</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取消节点出队的逻辑</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 把当前节点封装的 Thread 置为空</span></span><br><span class="line">    node.thread = <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">// 获取当前取消的 node 的前驱节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;</span><br><span class="line">    <span class="comment">// 前驱节点也被取消了，循环找到前面最近的没被取消的节点</span></span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 获取前驱节点的后继节点，可能是当前 node，也可能是 waitStatus &gt; 0 的节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 把当前节点的状态设置为 【取消状态 1】</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 条件成立说明当前节点是尾节点，把当前节点的前驱节点设置为尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        <span class="comment">// 把前驱节点的后继节点置空，这里直接把所有的取消节点出队</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 说明当前节点不是 tail 节点</span></span><br><span class="line">        <span class="type">int</span> ws;</span><br><span class="line">        <span class="comment">// 条件一成立说明当前节点不是 head.next 节点</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            <span class="comment">// 判断前驱节点的状态是不是 -1，不成立说明前驱状态可能是 0 或者刚被其他线程取消排队了</span></span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             <span class="comment">// 如果状态不是 -1，设置前驱节点的状态为 -1</span></span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            <span class="comment">// 前驱节点的线程不为null</span></span><br><span class="line">            pred.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="comment">// 当前节点的后继节点是正常节点</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 把 前驱节点的后继节点 设置为 当前节点的后继节点，【从队列中删除了当前节点】</span></span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前节点是 head.next 节点，唤醒当前节点的后继节点</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><h5 id="基本使用-5"><a href="#基本使用-5" class="headerlink" title="基本使用"></a>基本使用</h5><p><code>public boolean tryLock()</code>：尝试获取锁，获取到返回 true，获取不到直接放弃，不进入阻塞队列</p>
<p><code>public boolean tryLock(long timeout, TimeUnit unit)</code>：在给定时间内获取锁，获取不到就退出</p>
<p>注意：tryLock 期间也可以被打断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;获取不到锁&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;被打断，获取不到锁&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;获取到锁&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程获取到锁&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程释放了锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h5><ul>
<li><p>成员变量：指定超时限制的阈值，小于该值的线程不会被挂起</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">spinForTimeoutThreshold</span> <span class="operator">=</span> <span class="number">1000L</span>;</span><br></pre></td></tr></table></figure>

<p>超时时间设置的小于该值，就会被禁止挂起，因为阻塞在唤醒的成本太高，不如选择自旋空转</p>
</li>
<li><p>tryLock()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;   </span><br><span class="line">    <span class="comment">// 只尝试一次</span></span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>tryLock(long timeout, TimeUnit unit)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())        </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();    </span><br><span class="line">    <span class="comment">// tryAcquire 尝试一次</span></span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;    </span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span> &#123;    </span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 获取最后期限的时间戳</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">// 计算还需等待的时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)	<span class="comment">//时间已到     </span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">// 如果 nanosTimeout 大于该值，才有阻塞的意义，否则直接自旋会好点</span></span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 【被打断会报异常】</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="哲学家就餐"><a href="#哲学家就餐" class="headerlink" title="哲学家就餐"></a>哲学家就餐</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Chopstick</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;1&quot;</span>);<span class="comment">//...</span></span><br><span class="line">    <span class="type">Chopstick</span> <span class="variable">c5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5).start();    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试获得左手筷子</span></span><br><span class="line">            <span class="keyword">if</span> (left.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 尝试获得右手筷子</span></span><br><span class="line">                    <span class="keyword">if</span> (right.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            right.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    left.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chopstick</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopstick</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><h5 id="基本使用-6"><a href="#基本使用-6" class="headerlink" title="基本使用"></a>基本使用</h5><p>synchronized 的条件变量，是当条件不满足时进入 WaitSet 等待；ReentrantLock 的条件变量比 synchronized 强大之处在于支持多个条件变量</p>
<p>ReentrantLock 类获取 Condition 对象：<code>public Condition newCondition()</code></p>
<p>Condition 类 API：</p>
<ul>
<li><code>void await()</code>：当前线程从运行状态进入等待状态，释放锁</li>
<li><code>void signal()</code>：唤醒一个等待在 Condition 上的线程，但是必须获得与该 Condition 相关的锁</li>
</ul>
<p>使用流程：</p>
<ul>
<li><p><strong>await &#x2F; signal 前需要获得锁</strong></p>
</li>
<li><p>await 执行后，会释放锁进入 ConditionObject 等待</p>
</li>
<li><p>await 的线程被唤醒去重新竞争 lock 锁</p>
</li>
<li><p><strong>线程在条件队列被打断会抛出中断异常</strong></p>
</li>
<li><p>竞争 lock 锁成功后，从 await 后继续执行</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;    </span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//创建一个新的条件变量</span></span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;进入等待&quot;</span>);</span><br><span class="line">            <span class="comment">//进入休息室等待</span></span><br><span class="line">            condition1.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;被唤醒了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;).start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//叫醒</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;            </span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//唤醒</span></span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h5><h6 id="await"><a href="#await" class="headerlink" title="await"></a>await</h6><p>总体流程是将 await 线程包装成 node 节点放入 ConditionObject 的条件队列，如果被唤醒就将 node 转移到 AQS 的执行阻塞队列，等待获取锁，<strong>每个 Condition 对象都包含一个等待队列</strong></p>
<ul>
<li><p>开始 Thread-0 持有锁，调用 await，线程进入 ConditionObject 等待，直到被唤醒或打断，调用 await 方法的线程都是持锁状态的，所以说逻辑里<strong>不存在并发</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     <span class="comment">// 判断当前线程是否是中断状态，是就直接给个中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 将调用 await 的线程包装成 Node，添加到条件队列并返回</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="comment">// 完全释放节点持有的锁，因为其他线程唤醒当前线程的前提是【持有锁】</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置打断模式为没有被打断，状态码为 0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果该节点还没有转移至 AQS 阻塞队列, park 阻塞，等待进入阻塞队列</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 如果被打断，退出等待队列，对应的 node 【也会被迁移到阻塞队列】尾部，状态设置为 0</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逻辑到这说明当前线程退出等待队列，进入【阻塞队列】</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试枪锁，释放了多少锁就【重新获取多少锁】，获取锁成功判断打断模式</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// node 在条件队列时 如果被外部线程中断唤醒，会加入到阻塞队列，但是并未设 nextWaiter = null</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 清理条件队列内所有已取消的 Node</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 条件成立说明挂起期间发生过中断</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 应用打断模式</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打断模式 - 在退出等待时重新设置打断状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REINTERRUPT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 打断模式 - 在退出等待时抛出异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROW_IE</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ReentrantLock-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F1.png"></p>
</li>
<li><p><strong>创建新的 Node 状态为 -2（Node.CONDITION）</strong>，关联 Thread-0，加入等待队列尾部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前条件队列的尾节点的引用，保存到局部变量 t 中</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">    <span class="comment">// 当前队列中不是空，并且节点的状态不是 CONDITION（-2），说明当前节点发生了中断</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 清理条件队列内所有已取消的 Node</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 清理完成重新获取 尾节点 的引用</span></span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个关联当前线程的新 node, 设置状态为 CONDITION(-2)，添加至队列尾部</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        firstWaiter = node;		<span class="comment">// 空队列直接放在队首【不用CAS因为执行线程是持锁线程，并发安全】</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;	<span class="comment">// 非空队列队尾追加</span></span><br><span class="line">    lastWaiter = node;			<span class="comment">// 更新队尾的引用</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清理条件队列内所有已取消（不是CONDITION）的 node，【链表删除的逻辑】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 从头节点开始遍历【FIFO】</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="comment">// 指向正常的 CONDITION 节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">trail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 等待队列不空</span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取当前节点的后继节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> t.nextWaiter;</span><br><span class="line">        <span class="comment">// 判断 t 节点是不是 CONDITION 节点，条件队列内不是 CONDITION 就不是正常的</span></span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123; </span><br><span class="line">            <span class="comment">// 不是正常节点，需要 t 与下一个节点断开</span></span><br><span class="line">            t.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 条件成立说明遍历到的节点还未碰到过正常节点</span></span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 更新 firstWaiter 指针为下个节点</span></span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 让上一个正常节点指向 当前取消节点的 下一个节点，【删除非正常的节点】</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="comment">// t 是尾节点了，更新 lastWaiter 指向最后一个正常节点</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// trail 指向的是正常节点 </span></span><br><span class="line">            trail = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把 t.next 赋值给 t，循环遍历</span></span><br><span class="line">        t = next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来 Thread-0 进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程可能重入，需要将 state 全部释放</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 完全释放锁是否成功，false 代表成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程所持有的 state 值总数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// release -&gt; tryRelease 解锁重入锁</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            <span class="comment">// 释放成功</span></span><br><span class="line">            failed = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 返回解锁的深度</span></span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 解锁失败抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 没有释放成功，将当前 node 设置为取消状态</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>fullyRelease 中会 unpark AQS 队列中的下一个节点竞争锁，假设 Thread-1 竞争成功</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ReentrantLock-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F2.png"></p>
</li>
<li><p>Thread-0 进入 isOnSyncQueue 逻辑判断节点<strong>是否移动到阻塞队列</strong>，没有就 park 阻塞 Thread-0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// node 的状态是 CONDITION，signal 方法是先修改状态再迁移，所以前驱节点为空证明还【没有完成迁移】</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 说明当前节点已经成功入队到阻塞队列，且当前节点后面已经有其它 node，因为条件队列的 next 指针为 null</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// 说明【可能在阻塞队列，但是是尾节点】</span></span><br><span class="line">    <span class="comment">// 从阻塞队列的尾节点开始向前【遍历查找 node】，如果查找到返回 true，查找不到返回 false</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>await 线程 park 后如果被 unpark 或者被打断，都会进入 checkInterruptWhileWaiting 判断线程是否被打断：<strong>在条件队列被打断的线程需要抛出异常</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// Thread.interrupted() 返回当前线程中断标记位，并且重置当前标记位 为 false</span></span><br><span class="line">    <span class="comment">// 如果被中断了，根据是否在条件队列被中断的，设置中断状态码</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?(transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个方法只有在线程是被打断唤醒时才会调用</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferAfterCancelledWait</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 条件成立说明当前node一定是在条件队列内，因为 signal 迁移节点到阻塞队列时，会将节点的状态修改为 0</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 把【中断唤醒的 node 加入到阻塞队列中】</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="comment">// 表示是在条件队列内被中断了，设置为 THROW_IE 为 -1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行到这里的情况：</span></span><br><span class="line">    <span class="comment">//1.当前node已经被外部线程调用 signal 方法将其迁移到 阻塞队列 内了</span></span><br><span class="line">    <span class="comment">//2.当前node正在被外部线程调用 signal 方法将其迁移至 阻塞队列 进行中状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前线程还没到阻塞队列，一直释放 CPU</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示当前节点被中断唤醒时不在条件队列了，设置为 REINTERRUPT 为 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后开始处理中断状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reportInterruptAfterWait</span><span class="params">(<span class="type">int</span> interruptMode)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 条件成立说明【在条件队列内发生过中断，此时 await 方法抛出中断异常】</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件成立说明【在条件队列外发生的中断，此时设置当前线程的中断标记位为 true】</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        <span class="comment">// 进行一次自己打断，产生中断的效果</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h6><ul>
<li><p>假设 Thread-1 要来唤醒 Thread-0，进入 ConditionObject 的 doSignal 流程，<strong>取得等待队列中第一个 Node</strong>，即 Thread-0 所在 Node，必须持有锁才能唤醒, 因此 doSignal 内线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 判断调用 signal 方法的线程是否是独占锁持有线程</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="comment">// 获取条件队列中第一个 Node</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="comment">// 不为空就将第该节点【迁移到阻塞队列】</span></span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒 - 【将没取消的第一个节点转移至 AQS 队列尾部】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 成立说明当前节点的下一个节点是 null，当前节点是尾节点了，队列中只有当前一个节点了</span></span><br><span class="line">        <span class="keyword">if</span> ((firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 将等待队列中的 Node 转移至 AQS 队列，不成功且还有节点则继续循环</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// signalAll() 会调用这个函数，唤醒所有的节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignalAll</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    <span class="comment">// 唤醒所有的节点，都放到阻塞队列中</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 transferForSignal，<strong>先将节点的 waitStatus 改为 0，然后加入 AQS 阻塞队列尾部</strong>，将 Thread-3 的 waitStatus 改为 -1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// CAS 修改当前节点的状态，修改为 0，因为当前节点马上要迁移到阻塞队列了</span></span><br><span class="line">    <span class="comment">// 如果状态已经不是 CONDITION, 说明线程被取消（await 释放全部锁失败）或者被中断（可打断 cancelAcquire）</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="comment">// 返回函数调用处继续寻找下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 【先改状态，再进行迁移】</span></span><br><span class="line">    <span class="comment">// 将当前 node 入阻塞队列，p 是当前节点在阻塞队列的【前驱节点】</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果前驱节点被取消或者不能设置状态为 Node.SIGNAL，就 unpark 取消当前节点线程的阻塞状态, </span></span><br><span class="line">    <span class="comment">// 让 thread-0 线程竞争锁，重新同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ReentrantLock-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F3.png"></p>
</li>
<li><p>Thread-1 释放锁，进入 unlock 流程</p>
</li>
</ul>
<hr>
<h3 id="ReadWrite"><a href="#ReadWrite" class="headerlink" title="ReadWrite"></a>ReadWrite</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>独占锁：指该锁一次只能被一个线程所持有，对 ReentrantLock 和 Synchronized 而言都是独占锁</p>
<p>共享锁：指该锁可以被多个线程锁持有</p>
<p>ReentrantReadWriteLock 其<strong>读锁是共享锁，写锁是独占锁</strong></p>
<p>作用：多个线程同时读一个资源类没有任何问题，为了满足并发量，读取共享资源应该同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</p>
<p>使用规则：</p>
<ul>
<li><p>加锁解锁格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">r.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	r.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读-读能共存、读-写不能共存、写-写不能共存</p>
</li>
<li><p>读锁不支持条件变量</p>
</li>
<li><p><strong>重入时升级不支持</strong>：持有读锁的情况下去获取写锁会导致获取写锁永久等待，需要先释放读，再去获得写</p>
</li>
<li><p><strong>重入时降级支持</strong>：持有写锁的情况下去获取读锁，造成只有当前线程会持有读锁，因为写锁会互斥其他的锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">w.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    r.lock();<span class="comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    	w.unlock();<span class="comment">// 要在写锁释放之前获取读锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">	r.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>构造方法：</p>
<ul>
<li><code>public ReentrantReadWriteLock()</code>：默认构造方法，非公平锁</li>
<li><code>public ReentrantReadWriteLock(boolean fair)</code>：true 为公平锁</li>
</ul>
<p>常用API：</p>
<ul>
<li><code>public ReentrantReadWriteLock.ReadLock readLock()</code>：返回读锁</li>
<li><code>public ReentrantReadWriteLock.WriteLock writeLock()</code>：返回写锁</li>
<li><code>public void lock()</code>：加锁</li>
<li><code>public void unlock()</code>：解锁</li>
<li><code>public boolean tryLock()</code>：尝试获取锁</li>
</ul>
<p>读读并发：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">r</span> <span class="operator">=</span> rw.readLock();</span><br><span class="line">    ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">w</span> <span class="operator">=</span> rw.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1 running &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 2 running &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="缓存应用"><a href="#缓存应用" class="headerlink" title="缓存应用"></a>缓存应用</h4><p>缓存更新时，是先清缓存还是先更新数据库</p>
<ul>
<li><p>先清缓存：可能造成刚清理缓存还没有更新数据库，线程直接查询了数据库更新过期数据到缓存</p>
</li>
<li><p>先更新据库：可能造成刚更新数据库，还没清空缓存就有线程从缓存拿到了旧数据</p>
</li>
<li><p>补充情况：查询线程 A 查询数据时恰好缓存数据由于时间到期失效，或是第一次查询</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ReentrantReadWriteLock缓存.png" style="zoom:80%;"></li>
</ul>
<p>可以使用读写锁进行操作</p>
<hr>
<h4 id="实现原理-5"><a href="#实现原理-5" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="成员属性-5"><a href="#成员属性-5" class="headerlink" title="成员属性"></a>成员属性</h5><p>读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个，原理与 ReentrantLock 加锁相比没有特殊之处，不同是<strong>写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位</strong></p>
<ul>
<li><p>读写锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;		</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造方法：默认是非公平锁，可以指定参数创建公平锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    <span class="comment">// true 为公平锁</span></span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    <span class="comment">// 这两个 lock 共享同一个 sync 实例，都是由 ReentrantReadWriteLock 的 sync 提供同步实现</span></span><br><span class="line">    readerLock = <span class="keyword">new</span> <span class="title class_">ReadLock</span>(<span class="built_in">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> <span class="title class_">WriteLock</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Sync 类的属性：</p>
<ul>
<li><p>统计变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来移位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_SHIFT</span>   <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 高16位的1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_UNIT</span>    <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="comment">// 65535，16个1，代表写锁的最大重入次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span>      <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 低16位掩码：0b 1111 1111 1111 1111，用来获取写锁重入的次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCLUSIVE_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取读写锁的次数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取读写锁的读锁分配的总次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sharedCount</span><span class="params">(<span class="type">int</span> c)</span>    &#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"><span class="comment">// 写锁（独占）锁的重入次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">exclusiveCount</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录读锁线程自己的持有读锁的数量（重入次数），因为 state 高16位记录的是全局范围内所有的读线程获取读锁的总量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HoldCounter</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">tid</span> <span class="operator">=</span> getThreadId(Thread.currentThread());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程安全的存放线程各自的 HoldCounter 对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalHoldCounter</span> <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;HoldCounter&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> HoldCounter <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HoldCounter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内部类实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前线程持有的可重入读锁的数量，计数为 0 时删除</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"><span class="comment">// 记录最后一个获取【读锁】线程的 HoldCounter 对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br></pre></td></tr></table></figure>
</li>
<li><p>首次获取锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个获取读锁的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">Thread</span> <span class="variable">firstReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 记录该线程持有的读锁次数（读锁重入次数）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> firstReaderHoldCount;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Sync 构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sync() &#123;</span><br><span class="line">    readHolds = <span class="keyword">new</span> <span class="title class_">ThreadLocalHoldCounter</span>();</span><br><span class="line">    <span class="comment">// 确保其他线程的数据可见性，state 是 volatile 修饰的变量，重写该值会将线程本地缓存数据【同步至主存】</span></span><br><span class="line">    setState(getState()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="加锁原理"><a href="#加锁原理" class="headerlink" title="加锁原理"></a>加锁原理</h5><ul>
<li><p>t1 线程：w.lock（<strong>写锁</strong>），成功上锁 state &#x3D; 0_1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lock()  -&gt; sync.acquire(1);</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试获得写锁，获得写锁失败，将当前线程关联到一个 Node 对象上, 模式为独占模式 </span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 获得低 16 位, 代表写锁的 state 计数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">    <span class="comment">// 说明有读锁或者写锁</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c != 0 and w == 0 表示有读锁，【读锁不能升级】，直接返回 false</span></span><br><span class="line">        <span class="comment">// w != 0 说明有写锁，写锁的拥有者不是自己，获取失败</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行到这里只有一种情况：【写锁重入】，所以下面几行代码不存在并发</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 写锁重入, 获得锁成功，没有并发，所以不使用 CAS</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// c == 0，说明没有任何锁，判断写锁是否该阻塞，是 false 就尝试获取锁，失败返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 获得锁成功，设置锁的持有线程为当前线程</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非公平锁 writerShouldBlock 总是返回 false, 无需阻塞</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 公平锁会检查 AQS 队列中是否有前驱节点, 没有(false)才去竞争</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>t2 r.lock（<strong>读锁</strong>），进入 tryAcquireShared 流程：</p>
<ul>
<li>返回 -1 表示失败</li>
<li>如果返回 0 表示成功</li>
<li>返回正数表示还有多少后继节点支持共享模式，读写锁返回 1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// tryAcquireShared 返回负数, 表示获取读锁失败</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试以共享模式获取</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// exclusiveCount(c) 代表低 16 位, 写锁的 state，成立说明有线程持有写锁</span></span><br><span class="line">    <span class="comment">// 写锁的持有者不是当前线程，则获取读锁失败，【写锁允许降级】</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 高 16 位，代表读锁的 state，共享锁分配出去的总次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);</span><br><span class="line">    <span class="comment">// 读锁是否应该阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;	r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;	<span class="comment">// 尝试增加读锁计数</span></span><br><span class="line">        <span class="comment">// 加锁成功</span></span><br><span class="line">        <span class="comment">// 加锁之前读锁为 0，说明当前线程是第一个读锁线程</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 第一个读锁线程是自己就发生了读锁重入</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// cachedHoldCounter 设置为当前线程的 holdCounter 对象，即最后一个获取读锁的线程</span></span><br><span class="line">            <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">            <span class="comment">// 说明还没设置 rh</span></span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                <span class="comment">// 获取当前线程的锁重入的对象，赋值给 cachedHoldCounter</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="comment">// 还没重入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            <span class="comment">// 重入 + 1</span></span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读锁加锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逻辑到这 应该阻塞，或者 cas 加锁失败</span></span><br><span class="line">    <span class="comment">// 会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非公平锁 readerShouldBlock 偏向写锁一些，看 AQS 阻塞队列中第一个节点是否是写锁，是则阻塞，反之不阻塞</span></span><br><span class="line"><span class="comment">// 防止一直有读锁线程，导致写锁线程饥饿</span></span><br><span class="line"><span class="comment">// true 则该阻塞, false 则不阻塞</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullTryAcquireShared</span><span class="params">(Thread current)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前读锁线程持有的读锁次数对象</span></span><br><span class="line">    <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 说明有线程持有写锁</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 写锁不是自己则获取锁失败</span></span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">// 条件成立说明当前线程是 firstReader，当前锁是读忙碌状态，而且当前线程也是读锁重入</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 最后一个读锁的 HoldCounter</span></span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="comment">// 说明当前线程也不是最后一个读锁</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        <span class="comment">// 获取当前线程的 HoldCounter</span></span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="comment">// 条件成立说明 HoldCounter 对象是上一步代码新建的</span></span><br><span class="line">                        <span class="comment">// 当前线程不是锁重入，在 readerShouldBlock() 返回 true 时需要去排队</span></span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            <span class="comment">// 防止内存泄漏</span></span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 越界判断</span></span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 读锁加锁，条件内的逻辑与 tryAcquireShared 相同</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取读锁失败，进入 sync.doAcquireShared(1) 流程开始阻塞，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为共享模式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前驱节点就头节点就去尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 再一次尝试获取读锁</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// r &gt;= 0 表示获取成功</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//【这里会设置自己为头节点，唤醒相连的后序的共享节点】</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 是否在获取读锁失败时阻塞      					 park 当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，shouldParkAfterFailedAcquire 内把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一次尝试 tryAcquireShared，不成功在 parkAndCheckInterrupt() 处 park</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ReentrantReadWriteLock加锁1.png" style="zoom: 80%;">
</li>
<li><p>这种状态下，假设又有 t3 r.lock，t4 w.lock，这期间 t1 仍然持有锁，就变成了下面的样子</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ReentrantReadWriteLock%E5%8A%A0%E9%94%812.png"></p>
</li>
</ul>
<hr>
<h5 id="解锁原理"><a href="#解锁原理" class="headerlink" title="解锁原理"></a>解锁原理</h5><ul>
<li><p>t1 w.unlock， 写锁解锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 头节点不为空并且不是等待状态不是 0，唤醒后继的非取消节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">// 因为可重入的原因, 写锁计数为 0, 才算释放成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>唤醒流程 sync.unparkSuccessor，这时 t2 在 doAcquireShared 的 parkAndCheckInterrupt() 处恢复运行，继续循环，执行 tryAcquireShared 成功则让读锁计数加一</p>
</li>
<li><p>接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点；还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒下一个节点，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行，<strong>唤醒连续的所有的共享节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; </span><br><span class="line">    <span class="comment">// 设置自己为 head 节点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">// propagate 表示有共享资源（例如共享读锁或信号量），为 0 就没有资源</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取下一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">// 如果当前是最后一个节点，或者下一个节点是【等待共享读锁的节点】</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            <span class="comment">// 唤醒后继节点</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">	<span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">// SIGNAL 唤醒后继</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 因为读锁共享，如果其它线程也在释放读锁，那么需要将 waitStatus 先改为 0</span></span><br><span class="line">            	<span class="comment">// 防止 unparkSuccessor 被多次执行</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                <span class="comment">// 唤醒后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果已经是 0 了，改为 -3，用来解决传播性</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 条件不成立说明被唤醒的节点非常积极，直接将自己设置为了新的 head，</span></span><br><span class="line">        <span class="comment">// 此时唤醒它的节点（前驱）执行 h == head 不成立，所以不会跳出循环，会继续唤醒新的 head 节点的后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ReentrantReadWriteLock解锁1.png" style="zoom: 67%;">
</li>
<li><p>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</p>
</li>
<li><p>t2 读锁解锁，进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但计数还不为零，t3 同样让计数减一，计数为零，进入doReleaseShared() 将头节点从 -1 改为 0 并唤醒下一个节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - SHARED_UNIT;</span><br><span class="line">        <span class="comment">// 读锁的计数不会影响其它获取读锁线程, 但会影响其它获取写锁线程，计数为 0 才是真正释放</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// 返回是否已经完全释放了 </span></span><br><span class="line">            <span class="type">return</span> <span class="variable">nextc</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是头节点的临节点，并且没有其他节点竞争，tryAcquire(1) 成功，修改头结点，流程结束</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ReentrantReadWriteLock解锁2.png" style="zoom: 67%;"></li>
</ul>
<hr>
<h4 id="Stamped"><a href="#Stamped" class="headerlink" title="Stamped"></a>Stamped</h4><p>StampedLock：读写锁，该类自 JDK 8 加入，是为了进一步优化读性能</p>
<p>特点：</p>
<ul>
<li><p>在使用读锁、写锁时都必须配合戳使用</p>
</li>
<li><p>StampedLock 不支持条件变量</p>
</li>
<li><p>StampedLock <strong>不支持重入</strong></p>
</li>
</ul>
<p>基本用法</p>
<ul>
<li><p>加解读锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">lock.unlockRead(stamp);			<span class="comment">// 类似于 unpark，解指定的锁</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>加解写锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure>
</li>
<li><p>乐观读，StampedLock 支持 <code>tryOptimisticRead()</code> 方法，读取完毕后做一次<strong>戳校验</strong>，如果校验通过，表示这期间没有其他线程的写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据一致性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 验戳</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;</span><br><span class="line">	<span class="comment">// 锁升级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>提供一个数据容器类内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法：</p>
<ul>
<li>读-读可以优化</li>
<li>读-写优化读，补加读锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">DataContainerStamped</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainerStamped</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    	dataContainer.read(<span class="number">1000</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.write(<span class="number">1000</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainerStamped</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> readTime)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; optimistic read locking&quot;</span> + stamp);</span><br><span class="line">        Thread.sleep(readTime);</span><br><span class="line">        <span class="comment">// 戳有效，直接返回数据</span></span><br><span class="line">        <span class="keyword">if</span> (lock.validate(stamp)) &#123;</span><br><span class="line">            Sout(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; optimistic read finish...&quot;</span> + stamp);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明其他线程更改了戳，需要锁升级了，从乐观读升级到读锁</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; updating to read lock&quot;</span> + stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp = lock.readLock();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; read lock&quot;</span> + stamp);</span><br><span class="line">            Thread.sleep(readTime);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; read finish...&quot;</span> + stamp);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; read unlock &quot;</span> +  stamp);</span><br><span class="line">            lock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> newData)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; write lock &quot;</span> + stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="built_in">this</span>.data = newData;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; write unlock &quot;</span> + stamp);</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="CountDown"><a href="#CountDown" class="headerlink" title="CountDown"></a>CountDown</h3><h4 id="基本使用-7"><a href="#基本使用-7" class="headerlink" title="基本使用"></a>基本使用</h4><p>CountDownLatch：计数器，用来进行线程同步协作，<strong>等待所有线程完成</strong></p>
<p>构造器：</p>
<ul>
<li><code>public CountDownLatch(int count)</code>：初始化唤醒需要的 down 几步</li>
</ul>
<p>常用API：</p>
<ul>
<li><code>public void await() </code>：让当前线程等待，必须 down 完初始化的数字才可以被唤醒，否则进入无限等待</li>
<li><code>public void countDown()</code>：计数器进行减 1（down 1）</li>
</ul>
<p>应用：同步等待多个 Rest 远程调用结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LOL 10人进入游戏倒计时</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    String[] all = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">finalJ</span> <span class="operator">=</span> j;<span class="comment">//常量</span></span><br><span class="line">        service.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">100</span>));	<span class="comment">//随机休眠</span></span><br><span class="line">                all[finalJ] = i + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">                System.out.print(<span class="string">&quot;\r&quot;</span> + Arrays.toString(all));	<span class="comment">// \r代表覆盖</span></span><br><span class="line">            &#125;</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    latch.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;\n游戏开始&quot;</span>);</span><br><span class="line">    service.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%, 100%]</span></span><br><span class="line"><span class="comment">游戏开始</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="实现原理-6"><a href="#实现原理-6" class="headerlink" title="实现原理"></a>实现原理</h4><p>阻塞等待：</p>
<ul>
<li><p>线程调用 await() 等待其他线程完成任务：支持打断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer#acquireSharedInterruptibly</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 判断线程是否被打断，抛出打断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 尝试获取共享锁，条件成立说明 state &gt; 0，此时线程入队阻塞等待，等待其他线程获取共享资源</span></span><br><span class="line">    <span class="comment">// 条件不成立说明 state = 0，此时不需要阻塞线程，直接结束函数调用</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CountDownLatch.Sync#tryAcquireShared</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程进入 AbstractQueuedSynchronizer#doAcquireSharedInterruptibly 函数阻塞挂起，等待 latch 变为 0：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 将调用latch.await()方法的线程 包装成 SHARED 类型的 node 加入到 AQS 的阻塞队列中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 前驱节点时头节点就可以尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 再次尝试获取锁，获取成功返回 1</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 获取锁成功，设置当前节点为 head 节点，并且向后传播</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 阻塞在这里</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 阻塞线程被中断后抛出异常，进入取消节点的逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取共享锁成功，进入唤醒阻塞队列中与头节点相连的 SHARED 模式的节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 将当前节点设置为新的 head 节点，前驱节点和持有线程置为 null</span></span><br><span class="line">    setHead(node);</span><br><span class="line">	<span class="comment">// propagate = 1，条件一成立</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> || (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取当前节点的后继节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">// 当前节点是尾节点时 next 为 null，或者后继节点是 SHARED 共享模式</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            <span class="comment">// 唤醒所有的等待共享锁的节点</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>计数减一：</p>
<ul>
<li><p>线程进入 countDown() 完成计数器减一（释放锁）的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试释放共享锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁成功开始唤醒阻塞节点</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新 state 值，每调用一次，state 值减一，当 state -1 正好为 0 时，返回 true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 条件成立说明前面【已经有线程触发唤醒操作】了，这里返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 计数器减一</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// 计数器为 0 时返回 true</span></span><br><span class="line">            <span class="type">return</span> <span class="variable">nextc</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>state &#x3D; 0 时，当前线程需要执行<strong>唤醒阻塞节点的任务</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 判断队列是否是空队列</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">// 头节点的状态为 signal，说明后继节点没有被唤醒过</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// cas 设置头节点的状态为 0，设置失败继续自旋</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 唤醒后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果有其他线程已经设置了头节点的状态，重新设置为 PROPAGATE 传播属性</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 条件不成立说明被唤醒的节点非常积极，直接将自己设置为了新的head，</span></span><br><span class="line">        <span class="comment">// 此时唤醒它的节点（前驱）执行 h == head 不成立，所以不会跳出循环，会继续唤醒新的 head 节点的后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><h4 id="基本使用-8"><a href="#基本使用-8" class="headerlink" title="基本使用"></a>基本使用</h4><p>CyclicBarrier：循环屏障，用来进行线程协作，等待线程满足某个计数，才能触发自己执行</p>
<p>常用方法：</p>
<ul>
<li><code>public CyclicBarrier(int parties, Runnable barrierAction)</code>：用于在线程到达屏障 parties 时，执行 barrierAction<ul>
<li>parties：代表多少个线程到达屏障开始触发线程任务</li>
<li>barrierAction：线程任务</li>
</ul>
</li>
<li><code>public int await()</code>：线程调用 await 方法通知 CyclicBarrier 本线程已经到达屏障</li>
</ul>
<p>与 CountDownLatch 的区别：CyclicBarrier 是可以重用的</p>
<p>应用：可以实现多线程中，某个任务在等待其他线程执行完毕以后触发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;task1 task2 finish...&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; <span class="comment">// 循环重用</span></span><br><span class="line">        service.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task1 begin...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                barrier.await();    <span class="comment">// 2 - 1 = 1</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        service.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task2 begin...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                barrier.await();    <span class="comment">// 1 - 1 = 0</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    service.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="实现原理-7"><a href="#实现原理-7" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="成员属性-6"><a href="#成员属性-6" class="headerlink" title="成员属性"></a>成员属性</h5><ul>
<li><p>全局锁：利用可重入锁实现的工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// barrier 实现是依赖于Condition条件队列，condition 条件队列必须依赖lock才能使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 线程挂起实现使用的 condition 队列，当前代所有线程到位，这个条件队列内的线程才会被唤醒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">trip</span> <span class="operator">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程数量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> parties;	<span class="comment">// 代表多少个线程到达屏障开始触发线程任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;			<span class="comment">// 表示当前“代”还有多少个线程未到位，初始值为 parties</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当前代中最后一个线程到位后要执行的事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br></pre></td></tr></table></figure>
</li>
<li><p>代：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示 barrier 对象当前 代</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Generation</span> <span class="variable">generation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Generation</span> &#123;</span><br><span class="line">    <span class="comment">// 表示当前“代”是否被打破，如果被打破再来到这一代的线程 就会直接抛出 BrokenException 异常</span></span><br><span class="line">    <span class="comment">// 且在这一代挂起的线程都会被唤醒，然后抛出 BrokerException 异常。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">broken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrie</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">    <span class="comment">// 因为小于等于 0 的 barrier 没有任何意义</span></span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.parties = parties;</span><br><span class="line">    <span class="built_in">this</span>.count = parties;</span><br><span class="line">    <span class="comment">// 可以为 null</span></span><br><span class="line">    <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-CyclicBarrier工作原理.png" style="zoom: 80%;">



<hr>
<h5 id="成员方法-5"><a href="#成员方法-5" class="headerlink" title="成员方法"></a>成员方法</h5><ul>
<li><p>await()：阻塞等待所有线程到位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// timed：表示当前调用await方法的线程是否指定了超时时长，如果 true 表示线程是响应超时的</span></span><br><span class="line"><span class="comment">// nanos：线程等待超时时长，单位是纳秒</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前代</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【如果当前代是已经被打破状态，则当前调用await方法的线程，直接抛出Broken异常】</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line">		<span class="comment">// 如果当前线程被中断了，则打破当前代，然后当前线程抛出中断异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// 设置当前代的状态为 broken 状态，唤醒在 trip 条件队列内的线程</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逻辑到这说明，当前线程中断状态是 false， 当前代的 broken 为 false（未打破状态）</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 假设 parties 给的是 5，那么index对应的值为 4,3,2,1,0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">        <span class="comment">// 条件成立说明当前线程是最后一个到达 barrier 的线程，【需要开启新代，唤醒阻塞线程】</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 栅栏任务启动标记</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 启动触发的任务</span></span><br><span class="line">                    command.run();</span><br><span class="line">                <span class="comment">// run()未抛出异常的话，启动标记设置为 true</span></span><br><span class="line">                ranAction = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 开启新的一代，这里会【唤醒所有的阻塞队列】</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="comment">// 返回 0 因为当前线程是此代最后一个到达的线程，index == 0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 如果 command.run() 执行抛出异常的话，会进入到这里</span></span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自旋，一直到条件满足、当前代被打破、线程被中断，等待超时</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 根据是否需要超时等待选择阻塞方法</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    <span class="comment">// 当前线程释放掉 lock，【进入到 trip 条件队列的尾部挂起自己】，等待被唤醒</span></span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// 被中断后来到这里的逻辑</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 当前代没有变化并且没有被打破</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; !g.broken) &#123;</span><br><span class="line">                    <span class="comment">// 打破屏障</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="comment">// node 节点在【条件队列】内收到中断信号时 会抛出中断异常</span></span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 等待过程中代变化了，完成一次自我打断</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 唤醒后的线程，【判断当前代已经被打破，线程唤醒后依次抛出 BrokenBarrier 异常】</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前线程挂起期间，最后一个线程到位了，然后触发了开启新的一代的逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">			<span class="comment">// 当前线程 trip 中等待超时，然后主动转移到阻塞队列</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="comment">// 抛出超时异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>breakBarrier()：打破 Barrier 屏障</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">breakBarrier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 将代中的 broken 设置为 true，表示这一代是被打破了，再来到这一代的线程，直接抛出异常</span></span><br><span class="line">    generation.broken = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 重置 count 为 parties</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 将在trip条件队列内挂起的线程全部唤醒，唤醒后的线程会检查当前是否是打破的，然后抛出异常</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>nextGeneration()：开启新的下一代 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">nextGeneration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 将在 trip 条件队列内挂起的线程全部唤醒</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// 重置 count 为 parties</span></span><br><span class="line">    count = parties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启新的一代，使用一个新的generation对象，表示新的一代，新的一代和上一代【没有任何关系】</span></span><br><span class="line">    generation = <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>参考视频：<a href="https://space.bilibili.com/457326371/">https://space.bilibili.com/457326371/</a></p>
<hr>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><h4 id="基本使用-9"><a href="#基本使用-9" class="headerlink" title="基本使用"></a>基本使用</h4><p>synchronized 可以起到锁的作用，但某个时间段内，只能有一个线程允许执行</p>
<p>Semaphore（信号量）用来限制能同时访问共享资源的线程上限，非重入锁</p>
<p>构造方法：</p>
<ul>
<li><code>public Semaphore(int permits)</code>：permits 表示许可线程的数量（state）</li>
<li><code>public Semaphore(int permits, boolean fair)</code>：fair 表示公平性，如果设为 true，下次执行的线程会是等待最久的线程</li>
</ul>
<p>常用API：</p>
<ul>
<li><code>public void acquire()</code>：表示获取许可</li>
<li><code>public void release()</code>：表示释放许可，acquire() 和 release() 方法之间的代码为同步代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建Semaphore对象</span></span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 获取许可</span></span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                sout(Thread.currentThread().getName() + <span class="string">&quot; running...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                sout(Thread.currentThread().getName() + <span class="string">&quot; end...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 4. 释放许可</span></span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="实现原理-8"><a href="#实现原理-8" class="headerlink" title="实现原理"></a>实现原理</h4><p>加锁流程：</p>
<ul>
<li><p>Semaphore 的 permits（state）为 3，这时 5 个线程来获取资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sync(<span class="type">int</span> permits) &#123;</span><br><span class="line">    setState(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设其中 Thread-1，Thread-2，Thread-4 CAS 竞争成功，permits 变为 0，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列park 阻塞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// acquire() -&gt; sync.acquireSharedInterruptibly(1)，可中断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 尝试获取通行证，获取成功返回 &gt;= 0的值</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 获取许可证失败，进入阻塞</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tryAcquireShared() -&gt; nonfairTryAcquireShared()</span></span><br><span class="line"><span class="comment">// 非公平，公平锁会在循环内 hasQueuedPredecessors()方法判断阻塞队列是否有临头节点(第二个节点)</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取 state ，state 这里【表示通行证】</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 计算当前线程获取通行证完成之后，通行证还剩余数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="comment">// 如果许可已经用完, 返回负数, 表示获取失败,</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 许可证足够分配的，如果 cas 重试成功, 返回正数, 表示获取成功</span></span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 将调用 Semaphore.aquire 方法的线程，包装成 node 加入到 AQS 的阻塞队列中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="comment">// 获取标记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 前驱节点是头节点可以再次获取许可</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 再次尝试获取许可，【返回剩余的许可证数量】</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 成功后本线程出队（AQS）, 所在 Node设置为 head</span></span><br><span class="line">                    <span class="comment">// r 表示【可用资源数】, 为 0 则不会继续传播</span></span><br><span class="line">                    setHeadAndPropagate(node, r); </span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 被打断后进入该逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;    </span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 设置自己为 head 节点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">// propagate 表示有【共享资源】（例如共享读锁或信号量）</span></span><br><span class="line">    <span class="comment">// head waitStatus == Node.SIGNAL 或 Node.PROPAGATE，doReleaseShared 函数中设置的</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">// 如果是最后一个节点或者是等待共享读锁的节点，做一次唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Semaphore%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B1.png"></p>
</li>
<li><p>这时 Thread-4 释放了 permits，状态如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// release() -&gt; releaseShared()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取当前锁资源的可用许可证数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">        <span class="comment">// 索引越界判断</span></span><br><span class="line">        <span class="keyword">if</span> (next &lt; current)            </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);        </span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="comment">// PROPAGATE 详解    </span></span><br><span class="line">    <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark	</span></span><br><span class="line">    <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-Semaphore%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B2.png"></p>
</li>
<li><p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，并且 unpark 接下来的共享状态的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</p>
</li>
</ul>
<hr>
<h4 id="PROPAGATE"><a href="#PROPAGATE" class="headerlink" title="PROPAGATE"></a>PROPAGATE</h4><p>假设存在某次循环中队列里排队的结点情况为 <code>head(-1) → t1(-1) → t2(0)</code>，存在将要释放信号量的 T3 和 T4，释放顺序为先 T3 后 T4</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老版本代码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;    </span><br><span class="line">    setHead(node);    </span><br><span class="line">    <span class="comment">// 有空闲资源    </span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> &amp;&amp; node.waitStatus != <span class="number">0</span>) &#123;    	</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;        </span><br><span class="line">        <span class="comment">// 下一个        </span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())            </span><br><span class="line">            unparkSuccessor(node);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常流程：</p>
<ul>
<li>T3 调用 releaseShared(1)，直接调用了 unparkSuccessor(head)，head.waitStatus 从 -1 变为 0</li>
<li>T1 由于 T3 释放信号量被唤醒，然后 T4 释放，唤醒 T2</li>
</ul>
<p>BUG 流程：</p>
<ul>
<li>T3 调用 releaseShared(1)，直接调用了 unparkSuccessor(head)，head.waitStatus 从 -1 变为 0</li>
<li>T1 由于 T3 释放信号量被唤醒，调用 tryAcquireShared，返回值为 0（获取锁成功，但没有剩余资源量）</li>
<li>T1 还没调用 setHeadAndPropagate 方法，T4 调用 releaseShared(1)，此时 head.waitStatus 为 0（此时读到的 head 和 1 中为同一个 head），不满足条件，因此不调用 unparkSuccessor(head)</li>
<li>T1 获取信号量成功，调用 setHeadAndPropagate(t1.node, 0) 时，因为不满足 propagate &gt; 0（剩余资源量 &#x3D;&#x3D; 0），从而不会唤醒后继结点， <strong>T2 线程得不到唤醒</strong></li>
</ul>
<p>更新后流程：</p>
<ul>
<li><p>T3 调用 releaseShared(1)，直接调用了 unparkSuccessor(head)，head.waitStatus 从 -1 变为 0</p>
</li>
<li><p>T1 由于 T3 释放信号量被唤醒，调用 tryAcquireShared，返回值为 0（获取锁成功，但没有剩余资源量）</p>
</li>
<li><p>T1 还没调用 setHeadAndPropagate 方法，T4 调用 releaseShared()，此时 head.waitStatus 为 0（此时读到的 head 和 1 中为同一个 head），调用 doReleaseShared() 将等待状态置为 <strong>PROPAGATE（-3）</strong></p>
</li>
<li><p>T1 获取信号量成功，调用 setHeadAndPropagate 时，读到 h.waitStatus &lt; 0，从而调用 doReleaseShared() 唤醒 T2</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;    </span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 设置自己为 head 节点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">// propagate 表示有共享资源（例如共享读锁或信号量）</span></span><br><span class="line">    <span class="comment">// head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">// 如果是最后一个节点或者是等待共享读锁的节点，做一次唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark	</span></span><br><span class="line">    <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE    </span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 防止 unparkSuccessor 被多次执行</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 唤醒后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果已经是 0 了，改为 -3，用来解决传播性</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>Exchanger：交换器，是一个用于线程间协作的工具类，用于进行线程间的数据交换</p>
<p>工作流程：两个线程通过 exchange 方法交换数据，如果第一个线程先执行 exchange() 方法，它会一直等待第二个线程也执行 exchange 方法，当两个线程都到达同步点时，这两个线程就可以交换数据</p>
<p>常用方法：</p>
<ul>
<li><code>public Exchanger()</code>：创建一个新的交换器</li>
<li><code>public V exchange(V x)</code>：等待另一个线程到达此交换点</li>
<li><code>public V exchange(V x, long timeout, TimeUnit unit)</code>：等待一定的时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建交换对象（信使）</span></span><br><span class="line">        Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadA</span>(exchanger).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadA</span>(exchanger).start();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Exchanger&lt;String&gt; <span class="title function_">exchanger</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadA</span><span class="params">(Exchanger&lt;String&gt; exchanger)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.exchanger = exchanger;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            sout(<span class="string">&quot;线程A，做好了礼物A，等待线程B送来的礼物B&quot;</span>);</span><br><span class="line">            <span class="comment">//如果等待了5s还没有交换就死亡（抛出异常）！</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> exchanger.exchange(<span class="string">&quot;礼物A&quot;</span>,<span class="number">5</span>,TimeUnit.SECONDS);</span><br><span class="line">            sout(<span class="string">&quot;线程A收到线程B的礼物：&quot;</span> + s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程A等待了5s，没有收到礼物,最终就执行结束了!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Exchanger&lt;String&gt; exchanger;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadB</span><span class="params">(Exchanger&lt;String&gt; exchanger)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.exchanger = exchanger;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sout(<span class="string">&quot;线程B,做好了礼物B,等待线程A送来的礼物A.....&quot;</span>);</span><br><span class="line">            <span class="comment">// 开始交换礼物。参数是送给其他线程的礼物!</span></span><br><span class="line">            sout(<span class="string">&quot;线程B收到线程A的礼物：&quot;</span> + exchanger.exchange(<span class="string">&quot;礼物B&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="并发包"><a href="#并发包" class="headerlink" title="并发包"></a>并发包</h2><h3 id="ConHashMap"><a href="#ConHashMap" class="headerlink" title="ConHashMap"></a>ConHashMap</h3><h4 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h4><h5 id="集合对比"><a href="#集合对比" class="headerlink" title="集合对比"></a>集合对比</h5><p>三种集合：</p>
<ul>
<li>HashMap 是线程不安全的，性能好</li>
<li>Hashtable 线程安全基于 synchronized，综合性能差，已经被淘汰</li>
<li>ConcurrentHashMap 保证了线程安全，综合性能较好，不止线程安全，而且效率高，性能好</li>
</ul>
<p>集合对比：</p>
<ol>
<li>Hashtable 继承 Dictionary 类，HashMap、ConcurrentHashMap 继承 AbstractMap，均实现 Map 接口</li>
<li>Hashtable 底层是数组 + 链表，JDK8 以后 HashMap 和 ConcurrentHashMap 底层是数组 + 链表 + 红黑树</li>
<li>HashMap 线程非安全，Hashtable 线程安全，Hashtable 的方法都加了 synchronized 关来确保线程同步</li>
<li>ConcurrentHashMap、Hashtable <strong>不允许 null 值</strong>，HashMap 允许 null 值</li>
<li>ConcurrentHashMap、HashMap 的初始容量为 16，Hashtable 初始容量为11，填充因子默认都是 0.75，两种 Map 扩容是当前容量翻倍：capacity * 2，Hashtable 扩容时是容量翻倍 + 1：capacity*2 + 1</li>
</ol>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/ConcurrentHashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="ConcurrentHashMap数据结构"></p>
<p>工作步骤：</p>
<ol>
<li><p>初始化，使用 cas 来保证并发安全，懒惰初始化 table</p>
</li>
<li><p>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将<strong>链表树化</strong>，树化过程会用 synchronized 锁住链表头</p>
<p>说明：锁住某个槽位的对象头，是一种很好的<strong>细粒度的加锁</strong>方式，类似 MySQL 中的行锁</p>
</li>
<li><p>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 bin 的尾部</p>
</li>
<li><p>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 会让 get 操作在新 table 进行搜索</p>
</li>
<li><p>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时其它竞争线程也不是无事可做，它们会帮助把其它 bin 进行扩容</p>
</li>
<li><p>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中，最后统计数量时累加</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求：多个线程同时往HashMap容器中存入数据会出现安全问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMapDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AddMapDataThread</span>().start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AddMapDataThread</span>().start();</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">1000</span> * <span class="number">5</span>);<span class="comment">//休息5秒，确保两个线程执行完毕</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Map大小：&quot;</span> + map.size());<span class="comment">//20万</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddMapDataThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">1000000</span> ; i++ )&#123;</span><br><span class="line">            ConcurrentHashMapDemo.map.put(<span class="string">&quot;键：&quot;</span>+i , <span class="string">&quot;值&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="并发死链"><a href="#并发死链" class="headerlink" title="并发死链"></a>并发死链</h5><p>JDK1.7 的 HashMap 采用的头插法（拉链法）进行节点的添加，HashMap 的扩容长度为原来的 2 倍</p>
<p>resize() 中节点（Entry）转移的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;<span class="comment">//得到新数组的长度   </span></span><br><span class="line">    <span class="comment">// 遍历整个数组对应下标下的链表，e代表一个节点</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;   </span><br><span class="line">        <span class="comment">// 当e == null时，则该链表遍历完了，继续遍历下一数组下标的链表 </span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123; </span><br><span class="line">            <span class="comment">// 先把e节点的下一节点存起来</span></span><br><span class="line">            Entry&lt;K,V&gt; next = e.next; </span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;              <span class="comment">//得到新的hash值</span></span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在新数组下得到新的数组下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);  </span><br><span class="line">             <span class="comment">// 将e的next指针指向新数组下标的位置</span></span><br><span class="line">            e.next = newTable[i];   </span><br><span class="line">            <span class="comment">// 将该数组下标的节点变为e节点</span></span><br><span class="line">            newTable[i] = e; </span><br><span class="line">            <span class="comment">// 遍历链表的下一节点</span></span><br><span class="line">            e = next;                                   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK 8 虽然将扩容算法做了调整，改用了尾插法，但仍不意味着能够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据）</p>
<p>B站视频解析：<a href="https://www.bilibili.com/video/BV1n541177Ea">https://www.bilibili.com/video/BV1n541177Ea</a></p>
<hr>
<h4 id="成员属性-7"><a href="#成员属性-7" class="headerlink" title="成员属性"></a>成员属性</h4><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><ul>
<li><p>存储数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
</li>
<li><p>散列表的长度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;	<span class="comment">// 最大长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;			<span class="comment">// 默认长度</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>并发级别，JDK7 遗留下来，1.8 中不代表并发级别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>负载因子，JDK1.8 的 ConcurrentHashMap 中是固定值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>阈值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;		<span class="comment">// 链表树化的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;	<span class="comment">// 红黑树转化为链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;	<span class="comment">// 当数组长度达到64且某个桶位中的链表长度超过8，才会真正树化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>扩容相关：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TRANSFER_STRIDE</span> <span class="operator">=</span> <span class="number">16</span>;	<span class="comment">// 线程迁移数据【最小步长】，控制线程迁移任务的最小区间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_BITS</span> <span class="operator">=</span> <span class="number">16</span>;			<span class="comment">// 用来计算扩容时生成的【标识戳】</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RESIZERS</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;<span class="comment">// 65535-1并发扩容最多线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_SHIFT</span> <span class="operator">=</span> <span class="number">32</span> - RESIZE_STAMP_BITS;		<span class="comment">// 扩容时使用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>节点哈希值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVED</span>     <span class="operator">=</span> -<span class="number">1</span>; 			<span class="comment">// 表示当前节点是 FWD 节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEBIN</span>   <span class="operator">=</span> -<span class="number">2</span>; 			<span class="comment">// 表示当前节点已经树化，且当前节点为 TreeBin 对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESERVED</span>  <span class="operator">=</span> -<span class="number">3</span>; 			<span class="comment">// 表示节点时临时节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_BITS</span> <span class="operator">=</span> <span class="number">0x7fffffff</span>; 	<span class="comment">// 正常节点的哈希值的可用的位数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>扩容过程：volatile 修饰保证多线程的可见性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩容过程中，会将扩容中的新 table 赋值给 nextTable 保持引用，扩容结束之后，这里会被设置为 null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="comment">// 记录扩容进度，所有线程都要从 0 - transferIndex 中分配区间任务，简单说就是老表转移到哪了，索引从高到低转移</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> transferIndex;</span><br></pre></td></tr></table></figure>
</li>
<li><p>累加统计：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LongAdder 中的 baseCount 未发生竞争时或者当前LongAdder处于加锁状态时，增量累到到 baseCount 中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> baseCount;</span><br><span class="line"><span class="comment">// LongAdder 中的 cellsBuzy，0 表示当前 LongAdder 对象无锁状态，1 表示当前 LongAdder 对象加锁状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br><span class="line"><span class="comment">// LongAdder 中的 cells 数组，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制变量：</p>
<p><strong>sizeCtl</strong> &lt; 0：</p>
<ul>
<li><p>-1 表示当前 table 正在初始化（有线程在创建 table 数组），当前线程需要自旋等待</p>
</li>
<li><p>其他负数表示当前 map 的 table 数组正在进行扩容，高 16 位表示扩容的标识戳；低 16 位表示 (1 + nThread) 当前参与并发扩容的线程数量 + 1</p>
</li>
</ul>
<p>sizeCtl &#x3D; 0，表示创建 table 数组时使用 DEFAULT_CAPACITY 为数组大小</p>
<p>sizeCtl &gt; 0：</p>
<ul>
<li>如果 table 未初始化，表示初始化大小</li>
<li>如果 table 已经初始化，表示下次扩容时的触发条件（阈值，元素个数，不是数组的长度）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;		<span class="comment">// volatile 保持可见性</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><ul>
<li><p>Node 节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Entry</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">// 节点哈希值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="comment">// 单向链表</span></span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>TreeBin 节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeBin</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">// 红黑树根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root;</span><br><span class="line">    <span class="comment">// 链表的头节点</span></span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">// 等待者线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> lockState;</span><br><span class="line">    <span class="comment">// 写锁状态 写锁是独占状态，以散列表来看，真正进入到 TreeBin 中的写线程同一时刻只有一个线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WRITER</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 等待者状态（写线程在等待），当 TreeBin 中有读线程目前正在读取数据时，写线程无法修改数据</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WAITER</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 读锁状态是共享，同一时刻可以有多个线程 同时进入到 TreeBi 对象中获取数据，每一个线程都给 lockState + 4</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">READER</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>TreeNode 节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;   <span class="comment">//双向链表</span></span><br><span class="line">    <span class="type">boolean</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ForwardingNode 节点：转移节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">// 持有扩容后新的哈希表的引用</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="comment">// ForwardingNode 节点的 hash 值设为 -1</span></span><br><span class="line">        <span class="built_in">super</span>(MOVED, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h5><ul>
<li><p>变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示sizeCtl属性在 ConcurrentHashMap 中内存偏移地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> SIZECTL;</span><br><span class="line"><span class="comment">// 表示transferIndex属性在 ConcurrentHashMap 中内存偏移地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> TRANSFERINDEX;</span><br><span class="line"><span class="comment">// 表示baseCount属性在 ConcurrentHashMap 中内存偏移地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> BASECOUNT;</span><br><span class="line"><span class="comment">// 表示cellsBusy属性在 ConcurrentHashMap 中内存偏移地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> CELLSBUSY;</span><br><span class="line"><span class="comment">// 表示cellValue属性在 CounterCell 中内存偏移地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> CELLVALUE;</span><br><span class="line"><span class="comment">// 表示数组第一个元素的偏移地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> ABASE;</span><br><span class="line"><span class="comment">// 用位移运算替代乘法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> ASHIFT;</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示数组单元所占用空间大小，scale 表示 Node[] 数组中每一个单元所占用空间大小，int 是 4 字节</span></span><br><span class="line"><span class="type">int</span> <span class="variable">scale</span> <span class="operator">=</span> U.arrayIndexScale(ak);</span><br><span class="line"><span class="comment">// 判断一个数是不是 2 的 n 次幂，比如 8：1000 &amp; 0111 = 0000</span></span><br><span class="line"><span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// numberOfLeadingZeros(n)：返回当前数值转换为二进制后，从高位到低位开始统计，看有多少个0连续在一起</span></span><br><span class="line"><span class="comment">// 8 → 1000 numberOfLeadingZeros(8) = 28</span></span><br><span class="line"><span class="comment">// 4 → 100 numberOfLeadingZeros(4) = 29   int 值就是占4个字节</span></span><br><span class="line">ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ASHIFT = 31 - 29 = 2 ，int 的大小就是 2 的 2 次方，获取次方数</span></span><br><span class="line"><span class="comment">// ABASE + （5 &lt;&lt; ASHIFT） 用位移运算替代了乘法，获取 arr[5] 的值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><p>无参构造， 散列表结构延迟初始化，默认的数组大小是 16：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有参构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 指定容量初始化</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               <span class="comment">// 假如传入的参数是 16，16 + 8 + 1 ，最后得到 32</span></span><br><span class="line">               <span class="comment">// 传入 12， 12 + 6 + 1 = 19，最后得到 32，尽可能的大，与 HashMap不一样</span></span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// sizeCtl &gt; 0，当目前 table 未初始化时，sizeCtl 表示初始化容量</span></span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap 部分详解了该函数，核心思想就是<strong>把最高位是 1 的位以及右边的位全部置 1</strong>，结果加 1 后就是 2 的 n 次幂</p>
</li>
<li><p>多个参数构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">// 初始容量小于并发级别</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)  </span><br><span class="line">        <span class="comment">// 把并发级别赋值给初始容量</span></span><br><span class="line">        initialCapacity = concurrencyLevel; </span><br><span class="line">	<span class="comment">// loadFactor 默认是 0.75</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">    <span class="comment">// sizeCtl &gt; 0，当目前 table 未初始化时，sizeCtl 表示初始化容量</span></span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>集合构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = DEFAULT_CAPACITY;	<span class="comment">// 默认16</span></span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试触发扩容</span></span><br><span class="line">    tryPresize(m.size());</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet())</span><br><span class="line">        putVal(e.getKey(), e.getValue(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryPresize</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="comment">// 扩容为大于 2 倍的最小的 2 的 n 次幂</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">    	tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="type">int</span> n;</span><br><span class="line">        <span class="comment">// 数组还未初始化，【一般是调用集合构造方法才会成立，put 后调用该方法都是不成立的】</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);<span class="comment">// 扩容阈值：n - 1/4 n</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;	<span class="comment">// 扩容阈值赋值给sizeCtl</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未达到扩容阈值或者数组长度已经大于最大长度</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 与 addCount 逻辑相同</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="成员方法-6"><a href="#成员方法-6" class="headerlink" title="成员方法"></a>成员方法</h4><h5 id="数据访存"><a href="#数据访存" class="headerlink" title="数据访存"></a>数据访存</h5><ul>
<li><p>tabAt()：获取数组某个槽位的<strong>头节点</strong>，类似于数组中的直接寻址 arr[i]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i 是数组索引</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// (i &lt;&lt; ASHIFT) + ABASE == ABASE + i * 4 （一个 int 占 4 个字节），这就相当于寻址，替代了乘法</span></span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>casTabAt()：指定数组索引位置修改原值为指定的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>setTabAt()：指定数组索引位置设置值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// 第三个参数 onlyIfAbsent 为 false 表示哈希表中存在相同的 key 时【用当前数据覆盖旧数据】</span></span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>putVal()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// 【ConcurrentHashMap 不能存放 null 值】</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 扰动运算，高低位都参与寻址运算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 表示当前 k-v 封装成 node 后插入到指定桶位后，在桶位中的所属链表的下标位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// tab 引用当前 map 的数组 table，开始自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// f 表示桶位的头节点，n 表示哈希表数组的长度</span></span><br><span class="line">        <span class="comment">// i 表示 key 通过寻址计算后得到的桶位下标，fh 表示桶位头结点的 hash 值</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【CASE1】：表示当前 map 中的 table 尚未初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//【延迟初始化】</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【CASE2】：i 表示 key 使用【寻址算法】得到 key 对应数组的下标位置，tabAt 获取指定桶位的头结点f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 对应的数组为 null 说明没有哈希冲突，直接新建节点添加到表中</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 【CASE3】：逻辑说明数组已经被初始化，并且当前 key 对应的位置不为 null</span></span><br><span class="line">        <span class="comment">// 条件成立表示当前桶位的头结点为 FWD 结点，表示目前 map 正处于扩容过程中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 当前线程【需要去帮助哈希表完成扩容】</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【CASE4】：哈希表没有在扩容，当前桶位可能是链表也可能是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当插入 key 存在时，会将旧值赋值给 oldVal 返回</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 【锁住当前 key 寻址的桶位的头节点】</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 这里重新获取一下桶的头节点有没有被修改，因为可能被其他线程修改过，这里是线程安全的获取</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 【头节点的哈希值大于 0 说明当前桶位是普通的链表节点】</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 当前的插入操作没出现重复的 key，追加到链表的末尾，binCount表示链表长度 -1</span></span><br><span class="line">                        <span class="comment">// 插入的key与链表中的某个元素的 key 一致，变成替换操作，binCount 表示第几个节点冲突</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 迭代循环当前桶位的链表，e 是每次循环处理节点，e 初始是头节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            <span class="comment">// 当前循环节点 key</span></span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// key 的哈希值与当前节点的哈希一致，并且 key 的值也相同</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">// 把当前节点的 value 赋值给 oldVal</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">// 允许覆盖</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    <span class="comment">// 新数据覆盖旧数据</span></span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="comment">// 跳出循环</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">// 如果下一个节点为空，把数据封装成节点插入链表尾部，【binCount 代表长度 - 1】</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 当前桶位头节点是红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 条件成立说明当前是链表或者红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 binCount &gt;= 8 表示处理的桶位一定是链表，说明长度是 9</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 树化</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计当前 table 一共有多少数据，判断是否达到扩容阈值标准，触发扩容</span></span><br><span class="line">    <span class="comment">// binCount = 0 表示当前桶位为 null，node 可以直接放入，2 表示当前桶位已经是红黑树</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>spread()：扰动函数</p>
<p>将 hashCode 无符号右移 16 位，高 16bit 和低 16bit 做异或，最后与 HASH_BITS 相与变成正数，<strong>与树化节点和转移节点区分</strong>，把高低位都利用起来减少哈希冲突，保证散列的均匀性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">spread</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS; <span class="comment">// 0111 1111 1111 1111 1111 1111 1111 1111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>initTable()：初始化数组，延迟初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    <span class="comment">// tab 引用 map.table，sc 引用 sizeCtl</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="comment">// table 尚未初始化，开始自旋</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// sc &lt; 0 说明 table 正在初始化或者正在扩容，当前线程可以释放 CPU 资源</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="comment">// sizeCtl 设置为 -1，相当于加锁，【设置的是 SIZECTL 位置的数据】，</span></span><br><span class="line">        <span class="comment">// 因为是 sizeCtl 是基本类型，不是引用类型，所以 sc 保存的是数据的副本</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 线程安全的逻辑，再进行一次判断</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// sc &gt; 0 创建 table 时使用 sc 为指定大小，否则使用 16 默认值</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="comment">// 创建哈希表数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 扩容阈值，n &gt;&gt;&gt; 2  =&gt; 等于 1/4 n ，n - (1/4)n = 3/4 n =&gt; 0.75 * n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 解锁，把下一次扩容的阈值赋值给 sizeCtl</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>treeifyBin()：树化方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="type">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 条件成立：【说明当前 table 数组长度未达到 64，此时不进行树化操作，进行扩容操作】</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            <span class="comment">// 当前容量的 2 倍</span></span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 条件成立：说明当前桶位有数据，且是普通 node 数据。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="literal">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 【树化加锁】</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="comment">// 条件成立：表示加锁没问题。</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;(e.hash, e.key, e.val,<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="literal">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>addCount()：添加计数，<strong>代表哈希表中的数据总量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">    <span class="comment">// 【上面这部分的逻辑就是 LongAdder 的累加逻辑】</span></span><br><span class="line">    CounterCell[] as; <span class="type">long</span> b, s;</span><br><span class="line">    <span class="comment">// 判断累加数组 cells 是否初始化，没有就去累加 base 域，累加失败进入条件内逻辑</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="type">long</span> v; <span class="type">int</span> m;</span><br><span class="line">        <span class="comment">// true 未竞争，false 发生竞争</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 判断 cells 是否被其他线程初始化</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 前面的条件为 fasle 说明 cells 被其他线程初始化，通过 hash 寻址对应的槽位</span></span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            <span class="comment">// 尝试去对应的槽位累加，累加失败进入 fullAddCount 进行重试或者扩容</span></span><br><span class="line">            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            <span class="comment">// 与 Striped64#longAccumulate 方法相同</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示当前桶位是 null，或者一个链表节点</span></span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)	</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    	<span class="comment">// 【获取当前散列表元素个数】，这是一个期望值</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表示一定 【是一个 put 操作调用的 addCount】</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 条件一：true 说明当前 sizeCtl 可能为一个负数表示正在扩容中，或者 sizeCtl 是一个正数，表示扩容阈值</span></span><br><span class="line">        <span class="comment">//        false 表示哈希表的数据的数量没达到扩容条件</span></span><br><span class="line">        <span class="comment">// 然后判断当前 table 数组是否初始化了，当前 table 长度是否小于最大值限制，就可以进行扩容</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 16 -&gt; 32 扩容 标识为：1000 0000 0001 1011，【负数，扩容批次唯一标识戳】</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 表示当前 table，【正在扩容】，sc 高 16 位是扩容标识戳，低 16 位是线程数 + 1</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 条件一：判断扩容标识戳是否一样，fasle 代表一样</span></span><br><span class="line">                <span class="comment">// 勘误两个条件：</span></span><br><span class="line">                <span class="comment">// 条件二是：sc == (rs &lt;&lt; 16 ) + 1，true 代表扩容完成，因为低16位是1代表没有线程扩容了</span></span><br><span class="line">                <span class="comment">// 条件三是：sc == (rs &lt;&lt; 16) + MAX_RESIZERS，判断是否已经超过最大允许的并发扩容线程数</span></span><br><span class="line">                <span class="comment">// 条件四：判断新表的引用是否是 null，代表扩容完成</span></span><br><span class="line">                <span class="comment">// 条件五：【扩容是从高位到低位转移】，transferIndex &lt; 0 说明没有区间需要扩容了</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 设置当前线程参与到扩容任务中，将 sc 低 16 位值加 1，表示多一个线程参与扩容</span></span><br><span class="line">                <span class="comment">// 设置失败其他线程或者 transfer 内部修改了 sizeCtl 值</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">//【协助扩容线程】，持有nextTable参数</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 逻辑到这说明当前线程是触发扩容的第一个线程，线程数量 + 2</span></span><br><span class="line">            <span class="comment">// 1000 0000 0001 1011 0000 0000 0000 0000 +2 =&gt; 1000 0000 0001 1011 0000 0000 0000 0010</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,(rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">//【触发扩容条件的线程】，不持有 nextTable，初始线程会新建 nextTable</span></span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>resizeStamp()：扩容标识符，<strong>每次扩容都会产生一个，不是每个线程都产生</strong>，16 扩容到 32 产生一个，32 扩容到 64 产生一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容的标识符</span></span><br><span class="line"><span class="comment"> * 16 -&gt; 32 从16扩容到32</span></span><br><span class="line"><span class="comment"> * numberOfLeadingZeros(16) =&gt; 1 0000 =&gt; 32 - 5 = 27 =&gt; 0000 0000 0001 1011</span></span><br><span class="line"><span class="comment"> * (1 &lt;&lt; (RESIZE_STAMP_BITS - 1)) =&gt; 1000 0000 0000 0000 =&gt; 32768</span></span><br><span class="line"><span class="comment"> * ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * 0000 0000 0001 1011</span></span><br><span class="line"><span class="comment"> * 1000 0000 0000 0000</span></span><br><span class="line"><span class="comment"> * 1000 0000 0001 1011</span></span><br><span class="line"><span class="comment"> * 永远是负数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">resizeStamp</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 或运算</span></span><br><span class="line">    <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>)); <span class="comment">// (16 -1 = 15)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a>扩容方法</h5><p>扩容机制：</p>
<ul>
<li>当链表中元素个数超过 8 个，数组的大小还未超过 64 时，此时进行数组的扩容，如果超过则将链表转化成红黑树</li>
<li>put 数据后调用 addCount() 方法，判断当前哈希表的容量超过阈值 sizeCtl，超过进行扩容</li>
<li>增删改线程发现其他线程正在扩容，帮其扩容</li>
</ul>
<p>常见方法：</p>
<ul>
<li><p>transfer()：数据转移到新表中，完成扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="comment">// n 表示扩容之前 table 数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">    <span class="comment">// stride 表示分配给线程任务的步长，默认就是 16 </span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE;</span><br><span class="line">    <span class="comment">// 如果当前线程为触发本次扩容的线程，需要做一些扩容准备工作，【协助线程不做这一步】</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个容量是之前【二倍的 table 数组】</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把新表赋值给对象属性 nextTable，方便其他线程获取新表</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// 记录迁移数据整体位置的一个标记，transferIndex 计数从1开始不是 0，所以这里是长度，不是长度-1</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">    <span class="comment">// 当某个桶位数据处理完毕后，将此桶位设置为 fwd 节点，其它写线程或读线程看到后，可以从中获取到新表</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">// 推进标记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 完成标记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// i 表示分配给当前线程任务，执行到的桶位</span></span><br><span class="line">    <span class="comment">// bound 表示分配给当前线程任务的下界限制，因为是倒序迁移，16 迁移完 迁移 15，15完成去迁移14</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 给当前线程【分配任务区间】</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="comment">// 分配任务的开始下标，分配任务的结束下标</span></span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">         </span><br><span class="line">            <span class="comment">// --i 让当前线程处理下一个索引，true说明当前的迁移任务尚未完成，false说明线程已经完成或者还未分配</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 迁移的开始下标，小于0说明没有区间需要迁移了，设置当前线程的 i 变量为 -1 跳出循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 逻辑到这说明还有区间需要分配，然后给当前线程分配任务，</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      <span class="comment">// 判断区间是否还够一个步长，不够就全部分配</span></span><br><span class="line">                      nextBound = (nextIndex &gt; stride ? nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">// 当前线程的结束下标</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                <span class="comment">// 当前线程的开始下标，上一个线程结束的下标的下一个索引就是这个线程开始的下标</span></span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 任务分配结束，跳出循环执行迁移操作</span></span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【分配完成，开始数据迁移操作】</span></span><br><span class="line">        <span class="comment">// 【CASE1】：i &lt; 0 成立表示当前线程未分配到任务，或者任务执行完了</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="type">int</span> sc;</span><br><span class="line">            <span class="comment">// 如果迁移完成</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="literal">null</span>;	<span class="comment">// help GC</span></span><br><span class="line">                table = nextTab;	<span class="comment">// 新表赋值给当前对象</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);<span class="comment">// 扩容阈值为 2n - n/2 = 3n/2 = 0.75*(2n)</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前线程完成了分配的任务区间，可以退出，先把 sizeCtl 赋值给 sc 保留</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 判断当前线程是不是最后一个线程，不是的话直接 return，</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">// 所以最后一个线程退出的时候，sizeCtl 的低 16 位为 1</span></span><br><span class="line">                finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 【这里表示最后一个线程需要重新检查一遍是否有漏掉的区间】</span></span><br><span class="line">                i = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【CASE2】：当前桶位未存放数据，只需要将此处设置为 fwd 节点即可。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">        <span class="comment">// 【CASE3】：说明当前桶位已经迁移过了，当前线程不用再处理了，直接处理下一个桶位即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="literal">true</span>; </span><br><span class="line">        <span class="comment">// 【CASE4】：当前桶位有数据，而且 node 节点不是 fwd 节点，说明这些数据需要迁移</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 【锁住头节点】</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 二次检查，防止头节点已经被修改了，因为这里才是线程安全的访问</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 【迁移数据的逻辑，和 HashMap 相似】</span></span><br><span class="line">                        </span><br><span class="line">                    <span class="comment">// ln 表示低位链表引用</span></span><br><span class="line">                    <span class="comment">// hn 表示高位链表引用</span></span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">// 哈希 &gt; 0 表示当前桶位是链表桶位</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 和 HashMap 的处理方式一致，与老数组长度相与，16 是 10000</span></span><br><span class="line">                        <span class="comment">// 判断对应的 1 的位置上是 0 或 1 分成高低位链表</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="comment">// 遍历链表，寻找【逆序看】最长的对应位相同的链表，看下面的图更好的理解</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="comment">// 将当前节点的哈希 与 n</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                            <span class="comment">// 如果当前值与前面节点的值 对应位 不同，则修改 runBit，把 lastRun 指向当前节点</span></span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 判断筛选出的链表是低位的还是高位的</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;	<span class="comment">// ln 指向该链表</span></span><br><span class="line">                            hn = <span class="literal">null</span>;		<span class="comment">// hn 为 null</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 说明 lastRun 引用的链表为高位链表，就让 hn 指向高位链表头节点</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 从头开始遍历所有的链表节点，迭代到 p == lastRun 节点跳出循环</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                <span class="comment">// 【头插法】，从右往左看，首先 ln 指向的是上一个节点，</span></span><br><span class="line">                                <span class="comment">// 所以这次新建的节点的 next 指向上一个节点，然后更新 ln 的引用</span></span><br><span class="line">                                ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 高低位链设置到新表中的指定位置</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 老表中的该桶位设置为 fwd 节点</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 条件成立：表示当前桶位是 红黑树结点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">// 迭代 TreeBin 中的双向链表，从头结点至尾节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="comment">// 迭代的当前元素的 hash</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="comment">// 条件成立表示当前循环节点属于低位链节点</span></span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//【尾插法】</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                <span class="comment">// loTail 指向尾节点</span></span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 拆成的高位低位两个链，【判断是否需要需要转化为链表】，反之保持树化</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                        (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                        (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表处理的 LastRun 机制，<strong>可以减少节点的创建</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ConcurrentHashMap-LastRun%E6%9C%BA%E5%88%B6.png"></p>
</li>
<li><p>helpTransfer()：帮助扩容机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="comment">// 数组不为空，节点是转发节点，获取转发节点指向的新表开始协助主线程扩容</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 扩容标识戳</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length);</span><br><span class="line">        <span class="comment">// 判断数据迁移是否完成，迁移完成会把 新表赋值给 nextTable 属性</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 设置扩容线程数量 + 1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 协助扩容</span></span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><p>ConcurrentHashMap 使用 get()  方法获取指定 key 的数据</p>
<ul>
<li><p>get()：获取指定数据的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// 扰动运算，获取 key 的哈希值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 判断当前哈希表的数组是否初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// 如果 table 已经初始化，进行【哈希寻址】，映射到数组对应索引处，获取该索引处的头节点</span></span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 对比头结点 hash 与查询 key 的 hash 是否一致</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="comment">// 进行值的判断，如果成功就说明当前节点就是要查询的节点，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前槽位的【哈希值小于0】说明是红黑树节点或者是正在扩容的 fwd 节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 当前桶位是【链表】，循环遍历查找</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ForwardingNode#find：转移节点的查找方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取新表的引用</span></span><br><span class="line">    outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;)  &#123;</span><br><span class="line">        <span class="comment">// e 表示在扩容而创建新表使用寻址算法得到的桶位头结点，n 表示为扩容而创建的新表的长度</span></span><br><span class="line">        Node&lt;K,V&gt; e; <span class="type">int</span> n;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> || tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 在新表中重新定位 hash 对应的头结点，表示在 oldTable 中对应的桶位在迁移之前就是 null</span></span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> eh; K ek;</span><br><span class="line">            <span class="comment">// 【哈希相同值也相同】，表示新表当前命中桶位中的数据，即为查询想要数据</span></span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp; ((ek = e.key) == k || (ek != <span class="literal">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// eh &lt; 0 说明当前新表中该索引的头节点是 TreeBin 类型，或者是 FWD 类型</span></span><br><span class="line">            <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 在并发很大的情况下新扩容的表还没完成可能【再次扩容】，在此方法处再次拿到 FWD 类型</span></span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</span><br><span class="line">                    <span class="comment">// 继续获取新的 fwd 指向的新数组的地址，递归了</span></span><br><span class="line">                    tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class="line">                    <span class="keyword">continue</span> outer;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 说明此桶位为 TreeBin 节点，使用TreeBin.find 查找红黑树中相应节点。</span></span><br><span class="line">                    <span class="keyword">return</span> e.find(h, k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 逻辑到这说明当前桶位是链表，将当前元素指向链表的下一个元素，判断当前元素的下一个位置是否为空</span></span><br><span class="line">            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 条件成立说明迭代到链表末尾，【未找到对应的数据，返回 null】</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h5><ul>
<li><p>remove()：删除指定元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>replaceNode()：替代指定的元素，会协助扩容，<strong>增删改（写）都会协助扩容，查询（读）操作不会</strong>，因为读操作不涉及加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算 key 扰动运算后的 hash</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 开始自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【CASE1】：table 还未初始化或者哈希寻址的数组索引处为 null，直接结束自旋，返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span> || (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 【CASE2】：条件成立说明当前 table 正在扩容，【当前是个写操作，所以当前线程需要协助 table 完成扩容】</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">// 【CASE3】：当前桶位可能是 链表 也可能是 红黑树 </span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 保留替换之前数据引用</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 校验标记</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">validated</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 【加锁当前桶位头结点】，加锁成功之后会进入代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 双重检查</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 说明当前节点是链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        validated = <span class="literal">true</span>;</span><br><span class="line">                        <span class="comment">//遍历所有的节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f, pred = <span class="literal">null</span>;;) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// hash 和值都相同，定位到了具体的节点</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">// 当前节点的value</span></span><br><span class="line">                                <span class="type">V</span> <span class="variable">ev</span> <span class="operator">=</span> e.val;</span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="literal">null</span> || cv == ev ||</span><br><span class="line">                                    (ev != <span class="literal">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    <span class="comment">// 将当前节点的值 赋值给 oldVal 后续返回会用到</span></span><br><span class="line">                                    oldVal = ev;</span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="literal">null</span>)		<span class="comment">// 条件成立说明是替换操作</span></span><br><span class="line">                                        e.val = value;	</span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="literal">null</span>)	<span class="comment">// 非头节点删除操作，断开链表</span></span><br><span class="line">                                        pred.next = e.next;	</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        <span class="comment">// 说明当前节点即为头结点，将桶位头节点设置为以前头节点的下一个节点</span></span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 说明是红黑树节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        validated = <span class="literal">true</span>;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(hash, key, <span class="literal">null</span>)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="keyword">if</span> (cv == <span class="literal">null</span> || cv == pv ||</span><br><span class="line">                                (pv != <span class="literal">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                oldVal = pv;</span><br><span class="line">                                <span class="comment">// 条件成立说明替换操作</span></span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="literal">null</span>)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                                <span class="comment">// 删除操作</span></span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 其他线程修改过桶位头结点时，当前线程 sync 头结点锁错对象，validated 为 false，会进入下次 for 自旋</span></span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 替换的值为 null，【说明当前是一次删除操作，更新当前元素个数计数器】</span></span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>参考视频：<a href="https://space.bilibili.com/457326371/">https://space.bilibili.com/457326371/</a></p>
<hr>
<h4 id="JDK7原理"><a href="#JDK7原理" class="headerlink" title="JDK7原理"></a>JDK7原理</h4><p>ConcurrentHashMap 对锁粒度进行了优化，<strong>分段锁技术</strong>，将整张表分成了多个数组（Segment），每个数组又是一个类似 HashMap 数组的结构。允许多个修改操作并发进行，Segment 是一种可重入锁，继承 ReentrantLock，并发时锁住的是每个 Segment，其他 Segment 还是可以操作的，这样不同 Segment 之间就可以实现并发，大大提高效率。</p>
<p>底层结构： <strong>Segment 数组 + HashEntry 数组 + 链表</strong>（数组 + 链表是 HashMap 的结构）</p>
<ul>
<li><p>优点：如果多个线程访问不同的 segment，实际是没有冲突的，这与 JDK8 中是类似的</p>
</li>
<li><p>缺点：Segments 数组默认大小为16，这个容量初始化指定后就不能改变了，并且不是懒惰初始化</p>
<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ConcurrentHashMap">https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ConcurrentHashMap</a> 1.7底层结构.png)</p>
</li>
</ul>
<hr>
<h3 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h3><h4 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h4><p>CopyOnWriteArrayList 采用了<strong>写入时拷贝</strong>的思想，增删改操作会将底层数组拷贝一份，在新数组上执行操作，不影响其它线程的<strong>并发读，读写分离</strong></p>
<p>CopyOnWriteArraySet 底层对 CopyOnWriteArrayList 进行了包装，装饰器模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">    al = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>存储结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;	<span class="comment">// volatile 保证了读写线程之间的可见性</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>全局锁：保证线程的执行安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增数据：需要加锁，<strong>创建新的数组操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁，保证线程安全</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取旧的数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">// 【拷贝新的数组（这里是比较耗时的操作，但不影响其它读线程）】</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 添加新元素</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 替换旧的数组，【这个操作以后，其他线程获取数组就是获取的新数组了】</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读操作：不加锁，<strong>在原数组上操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适合读多写少的应用场景</p>
</li>
<li><p>迭代器：CopyOnWriteArrayList 在返回迭代器时，<strong>创建一个内部数组当前的快照（引用）</strong>，即使其他线程替换了原始数组，迭代器遍历的快照依然引用的是创建快照时的数组，所以这种实现方式也存在一定的数据延迟性，对其他线程并行添加的数据不可见</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取到数组引用，整个遍历的过程该数组都不会变，一直引用的都是老数组，</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">COWIterator</span>&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器会创建一个底层array的快照，故主类的修改不影响该快照</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">COWIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 内部数组快照</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">COWIterator</span><span class="params">(Object[] elements, <span class="type">int</span> initialCursor)</span> &#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        <span class="comment">// 数组的引用在迭代过程不会改变</span></span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【不支持写操作】，因为是在快照上操作，无法同步回去</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h4><p>数据一致性就是读到最新更新的数据：</p>
<ul>
<li><p>强一致性：当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值</p>
</li>
<li><p>弱一致性：系统并不保证进程或者线程的访问都会返回最新的更新过的值，也不会承诺多久之后可以读到</p>
</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-CopyOnWriteArrayList弱一致性.png" style="zoom:80%;">

<table>
<thead>
<tr>
<th>时间点</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Thread-0 getArray()</td>
</tr>
<tr>
<td>2</td>
<td>Thread-1 getArray()</td>
</tr>
<tr>
<td>3</td>
<td>Thread-1 setArray(arrayCopy)</td>
</tr>
<tr>
<td>4</td>
<td>Thread-0 array[index]</td>
</tr>
</tbody></table>
<p>Thread-0 读到了脏数据</p>
<p>不一定弱一致性就不好</p>
<ul>
<li>数据库的<strong>事务隔离级别</strong>就是弱一致性的表现</li>
<li>并发高和一致性是矛盾的，需要权衡</li>
</ul>
<hr>
<h4 id="安全失败"><a href="#安全失败" class="headerlink" title="安全失败"></a>安全失败</h4><p>在 java.util 包的集合类就都是快速失败的，而 java.util.concurrent 包下的类都是安全失败</p>
<ul>
<li><p>快速失败：在 A 线程使用<strong>迭代器</strong>对集合进行遍历的过程中，此时 B 线程对集合进行修改（增删改），或者 A 线程在遍历过程中对集合进行修改，都会导致 A 线程抛出 ConcurrentModificationException 异常</p>
<ul>
<li>AbstractList 类中的成员变量 modCount，用来记录 List 结构发生变化的次数，<strong>结构发生变化</strong>是指添加或者删除至少一个元素的操作，或者是调整内部数组的大小，仅仅设置元素的值不算结构发生变化</li>
<li>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了抛出 CME 异常</li>
</ul>
</li>
<li><p>安全失败：采用安全失败机制的集合容器，在<strong>迭代器</strong>遍历时直接在原集合数组内容上访问，但其他线程的增删改都会新建数组进行修改，就算修改了集合底层的数组容器，迭代器依然引用着以前的数组（<strong>快照思想</strong>），所以不会出现异常</p>
<p>ConcurrentHashMap 不会出现并发时的迭代异常，因为在迭代过程中 CHM 的迭代器并没有判断结构的变化，迭代器还可以根据迭代的节点状态去寻找并发扩容时的新表进行迭代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ConcurrentHashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>();</span><br><span class="line"><span class="comment">// KeyIterator</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> map.keySet().iterator();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Traverser(Node&lt;K,V&gt;[] tab, <span class="type">int</span> size, <span class="type">int</span> index, <span class="type">int</span> limit) &#123;</span><br><span class="line">    <span class="comment">// 引用还是原来集合的 Node 数组，所以其他线程对数据的修改是可见的</span></span><br><span class="line">    <span class="built_in">this</span>.tab = tab;</span><br><span class="line">    <span class="built_in">this</span>.baseSize = size;</span><br><span class="line">    <span class="built_in">this</span>.baseIndex = <span class="built_in">this</span>.index = index;</span><br><span class="line">    <span class="built_in">this</span>.baseLimit = limit;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123; <span class="keyword">return</span> next != <span class="literal">null</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    <span class="keyword">if</span> ((p = next) == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> p.key;</span><br><span class="line">    lastReturned = p;</span><br><span class="line">    <span class="comment">// 在方法中进行下一个节点的获取，会进行槽位头节点的状态判断</span></span><br><span class="line">    advance();</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>Collections类是用来操作集合的工具类，提供了集合转换成线程安全的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">synchronizedCollection</span><span class="params">(Collection&lt;T&gt; c)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SynchronizedCollection</span>&lt;&gt;(c);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SynchronizedMap</span>&lt;&gt;(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码：底层也是对方法进行加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.add(e);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="SkipListMap"><a href="#SkipListMap" class="headerlink" title="SkipListMap"></a>SkipListMap</h3><h4 id="底层结构-1"><a href="#底层结构-1" class="headerlink" title="底层结构"></a>底层结构</h4><p>跳表 SkipList 是一个<strong>有序的链表</strong>，默认升序，底层是链表加多级索引的结构。跳表可以对元素进行快速查询，类似于平衡树，是一种利用空间换时间的算法</p>
<p>对于单链表，即使链表是有序的，如果查找数据也只能从头到尾遍历链表，所以采用链表上建索引的方式提高效率，跳表的查询时间复杂度是 **O(logn)**，空间复杂度 O(n)</p>
<p>ConcurrentSkipListMap 提供了一种线程安全的并发访问的排序映射表，内部是跳表结构实现，通过 CAS + volatile 保证线程安全</p>
<p>平衡树和跳表的区别：</p>
<ul>
<li>对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整；而对跳表的插入和删除，<strong>只需要对整个结构的局部进行操作</strong></li>
<li>在高并发的情况下，保证整个平衡树的线程安全需要一个全局锁；对于跳表则只需要部分锁，拥有更好的性能</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ConcurrentSkipListMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p>
<p>BaseHeader 存储数据，headIndex 存储索引，纵向上<strong>所有索引都指向链表最下面的节点</strong></p>
<hr>
<h4 id="成员变量-2"><a href="#成员变量-2" class="headerlink" title="成员变量"></a>成员变量</h4><ul>
<li><p>标识索引头节点位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">BASE_HEADER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>跳表的顶层索引</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> HeadIndex&lt;K,V&gt; head;</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较器，为 null 则使用自然排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Node 节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt;&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;  				<span class="comment">// key 是 final 的, 说明节点一旦定下来, 除了删除, 一般不会改动 key</span></span><br><span class="line">    <span class="keyword">volatile</span> Object value; 		<span class="comment">// 对应的 value</span></span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K, V&gt; next; 	<span class="comment">// 下一个节点，单向链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引节点 Index，只有向下和向右的指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Index</span>&lt;K, V&gt;&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K, V&gt; node; 		<span class="comment">// 索引指向的节点，每个都会指向数据节点</span></span><br><span class="line">    <span class="keyword">final</span> Index&lt;K, V&gt; down; 	<span class="comment">// 下边level层的Index，分层索引</span></span><br><span class="line">    <span class="keyword">volatile</span> Index&lt;K, V&gt; right; <span class="comment">// 右边的Index，单向</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 index 本身和 succ 之间插入一个新的节点 newSucc</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">link</span><span class="params">(Index&lt;K, V&gt; succ, Index&lt;K, V&gt; newSucc)</span>&#123;</span><br><span class="line">        Node&lt;K, V&gt; n = node;</span><br><span class="line">        newSucc.right = succ;</span><br><span class="line">        <span class="comment">// 把当前节点的右指针从 succ 改为 newSucc</span></span><br><span class="line">        <span class="keyword">return</span> n.value != <span class="literal">null</span> &amp;&amp; casRight(succ, newSucc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开当前节点和 succ 节点，将当前的节点 index 设置其的 right 为 succ.right，就是把 succ 删除</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">unlink</span><span class="params">(Index&lt;K, V&gt; succ)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.value != <span class="literal">null</span> &amp;&amp; casRight(succ, succ.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>头索引节点 HeadIndex</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HeadIndex</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Index</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> level;	<span class="comment">// 表示索引层级，所有的 HeadIndex 都指向同一个 Base_header 节点</span></span><br><span class="line">    HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, <span class="type">int</span> level) &#123;</span><br><span class="line">        <span class="built_in">super</span>(node, down, right);</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="成员方法-7"><a href="#成员方法-7" class="headerlink" title="成员方法"></a>成员方法</h4><h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><ul>
<li><p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentSkipListMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.comparator = <span class="literal">null</span>;	<span class="comment">// comparator 为 null，使用 key 的自然序，如字典序</span></span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">    keySet = <span class="literal">null</span>;</span><br><span class="line">    entrySet = <span class="literal">null</span>;</span><br><span class="line">    values = <span class="literal">null</span>;</span><br><span class="line">    descendingMap = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 初始化索引头节点，Node 的 key 为 null，value 为 BASE_HEADER 对象，下一个节点为 null</span></span><br><span class="line">    <span class="comment">// head 的分层索引 down 为 null，链表的后续索引 right 为 null，层级 level 为第 1 层</span></span><br><span class="line">    head = <span class="keyword">new</span> <span class="title class_">HeadIndex</span>&lt;K,V&gt;(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(<span class="literal">null</span>, BASE_HEADER, <span class="literal">null</span>), <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cpr：排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//　x 是比较者，y 是被比较者，比较者大于被比较者 返回正数，小于返回负数，相等返回 0</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">cpr</span><span class="params">(Comparator c, Object x, Object y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (c != <span class="literal">null</span>) ? c.compare(x, y) : ((Comparable)x).compareTo(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="添加方法-1"><a href="#添加方法-1" class="headerlink" title="添加方法"></a>添加方法</h5><ul>
<li><p>findPredecessor()：寻找前置节点</p>
<p>从最上层的头索引开始向右查找（链表的后续索引），如果后续索引的节点的 key 大于要查找的 key，则头索引移到下层链表，在下层链表查找，以此反复，一直查找到没有下层的分层索引为止，返回该索引的节点。如果后续索引的节点的 key 小于要查找的 key，则在该层链表中向后查找。由于查找的 key 可能永远大于索引节点的 key，所以只能找到目标的前置索引节点。如果遇到空值索引的存在，通过 CAS 来断开索引</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title function_">findPredecessor</span><span class="params">(Object key, Comparator&lt;? <span class="built_in">super</span> K&gt; cmp)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(); <span class="comment">// don&#x27;t postpone errors</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 1.初始数据 q 是 head，r 是最顶层 h 的右 Index 节点</span></span><br><span class="line">        <span class="keyword">for</span> (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123;</span><br><span class="line">            <span class="comment">// 2.右索引节点不为空，则进行向下查找</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> n.key;</span><br><span class="line">                <span class="comment">// 3.n.value 为 null 说明节点 n 正在删除的过程中，此时【当前线程帮其删除索引】</span></span><br><span class="line">                <span class="keyword">if</span> (n.value == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在 index 层直接删除 r 索引节点</span></span><br><span class="line">                    <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                        <span class="comment">// 删除失败重新从 head 节点开始查找，break 一个 for 到步骤 1，又从初始值开始</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 删除节点 r 成功，获取新的 r 节点,</span></span><br><span class="line">                    r = q.right;</span><br><span class="line">                    <span class="comment">// 回到步骤 2，还是从这层索引开始向右遍历</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 4.若参数 key &gt; r.node.key，则继续向右遍历, continue 到步骤 2 处获取右节点</span></span><br><span class="line">                <span class="comment">//   若参数 key &lt; r.node.key，说明需要进入下层索引，到步骤 5</span></span><br><span class="line">                <span class="keyword">if</span> (cpr(cmp, key, k) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    q = r;</span><br><span class="line">                    r = r.right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 5.先让 d 指向 q 的下一层，判断是否是 null，是则说明已经到了数据层，也就是第一层</span></span><br><span class="line">            <span class="keyword">if</span> ((d = q.down) == <span class="literal">null</span>) </span><br><span class="line">                <span class="keyword">return</span> q.node;</span><br><span class="line">            <span class="comment">// 6.未到数据层, 进行重新赋值向下扫描</span></span><br><span class="line">            q = d;		<span class="comment">// q 指向 d</span></span><br><span class="line">            r = d.right;<span class="comment">// r 指向 q 的后续索引节点，此时(q.key &lt; key &lt; r.key)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ConcurrentSkipListMap-Put%E6%B5%81%E7%A8%8B.png"></p>
</li>
<li><p>put()：添加数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// 非空判断，value不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> doPut(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">doPut</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; z;</span><br><span class="line">    <span class="comment">// 非空判断，key 不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; cmp = comparator;</span><br><span class="line">    <span class="comment">// outer 循环，【把待插入数据插入到数据层的合适的位置，并在扫描过程中处理已删除(value = null)的数据】</span></span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//0.for (;;)</span></span><br><span class="line">        <span class="comment">//1.将 key 对应的前继节点找到, b 为前继节点，是数据层的, n 是前继节点的 next, </span></span><br><span class="line">		<span class="comment">//  若没发生条件竞争，最终 key 在 b 与 n 之间 (找到的 b 在 base_level 上)</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            <span class="comment">// 2.n 不为 null 说明 b 不是链表的最后一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (n != <span class="literal">null</span>) &#123;</span><br><span class="line">                Object v; <span class="type">int</span> c;</span><br><span class="line">                <span class="comment">// 3.获取 n 的右节点</span></span><br><span class="line">                Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                <span class="comment">// 4.条件竞争，并发下其他线程在 b 之后插入节点或直接删除节点 n, break 到步骤 0</span></span><br><span class="line">                <span class="keyword">if</span> (n != b.next)              </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//  若节点 n 已经删除, 则调用 helpDelete 进行【帮助删除节点】</span></span><br><span class="line">                <span class="keyword">if</span> ((v = n.value) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    n.helpDelete(b, f);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 5.节点 b 被删除中，则 break 到步骤 0,</span></span><br><span class="line">				<span class="comment">//  【调用findPredecessor帮助删除index层的数据, node层的数据会通过helpDelete方法进行删除】</span></span><br><span class="line">                <span class="keyword">if</span> (b.value == <span class="literal">null</span> || v == n) </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 6.若 key &gt; n.key，则进行向后扫描</span></span><br><span class="line">                <span class="comment">//   若 key &lt; n.key，则证明 key 应该存储在 b 和 n 之间</span></span><br><span class="line">                <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    b = n;</span><br><span class="line">                    n = f;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 7.key 的值和 n.key 相等，则可以直接覆盖赋值</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// onlyIfAbsent 默认 false，</span></span><br><span class="line">                    <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, value)) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">V</span> <span class="variable">vv</span> <span class="operator">=</span> (V)v;</span><br><span class="line">                        <span class="comment">// 返回被覆盖的值</span></span><br><span class="line">                        <span class="keyword">return</span> vv;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// cas失败，break 一层循环，返回 0 重试</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else c &lt; 0; fall through</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 8.此时的情况 b.key &lt; key &lt; n.key，对应流程图1中的7，创建z节点指向n</span></span><br><span class="line">            z = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(key, value, n);</span><br><span class="line">            <span class="comment">// 9.尝试把 b.next 从 n 设置成 z</span></span><br><span class="line">            <span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">                <span class="comment">// cas失败，返回到步骤0，重试</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 10.break outer 后, 上面的 for 循环不会再执行, 而后执行下面的代码</span></span><br><span class="line">            <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 【以上插入节点已经完成，剩下的任务要根据随机数的值来表示是否向上增加层数与上层索引】</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 随机数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rnd</span> <span class="operator">=</span> ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果随机数的二进制与 10000000000000000000000000000001 进行与运算为 0</span></span><br><span class="line">    <span class="comment">// 即随机数的二进制最高位与最末尾必须为 0，其他位无所谓，就进入该循环</span></span><br><span class="line">    <span class="comment">// 如果随机数的二进制最高位与最末位不为 0，不增加新节点的层数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 11.判断是否需要添加 level，32 位</span></span><br><span class="line">    <span class="keyword">if</span> ((rnd &amp; <span class="number">0x80000001</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 索引层 level，从 1 开始，就是最底层</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>, max;</span><br><span class="line">        <span class="comment">// 12.判断最低位前面有几个 1，有几个leve就加几：0..0 0001 1110，这是4个，则1+4=5</span></span><br><span class="line">        <span class="comment">//    【最大有30个就是 1 + 30 = 31</span></span><br><span class="line">        <span class="keyword">while</span> (((rnd &gt;&gt;&gt;= <span class="number">1</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">            ++level;</span><br><span class="line">        <span class="comment">// 最终会指向 z 节点，就是添加的节点 </span></span><br><span class="line">        Index&lt;K,V&gt; idx = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 指向头索引节点</span></span><br><span class="line">        HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 13.判断level是否比当前最高索引小，图中 max 为 3</span></span><br><span class="line">        <span class="keyword">if</span> (level &lt;= (max = h.level)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                <span class="comment">// 根据层数level不断创建新增节点的上层索引，索引的后继索引留空</span></span><br><span class="line">                <span class="comment">// 第一次idx为null，也就是下层索引为空，第二次把上次的索引作为下层索引，【类似头插法】</span></span><br><span class="line">                idx = <span class="keyword">new</span> <span class="title class_">Index</span>&lt;K,V&gt;(z, idx, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 循环以后的索引结构</span></span><br><span class="line">            <span class="comment">// index-3	← idx</span></span><br><span class="line">            <span class="comment">//   ↓</span></span><br><span class="line">            <span class="comment">// index-2</span></span><br><span class="line">            <span class="comment">//   ↓</span></span><br><span class="line">            <span class="comment">// index-1</span></span><br><span class="line">            <span class="comment">//   ↓</span></span><br><span class="line">            <span class="comment">//  z-node</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 14.若 level &gt; max，则【只增加一层 index 索引层】，3 + 1 = 4</span></span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            level = max + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//创建一个 index 数组，长度是 level+1，假设 level 是 4，创建的数组长度为 5</span></span><br><span class="line">            Index&lt;K,V&gt;[] idxs = (Index&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Index</span>&lt;?,?&gt;[level+<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// index[0]的数组 slot 并没有使用，只使用 [1,level] 这些数组的 slot</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                idxs[i] = idx = <span class="keyword">new</span> <span class="title class_">Index</span>&lt;K,V&gt;(z, idx, <span class="literal">null</span>);</span><br><span class="line">              		<span class="comment">// index-4   ← idx</span></span><br><span class="line">                    <span class="comment">//   ↓</span></span><br><span class="line">                  	<span class="comment">// ......</span></span><br><span class="line">                    <span class="comment">//   ↓</span></span><br><span class="line">                    <span class="comment">// index-1</span></span><br><span class="line">                    <span class="comment">//   ↓</span></span><br><span class="line">                    <span class="comment">//  z-node</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                h = head;</span><br><span class="line">                <span class="comment">// 获取头索引的层数，3</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">oldLevel</span> <span class="operator">=</span> h.level;</span><br><span class="line">                <span class="comment">// 如果 level &lt;= oldLevel，说明其他线程进行了 index 层增加操作，退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (level &lt;= oldLevel)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 定义一个新的头索引节点</span></span><br><span class="line">                HeadIndex&lt;K,V&gt; newh = h;</span><br><span class="line">                <span class="comment">// 获取头索引的节点，就是 BASE_HEADER</span></span><br><span class="line">                Node&lt;K,V&gt; oldbase = h.node;</span><br><span class="line">                <span class="comment">// 升级 baseHeader 索引，升高一级，并发下可能升高多级</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> oldLevel + <span class="number">1</span>; j &lt;= level; ++j)</span><br><span class="line">                    <span class="comment">// 参数1：底层node，参数二：down，为以前的头节点，参数三：right，新建</span></span><br><span class="line">                    newh = <span class="keyword">new</span> <span class="title class_">HeadIndex</span>&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">                <span class="comment">// 执行完for循环之后，baseHeader 索引长这个样子，这里只升高一级</span></span><br><span class="line">                <span class="comment">// index-4             →             index-4	← idx</span></span><br><span class="line">                <span class="comment">//   ↓                                  ↓</span></span><br><span class="line">                <span class="comment">// index-3                           index-3     </span></span><br><span class="line">                <span class="comment">//   ↓                                  ↓</span></span><br><span class="line">                <span class="comment">// index-2                           index-2</span></span><br><span class="line">                <span class="comment">//   ↓                                  ↓</span></span><br><span class="line">                <span class="comment">// index-1                           index-1</span></span><br><span class="line">                <span class="comment">//   ↓                                  ↓</span></span><br><span class="line">                <span class="comment">// baseHeader    →    ....      →     z-node</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// cas 成功后，head 字段指向最新的 headIndex，baseHeader 的 index-4</span></span><br><span class="line">                <span class="keyword">if</span> (casHead(h, newh)) &#123;</span><br><span class="line">                    <span class="comment">// h 指向最新的 index-4 节点</span></span><br><span class="line">                    h = newh;</span><br><span class="line">                    <span class="comment">// 让 idx 指向 z-node 的 index-3 节点，</span></span><br><span class="line">					<span class="comment">// 因为从 index-3 - index-1 的这些 z-node 索引节点 都没有插入到索引链表</span></span><br><span class="line">                    idx = idxs[level = oldLevel];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 15.【把新加的索引插入索引链表中】，有上述两种情况，一种索引高度不变，另一种是高度加 1</span></span><br><span class="line">        <span class="comment">// 要插入的是第几层的索引</span></span><br><span class="line">        splice: <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">insertionLevel</span> <span class="operator">=</span> level;;) &#123;</span><br><span class="line">            <span class="comment">// 获取头索引的层数，情况 1 是 3，情况 2 是 4</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> h.level;</span><br><span class="line">            <span class="comment">// 【遍历 insertionLevel 层的索引，找到合适的插入位置】</span></span><br><span class="line">            <span class="keyword">for</span> (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;</span><br><span class="line">                <span class="comment">// 如果头索引为 null 或者新增节点索引为 null，退出插入索引的总循环</span></span><br><span class="line">                <span class="keyword">if</span> (q == <span class="literal">null</span> || t == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 此处表示有其他线程删除了头索引或者新增节点的索引</span></span><br><span class="line">                    <span class="keyword">break</span> splice;</span><br><span class="line">                <span class="comment">// 头索引的链表后续索引存在，如果是新层则为新节点索引，如果是老层则为原索引</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 获取r的节点</span></span><br><span class="line">                    Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                    <span class="comment">// 插入的key和n.key的比较值</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> cpr(cmp, key, n.key);</span><br><span class="line">                    <span class="comment">// 【删除空值索引】</span></span><br><span class="line">                    <span class="keyword">if</span> (n.value == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        r = q.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// key &gt; r.node.key，向右扫描</span></span><br><span class="line">                    <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        q = r;</span><br><span class="line">                        r = r.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行到这里，说明 key &lt; r.node.key，判断是否是第 j 层插入新增节点的前置索引</span></span><br><span class="line">                <span class="keyword">if</span> (j == insertionLevel) &#123;</span><br><span class="line">                    <span class="comment">// 【将新索引节点 t 插入 q r 之间】</span></span><br><span class="line">                    <span class="keyword">if</span> (!q.link(r, t))</span><br><span class="line">                        <span class="keyword">break</span>; </span><br><span class="line">                    <span class="comment">// 如果新增节点的值为 null，表示该节点已经被其他线程删除</span></span><br><span class="line">                    <span class="keyword">if</span> (t.node.value == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 找到该节点</span></span><br><span class="line">                        findNode(key);</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 插入层逐层自减，当为最底层时退出循环</span></span><br><span class="line">                    <span class="keyword">if</span> (--insertionLevel == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">// 其他节点随着插入节点的层数下移而下移</span></span><br><span class="line">                <span class="keyword">if</span> (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span><br><span class="line">                    t = t.down;</span><br><span class="line">                q = q.down;</span><br><span class="line">                r = q.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>findNode()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title function_">findNode</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// 原理与doGet相同，无非是 findNode 返回节点，doGet 返回 value</span></span><br><span class="line">    <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="获取方法-1"><a href="#获取方法-1" class="headerlink" title="获取方法"></a>获取方法</h5><ul>
<li><p>get(key)：获取对应的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doGet(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>doGet()：扫描过程会对已 value &#x3D; null 的元素进行删除处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">doGet</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 1.找到最底层节点的前置节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="type">int</span> c;</span><br><span class="line">            <span class="comment">// 2.【如果该前置节点的链表后续节点为 null，说明不存在该节点】</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="comment">// b → n → f</span></span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="comment">// 3.如果n不为前置节点的后续节点，表示已经有其他线程删除了该节点</span></span><br><span class="line">            <span class="keyword">if</span> (n != b.next) </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 4.如果后续节点的值为null，【需要帮助删除该节点】</span></span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="literal">null</span>) &#123;</span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 5.如果前置节点已被其他线程删除，重新循环</span></span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="literal">null</span> || v == n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">             <span class="comment">// 6.如果要获取的key与后续节点的key相等，返回节点的value</span></span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">V</span> <span class="variable">vv</span> <span class="operator">=</span> (V)v;</span><br><span class="line">                <span class="keyword">return</span> vv;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7.key &lt; n.key，因位 key &gt; b.key，b 和 n 相连，说明不存在该节点或者被其他线程删除了</span></span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            b = n;</span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="删除方法-1"><a href="#删除方法-1" class="headerlink" title="删除方法"></a>删除方法</h5><ul>
<li><p>remove()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doRemove(key, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">doRemove</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 1.找到最底层目标节点的前置节点，b.key &lt; key</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="type">int</span> c;</span><br><span class="line">            <span class="comment">// 2.如果该前置节点的链表后续节点为 null，退出循环，说明不存在这个元素</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="comment">// b → n → f</span></span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                    <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="literal">null</span>) &#123;        <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="literal">null</span> || v == n)      <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//3.key &lt; n.key，说明被其他线程删除了，或者不存在该节点</span></span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="comment">//4.key &gt; n.key，继续向后扫描</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5.到这里是 key = n.key，value 不为空的情况下判断 value 和 n.value 是否相等</span></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="literal">null</span> &amp;&amp; !value.equals(v))</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="comment">//6.【把 n 节点的 value 置空】</span></span><br><span class="line">            <span class="keyword">if</span> (!n.casValue(v, <span class="literal">null</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//7.【给 n 添加一个删除标志 mark】，mark.next = f，然后把 b.next 设置为 f，成功后n出队</span></span><br><span class="line">            <span class="keyword">if</span> (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">                <span class="comment">// 对 key 对应的 index 进行删除，调用了 findPredecessor 方法</span></span><br><span class="line">                findNode(key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 进行操作失败后通过 findPredecessor 中进行 index 的删除</span></span><br><span class="line">                findPredecessor(key, cmp);</span><br><span class="line">                <span class="keyword">if</span> (head.right == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 进行headIndex 对应的index 层的删除</span></span><br><span class="line">                    tryReduceLevel();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">V</span> <span class="variable">vv</span> <span class="operator">=</span> (V)v;</span><br><span class="line">            <span class="keyword">return</span> vv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过 findPredecessor() 中的 unlink() 后索引已经被删除</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ConcurrentSkipListMap-remove%E6%B5%81%E7%A8%8B.png"></p>
</li>
<li><p>appendMarker()：添加删除标记节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">appendMarker</span><span class="params">(Node&lt;K,V&gt; f)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 CAS 让 n.next 指向一个 key 为 null，value 为 this，next 为 f 的标记节点</span></span><br><span class="line">    <span class="keyword">return</span> casNext(f, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>helpDelete()：将添加了删除标记的节点清除，参数是该节点的前驱和后继节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">helpDelete</span><span class="params">(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f)</span> &#123;</span><br><span class="line">    <span class="comment">// this 节点的后续节点为 f，且本身为 b 的后续节点，一般都是正确的，除非被别的线程删除</span></span><br><span class="line">    <span class="keyword">if</span> (f == next &amp;&amp; <span class="built_in">this</span> == b.next) &#123;</span><br><span class="line">        <span class="comment">// 如果 n 还还没有被标记</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span> || f.value != f) </span><br><span class="line">            casNext(f, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(f));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 通过 CAS，将 b 的下一个节点 n 变成 f.next，即成为图中的样式</span></span><br><span class="line">            b.casNext(<span class="built_in">this</span>, f.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>tryReduceLevel()：删除索引</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">tryReduceLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">    HeadIndex&lt;K,V&gt; d;</span><br><span class="line">    HeadIndex&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (h.level &gt; <span class="number">3</span> &amp;&amp;</span><br><span class="line">        (d = (HeadIndex&lt;K,V&gt;)h.down) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (e = (HeadIndex&lt;K,V&gt;)d.down) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        e.right == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        d.right == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        h.right == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// 设置头索引</span></span><br><span class="line">        casHead(h, d) &amp;&amp; </span><br><span class="line">        <span class="comment">// 重新检查</span></span><br><span class="line">        h.right != <span class="literal">null</span>) </span><br><span class="line">        <span class="comment">// 重新检查返回true，说明其他线程增加了索引层级，把索引头节点设置回来</span></span><br><span class="line">        casHead(d, h);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>参考文章：<a href="https://my.oschina.net/u/3768341/blog/3135659">https://my.oschina.net/u/3768341/blog/3135659</a></p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1Er4y1P7k1">https://www.bilibili.com/video/BV1Er4y1P7k1</a></p>
<hr>
<h3 id="NoBlocking"><a href="#NoBlocking" class="headerlink" title="NoBlocking"></a>NoBlocking</h3><h4 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h4><p>并发编程中，需要用到安全的队列，实现安全队列可以使用 2 种方式：</p>
<ul>
<li>加锁，这种实现方式是阻塞队列</li>
<li>使用循环 CAS 算法实现，这种方式是非阻塞队列</li>
</ul>
<p>ConcurrentLinkedQueue 是一个基于链接节点的无界线程安全队列，采用先进先出的规则对节点进行排序，当添加一个元素时，会添加到队列的尾部，当获取一个元素时，会返回队列头部的元素</p>
<p>补充：ConcurrentLinkedDeque 是双向链表结构的无界并发队列</p>
<p>ConcurrentLinkedQueue 使用约定：</p>
<ol>
<li>不允许 null 入列</li>
<li>队列中所有未删除的节点的 item 都不能为 null 且都能从 head 节点遍历到</li>
<li>删除节点是将 item 设置为 null，队列迭代时跳过 item 为 null 节点</li>
<li>head 节点跟 tail 不一定指向头节点或尾节点，可能<strong>存在滞后性</strong></li>
</ol>
<p>ConcurrentLinkedQueue 由 head 节点和 tail 节点组成，每个节点由节点元素和指向下一个节点的引用组成，组成一张链表结构的队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">volatile</span> E item;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><p>无参构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentLinkedQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 默认情况下 head 节点存储的元素为空，dummy 节点，tail 节点等于 head 节点</span></span><br><span class="line">    head = tail = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有参构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentLinkedQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Node&lt;E&gt; h = <span class="literal">null</span>, t = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 遍历节点</span></span><br><span class="line">    <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="literal">null</span>)</span><br><span class="line">            h = t = newNode;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 单向链表</span></span><br><span class="line">            t.lazySetNext(newNode);</span><br><span class="line">            t = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>)</span><br><span class="line">        h = t = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">    head = h;</span><br><span class="line">    tail = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="入队方法"><a href="#入队方法" class="headerlink" title="入队方法"></a>入队方法</h4><p>与传统的链表不同，单线程入队的工作流程：</p>
<ul>
<li>将入队节点设置成当前队列尾节点的下一个节点</li>
<li>更新 tail 节点，如果 tail 节点的 next 节点不为空，则将入队节点设置成 tail 节点；如果 tail 节点的 next 节点为空，则将入队节点设置成 tail 的 next 节点，所以 tail 节点不总是尾节点，<strong>存在滞后性</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 创建入队节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 循环 CAS 直到入队成功</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        <span class="comment">// p 用来表示队列的尾节点，初始情况下等于 tail 节点，q 是 p 的 next 节点</span></span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="comment">// 条件成立说明 p 是尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p 是尾节点，设置 p 节点的下一个节点为新节点</span></span><br><span class="line">            <span class="comment">// 设置成功则 casNext 返回 true，否则返回 false，说明有其他线程更新过尾节点，继续寻找尾节点，继续 CAS</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="literal">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">// 首次添加时，p 等于 t，不进行尾节点更新，所以尾节点存在滞后性</span></span><br><span class="line">                <span class="keyword">if</span> (p != t)</span><br><span class="line">                    <span class="comment">// 将 tail 设置成新入队的节点，设置失败表示其他线程更新了 tail 节点</span></span><br><span class="line">                    casTail(t, newNode); </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// 当 tail 不指向最后节点时，如果执行出列操作，可能将 tail 也移除，tail 不在链表中 </span></span><br><span class="line">        	<span class="comment">// 此时需要对 tail 节点进行复位，复位到 head 节点</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 推动 tail 尾节点往队尾移动</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图解入队：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ConcurrentLinkedQueue%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C1.png"></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ConcurrentLinkedQueue%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C2.png"></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ConcurrentLinkedQueue%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C3.png"></p>
<p>当 tail 节点和尾节点的距离<strong>大于等于 1</strong> 时（每入队两次）更新 tail，可以减少 CAS 更新 tail 节点的次数，提高入队效率</p>
<p>线程安全问题：</p>
<ul>
<li>线程 1 线程 2 同时入队，无论从哪个位置开始并发入队，都可以循环 CAS，直到入队成功，线程安全</li>
<li>线程 1 遍历，线程 2 入队，所以造成 ConcurrentLinkedQueue 的 size 是变化，需要加锁保证安全</li>
<li>线程 1 线程 2 同时出列，线程也是安全的</li>
</ul>
<hr>
<h4 id="出队方法"><a href="#出队方法" class="headerlink" title="出队方法"></a>出队方法</h4><p>出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用，并不是每次出队都更新 head 节点</p>
<ul>
<li>当 head 节点里有元素时，直接弹出 head 节点里的元素，而不会更新 head 节点</li>
<li>当 head 节点里没有元素时，出队操作才会更新 head 节点</li>
</ul>
<p><strong>批处理方式</strong>可以减少使用 CAS 更新 head 节点的消耗，从而提高出队效率</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// p 节点表示首节点，即需要出队的节点，FIFO</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">item</span> <span class="operator">=</span> p.item;</span><br><span class="line">			<span class="comment">// 如果 p 节点的元素不为 null，则通过 CAS 来设置 p 节点引用元素为 null，成功返回 item</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="literal">null</span> &amp;&amp; p.casItem(item, <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p != h)	</span><br><span class="line">                   	<span class="comment">// 对 head 进行移动</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="literal">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">           	<span class="comment">// 逻辑到这说明头节点的元素为空或头节点发生了变化，头节点被另外一个线程修改了</span></span><br><span class="line">            <span class="comment">// 那么获取 p 节点的下一个节点，如果 p 节点的下一节点也为 null，则表明队列已经空了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">      		<span class="comment">// 第一轮操作失败，下一轮继续，调回到循环前</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="comment">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">updateHead</span><span class="params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">        <span class="comment">// 将旧结点 h 的 next 域指向为 h，help gc</span></span><br><span class="line">        h.lazySetNext(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在更新完 head 之后，会将旧的头结点 h 的 next 域指向为 h，图中所示的虚线也就表示这个节点的自引用，被移动的节点（item 为 null 的节点）会被 GC 回收</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ConcurrentLinkedQueue%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C1.png"></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ConcurrentLinkedQueue%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C2.png"></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-ConcurrentLinkedQueue%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C3.png"></p>
<p>如果这时，有一个线程来添加元素，通过 tail 获取的 next 节点则仍然是它本身，这就出现了p &#x3D;&#x3D; q 的情况，出现该种情况之后，则会触发执行 head 的更新，将 p 节点重新指向为 head</p>
<p>参考文章：<a href="https://www.jianshu.com/p/231caf90f30b">https://www.jianshu.com/p/231caf90f30b</a></p>
<hr>
<h4 id="成员方法-8"><a href="#成员方法-8" class="headerlink" title="成员方法"></a>成员方法</h4><ul>
<li><p>peek()：会改变 head 指向，执行 peek() 方法后 head 会指向第一个具有非空元素的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取链表的首部元素，只读取而不移除</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">item</span> <span class="operator">=</span> p.item;</span><br><span class="line">            <span class="keyword">if</span> (item != <span class="literal">null</span> || (q = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 更改h的位置为非空元素节点</span></span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>size()：用来获取当前队列的元素个数，因为整个过程都没有加锁，在并发环境中从调用 size 方法到返回结果期间有可能增删元素，导致统计的元素个数不精确</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// first() 获取第一个具有非空元素的节点，若不存在，返回 null</span></span><br><span class="line">    <span class="comment">// succ(p) 方法获取 p 的后继节点，若 p == p.next，则返回 head</span></span><br><span class="line">    <span class="comment">// 类似遍历链表</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="literal">null</span>; p = succ(p))</span><br><span class="line">        <span class="keyword">if</span> (p.item != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 最大返回Integer.MAX_VALUE</span></span><br><span class="line">            <span class="keyword">if</span> (++count == Integer.MAX_VALUE)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>remove()：移除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// 删除的元素不能为null</span></span><br><span class="line">    <span class="keyword">if</span> (o != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;E&gt; next, pred = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="literal">null</span>; pred = p, p = next) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">E</span> <span class="variable">item</span> <span class="operator">=</span> p.item;</span><br><span class="line">            <span class="comment">// 节点元素不为null</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 若不匹配，则获取next节点继续匹配</span></span><br><span class="line">                <span class="keyword">if</span> (!o.equals(item)) &#123;</span><br><span class="line">                    next = succ(p);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 若匹配，则通过 CAS 操作将对应节点元素置为 null</span></span><br><span class="line">                removed = p.casItem(item, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取删除节点的后继节点</span></span><br><span class="line">            next = succ(p);</span><br><span class="line">            <span class="comment">// 将被删除的节点移除队列</span></span><br><span class="line">            <span class="keyword">if</span> (pred != <span class="literal">null</span> &amp;&amp; next != <span class="literal">null</span>) <span class="comment">// unlink</span></span><br><span class="line">                pred.casNext(p, next);</span><br><span class="line">            <span class="keyword">if</span> (removed)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="NET"><a href="#NET" class="headerlink" title="NET"></a>NET</h1><h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><p>网络编程，就是在一定的协议下，实现两台计算机的通信的技术</p>
<p>通信一定是基于软件结构实现的:</p>
<ul>
<li>C&#x2F;S 结构 ：全称为 Client&#x2F;Server 结构，是指客户端和服务器结构，常见程序有 QQ、IDEA 等软件</li>
<li>B&#x2F;S 结构 ：全称为 Browser&#x2F;Server 结构，是指浏览器和服务器结构</li>
</ul>
<p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持</p>
<p>网络通信的三要素：</p>
<ol>
<li><p>协议：计算机网络客户端与服务端通信必须约定和彼此遵守的通信规则，HTTP、FTP、TCP、UDP、SMTP</p>
</li>
<li><p>IP 地址：互联网协议地址（Internet Protocol Address），用来给一个网络中的计算机设备做唯一的编号</p>
<ul>
<li><p>IPv4：4 个字节，32 位组成，192.168.1.1</p>
</li>
<li><p>IPv6：可以实现为所有设备分配 IP，128 位</p>
</li>
<li><p>ipconfig：查看本机的 IP</p>
<ul>
<li>ping 检查本机与某个 IP 指定的机器是否联通，或者说是检测对方是否在线。</li>
<li>ping 空格 IP地址 ：ping 220.181.57.216，ping <a href="http://www.baidu.com/">www.baidu.com</a></li>
</ul>
</li>
</ul>
<p>特殊的IP地址： 本机IP地址，<strong>127.0.0.1 &#x3D;&#x3D; localhost</strong>，回环测试</p>
</li>
<li><p>端口：端口号就可以唯一标识设备中的进程（应用程序）。端口号是用两个字节表示的整数，取值范围是 0-65535，0-1023 之间的端口号用于一些知名的网络服务和应用普通的应用程序需要使用 1024 以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败，报出端口被占用异常</p>
</li>
</ol>
<p>利用<strong>协议+IP 地址+端口号</strong>三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互</p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1kT4y1M7vt">https://www.bilibili.com/video/BV1kT4y1M7vt</a></p>
<hr>
<h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>网络通信协议：对计算机必须遵守的规则，只有遵守这些规则，计算机之间才能进行通信</p>
<p>通信<strong>是进程与进程之间的通信</strong>，不是主机与主机之间的通信</p>
<p>TCP&#x2F;IP协议：传输控制协议 (Transmission Control Protocol)</p>
<p>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流，每一条 TCP 连接只能是点对点的（一对一）</p>
<ul>
<li>在通信之前必须确定对方在线并且连接成功才可以通信</li>
<li>例如下载文件、浏览网页等（要求可靠传输）</li>
</ul>
<p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，不可靠，没有拥塞控制，面向报文，支持一对一、一对多、多对一和多对多的交互通信</p>
<ul>
<li>直接发消息给对方，不管对方是否在线，发消息后也不需要确认</li>
<li>无线（视频会议，通话），性能好，可能丢失一些数据</li>
</ul>
<hr>
<h3 id="Java模型"><a href="#Java模型" class="headerlink" title="Java模型"></a>Java模型</h3><p>相关概念：</p>
<ul>
<li>同步：当前线程要自己进行数据的读写操作（自己去银行取钱）</li>
<li>异步：当前线程可以去做其他事情（委托别人拿银行卡到银行取钱，然后给你）</li>
<li>阻塞：在数据没有的情况下，还是要继续等待着读（排队等待）</li>
<li>非阻塞：在数据没有的情况下，会去做其他事情，一旦有了数据再来获取（柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理）</li>
</ul>
<p>Java 中的通信模型:</p>
<ol>
<li><p>BIO 表示同步阻塞式通信，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善</p>
<p>同步阻塞式性能极差：大量线程，大量阻塞</p>
</li>
<li><p>伪异步通信：引入线程池，不需要一个客户端一个线程，实现线程复用来处理很多个客户端，线程可控</p>
<p>高并发下性能还是很差：线程数量少，数据依然是阻塞的，数据没有来线程还是要等待</p>
</li>
<li><p>NIO 表示<strong>同步非阻塞 IO</strong>，服务器实现模式为请求对应一个线程，客户端发送的连接会注册到多路复用器上，多路复用器轮询到连接有 I&#x2F;O 请求时才启动一个线程进行处理</p>
<p>工作原理：1 个主线程专门负责接收客户端，1 个线程轮询所有的客户端，发来了数据才会开启线程处理</p>
<p>同步：线程还要不断的接收客户端连接，以及处理数据</p>
<p>非阻塞：如果一个管道没有数据，不需要等待，可以轮询下一个管道是否有数据</p>
</li>
<li><p>AIO 表示异步非阻塞 IO，AIO 引入异步通道的概念，采用了 Proactor 模式，有效的请求才启动线程，特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</p>
<p>异步：服务端线程接收到了客户端管道以后就交给底层处理 IO 通信，线程可以做其他事情</p>
<p>非阻塞：底层也是客户端有数据才会处理，有了数据以后处理好通知服务器应用来启动线程进行处理</p>
</li>
</ol>
<p>各种模型应用场景：</p>
<ul>
<li>BIO 适用于连接数目比较小且固定的架构，该方式对服务器资源要求比较高，并发局限于应用中，程序简单</li>
<li>NIO 适用于连接数目多且连接比较短（轻操作）的架构，如聊天服务器，并发局限于应用中，编程复杂，JDK 1.4 开始支持</li>
<li>AIO 适用于连接数目多且连接比较长（重操作）的架构，如相册服务器，充分调用操作系统参与并发操作，JDK 1.7 开始支持</li>
</ul>
<hr>
<h2 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><h4 id="五种模型"><a href="#五种模型" class="headerlink" title="五种模型"></a>五种模型</h4><p>对于一个套接字上的输入操作，第一步是等待数据从网络中到达，当数据到达时被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区</p>
<p>Linux 有五种 I&#x2F;O 模型：</p>
<ul>
<li>阻塞式 I&#x2F;O</li>
<li>非阻塞式 I&#x2F;O</li>
<li>I&#x2F;O 复用（select 和 poll）</li>
<li>信号驱动式 I&#x2F;O（SIGIO）</li>
<li>异步 I&#x2F;O（AIO）</li>
</ul>
<p>五种模型对比：</p>
<ul>
<li>同步 I&#x2F;O 包括阻塞式 I&#x2F;O、非阻塞式 I&#x2F;O、I&#x2F;O 复用和信号驱动 I&#x2F;O ，它们的主要区别在第一个阶段，非阻塞式 I&#x2F;O 、信号驱动 I&#x2F;O 和异步 I&#x2F;O 在第一阶段不会阻塞</li>
</ul>
<ul>
<li>同步 I&#x2F;O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞</li>
<li>异步 I&#x2F;O：第二阶段应用进程不会阻塞</li>
</ul>
<hr>
<h4 id="阻塞式IO"><a href="#阻塞式IO" class="headerlink" title="阻塞式IO"></a>阻塞式IO</h4><p>应用进程通过系统调用 recvfrom 接收数据，会被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。阻塞不意味着整个操作系统都被阻塞，其它应用进程还可以执行，只是当前阻塞进程不消耗 CPU 时间，这种模型的 CPU 利用率会比较高</p>
<p>recvfrom() 用于<strong>接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中</strong>，把 recvfrom() 当成系统调用</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO%E6%A8%A1%E5%9E%8B-%E9%98%BB%E5%A1%9E%E5%BC%8FIO.png"></p>
<hr>
<h4 id="非阻塞式"><a href="#非阻塞式" class="headerlink" title="非阻塞式"></a>非阻塞式</h4><p>应用进程通过 recvfrom 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好数据，内核返回一个错误码，过一段时间应用进程再执行 recvfrom 系统调用，在两次发送请求的时间段，进程可以进行其他任务，这种方式称为轮询（polling）</p>
<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO%E6%A8%A1%E5%9E%8B-%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIO.png"></p>
<hr>
<h4 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h4><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，等待数据阶段应用进程是非阻塞的。当内核数据准备就绪时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中</p>
<p>相比于非阻塞式 I&#x2F;O 的轮询方式，信号驱动 I&#x2F;O 的 CPU 利用率更高</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO%E6%A8%A1%E5%9E%8B-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO.png"></p>
<hr>
<h4 id="IO-复用"><a href="#IO-复用" class="headerlink" title="IO 复用"></a>IO 复用</h4><p>IO 复用模型使用 select 或者 poll 函数等待数据，select 会监听所有注册好的 IO，<strong>等待多个套接字中的任何一个变为可读</strong>，等待过程会被阻塞，当某个套接字准备好数据变为可读时 select 调用就返回，然后调用 recvfrom 把数据从内核复制到进程中</p>
<p>IO 复用让单个进程具有处理多个 I&#x2F;O 事件的能力，又被称为 Event Driven I&#x2F;O，即<strong>事件驱动 I&#x2F;O</strong></p>
<p>如果一个 Web 服务器没有 I&#x2F;O 复用，那么每一个 Socket 连接都要创建一个线程去处理，如果同时有几万个连接，就需要创建相同数量的线程。相比于多进程和多线程技术，I&#x2F;O 复用不需要进程线程创建和切换的开销，系统开销更小</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO%E6%A8%A1%E5%9E%8B-IO%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.png"></p>
<hr>
<h4 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a>异步 IO</h4><p>应用进程执行 aio_read 系统调用会立即返回，给内核传递描述符、缓冲区指针、缓冲区大小等。应用进程可以继续执行不会被阻塞，内核会在所有操作完成之后向应用进程发送信号</p>
<p>异步 I&#x2F;O 与信号驱动 I&#x2F;O 的区别在于，异步 I&#x2F;O 的信号是通知应用进程 I&#x2F;O 完成，而信号驱动 I&#x2F;O 的信号是通知应用进程可以开始 I&#x2F;O</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO%E6%A8%A1%E5%9E%8B-%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B.png"></p>
<hr>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>Socket 不是文件，只是一个标识符，但是 Unix 操作系统把所有东西都<strong>看作</strong>是文件，所以 Socket 说成 file descriptor，也就是 fd</p>
<p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I&#x2F;O 操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>fd_set 使用 <strong>bitmap 数组</strong>实现，数组大小用 FD_SETSIZE 定义，<strong>单进程</strong>只能监听少于 FD_SETSIZE 数量的描述符，32 位机默认是 1024 个，64 位机默认是 2048，可以对进行修改，然后重新编译内核</p>
</li>
<li><p>fd_set 有三种类型的描述符：readset、writeset、exceptset，对应读、写、异常条件的描述符集合</p>
</li>
<li><p>n 是监测的 socket 的最大数量</p>
</li>
<li><p>timeout 为超时参数，调用 select 会一直<strong>阻塞</strong>直到有描述符的事件到达或者等待的时间超过 timeout</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="type">long</span> tv_sec; 	<span class="comment">//秒</span></span><br><span class="line">    <span class="type">long</span> tv_usec;	<span class="comment">//微秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>timeout &#x3D;&#x3D; null：等待无限长的时间</li>
<li>tv_sec &#x3D;&#x3D; 0 &amp;&amp; tv_usec &#x3D;&#x3D; 0：获取后直接返回，不阻塞等待</li>
<li>tv_sec !&#x3D; 0 || tv_usec !&#x3D; 0：等待指定时间</li>
</ul>
</li>
<li><p>方法成功调用返回结果为<strong>就绪的文件描述符个数</strong>，出错返回结果为 -1，超时返回结果为 0</p>
</li>
</ul>
<p>Linux 提供了一组宏为 fd_set 进行赋值操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *fdset)</span>;			<span class="comment">// 将一个 fd_set 类型变量的所有值都置为 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;	<span class="comment">// 将一个 fd_set 类型变量的 fd 位置为 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;	<span class="comment">// 将一个 fd_set 类型变量的 fd 位置为 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;<span class="comment">// 判断 fd 位是否被置为 1</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr)));</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">2000</span>);</span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));<span class="comment">//绑定连接</span></span><br><span class="line">listen(sockfd, <span class="number">5</span>);<span class="comment">//监听5个端口</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;client, e, <span class="keyword">sizeof</span>(client));</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">	fds[i] = accept(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    <span class="comment">//将监听的对应的文件描述符fd存入fds：[3,4,5,6,7]</span></span><br><span class="line">    <span class="keyword">if</span>(fds[i] &gt; max)</span><br><span class="line">		max = fds[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    FD_ZERO(&amp;rset);<span class="comment">//置为0</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    	FD_SET(fds[i], &amp;rset);<span class="comment">//对应位置1 [0001 1111 00.....]</span></span><br><span class="line">	&#125;</span><br><span class="line">	print(<span class="string">&quot;round again&quot;</span>);</span><br><span class="line">	select(max + <span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//监听</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fds[i], &amp;rset)) &#123;<span class="comment">//判断监听哪一个端口</span></span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="number">0</span>, MAXBUF);</span><br><span class="line">            read(fds[i], buffer, MAXBUF);<span class="comment">//进入内核态读数据</span></span><br><span class="line">            print(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考视频：<a href="https://www.bilibili.com/video/BV19D4y1o797">https://www.bilibili.com/video/BV19D4y1o797</a></p>
<hr>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p>select 调用流程图：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-select%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png"></p>
<ol>
<li>使用 copy_from_user 从用户空间拷贝 fd_set 到内核空间，进程阻塞</li>
<li>注册回调函数 _pollwait</li>
<li>遍历所有 fd，调用其对应的 poll 方法判断当前请求是否准备就绪，对于 socket，这个 poll 方法是 sock_poll，sock_poll 根据情况会调用到 tcp_poll、udp_poll 或者 datagram_poll，以 tcp_poll 为例，其核心实现就是 _pollwait</li>
<li>_pollwait 把 <strong>current（调用 select 的进程）</strong>挂到设备的等待队列，不同设备有不同的等待队列，对于 tcp_poll ，其等待队列是 sk → sk_sleep（把进程挂到等待队列中并不代表进程已经睡眠），在设备收到消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时 current 便被唤醒，进入就绪队列</li>
<li>poll 方法返回时会返回一个描述读写操作是否就绪的 mask 掩码，根据这个 mask 掩码给 fd_set 赋值</li>
<li>如果遍历完所有的 fd，还没有返回一个可读写的 mask 掩码，则会调用 schedule_timeout 让 current 进程进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程，如果超过一定的超时时间（schedule_timeout）没有其他线程唤醒，则调用 select 的进程会重新被唤醒获得 CPU，进而重新遍历 fd，判断有没有就绪的 fd</li>
<li>把 fd_set 从内核空间拷贝到用户空间，阻塞进程继续执行</li>
</ol>
<p>参考文章：<a href="https://www.cnblogs.com/anker/p/3265058.html">https://www.cnblogs.com/anker/p/3265058.html</a></p>
<p>其他流程图：<a href="https://www.processon.com/view/link/5f62b9a6e401fd2ad7e5d6d1">https://www.processon.com/view/link/5f62b9a6e401fd2ad7e5d6d1</a></p>
<hr>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">unsigned</span> <span class="type">int</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>select 和 poll 对比：</p>
<ul>
<li>select 会修改描述符，而 poll 不会</li>
<li>select 的描述符类型使用数组实现，有描述符的限制；而 poll 使用<strong>链表</strong>实现，没有描述符数量的限制</li>
<li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高</li>
</ul>
<ul>
<li>select 和 poll 速度都比较慢，<strong>每次调用</strong>都需要将全部描述符数组 fd 从应用进程缓冲区复制到内核缓冲区，同时每次都需要在内核遍历传递进来的所有 fd ，这个开销在 fd 很多时会很大</li>
<li>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll</li>
<li>select 和 poll 的时间复杂度 O(n)，对 socket 进行扫描时是线性扫描，即采用轮询的方法，效率较低，因为并不知道具体是哪个 socket 具有事件，所以随着 fd 数量的增加会造成遍历速度慢的<strong>线性下降</strong>性能问题</li>
<li>poll 还有一个特点是水平触发，如果报告了 fd 后，没有被处理，那么下次 poll 时会再次报告该 fd</li>
<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定</li>
</ul>
<p>参考文章：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md">https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md</a></p>
<hr>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><h5 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h5><p>epoll 使用事件的就绪通知方式，通过 epoll_ctl() 向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵<strong>红黑树</strong>上，一旦该 fd 就绪，<strong>内核通过 callback 回调函数将 I&#x2F;O 准备好的描述符加入到一个链表中</strong>管理，进程调用 epoll_wait() 便可以得到事件就绪的描述符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>；</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>epall_create：一个系统函数，函数将在内核空间内创建一个 epoll 数据结构，可以理解为 epoll 结构空间，返回值为 epoll 的文件描述符编号，以后有 client 连接时，向该 epoll 结构中添加监听，所以 epoll 使用一个文件描述符管理多个描述符</p>
</li>
<li><p>epall_ctl：epoll 的事件注册函数，select 函数是调用时指定需要监听的描述符和事件，epoll 先将用户感兴趣的描述符事件注册到 epoll 空间。此函数是非阻塞函数，用来增删改 epoll 空间内的描述符，参数解释：</p>
<ul>
<li><p>epfd：epoll 结构的进程 fd 编号，函数将依靠该编号找到对应的 epoll 结构</p>
</li>
<li><p>op：表示当前请求类型，有三个宏定义：</p>
<ul>
<li>EPOLL_CTL_ADD：注册新的 fd 到 epfd 中</li>
<li>EPOLL_CTL_MOD：修改已经注册的 fd 的监听事件</li>
<li>EPOLL_CTI_DEL：从 epfd 中删除一个 fd</li>
</ul>
</li>
<li><p>fd：需要监听的文件描述符，一般指 socket_fd</p>
</li>
<li><p>event：告诉内核对该 fd 资源感兴趣的事件，epoll_event 的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">_uint32_t</span> events;	<span class="comment">/*epoll events*/</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;	<span class="comment">/*user data variable*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>events 可以是以下几个宏集合：EPOLLIN、EPOLOUT、EPOLLPRI、EPOLLERR、EPOLLHUP（挂断）、EPOLET（边缘触发）、EPOLLONESHOT（只监听一次，事件触发后自动清除该 fd，从 epoll 列表）</p>
</li>
</ul>
</li>
<li><p>epoll_wait：等待事件的产生，类似于 select() 调用，返回值为本次就绪的 fd 个数，直接从就绪链表获取，时间复杂度 O(1)</p>
<ul>
<li>epfd：<strong>指定感兴趣的 epoll 事件列表</strong></li>
<li>events：指向一个 epoll_event 结构数组，当函数返回时，内核会把就绪状态的数据拷贝到该数组</li>
<li>maxevents：标明 epoll_event 数组最多能接收的数据量，即本次操作最多能获取多少就绪数据</li>
<li>timeout：单位为毫秒<ul>
<li>0：表示立即返回，非阻塞调用</li>
<li>-1：阻塞调用，直到有用户感兴趣的事件就绪为止</li>
<li>大于 0：阻塞调用，阻塞指定时间内如果有事件就绪则提前返回，否则等待指定时间后返回</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）：</p>
<ul>
<li>LT 模式：当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程，是默认的一种模式，并且同时支持 Blocking 和 No-Blocking</li>
<li>ET 模式：通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高；只支持 No-Blocking，以避免由于一个 fd 的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饥饿</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 epoll 描述符，每个应用程序只需要一个，用于监控所有套接字</span></span><br><span class="line"><span class="type">int</span> pollingfd = epoll_create(<span class="number">0xCAFE</span>);</span><br><span class="line"><span class="keyword">if</span> ( pollingfd &lt; <span class="number">0</span> )<span class="comment">// report error</span></span><br><span class="line"><span class="comment">// 初始化 epoll 结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将连接类实例与事件相关联，可以关联任何想要的东西</span></span><br><span class="line">ev.data.ptr = pConnection1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监视输入，并且在事件发生后不自动重新准备描述符</span></span><br><span class="line">ev.events = EPOLLIN | EPOLLONESHOT;</span><br><span class="line"><span class="comment">// 将描述符添加到监控列表中，即使另一个线程在epoll_wait中等待，描述符将被正确添加</span></span><br><span class="line"><span class="keyword">if</span> ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev) != <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// report error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最多等待 20 个事件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">pevents</span>[20];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待10秒，检索20个并存入epoll_event数组</span></span><br><span class="line"><span class="type">int</span> ready = epoll_wait(pollingfd, pevents, <span class="number">20</span>, <span class="number">10000</span>);</span><br><span class="line"><span class="comment">// 检查epoll是否成功</span></span><br><span class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span>)<span class="comment">// report error and abort</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span>)<span class="comment">// timeout; no event detected</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ready; i+ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( pevents[i].events &amp; EPOLLIN )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取连接指针</span></span><br><span class="line">            Connection * c = (Connection*) pevents[i].data.ptr;</span><br><span class="line">            c-&gt;handleReadEvent();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>流程图：<a href="https://gitee.com/seazean/images/blob/master/Java/IO-epoll%E5%8E%9F%E7%90%86%E5%9B%BE.jpg">https://gitee.com/seazean/images/blob/master/Java/IO-epoll%E5%8E%9F%E7%90%86%E5%9B%BE.jpg</a></p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV19D4y1o797">https://www.bilibili.com/video/BV19D4y1o797</a></p>
<hr>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>epoll 的特点：</p>
<ul>
<li><p>epoll 仅适用于 Linux 系统</p>
</li>
<li><p>epoll 使用<strong>一个文件描述符管理多个描述符</strong>，将用户关心的文件描述符的事件存放到内核的一个事件表（个人理解成哑元节点）</p>
</li>
<li><p>没有最大描述符数量（并发连接）的限制，打开 fd 的上限远大于1024（1G 内存能监听约 10 万个端口）</p>
</li>
<li><p>epoll 的时间复杂度 O(1)，epoll 理解为 event poll，不同于忙轮询和无差别轮询，调用 epoll_wait <strong>只是轮询就绪链表</strong>。当监听列表有设备就绪时调用回调函数，把就绪 fd 放入就绪链表中，并唤醒在 epoll_wait 中阻塞的进程，所以 epoll 实际上是<strong>事件驱动</strong>（每个事件关联上fd）的，降低了 system call 的时间复杂度</p>
</li>
<li><p>epoll 内核中根据每个 fd 上的 callback 函数来实现，只有活跃的 socket 才会主动调用 callback，所以使用 epoll 没有前面两者的线性下降的性能问题，效率提高</p>
</li>
<li><p>epoll 注册新的事件是注册到到内核中 epoll 句柄中，不需要每次调用 epoll_wait 时重复拷贝，对比前面两种只需要将描述符从进程缓冲区向内核缓冲区<strong>拷贝一次</strong>，也可以利用 <strong>mmap() 文件映射内存</strong>加速与内核空间的消息传递（只是可以用，并没有用）</p>
</li>
<li><p>前面两者要把 current 往设备等待队列中挂一次，epoll 也只把 current 往等待队列上挂一次，但是这里的等待队列并不是设备等待队列，只是一个 epoll 内部定义的等待队列，这样可以节省开销</p>
</li>
<li><p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符，也不会产生像 select 和 poll 的不确定情况</p>
</li>
</ul>
<p>参考文章：<a href="https://www.jianshu.com/p/dfd940e7fca2">https://www.jianshu.com/p/dfd940e7fca2</a></p>
<p>参考文章：<a href="https://www.cnblogs.com/anker/p/3265058.html">https://www.cnblogs.com/anker/p/3265058.html</a></p>
<hr>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>应用场景： </p>
<ul>
<li><p>select 应用场景：</p>
<ul>
<li>select 的 timeout 参数精度为微秒，poll 和 epoll 为毫秒，因此 select 适用<strong>实时性要求比较高</strong>的场景，比如核反应堆的控制</li>
<li>select 可移植性更好，几乎被所有主流平台所支持</li>
</ul>
</li>
<li><p>poll 应用场景：poll 没有最大描述符数量的限制，适用于平台支持并且对实时性要求不高的情况</p>
</li>
<li><p>epoll 应用场景：</p>
<ul>
<li>运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是<strong>长连接</strong></li>
<li>需要同时监控小于 1000 个描述符，没必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势</li>
<li>需要监控的描述符状态变化多，而且是非常短暂的，就没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，每次对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率，并且 epoll 的描述符存储在内核，不容易调试</li>
</ul>
</li>
</ul>
<p>参考文章：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md">https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md</a></p>
<hr>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><h4 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h4><p>用户空间：用户代码、用户堆栈</p>
<p>内核空间：内核代码、内核调度程序、进程描述符（内核堆栈、thread_info 进程描述符）</p>
<ul>
<li>进程描述符和用户的进程是一一对应的</li>
<li>SYS_API 系统调用：如 read、write，系统调用就是 0X80 中断</li>
<li>进程描述符 pd：进程从用户态切换到内核态时，需要<strong>保存用户态时的上下文信息在 PCB 中</strong></li>
<li>线程上下文：用户程序基地址，程序计数器、cpu cache、寄存器等，方便程序切回用户态时恢复现场</li>
<li>内核堆栈：<strong>系统调用函数也是要创建变量的，</strong>这些变量在内核堆栈上分配</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81.png"></p>
<hr>
<h4 id="80中断"><a href="#80中断" class="headerlink" title="80中断"></a>80中断</h4><p>在用户程序中调用操作系统提供的核心态级别的子功能，为了系统安全需要进行用户态和内核态转换，状态的转换需要进行 CPU 中断，中断分为硬中断和软中断：</p>
<ul>
<li>硬中断：如网络传输中，数据到达网卡后，网卡经过一系列操作后发起硬件中断</li>
<li>软中断：如程序运行过程中本身产生的一些中断<ul>
<li>发起 <code>0X80</code> 中断</li>
<li>程序执行碰到除 0 异常</li>
</ul>
</li>
</ul>
<p>系统调用 system_call 函数所对应的中断指令编号是 0X80（十进制是 8×16&#x3D;128），而该指令编号对应的就是系统调用程序的入口，所以称系统调用为 80 中断</p>
<p>系统调用的流程：</p>
<ul>
<li>在 CPU 寄存器里存一个系统调用号，表示哪个系统函数，比如 read</li>
<li>将 CPU 的临时数据都保存到 thread_info 中</li>
<li>执行 80 中断处理程序，找到刚刚存的系统调用号（read），先检查缓存中有没有对应的数据，没有就去磁盘中加载到内核缓冲区，然后从内核缓冲区拷贝到用户空间</li>
<li>最后恢复到用户态，通过 thread_info 恢复现场，用户态继续执行</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B.jpg"></p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV19D4y1o797">https://www.bilibili.com/video/BV19D4y1o797</a></p>
<hr>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><p>DMA (Direct Memory Access) ：直接存储器访问，让外部设备不通过 CPU 直接与系统内存交换数据的接口技术</p>
<p>作用：可以解决批量数据的输入&#x2F;输出问题，使数据的传送速度取决于存储器和外设的工作速度</p>
<p>把内存数据传输到网卡然后发送：</p>
<ul>
<li>没有 DMA：CPU 读内存数据到 CPU 高速缓存，再写到网卡，这样就把 CPU 的速度拉低到和网卡一个速度</li>
<li>使用 DMA：把数据读到 Socket 内核缓存区（CPU 复制），CPU 分配给 DMA 开始<strong>异步</strong>操作，DMA 读取 Socket 缓冲区到 DMA 缓冲区，然后写到网卡。DMA 执行完后<strong>中断</strong>（就是通知） CPU，这时 Socket 内核缓冲区为空，CPU 从用户态切换到内核态，执行中断处理程序，将需要使用 Socket 缓冲区的阻塞进程移到就绪队列</li>
</ul>
<p>一个完整的 DMA 传输过程必须经历 DMA 请求、DMA 响应、DMA 传输、DMA 结束四个步骤：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-DMA.png" style="zoom: 50%;">

<p>DMA 方式是一种完全由硬件进行信息传送的控制方式，通常系统总线由 CPU 管理，在 DMA 方式中，CPU 的主存控制信号被禁止使用，CPU 把总线（地址总线、数据总线、控制总线）让出来由 DMA 控制器接管，用来控制传送的字节数、判断 DMA 是否结束、以及发出 DMA 结束信号，所以 DMA 控制器必须有以下功能：</p>
<ul>
<li>接受外设发出的 DMA 请求，并向 CPU 发出总线接管请求</li>
<li>当 CPU 发出允许接管信号后，进入 DMA 操作周期</li>
<li>确定传送数据的主存单元地址及长度，并自动修改主存地址计数和传送长度计数</li>
<li>规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作</li>
<li>判断 DMA 传送是否结束，发出 DMA 结束信号，使 CPU 恢复正常工作状态（中断）</li>
</ul>
<hr>
<h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>传统的 I&#x2F;O 操作进行了 4 次用户空间与内核空间的上下文切换，以及 4 次数据拷贝：</p>
<ul>
<li>JVM 发出 read 系统调用，OS 上下文切换到内核模式（切换 1）并将数据从网卡或硬盘等设备通过 DMA 读取到内核空间缓冲区（拷贝 1），内核缓冲区实际上是<strong>磁盘高速缓存（PageCache）</strong></li>
<li>OS 内核将数据复制到用户空间缓冲区（拷贝 2），然后 read 系统调用返回，又会导致一次内核空间到用户空间的上下文切换（切换 2）</li>
<li>JVM 处理代码逻辑并发送 write() 系统调用，OS 上下文切换到内核模式（切换3）并从用户空间缓冲区复制数据到内核空间缓冲区（拷贝3）</li>
<li>将内核空间缓冲区中的数据写到 hardware（拷贝4），write 系统调用返回，导致内核空间到用户空间的再次上下文切换（切换4）</li>
</ul>
<p>流程图中的箭头反过来也成立，可以从网卡获取数据</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-BIO%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p>
<p>read 调用图示：read、write 都是系统调用指令</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-缓冲区读写.png" style="zoom: 67%;">



<hr>
<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>mmap（Memory Mapped Files）内存映射加 write 实现零拷贝，<strong>零拷贝就是没有数据从内核空间复制到用户空间</strong></p>
<p>用户空间和内核空间都使用内存，所以可以共享同一块物理内存地址，省去用户态和内核态之间的拷贝。写网卡时，共享空间的内容拷贝到 Socket 缓冲区，然后交给 DMA 发送到网卡，只需要 3 次复制</p>
<p>进行了 4 次用户空间与内核空间的上下文切换，以及 3 次数据拷贝（2 次 DMA，一次 CPU 复制）：</p>
<ul>
<li>发出 mmap 系统调用，DMA 拷贝到内核缓冲区，映射到共享缓冲区；mmap 系统调用返回，无需拷贝</li>
<li>发出 write 系统调用，将数据从内核缓冲区拷贝到内核 Socket 缓冲区；write 系统调用返回，DMA 将内核空间 Socket 缓冲区中的数据传递到协议引擎</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-mmap%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p>
<p>原理：利用操作系统的 Page 来实现文件到物理内存的直接映射，完成映射后对物理内存的操作会<strong>被同步</strong>到硬盘上</p>
<p>缺点：不可靠，写到 mmap 中的数据并没有被真正的写到硬盘，操作系统会在程序主动调用 flush 的时候才把数据真正的写到硬盘</p>
<p>Java NIO 提供了 <strong>MappedByteBuffer</strong> 类可以用来实现 mmap 内存映射，MappedByteBuffer 类对象<strong>只能通过调用 <code>FileChannel.map()</code> 获取</strong></p>
<hr>
<h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><p>sendfile 实现零拷贝，打开文件的文件描述符 fd 和 socket 的 fd 传递给 sendfile，然后经过 3 次复制和 2 次用户态和内核态的切换</p>
<p>原理：数据根本不经过用户态，直接从内核缓冲区进入到 Socket Buffer，由于和用户态完全无关，就减少了两次上下文切换</p>
<p>说明：零拷贝技术是不允许进程对文件内容作进一步的加工的，比如压缩数据再发送</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/IO-sendfile%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p>
<p>sendfile2.4 之后，sendfile 实现了更简单的方式，文件到达内核缓冲区后，不必再将数据全部复制到 socket buffer 缓冲区，而是只<strong>将记录数据位置和长度相关等描述符信息</strong>保存到 socket buffer，DMA 根据 Socket 缓冲区中描述符提供的位置和偏移量信息直接将内核空间缓冲区中的数据拷贝到协议引擎上（2 次复制 2 次切换）</p>
<p>Java NIO 对 sendfile 的支持是 <code>FileChannel.transferTo()/transferFrom()</code>，把磁盘文件读取 OS 内核缓冲区后的 fileChannel，直接转给 socketChannel 发送，底层就是 sendfile</p>
<p>参考文章：<a href="https://blog.csdn.net/hancoder/article/details/112149121">https://blog.csdn.net/hancoder/article/details/112149121</a></p>
<hr>
<h2 id="BIO-1"><a href="#BIO-1" class="headerlink" title="BIO"></a>BIO</h2><h3 id="Inet"><a href="#Inet" class="headerlink" title="Inet"></a>Inet</h3><p>一个 InetAddress 类的对象就代表一个 IP 地址对象</p>
<p>成员方法：</p>
<ul>
<li><code>static InetAddress getLocalHost()</code>：获得本地主机 IP 地址对象</li>
<li><code>static InetAddress getByName(String host)</code>：根据 IP 地址字符串或主机名获得对应的 IP 地址对象</li>
<li><code>String getHostName()</code>：获取主机名</li>
<li><code>String getHostAddress()</code>：获得 IP 地址字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InetAddressDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取本机地址对象</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(ip.getHostName());<span class="comment">//DESKTOP-NNMBHQR</span></span><br><span class="line">        System.out.println(ip.getHostAddress());<span class="comment">//192.168.11.1</span></span><br><span class="line">        <span class="comment">// 2.获取域名ip对象</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(ip2.getHostName());<span class="comment">//www.baidu.com</span></span><br><span class="line">        System.out.println(ip2.getHostAddress());<span class="comment">//14.215.177.38</span></span><br><span class="line">        <span class="comment">// 3.获取公网IP对象。</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip3</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;182.61.200.6&quot;</span>);</span><br><span class="line">        System.out.println(ip3.getHostName());<span class="comment">//182.61.200.6</span></span><br><span class="line">        System.out.println(ip3.getHostAddress());<span class="comment">//182.61.200.6</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4.判断是否能通： ping  5s之前测试是否可通</span></span><br><span class="line">        System.out.println(ip2.isReachable(<span class="number">5000</span>)); <span class="comment">// ping百度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>UDP（User Datagram Protocol）协议的特点：</p>
<ul>
<li>面向无连接的协议，发送端只管发送，不确认对方是否能收到，速度快，但是不可靠，会丢失数据</li>
<li>尽最大努力交付，没有拥塞控制</li>
<li>基于数据包进行数据传输，发送数据的包的大小限制 <strong>64KB</strong> 以内</li>
<li>支持一对一、一对多、多对一、多对多的交互通信</li>
</ul>
<p>UDP 协议的使用场景：在线视频、网络语音、电话</p>
<hr>
<h4 id="实现UDP"><a href="#实现UDP" class="headerlink" title="实现UDP"></a>实现UDP</h4><p>UDP 协议相关的两个类：</p>
<ul>
<li>DatagramPacket（数据包对象）：用来封装要发送或要接收的数据，比如：集装箱</li>
<li>DatagramSocket（发送对象）：用来发送或接收数据包，比如：码头</li>
</ul>
<p><strong>DatagramPacket</strong>：</p>
<ul>
<li><p>DatagramPacket 类：</p>
<p><code>public new DatagramPacket(byte[] buf, int length, InetAddress address, int port)</code>：创建发送端数据包对象 </p>
<ul>
<li>buf：要发送的内容，字节数组</li>
<li>length：要发送内容的长度，单位是字节</li>
<li>address：接收端的IP地址对象</li>
<li>port：接收端的端口号</li>
</ul>
<p><code>public new DatagramPacket(byte[] buf, int length)</code>：创建接收端的数据包对象</p>
<ul>
<li>buf：用来存储接收到内容		</li>
<li>length：能够接收内容的长度</li>
</ul>
</li>
<li><p>DatagramPacket 类常用方法：</p>
<ul>
<li><code>public int getLength()</code>：获得实际接收到的字节个数</li>
<li><code>public byte[] getData()</code>：返回数据缓冲区</li>
</ul>
</li>
</ul>
<p><strong>DatagramSocket</strong>：</p>
<ul>
<li>DatagramSocket 类构造方法：<ul>
<li><code>protected DatagramSocket()</code>：创建发送端的 Socket 对象，系统会随机分配一个端口号</li>
<li><code>protected DatagramSocket(int port)</code>：创建接收端的 Socket 对象并指定端口号</li>
</ul>
</li>
<li>DatagramSocket 类成员方法：<ul>
<li><code>public void send(DatagramPacket dp)</code>：发送数据包</li>
<li><code>public void receive(DatagramPacket p)</code>：接收数据包</li>
<li><code>public void close()</code>：关闭数据报套接字</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===启动客户端===&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建一个集装箱对象，用于封装需要发送的数据包!</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="string">&quot;我学Java&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,bubffer.length,InetAddress.getLoclHost,<span class="number">8000</span>);</span><br><span class="line">        <span class="comment">// 2.创建一个码头对象</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">// 3.开始发送数据包对象</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPServerDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==启动服务端程序==&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建一个接收客户都端的数据包对象（集装箱）</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, bubffer.length);</span><br><span class="line">        <span class="comment">// 2.创建一个接收端的码头对象</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8000</span>);</span><br><span class="line">        <span class="comment">// 3.开始接收</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line">        <span class="comment">// 4.从集装箱中获取本次读取的数据量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line">        <span class="comment">// 5.输出数据</span></span><br><span class="line">        <span class="comment">// String rs = new String(socket.getData(), 0, len)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer , <span class="number">0</span> , len);</span><br><span class="line">        System.out.println(rs);</span><br><span class="line">        <span class="comment">// 6.服务端还可以获取发来信息的客户端的IP和端口。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> packet.getAddress().getHostAdress();</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> packet.getPort();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="通讯方式"><a href="#通讯方式" class="headerlink" title="通讯方式"></a>通讯方式</h4><p>UDP 通信方式：</p>
<ul>
<li><p>单播：用于两个主机之间的端对端通信</p>
</li>
<li><p>组播：用于对一组特定的主机进行通信</p>
<p>IP : 224.0.1.0</p>
<p>Socket 对象 : MulticastSocket</p>
</li>
<li><p>广播：用于一个主机对整个局域网上所有主机上的数据通信</p>
<p>IP : 255.255.255.255</p>
<p>Socket 对象 : DatagramSocket</p>
</li>
</ul>
<hr>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>TCP&#x2F;IP (Transfer Control Protocol) 协议，传输控制协议</p>
<p>TCP&#x2F;IP 协议的特点：</p>
<ul>
<li>面向连接的协议，提供可靠交互，速度慢</li>
<li>点对点的全双工通信</li>
<li>通过<strong>三次握手</strong>建立连接，连接成功形成数据传输通道；通过<strong>四次挥手</strong>断开连接</li>
<li>基于字节流进行数据传输，传输数据大小没有限制</li>
</ul>
<p>TCP 协议的使用场景：文件上传和下载、邮件发送和接收、远程登录</p>
<p>注意：<strong>TCP 不会为没有数据的 ACK 超时重传</strong></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/三次握手.png" alt="三次握手" style="zoom: 50%;">

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/四次挥手.png" alt="四次挥手" style="zoom: 67%;">

<p>推荐阅读：<a href="https://yuanrengu.com/2020/77eef79f.html">https://yuanrengu.com/2020/77eef79f.html</a></p>
<hr>
<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>TCP 通信也叫 <strong>Socket 网络编程</strong>，只要代码基于 Socket 开发，底层就是基于了可靠传输的 TCP 通信</p>
<p>双向通信：Java Socket 是全双工的，在任意时刻，线路上存在 <code>A -&gt; B</code> 和 <code>B -&gt; A</code> 的双向信号传输，即使是阻塞 IO，读和写也是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读</p>
<p>TCP 协议相关的类：</p>
<ul>
<li>Socket：一个该类的对象就代表一个客户端程序。</li>
<li>ServerSocket：一个该类的对象就代表一个服务器端程序。</li>
</ul>
<p>Socket 类：</p>
<ul>
<li><p>构造方法：</p>
<ul>
<li><p><code>Socket(InetAddress address,int port)</code>：创建流套接字并将其连接到指定 IP 指定端口号</p>
</li>
<li><p><code>Socket(String host, int port)</code>：根据 IP 地址字符串和端口号创建客户端 Socket 对象</p>
<p>注意事项：<strong>执行该方法，就会立即连接指定的服务器，连接成功，则表示三次握手通过</strong>，反之抛出异常</p>
</li>
</ul>
</li>
<li><p>常用 API：</p>
<ul>
<li><code>OutputStream getOutputStream()</code>：获得字节输出流对象</li>
<li><code>InputStream getInputStream()</code>：获得字节输入流对象</li>
<li><code>void shutdownInput()</code>：停止接受</li>
<li><code>void shutdownOutput()</code>：停止发送数据，终止通信</li>
<li><code>SocketAddress getRemoteSocketAddress() </code>：返回套接字连接到的端点的地址，未连接返回 null</li>
</ul>
</li>
</ul>
<p>ServerSocket 类：</p>
<ul>
<li><p>构造方法：<code>public ServerSocket(int port)</code></p>
</li>
<li><p>常用 API：<code>public Socket accept()</code>，<strong>阻塞等待</strong>接收一个客户端的 Socket 管道连接请求，连接成功返回一个 Socket 对象</p>
<p>三次握手后 TCP 连接建立成功，服务器内核会把连接从 SYN 半连接队列（一次握手时在服务端建立的队列）中移出，移入 accept 全连接队列，等待进程调用 accept 函数时把连接取出。如果进程不能及时调用 accept 函数，就会造成 accept 队列溢出，最终导致建立好的 TCP 连接被丢弃</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/Netty-TCP三次握手.png" style="zoom:67%;"></li>
</ul>
<p><strong>相当于</strong>客户端和服务器建立一个数据管道（虚连接，不是真正的物理连接），管道一般不用 close</p>
<hr>
<h4 id="实现TCP"><a href="#实现TCP" class="headerlink" title="实现TCP"></a>实现TCP</h4><h5 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h5><p>客户端的开发流程：</p>
<ol>
<li>客户端要请求于服务端的 Socket 管道连接</li>
<li>从 Socket 通信管道中得到一个字节输出流</li>
<li>通过字节输出流给服务端写出数据</li>
</ol>
<p>服务端的开发流程：</p>
<ol>
<li>用 ServerSocket 注册端口</li>
<li>接收客户端的 Socket 管道连接</li>
<li>从 Socket 通信管道中得到一个字节输入流</li>
<li>从字节输入流中读取客户端发来的数据</li>
</ol>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/BIO%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.png"></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/TCP-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B.png"></p>
<ul>
<li>如果输出缓冲区空间不够存放主机发送的数据，则会被阻塞，输入缓冲区同理</li>
<li>缓冲区不属于应用程序，属于内核</li>
<li>TCP 从输出缓冲区读取数据会加锁阻塞线程</li>
</ul>
<hr>
<h5 id="实现通信"><a href="#实现通信" class="headerlink" title="实现通信"></a>实现通信</h5><p>需求一：客户端发送一行数据，服务端接收一行数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.客户端要请求于服务端的socket管道连接。</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 2.从socket通信管道中得到一个字节输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 3.把低级的字节输出流包装成高级的打印流。</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">        <span class="comment">// 4.开始发消息出去</span></span><br><span class="line">        ps.println(<span class="string">&quot;我是客户端&quot;</span>);</span><br><span class="line">        ps.flush();<span class="comment">//一般不关闭IO流</span></span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送完毕~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----服务端启动----&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.注册端口: public ServerSocket(int port)</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 2.开始等待接收客户端的Socket管道连接。</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="comment">// 3.从socket通信管道中得到一个字节输入流。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">// 4.把字节输入流转换成字符输入流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">        <span class="comment">// 6.按照行读取消息 。</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">if</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>需求二：客户端可以反复发送数据，服务端可以反复数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.客户端要请求于服务端的socket管道连接。</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 2.从socket通信管道中得到一个字节输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 3.把低级的字节输出流包装成高级的打印流。</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">        <span class="comment">// 4.开始发消息出去</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.print(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">            ps.println(sc.nextLine());</span><br><span class="line">            ps.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----服务端启动----&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.注册端口: public ServerSocket(int port)</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 2.开始等待接收客户端的Socket管道连接。</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="comment">// 3.从socket通信管道中得到一个字节输入流。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">// 4.把字节输入流转换成字符输入流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">        <span class="comment">// 6.按照行读取消息 。</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>需求三：实现一个服务端可以同时接收多个客户端的消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">socket</span>.getOutputStream();</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.print(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">            ps.println(sc.nextLine());</span><br><span class="line">            ps.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----服务端启动----&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 开始等待接收客户端的Socket管道连接。</span></span><br><span class="line">             <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="comment">// 每接收到一个客户端必须为这个客户端管道分配一个独立的线程来处理与之通信。</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServerReaderThread</span>(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    privat Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;<span class="built_in">this</span>.socket = socket;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">           	<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is))</span><br><span class="line">           )&#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                sout(socket.getRemoteSocketAddress() + <span class="string">&quot;:&quot;</span> + line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            sout(socket.getRemoteSocketAddress() + <span class="string">&quot;下线了~~~~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="伪异步"><a href="#伪异步" class="headerlink" title="伪异步"></a>伪异步</h5><p>一个客户端要一个线程，并发越高系统瘫痪的越快，可以在服务端引入线程池，使用线程池来处理与客户端的消息通信</p>
<ul>
<li><p>优势：不会引起系统的死机，可以控制并发线程的数量</p>
</li>
<li><p>劣势：同时可以并发的线程将受到限制</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//线程池机制</span></span><br><span class="line">        <span class="comment">//创建一个线程池，如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">newCachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器启动了&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程名字 = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;等待连接....&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;连接到一个客户端&quot;</span>);</span><br><span class="line">            <span class="comment">//创建一个线程，与之通讯</span></span><br><span class="line">            newCachedThreadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">//可以和客户端通讯</span></span><br><span class="line">                    handler(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个handler方法，和客户端通讯</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程名字 = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket获取输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="comment">//循环的读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程名字 = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">//输出客户端发送的数据</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, read));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭和client的连接&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h4><h5 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h5><p>客户端：本地图片:  ‪E:\seazean\图片资源\beautiful.jpg<br>服务端：服务器路径：E:\seazean\图片服务器</p>
<p>UUID. randomUUID() : 方法生成随机的文件名</p>
<p>**socket.shutdownOutput()**：这个必须执行，不然服务器会一直循环等待数据，最后文件损坏，程序报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常量包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SRC_IMAGE</span> <span class="operator">=</span> <span class="string">&quot;D:\\seazean\\图片资源\\beautiful.jpg&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVER_DIR</span> <span class="operator">=</span> <span class="string">&quot;D:\\seazean\\图片服务器\\&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVER_IP</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SERVER_PORT</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(Constants.ERVER_IP,Constants.SERVER_PORT);</span><br><span class="line">        BufferedOutputStream bos=<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(socket.getOutputStream());</span><br><span class="line">        <span class="comment">//提取本机的图片上传给服务端。Constants.SRC_IMAGE</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>());</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len ;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(buffer, <span class="number">0</span> ,len);</span><br><span class="line">        &#125;</span><br><span class="line">        bos.flush();<span class="comment">// 刷新图片数据到服务端！！</span></span><br><span class="line">        socket.shutdownOutput();<span class="comment">// 告诉服务端我的数据已经发送完毕，不要在等我了！</span></span><br><span class="line">        bis.close();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//等待着服务端的响应数据！！</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">           				 <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        System.out.println(<span class="string">&quot;收到服务端响应：&quot;</span>+br.readLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----服务端启动----&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.注册端口: </span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(Constants.SERVER_PORT);</span><br><span class="line">        <span class="comment">// 2.定义一个循环不断的接收客户端的连接请求</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 3.开始等待接收客户端的Socket管道连接。</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="comment">// 4.每接收到一个客户端必须为这个客户端管道分配一个独立的线程来处理与之通信。</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServerReaderThread</span>(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;<span class="built_in">this</span>.socket = socket;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">           	<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(is);</span><br><span class="line">            <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileOutputStream</span></span><br><span class="line">                (Constants.SERVER_DIR+UUID.randomUUID().toString()+<span class="string">&quot;.jpg&quot;</span>));</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            bos.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端接收完毕了！&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4.响应数据给客户端</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(socket.getOutputStream());</span><br><span class="line">            ps.println(<span class="string">&quot;您好，已成功接收您上传的图片！&quot;</span>);</span><br><span class="line">            ps.flush();</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            sout(socket.getRemoteSocketAddress() + <span class="string">&quot;下线了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h5><p>构造方法：</p>
<ul>
<li><code>DataOutputStream(OutputStream out)</code> : 创建一个新的数据输出流，以将数据写入指定的底层输出流</li>
<li><code>DataInputStream(InputStream in) </code> : 创建使用指定的底层 InputStream 的 DataInputStream</li>
</ul>
<p>常用API：</p>
<ul>
<li><code>final void writeUTF(String str)</code> : 使用机器无关的方式使用 UTF-8 编码将字符串写入底层输出流</li>
<li><code>final String readUTF()</code> : 读取以 modified UTF-8 格式编码的 Unicode 字符串，返回 String 类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line">            <span class="comment">//  1、请求与服务端的Socket链接</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span> , <span class="number">8888</span>);</span><br><span class="line">            <span class="comment">//  2、把字节输出流包装成一个数据输出流</span></span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">//  3、先发送上传文件的后缀给服务端</span></span><br><span class="line">            dos.writeUTF(<span class="string">&quot;.png&quot;</span>);</span><br><span class="line">            <span class="comment">//  4、把文件数据发送给服务端进行接收</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">                dos.write(buffer , <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">            dos.flush();</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"> 		<span class="comment">// 1、得到一个数据输入流读取客户端发送过来的数据</span></span><br><span class="line">		<span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(socket.getInputStream());</span><br><span class="line">		<span class="comment">// 2、读取客户端发送过来的文件类型</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">		<span class="comment">// 3、定义一个字节输出管道负责把客户端发来的文件数据写出去</span></span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;path&quot;</span>+</span><br><span class="line">                    UUID.randomUUID().toString()+suffix);</span><br><span class="line">		<span class="comment">// 4、从数据输入流中读取文件数据，写出到字节输出流中去</span></span><br><span class="line">		<span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="type">int</span> len;</span><br><span class="line">		<span class="keyword">while</span>((len = dis.read(buffer)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line"> 			os.write(buffer,<span class="number">0</span>, len);</span><br><span class="line">		&#125;</span><br><span class="line">		os.close();</span><br><span class="line">		System.out.println(<span class="string">&quot;服务端接收文件保存成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>NIO的介绍</strong>：</p>
<p>Java NIO（New IO、Java non-blocking IO），从 Java 1.4 版本开始引入的一个新的 IO API，可以替代标准的 Java IO API，NIO 支持面向缓冲区的、基于通道的 IO 操作，以更加高效的方式进行文件的读写操作</p>
<ul>
<li>NIO 有三大核心部分：<strong>Channel（通道），Buffer（缓冲区），Selector（选择器）</strong></li>
<li>NIO 是非阻塞 IO，传统 IO 的 read 和 write 只能阻塞执行，线程在读写 IO 期间不能干其他事情，比如调用 socket.accept()，如果服务器没有数据传输过来，线程就一直阻塞，而 NIO 中可以配置 Socket 为非阻塞模式</li>
<li>NIO 可以做到用一个线程来处理多个操作的。假设有 1000 个请求过来，根据实际情况可以分配 20 或者 80 个线程来处理，不像之前的阻塞 IO 那样分配 1000 个</li>
</ul>
<p>NIO 和 BIO 的比较：</p>
<ul>
<li><p>BIO 以流的方式处理数据，而 NIO 以块的方式处理数据，块 I&#x2F;O 的效率比流 I&#x2F;O 高很多</p>
</li>
<li><p>BIO 是阻塞的，NIO 则是非阻塞的</p>
</li>
<li><p>BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel 和 Buffer 进行操作，数据从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector 用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道</p>
<table>
<thead>
<tr>
<th>NIO</th>
<th>BIO</th>
</tr>
</thead>
<tbody><tr>
<td>面向缓冲区（Buffer）</td>
<td>面向流（Stream）</td>
</tr>
<tr>
<td>非阻塞（Non Blocking IO）</td>
<td>阻塞IO(Blocking IO)</td>
</tr>
<tr>
<td>选择器（Selectors）</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h3 id="实现原理-9"><a href="#实现原理-9" class="headerlink" title="实现原理"></a>实现原理</h3><p>NIO 三大核心部分：Channel (通道)、Buffer (缓冲区)、Selector (选择器)</p>
<ul>
<li><p>Buffer 缓冲区</p>
<p>缓冲区本质是一块可以写入数据、读取数据的内存，<strong>底层是一个数组</strong>，这块内存被包装成 NIO Buffer 对象，并且提供了方法用来操作这块内存，相比较直接对数组的操作，Buffer 的 API 更加容易操作和管理</p>
</li>
<li><p>Channel 通道</p>
<p>Java NIO 的通道类似流，不同的是既可以从通道中读取数据，又可以写数据到通道，流的读写通常是单向的，通道可以非阻塞读取和写入通道，支持读取或写入缓冲区，也支持异步地读写</p>
</li>
<li><p>Selector 选择器</p>
<p>Selector 是一个 Java NIO 组件，能够检查一个或多个 NIO 通道，并确定哪些通道已经准备好进行读取或写入，这样一个单独的线程可以管理多个 channel，从而管理多个网络连接，提高效率</p>
</li>
</ul>
<p>NIO 的实现框架：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/NIO%E6%A1%86%E6%9E%B6.png"></p>
<ul>
<li>每个 Channel 对应一个 Buffer</li>
<li>一个线程对应 Selector ， 一个 Selector 对应多个 Channel（连接）</li>
<li>程序切换到哪个 Channel 是由事件决定的，Event 是一个重要的概念</li>
<li>Selector 会根据不同的事件，在各个通道上切换</li>
<li>Buffer 是一个内存块 ， 底层是一个数组</li>
<li>数据的读取写入是通过 Buffer 完成的 , BIO 中要么是输入流，或者是输出流，不能双向，NIO 的 Buffer 是可以读也可以写， flip() 切换 Buffer 的工作模式</li>
</ul>
<p>Java NIO 系统的核心在于：通道和缓冲区，通道表示打开的 IO 设备（例如：文件、 套接字）的连接。若要使用 NIO 系统，获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区，然后操作缓冲区，对数据进行处理。简而言之，Channel 负责传输， Buffer 负责存取数据</p>
<hr>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><h4 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>缓冲区（Buffer）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，用于特定基本数据类型的容器，用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/NIO-Buffer.png"></p>
<p><strong>Buffer 底层是一个数组</strong>，可以保存多个相同类型的数据，根据数据类型不同 ，有以下 Buffer 常用子类：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer </p>
<hr>
<h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><ul>
<li><p>容量（capacity）：作为一个内存块，Buffer 具有固定大小，缓冲区容量不能为负，并且创建后不能更改</p>
</li>
<li><p>限制 （limit）：表示缓冲区中可以操作数据的大小（limit 后数据不能进行读写），缓冲区的限制不能为负，并且不能大于其容量。写入模式，limit 等于 buffer 的容量；读取模式下，limit 等于写入的数据量</p>
</li>
<li><p>位置（position）：<strong>下一个要读取或写入的数据的索引</strong>，缓冲区的位置不能为负，并且不能大于其限制</p>
</li>
<li><p>标记（mark）与重置（reset）：标记是一个索引，通过 Buffer 中的 mark() 方法指定 Buffer 中一个特定的位置，可以通过调用 reset() 方法恢复到这个 position</p>
</li>
<li><p>位置、限制、容量遵守以下不变式： <strong>0 &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</strong></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/NIO-Buffer操作.png" style="zoom:67%;"></li>
</ul>
<hr>
<h4 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h4><p><code>static XxxBuffer allocate(int capacity)</code>：创建一个容量为 capacity 的 XxxBuffer 对象</p>
<p>Buffer 基本操作：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Buffer clear()</td>
<td>清空缓冲区，不清空内容，将位置设置为零，限制设置为容量</td>
</tr>
<tr>
<td>public Buffer flip()</td>
<td>翻转缓冲区，将缓冲区的界限设置为当前位置，position 置 0</td>
</tr>
<tr>
<td>public int capacity()</td>
<td>返回 Buffer的 capacity 大小</td>
</tr>
<tr>
<td>public final int limit()</td>
<td>返回 Buffer 的界限 limit 的位置</td>
</tr>
<tr>
<td>public Buffer limit(int n)</td>
<td>设置缓冲区界限为 n</td>
</tr>
<tr>
<td>public Buffer mark()</td>
<td>在此位置对缓冲区设置标记</td>
</tr>
<tr>
<td>public final int position()</td>
<td>返回缓冲区的当前位置 position</td>
</tr>
<tr>
<td>public Buffer position(int n)</td>
<td>设置缓冲区的当前位置为n</td>
</tr>
<tr>
<td>public Buffer reset()</td>
<td>将位置 position 重置为先前 mark 标记的位置</td>
</tr>
<tr>
<td>public Buffer rewind()</td>
<td>将位置设为为 0，取消设置的 mark</td>
</tr>
<tr>
<td>public final int remaining()</td>
<td>返回当前位置 position 和 limit 之间的元素个数</td>
</tr>
<tr>
<td>public final boolean hasRemaining()</td>
<td>判断缓冲区中是否还有元素</td>
</tr>
<tr>
<td>public static ByteBuffer wrap(byte[] array)</td>
<td>将一个字节数组包装到缓冲区中</td>
</tr>
<tr>
<td>abstract ByteBuffer asReadOnlyBuffer()</td>
<td>创建一个新的只读字节缓冲区</td>
</tr>
<tr>
<td>public abstract ByteBuffer compact()</td>
<td>缓冲区当前位置与其限制（如果有）之间的字节被复制到缓冲区的开头</td>
</tr>
</tbody></table>
<p>Buffer 数据操作：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public abstract byte get()</td>
<td>读取该缓冲区当前位置的单个字节，然后位置 + 1</td>
</tr>
<tr>
<td>public ByteBuffer get(byte[] dst)</td>
<td>读取多个字节到字节数组 dst 中</td>
</tr>
<tr>
<td>public abstract byte get(int index)</td>
<td>读取指定索引位置的字节，不移动 position</td>
</tr>
<tr>
<td>public abstract ByteBuffer put(byte b)</td>
<td>将给定单个字节写入缓冲区的当前位置，position+1</td>
</tr>
<tr>
<td>public final ByteBuffer put(byte[] src)</td>
<td>将 src 字节数组写入缓冲区的当前位置</td>
</tr>
<tr>
<td>public abstract ByteBuffer put(int index, byte b)</td>
<td>将指定字节写入缓冲区的索引位置，不移动 position</td>
</tr>
</tbody></table>
<p>提示：”\n”，占用两个字节</p>
<hr>
<h4 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h4><p>使用 Buffer 读写数据一般遵循以下四个步骤：</p>
<ul>
<li>写入数据到 Buffer</li>
<li>调用 flip()方法，转换为读取模式</li>
<li>从 Buffer 中读取数据</li>
<li>调用 buffer.clear() 方法清除缓冲区（不是清空了数据，只是重置指针）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBuffer</span> &#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;seazean&quot;</span>;</span><br><span class="line">		<span class="comment">//1. 分配一个指定大小的缓冲区</span></span><br><span class="line">		<span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------allocate()----------------&quot;</span>);</span><br><span class="line">		System.out.println(bufferf.position());<span class="comment">//0</span></span><br><span class="line">		System.out.println(buffer.limit());<span class="comment">//1024</span></span><br><span class="line">		System.out.println(buffer.capacity());<span class="comment">//1024</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 利用 put() 存入数据到缓冲区中</span></span><br><span class="line">      	buffer.put(str.getBytes());</span><br><span class="line">     	System.out.println(<span class="string">&quot;-----------------put()----------------&quot;</span>);</span><br><span class="line">		System.out.println(bufferf.position());<span class="comment">//7</span></span><br><span class="line">		System.out.println(buffer.limit());<span class="comment">//1024</span></span><br><span class="line">		System.out.println(buffer.capacity());<span class="comment">//1024</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 切换读取数据模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------flip()----------------&quot;</span>);</span><br><span class="line">        System.out.println(buffer.position());<span class="comment">//0</span></span><br><span class="line">        System.out.println(buffer.limit());<span class="comment">//7</span></span><br><span class="line">        System.out.println(buffer.capacity());<span class="comment">//1024</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4. 利用 get() 读取缓冲区中的数据</span></span><br><span class="line">        <span class="type">byte</span>[] dst = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.limit()];</span><br><span class="line">        buffer.get(dst);</span><br><span class="line">        System.out.println(dst.length);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(dst, <span class="number">0</span>, dst.length));</span><br><span class="line">        System.out.println(buffer.position());<span class="comment">//7</span></span><br><span class="line">        System.out.println(buffer.limit());<span class="comment">//7</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">//5. clear() : 清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态</span></span><br><span class="line">        System.out.println(buffer.hasRemaining());<span class="comment">//true</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">        System.out.println(buffer.hasRemaining());<span class="comment">//true</span></span><br><span class="line">      	System.out.println(<span class="string">&quot;-----------------clear()----------------&quot;</span>);</span><br><span class="line">      	System.out.println(buffer.position());<span class="comment">//0</span></span><br><span class="line">      	System.out.println(buffer.limit());<span class="comment">//1024</span></span><br><span class="line">      	System.out.println(buffer.capacity());<span class="comment">//1024</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="粘包拆包"><a href="#粘包拆包" class="headerlink" title="粘包拆包"></a>粘包拆包</h4><p>网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔，但这些数据在接收时，被进行了重新组合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hello,world\n</span></span><br><span class="line"><span class="comment">// I&#x27;m zhangsan\n</span></span><br><span class="line"><span class="comment">// How are you?\n</span></span><br><span class="line">------ &gt; 黏包，半包</span><br><span class="line"><span class="comment">// Hello,world\nI&#x27;m zhangsan\nHo</span></span><br><span class="line"><span class="comment">// w are you?\n</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">source</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">    <span class="comment">//                     11            24</span></span><br><span class="line">    source.put(<span class="string">&quot;Hello,world\nI&#x27;m zhangsan\nHo&quot;</span>.getBytes());</span><br><span class="line">    split(source);</span><br><span class="line"></span><br><span class="line">    source.put(<span class="string">&quot;w are you?\nhaha!\n&quot;</span>.getBytes());</span><br><span class="line">    split(source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span> &#123;</span><br><span class="line">    source.flip();</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldLimit</span> <span class="operator">=</span> source.limit();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; oldLimit; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据数据的长度设置缓冲区</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(i + <span class="number">1</span> - source.position());</span><br><span class="line">            <span class="comment">// 0 ~ limit</span></span><br><span class="line">            source.limit(i + <span class="number">1</span>);</span><br><span class="line">            target.put(source); <span class="comment">// 从source 读，向 target 写</span></span><br><span class="line">            <span class="comment">// debugAll(target); 访问 buffer 的方法</span></span><br><span class="line">            source.limit(oldLimit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问过的数据复制到开头</span></span><br><span class="line">    source.compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><h4 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Byte Buffer 有两种类型，一种是基于直接内存（也就是非堆内存），另一种是非直接内存（也就是堆内存）</p>
<p>Direct Memory 优点：</p>
<ul>
<li>Java 的 NIO 库允许 Java 程序使用直接内存，使用 native 函数直接分配堆外内存</li>
<li><strong>读写性能高</strong>，读写频繁的场合可能会考虑使用直接内存</li>
<li>大大提高 IO 性能，避免了在 Java 堆和 native 堆来回复制数据</li>
</ul>
<p>直接内存缺点：</p>
<ul>
<li>不能使用内核缓冲区 Page Cache 的缓存优势，无法缓存最近被访问的数据和使用预读功能</li>
<li>分配回收成本较高，不受 JVM 内存回收管理</li>
<li>可能导致 OutOfMemoryError 异常：OutOfMemoryError: Direct buffer memory</li>
<li>回收依赖 System.gc() 的调用，但这个调用 JVM 不保证执行、也不保证何时执行，行为是不可控的。程序一般需要自行管理，成对去调用 malloc、free</li>
</ul>
<p>应用场景：</p>
<ul>
<li>传输很大的数据文件，数据的生命周期很长，导致 Page Cache 没有起到缓存的作用，一般采用直接 IO 的方式</li>
<li>适合频繁的 IO 操作，比如网络并发场景</li>
</ul>
<p>数据流的角度：</p>
<ul>
<li>非直接内存的作用链：本地 IO → 内核缓冲区→ 用户（JVM）缓冲区 →内核缓冲区 → 本地 IO</li>
<li>直接内存是：本地 IO → 直接内存 → 本地 IO</li>
</ul>
<p>JVM 直接内存图解：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-直接内存直接缓冲区.png" style="zoom: 50%;">

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-直接内存非直接缓冲区.png" style="zoom:50%;">





<hr>
<h4 id="通信原理"><a href="#通信原理" class="headerlink" title="通信原理"></a>通信原理</h4><p>堆外内存不受 JVM GC 控制，可以使用堆外内存进行通信，防止 GC 后缓冲区位置发生变化的情况</p>
<p>NIO 使用的 SocketChannel 也是使用的堆外内存，源码解析：</p>
<ul>
<li><p>SocketChannel#write(java.nio.ByteBuffer) → SocketChannelImpl#write(java.nio.ByteBuffer)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">write</span><span class="params">(ByteBuffer var1)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">         var3 = IOUtil.write(<span class="built_in">this</span>.fd, var1, -<span class="number">1L</span>, nd);</span><br><span class="line">     &#125; <span class="keyword">while</span>(var3 == -<span class="number">3</span> &amp;&amp; <span class="built_in">this</span>.isOpen());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>IOUtil#write(java.io.FileDescriptor, java.nio.ByteBuffer, long, sun.nio.ch.NativeDispatcher)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">write</span><span class="params">(FileDescriptor var0, ByteBuffer var1, <span class="type">long</span> var2, NativeDispatcher var4)</span> &#123;</span><br><span class="line">    <span class="comment">// 【判断是否是直接内存，是则直接写出，不是则封装到直接内存】</span></span><br><span class="line">    <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> DirectBuffer) &#123;</span><br><span class="line">        <span class="keyword">return</span> writeFromNativeBuffer(var0, var1, var2, var4);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">        <span class="comment">// 从堆内buffer拷贝到堆外buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">var8</span> <span class="operator">=</span> Util.getTemporaryDirectBuffer(var7);</span><br><span class="line">        var8.put(var1);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 从堆外写到内核缓冲区</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">var9</span> <span class="operator">=</span> writeFromNativeBuffer(var0, var8, var2, var4);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读操作相同</p>
</li>
</ul>
<hr>
<h4 id="分配回收"><a href="#分配回收" class="headerlink" title="分配回收"></a>分配回收</h4><p>直接内存创建 Buffer 对象：<code>static XxxBuffer allocateDirect(int capacity)</code></p>
<p>DirectByteBuffer 源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123; </span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 分配直接内存</span></span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内存赋值</span></span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建回收函数</span></span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Deallocator</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        unsafe.freeMemory(address);</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分配和回收原理</strong>：</p>
<ul>
<li>使用了 Unsafe 对象的 allocateMemory 方法完成直接内存的分配，setMemory 方法完成赋值</li>
<li>ByteBuffer 的实现类内部，使用了 Cleaner（虚引用）来监测 ByteBuffer 对象，一旦 ByteBuffer 对象被垃圾回收，那么 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 Deallocator 的 run方法，最后通过 freeMemory 来释放直接内存</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接内存分配的底层原理：Unsafe</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_27</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">_1Gb</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> getUnsafe();</span><br><span class="line">        <span class="comment">// 分配内存</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> unsafe.allocateMemory(_1Gb);</span><br><span class="line">        unsafe.setMemory(base, _1Gb, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        unsafe.freeMemory(base);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) f.get(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> unsafe;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>FileChannel 提供 map 方法返回 MappedByteBuffer 对象，把文件映射到内存，通常情况可以映射整个文件，如果文件比较大，可以进行分段映射，完成映射后对物理内存的操作会被<strong>同步</strong>到硬盘上</p>
<p>FileChannel 中的成员属性：</p>
<ul>
<li><p>MapMode.mode：内存映像文件访问的方式，共三种：</p>
<ul>
<li><code>MapMode.READ_ONLY</code>：只读，修改得到的缓冲区将导致抛出异常</li>
<li><code>MapMode.READ_WRITE</code>：读&#x2F;写，对缓冲区的更改最终将写入文件，但此次修改对映射到同一文件的其他程序不一定是可见</li>
<li><code>MapMode.PRIVATE</code>：私用，可读可写，但是修改的内容不会写入文件，只是 buffer 自身的改变</li>
</ul>
</li>
<li><p><code>public final FileLock lock()</code>：获取此文件通道的排他锁</p>
</li>
</ul>
<p>MappedByteBuffer，可以让文件在直接内存（堆外内存）中进行修改，这种方式叫做<strong>内存映射</strong>，可以直接调用系统底层的缓存，没有 JVM 和 OS 之间的复制操作，提高了传输效率，作用：</p>
<ul>
<li><strong>可以用于进程间的通信，能达到共享内存页的作用</strong>，但在高并发下要对文件内存进行加锁，防止出现读写内容混乱和不一致性，Java 提供了文件锁 FileLock，但在父&#x2F;子进程中锁定后另一进程会一直等待，效率不高</li>
<li>读写那些太大而不能放进内存中的文件，<strong>分段映射</strong></li>
</ul>
<p>MappedByteBuffer 较之 ByteBuffer 新增的三个方法：</p>
<ul>
<li><code>final MappedByteBuffer force()</code>：缓冲区是 READ_WRITE 模式下，对缓冲区内容的修改<strong>强制写入文件</strong></li>
<li><code>final MappedByteBuffer load()</code>：将缓冲区的内容载入物理内存，并返回该缓冲区的引用</li>
<li><code>final boolean isLoaded()</code>：如果缓冲区的内容在物理内存中，则返回真，否则返回假</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MappedByteBufferTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 读写模式</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">ra</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取对应的通道</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ra.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1	FileChannel.MapMode.READ_WRITE 使用的读写模式</span></span><br><span class="line"><span class="comment">         * 参数2	0: 文件映射时的起始位置</span></span><br><span class="line"><span class="comment">         * 参数3	5: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存</span></span><br><span class="line"><span class="comment">         * 可以直接修改的范围就是 0-5</span></span><br><span class="line"><span class="comment">         * 实际类型 DirectByteBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">MappedByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        buffer.put(<span class="number">0</span>, (<span class="type">byte</span>) <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">        buffer.put(<span class="number">3</span>, (<span class="type">byte</span>) <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">        buffer.put(<span class="number">5</span>, (<span class="type">byte</span>) <span class="string">&#x27;Y&#x27;</span>);	<span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"></span><br><span class="line">        ra.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;修改成功~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从硬盘上将文件读入内存，要经过文件系统进行数据拷贝，拷贝操作是由文件系统和硬件驱动实现。通过内存映射的方法访问硬盘上的文件，拷贝数据的效率要比 read 和 write 系统调用高：</p>
<ul>
<li>read() 是系统调用，首先将文件从硬盘拷贝到内核空间的一个缓冲区，再将这些数据拷贝到用户空间，实际上进行了两次数据拷贝</li>
<li>mmap() 也是系统调用，但没有进行数据拷贝，当缺页中断发生时，直接将文件从硬盘拷贝到共享内存，只进行了一次数据拷贝</li>
</ul>
<p>注意：mmap 的文件映射，在 Full GC 时才会进行释放，如果需要手动清除内存映射文件，可以反射调用 sun.misc.Cleaner 方法</p>
<p>参考文章：<a href="https://www.jianshu.com/p/f90866dcbffc">https://www.jianshu.com/p/f90866dcbffc</a></p>
<hr>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><h4 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>通道（Channel）：表示 IO 源与目标打开的连接，Channel 类似于传统的流，只不过 Channel 本身不能直接访问数据，Channel 只能与 Buffer <strong>进行交互</strong></p>
<ol>
<li><p>NIO 的通道类似于流，但有些区别如下：</p>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲</li>
</ul>
</li>
<li><p>BIO 中的 Stream 是单向的，NIO 中的 Channel 是双向的，可以读操作，也可以写操作</p>
</li>
<li><p>Channel 在 NIO 中是一个接口：<code>public interface Channel extends Closeable&#123;&#125;</code></p>
</li>
</ol>
<p>Channel 实现类：</p>
<ul>
<li><p>FileChannel：用于读取、写入、映射和操作文件的通道，<strong>只能工作在阻塞模式下</strong></p>
<ul>
<li>通过 FileInputStream 获取的 Channel 只能读</li>
<li>通过 FileOutputStream 获取的 Channel 只能写</li>
<li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定</li>
</ul>
</li>
<li><p>DatagramChannel：通过 UDP 读写网络中的数据通道</p>
</li>
<li><p>SocketChannel：通过 TCP 读写网络中的数据</p>
</li>
<li><p>ServerSocketChannel：可以<strong>监听</strong>新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel</p>
<p>提示：ServerSocketChanne 类似 ServerSocket、SocketChannel 类似 Socket</p>
</li>
</ul>
<hr>
<h4 id="常用API-2"><a href="#常用API-2" class="headerlink" title="常用API"></a>常用API</h4><p>获取 Channel 方式：</p>
<ul>
<li>对支持通道的对象调用 <code>getChannel()</code> 方法</li>
<li>通过通道的静态方法 <code>open()</code> 打开并返回指定通道</li>
<li>使用 Files 类的静态方法 <code>newByteChannel()</code> 获取字节通道</li>
</ul>
<p>Channel 基本操作：<strong>读写都是相对于内存来看，也就是缓冲区</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public abstract int read(ByteBuffer dst)</td>
<td>从 Channel 中读取数据到 ByteBuffer，从 position 开始储存</td>
</tr>
<tr>
<td>public final long read(ByteBuffer[] dsts)</td>
<td>将 Channel 中的数据分散到 ByteBuffer[]</td>
</tr>
<tr>
<td>public abstract int write(ByteBuffer src)</td>
<td>将 ByteBuffer 中的数据写入 Channel，从 position 开始写出</td>
</tr>
<tr>
<td>public final long write(ByteBuffer[] srcs)</td>
<td>将 ByteBuffer[] 到中的数据聚集到 Channel</td>
</tr>
<tr>
<td>public abstract long position()</td>
<td>返回此通道的文件位置</td>
</tr>
<tr>
<td>FileChannel position(long newPosition)</td>
<td>设置此通道的文件位置</td>
</tr>
<tr>
<td>public abstract long size()</td>
<td>返回此通道的文件的当前大小</td>
</tr>
</tbody></table>
<p><strong>SelectableChannel 的操作 API</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SocketChannel accept()</td>
<td>如果通道处于非阻塞模式，没有请求连接时此方法将立即返回 NULL，否则将阻塞直到有新的连接或发生 I&#x2F;O 错误，<strong>通过该方法返回的套接字通道将处于阻塞模式</strong></td>
</tr>
<tr>
<td>SelectionKey register(Selector sel, int ops)</td>
<td>将通道注册到选择器上，并指定监听事件</td>
</tr>
<tr>
<td>SelectionKey register(Selector sel, int ops, Object att)</td>
<td>将通道注册到选择器上，并在当前通道<strong>绑定一个附件对象</strong>，Object 代表可以是任何类型</td>
</tr>
</tbody></table>
<hr>
<h4 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"> 		<span class="comment">// 1、字节输出流通向目标文件</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data01.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、得到字节输出流对应的通道  【FileChannel】</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> fos.getChannel();</span><br><span class="line">        <span class="comment">// 3、分配缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        buffer.put(<span class="string">&quot;hello,黑马Java程序员！&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 4、把缓冲区切换成写出模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        channel.write(buffer);</span><br><span class="line">        channel.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;写数据到文件中！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、定义一个文件字节输入流与源文件接通</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data01.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、需要得到文件字节输入流的文件通道</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line">        <span class="comment">// 3、定义一个缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 4、读取数据到缓冲区</span></span><br><span class="line">        channel.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 5、读取出缓冲区中的数据并输出即可</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(),<span class="number">0</span>,buffer.remaining());</span><br><span class="line">        System.out.println(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h4><p>Channel 的方法：<strong>sendfile 实现零拷贝</strong></p>
<ul>
<li><p><code>abstract long transferFrom(ReadableByteChannel src, long position, long count)</code>：从给定的可读字节通道将字节传输到该通道的文件中</p>
<ul>
<li>src：源通道</li>
<li>position：文件中要进行传输的位置，必须是非负的 </li>
<li>count：要传输的最大字节数，必须是非负的</li>
</ul>
</li>
<li><p><code>abstract long transferTo(long position, long count, WritableByteChannel target)</code>：将该通道文件的字节传输到给定的可写字节通道。</p>
<ul>
<li>position：传输开始的文件中的位置; 必须是非负的 </li>
<li>count：要传输的最大字节数; 必须是非负的 </li>
<li>target：目标通道</li>
</ul>
</li>
</ul>
<p>文件复制的两种方式：</p>
<ol>
<li>Buffer</li>
<li>使用上述两种方法</li>
</ol>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/NIO-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copy1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\壁纸.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\壁纸new.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 得到一个字节字节输入流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        <span class="comment">// 得到一个字节输出流</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">        <span class="comment">// 得到的是文件通道</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">isChannel</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">osChannel</span> <span class="operator">=</span> fos.getChannel();</span><br><span class="line">        <span class="comment">// 分配缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 必须先清空缓冲然后再写入数据到缓冲区</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="comment">// 开始读取一次数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> isChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span>(flag == -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 已经读取了数据 ，把缓冲区的模式切换成可读模式</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// 把数据写出到</span></span><br><span class="line">            osChannel.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        isChannel.close();</span><br><span class="line">        osChannel.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;复制完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copy02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    	<span class="comment">// 1、字节输入管道</span></span><br><span class="line">   	 	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data01.txt&quot;</span>);</span><br><span class="line">   	 	<span class="type">FileChannel</span> <span class="variable">isChannel</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line">    	<span class="comment">// 2、字节输出流管道</span></span><br><span class="line">    	<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data03.txt&quot;</span>);</span><br><span class="line">    	<span class="type">FileChannel</span> <span class="variable">osChannel</span> <span class="operator">=</span> fos.getChannel();</span><br><span class="line">    	<span class="comment">// 3、复制</span></span><br><span class="line">    	osChannel.transferFrom(isChannel,isChannel.position(),isChannel.size());</span><br><span class="line">    	isChannel.close();</span><br><span class="line">    	osChannel.close();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copy03</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    	<span class="comment">// 1、字节输入管道</span></span><br><span class="line">    	<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data01.txt&quot;</span>);</span><br><span class="line">    	<span class="type">FileChannel</span> <span class="variable">isChannel</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line">    	<span class="comment">// 2、字节输出流管道</span></span><br><span class="line">    	<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data04.txt&quot;</span>);</span><br><span class="line">    	<span class="type">FileChannel</span> <span class="variable">osChannel</span> <span class="operator">=</span> fos.getChannel();</span><br><span class="line">    	<span class="comment">// 3、复制</span></span><br><span class="line">    	isChannel.transferTo(isChannel.position() , isChannel.size() , osChannel);</span><br><span class="line">    	isChannel.close();</span><br><span class="line">    	osChannel.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="分散聚集"><a href="#分散聚集" class="headerlink" title="分散聚集"></a>分散聚集</h4><p>分散读取（Scatter ）：是指把 Channel 通道的数据读入到多个缓冲区中去</p>
<p>聚集写入（Gathering ）：是指将多个 Buffer 中的数据聚集到 Channel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    	<span class="comment">// 1、字节输入管道</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data01.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">isChannel</span> <span class="operator">=</span> is.getChannel();</span><br><span class="line">        <span class="comment">// 2、字节输出流管道</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data02.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">osChannel</span> <span class="operator">=</span> fos.getChannel();</span><br><span class="line">        <span class="comment">// 3、定义多个缓冲区做数据分散</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        ByteBuffer[] buffers = &#123;buffer1 , buffer2&#125;;</span><br><span class="line">        <span class="comment">// 4、从通道中读取数据分散到各个缓冲区</span></span><br><span class="line">        isChannel.read(buffers);</span><br><span class="line">        <span class="comment">// 5、从每个缓冲区中查询是否有数据读取到了</span></span><br><span class="line">        <span class="keyword">for</span>(ByteBuffer buffer : buffers)&#123;</span><br><span class="line">            buffer.flip();<span class="comment">// 切换到读数据模式</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array() , <span class="number">0</span> , buffer.remaining()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6、聚集写入到通道</span></span><br><span class="line">        osChannel.write(buffers);</span><br><span class="line">        isChannel.close();</span><br><span class="line">        osChannel.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;文件复制~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>选择器（Selector） 是 SelectableChannle 对象的<strong>多路复用器</strong>，Selector 可以同时监控多个通道的状况，利用 Selector 可使一个单独的线程管理多个 Channel，<strong>Selector 是非阻塞 IO 的核心</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/NIO-Selector.png"></p>
<ul>
<li>Selector 能够检测多个注册的通道上是否有事件发生（多个 Channel 以事件的方式可以注册到同一个 Selector)，如果有事件发生，就获取事件然后针对每个事件进行相应的处理，就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求</li>
<li>只有在连接&#x2F;通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程</li>
<li>避免了多线程之间的上下文切换导致的开销</li>
</ul>
<hr>
<h4 id="常用API-3"><a href="#常用API-3" class="headerlink" title="常用API"></a>常用API</h4><p>创建 Selector：<code>Selector selector = Selector.open();</code></p>
<p>向选择器注册通道：<code>SelectableChannel.register(Selector sel, int ops, Object att)</code></p>
<ul>
<li>参数一：选择器，指定当前 Channel 注册到的选择器</li>
<li>参数二：选择器对通道的监听事件，监听的事件类型用四个常量表示<ul>
<li>读 : SelectionKey.OP_READ （1）</li>
<li>写 : SelectionKey.OP_WRITE （4）</li>
<li>连接 : SelectionKey.OP_CONNECT （8）</li>
<li>接收 : SelectionKey.OP_ACCEPT （16）</li>
<li>若不止监听一个事件，使用位或操作符连接：<code>int interest = SelectionKey.OP_READ | SelectionKey.OP_WRITE</code></li>
</ul>
</li>
<li>参数三：可以关联一个附件，可以是任何对象</li>
</ul>
<p><strong>Selector API</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static Selector open()</td>
<td>打开选择器</td>
</tr>
<tr>
<td>public abstract void close()</td>
<td>关闭此选择器</td>
</tr>
<tr>
<td>public abstract int select()</td>
<td><strong>阻塞</strong>选择一组通道准备好进行 I&#x2F;O 操作的键</td>
</tr>
<tr>
<td>public abstract int select(long timeout)</td>
<td><strong>阻塞</strong>等待 timeout 毫秒</td>
</tr>
<tr>
<td>public abstract int selectNow()</td>
<td>获取一下，<strong>不阻塞</strong>，立刻返回</td>
</tr>
<tr>
<td>public abstract Selector wakeup()</td>
<td>唤醒正在阻塞的 selector</td>
</tr>
<tr>
<td>public abstract Set<SelectionKey> selectedKeys()</SelectionKey></td>
<td>返回此选择器的选择键集</td>
</tr>
</tbody></table>
<p>SelectionKey API:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public abstract void cancel()</td>
<td>取消该键的通道与其选择器的注册</td>
</tr>
<tr>
<td>public abstract SelectableChannel channel()</td>
<td>返回创建此键的通道，该方法在取消键之后仍将返回通道</td>
</tr>
<tr>
<td>public final Object attachment()</td>
<td>返回当前 key 关联的附件</td>
</tr>
<tr>
<td>public final boolean isAcceptable()</td>
<td>检测此密钥的通道是否已准备好接受新的套接字连接</td>
</tr>
<tr>
<td>public final boolean isConnectable()</td>
<td>检测此密钥的通道是否已完成或未完成其套接字连接操作</td>
</tr>
<tr>
<td>public final boolean isReadable()</td>
<td>检测此密钥的频道是否可以阅读</td>
</tr>
<tr>
<td>public final boolean isWritable()</td>
<td>检测此密钥的通道是否准备好进行写入</td>
</tr>
</tbody></table>
<p>基本步骤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取通道</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"><span class="comment">//2.切换非阻塞模式</span></span><br><span class="line">ssChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//3.绑定连接</span></span><br><span class="line">ssChannel.bin(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line"><span class="comment">//4.获取选择器</span></span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"><span class="comment">//5.将通道注册到选择器上，并且指定“监听接收事件”</span></span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="NIO实现"><a href="#NIO实现" class="headerlink" title="NIO实现"></a>NIO实现</h3><h4 id="常用API-4"><a href="#常用API-4" class="headerlink" title="常用API"></a>常用API</h4><ul>
<li><p>SelectableChannel_API</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public final SelectableChannel configureBlocking(boolean block)</td>
<td>设置此通道的阻塞模式</td>
</tr>
<tr>
<td>public final SelectionKey register(Selector sel, int ops)</td>
<td>向给定的选择器注册此通道，并选择关注的的事件</td>
</tr>
</tbody></table>
</li>
<li><p>SocketChannel_API：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public static SocketChannel open()</td>
<td>打开套接字通道</td>
</tr>
<tr>
<td align="left">public static SocketChannel open(SocketAddress remote)</td>
<td>打开套接字通道并连接到远程地址</td>
</tr>
<tr>
<td align="left">public abstract boolean connect(SocketAddress remote)</td>
<td>连接此通道的到远程地址</td>
</tr>
<tr>
<td align="left">public abstract SocketChannel bind(SocketAddress local)</td>
<td>将通道的套接字绑定到本地地址</td>
</tr>
<tr>
<td align="left">public abstract SocketAddress getLocalAddress()</td>
<td>返回套接字绑定的本地套接字地址</td>
</tr>
<tr>
<td align="left">public abstract SocketAddress getRemoteAddress()</td>
<td>返回套接字连接的远程套接字地址</td>
</tr>
</tbody></table>
</li>
<li><p>ServerSocketChannel_API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static ServerSocketChannel open()</td>
<td>打开服务器套接字通道</td>
</tr>
<tr>
<td>public final ServerSocketChannel bind(SocketAddress local)</td>
<td>将通道的套接字绑定到本地地址，并配置套接字以监听连接</td>
</tr>
<tr>
<td>public abstract SocketChannel accept()</td>
<td>接受与此通道套接字的连接，通过此方法返回的套接字通道将处于阻塞模式</td>
</tr>
</tbody></table>
<ul>
<li>如果 ServerSocketChannel 处于非阻塞模式，如果没有挂起连接，则此方法将立即返回 null</li>
<li>如果通道处于阻塞模式，如果没有挂起连接将无限期地阻塞，直到有新的连接或发生 I&#x2F;O 错误</li>
</ul>
</li>
</ul>
<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>服务端 ：</p>
<ol>
<li><p>获取通道，当客户端连接服务端时，服务端会通过 <code>ServerSocketChannel.accept</code> 得到 SocketChannel </p>
</li>
<li><p>切换非阻塞模式</p>
</li>
<li><p>绑定连接</p>
</li>
<li><p>获取选择器</p>
</li>
<li><p>将通道注册到选择器上，并且指定监听接收事件</p>
</li>
<li><p><strong>轮询式</strong>的获取选择器上已经准备就绪的事件</p>
</li>
</ol>
<p>客户端：</p>
<ol>
<li>获取通道：<code>SocketChannel sc = SocketChannel.open(new InetSocketAddress(HOST, PORT))</code></li>
<li>切换非阻塞模式</li>
<li>分配指定大小的缓冲区：<code>ByteBuffer buffer = ByteBuffer.allocate(1024)</code></li>
<li>发送数据给服务端</li>
</ol>
<p>37 行代码，如果判断条件改为 !&#x3D;-1，需要客户端 close 一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 1、获取通道</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 2、切换为非阻塞模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 3、绑定连接的端口</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">        <span class="comment">// 4、获取选择器Selector</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">// 5、将通道都注册到选择器上去，并且开始指定监听接收事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">		<span class="comment">// 6、使用Selector选择器阻塞等待轮已经就绪好的事件</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;----开始新一轮的时间处理----&quot;</span>);</span><br><span class="line">            <span class="comment">// 7、获取选择器中的所有注册的通道中已经就绪好的事件</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class="line">            <span class="comment">// 8、开始遍历这些准备好的事件</span></span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> it.next();<span class="comment">// 提取当前这个事件</span></span><br><span class="line">                <span class="comment">// 9、判断这个事件具体是什么</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">// 10、直接获取当前接入的客户端通道</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    <span class="comment">// 11 、切换成非阻塞模式</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     ByteBuffer buffer = ByteBuffer.allocate(16);</span></span><br><span class="line"><span class="comment">                	 // 将一个 byteBuffer 作为附件【关联】到 selectionKey 上</span></span><br><span class="line"><span class="comment">                	 SelectionKey scKey = sc.register(selector, 0, buffer);</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="comment">// 12、将本客户端通道注册到选择器</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">// 13、获取当前选择器上的读就绪事件</span></span><br><span class="line">                    <span class="type">SelectableChannel</span> <span class="variable">channel</span> <span class="operator">=</span> key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) channel;</span><br><span class="line">                    <span class="comment">// 14、读取数据</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="comment">// 获取关联的附件</span></span><br><span class="line">                    <span class="comment">// ByteBuffer buffer = (ByteBuffer) key.attachment();</span></span><br><span class="line">                    <span class="type">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = socketChannel.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        System.out.println(socketChannel.getRemoteAddress() + <span class="string">&quot;:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, len));</span><br><span class="line">                        buffer.clear();<span class="comment">// 清除之前的数据</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 删除当前的 selectionKey，防止重复操作</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、获取通道</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>));</span><br><span class="line">        <span class="comment">// 2、切换成非阻塞模式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 3、分配指定缓冲区大小</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 4、发送数据给服务端</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;请说：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            buffer.put((<span class="string">&quot;Client：&quot;</span> + msg).getBytes());</span><br><span class="line">            buffer.flip();</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p>Java AIO(NIO.2) ： AsynchronousI&#x2F;O，异步非阻塞，采用了 Proactor 模式。服务器实现模式为一个有效请求一个线程，客户端的 I&#x2F;O 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AIO异步非阻塞，基于NIO的，可以称之为NIO2<span class="number">.0</span></span><br><span class="line">  BIO                     NIO                                AIO        </span><br><span class="line">Socket                SocketChannel                    AsynchronousSocketChannel</span><br><span class="line">ServerSocket          ServerSocketChannel	       AsynchronousServerSocketChannel</span><br></pre></td></tr></table></figure>

<p>当进行读写操作时，调用 API 的 read 或 write 方法，这两种方法均为异步的，完成后会主动调用回调函数：</p>
<ul>
<li>对于读操作，当有流可读取时，操作系统会将可读的流传入 read 方法的缓冲区</li>
<li>对于写操作，当操作系统将 write 方法传递的流写入完毕时，操作系统主动通知应用程序</li>
</ul>
<p>在 JDK1.7 中，这部分内容被称作 NIO.2，主要在 Java.nio.channels 包下增加了下面四个异步通道：<br>AsynchronousSocketChannel、AsynchronousServerSocketChannel、AsynchronousFileChannel、AsynchronousDatagramChannel</p>
<hr>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>DataSource</title>
    <url>/2022/01/01/DB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>数据库：DataBase，简称 DB，存储和管理数据的仓库</p>
<span id="more"></span>

<p>数据库的优势：</p>
<ul>
<li>可以持久化存储数据</li>
<li>方便存储和管理数据</li>
<li>使用了统一的方式操作数据库 SQL</li>
</ul>
<p>数据库、数据表、数据的关系介绍：</p>
<ul>
<li><p>数据库</p>
<ul>
<li>用于存储和管理数据的仓库</li>
<li>一个库中可以包含多个数据表</li>
</ul>
</li>
<li><p>数据表</p>
<ul>
<li>数据库最重要的组成部分之一</li>
<li>由纵向的列和横向的行组成（类似 excel 表格）</li>
<li>可以指定列名、数据类型、约束等</li>
<li>一个表中可以存储多条数据</li>
</ul>
</li>
<li><p>数据：想要永久化存储的数据</p>
</li>
</ul>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1zJ411M7TB">https://www.bilibili.com/video/BV1zJ411M7TB</a></p>
<p>参考专栏：<a href="https://time.geekbang.org/column/intro/139">https://time.geekbang.org/column/intro/139</a></p>
<p>参考书籍：<a href="https://book.douban.com/subject/35231266/">https://book.douban.com/subject/35231266/</a></p>
<hr>
<h3 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL"></a>MySQL</h3><p>MySQL 数据库是一个最流行的关系型数据库管理系统之一，关系型数据库是将数据保存在不同的数据表中，而且表与表之间可以有关联关系，提高了灵活性</p>
<p>缺点：数据存储在磁盘中，导致读写性能差，而且数据关系复杂，扩展性差</p>
<p>MySQL 所使用的 SQL 语句是用于访问数据库最常用的标准化语言</p>
<p>MySQL 配置：</p>
<ul>
<li><p>MySQL 安装：<a href="https://www.jianshu.com/p/ba48f1e386f0">https://www.jianshu.com/p/ba48f1e386f0</a></p>
</li>
<li><p>MySQL 配置：</p>
<ul>
<li><p>修改 MySQL 默认字符集：安装 MySQL 之后第一件事就是修改字符集编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/mysql/my.cnf</span><br><span class="line"></span><br><span class="line">添加如下内容：</span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 MySQL 服务： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start/restart mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录 MySQL：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -p  敲回车，输入密码</span><br><span class="line">初始密码查看：cat /var/log/mysqld.log</span><br><span class="line">在root@localhost:   后面的就是初始密码</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看默认字符集命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;char%&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改MySQL登录密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global validate_password_policy=0;</span><br><span class="line">set global validate_password_length=1;</span><br><span class="line">  </span><br><span class="line">set password=password(&#x27;密码&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>授予远程连接权限（MySQL 内输入）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 授权</span><br><span class="line">grant all privileges on *.* to &#x27;root&#x27; @&#x27;%&#x27; identified by &#x27;密码&#x27;;</span><br><span class="line">-- 刷新</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>修改 MySQL 绑定 IP：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/mysql/mysql.conf.d</span><br><span class="line">sudo chmod 666 mysqld.cnf </span><br><span class="line">vim mysqld.cnf </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bind-address = 127.0.0.1注释该行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭 Linux 防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">放行3306端口</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>体系结构详解：</p>
<ul>
<li>第一层：网络连接层<ul>
<li>一些客户端和链接服务，包含本地 Socket 通信和大多数基于客户端&#x2F;服务端工具实现的 TCP&#x2F;IP 通信，主要完成一些类似于连接处理、授权认证、及相关的安全方案</li>
<li>在该层上引入了<strong>连接池</strong> Connection Pool 的概念，管理缓冲用户连接，线程处理等需要缓存的需求</li>
<li>在该层上实现基于 SSL 的安全链接，服务器也会为安全接入的每个客户端验证它所具有的操作权限</li>
</ul>
</li>
</ul>
<ul>
<li>第二层：核心服务层<ul>
<li>查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，所有的内置函数（日期、数学、加密函数等）<ul>
<li>Management Serveices &amp; Utilities：系统管理和控制工具，备份、安全、复制、集群等</li>
<li>SQL Interface：接受用户的 SQL 命令，并且返回用户需要查询的结果</li>
<li>Parser：SQL 语句分析器</li>
<li>Optimizer：查询优化器</li>
<li>Caches &amp; Buffers：查询缓存，服务器会查询内部的缓存，如果缓存空间足够大，可以在大量读操作的环境中提升系统性能</li>
</ul>
</li>
<li>所有<strong>跨存储引擎的功能</strong>在这一层实现，如存储过程、触发器、视图等</li>
<li>在该层服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询顺序，是否利用索引等， 最后生成相应的执行操作</li>
<li>MySQL 中服务器层不管理事务，<strong>事务是由存储引擎实现的</strong></li>
</ul>
</li>
<li>第三层：存储引擎层<ul>
<li>Pluggable Storage Engines：存储引擎接口，MySQL 区别于其他数据库的重要特点就是其存储引擎的架构模式是插件式的（存储引擎是基于表的，而不是数据库）</li>
<li>存储引擎<strong>真正的负责了 MySQL 中数据的存储和提取</strong>，服务器通过 API 和存储引擎进行通信</li>
<li>不同的存储引擎具有不同的功能，共用一个 Server 层，可以根据开发的需要，来选取合适的存储引擎</li>
</ul>
</li>
<li>第四层：系统文件层<ul>
<li>数据存储层，主要是将数据存储在文件系统之上，并完成与存储引擎的交互</li>
<li>File System：文件系统，保存配置文件、数据文件、日志文件、错误文件、二进制文件等</li>
</ul>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"></p>
<hr>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>池化技术：对于访问数据库来说，建立连接的代价是比较昂贵的，因为每个连接对应一个用来交互的线程，频繁的创建关闭连接比较耗费资源，有必要建立数据库连接池，以提高访问的性能</p>
<p>连接建立 TCP 以后需要做<strong>权限验证</strong>，验证成功后可以进行执行 SQL。如果这时管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限，只有再新建的连接才会使用新的权限设置</p>
<p>MySQL 服务器可以同时和多个客户端进行交互，所以要保证每个连接会话的隔离性（事务机制部分详解）</p>
<p>整体的执行流程：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SQL的执行流程.png" style="zoom: 33%;">



<hr>
<h4 id="权限信息"><a href="#权限信息" class="headerlink" title="权限信息"></a>权限信息</h4><p>grant 语句会同时修改数据表和内存，判断权限的时候使用的是内存数据</p>
<p>flush privileges 语句本身会用数据表（磁盘）的数据重建一份内存权限数据，所以在权限数据可能存在不一致的情况下使用，这种不一致往往是由于直接用 DML 语句操作系统权限表导致的，所以尽量不要使用这类语句</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%9D%83%E9%99%90%E8%8C%83%E5%9B%B4.png"></p>
<hr>
<h4 id="连接状态"><a href="#连接状态" class="headerlink" title="连接状态"></a>连接状态</h4><p>客户端如果长时间没有操作，连接器就会自动断开，时间是由参数 wait_timeout 控制的，默认值是 8 小时。如果在连接被断开之后，客户端<strong>再次发送请求</strong>的话，就会收到一个错误提醒：<code>Lost connection to MySQL server during query</code></p>
<p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接；短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个</p>
<p>为了减少连接的创建，推荐使用长连接，但是<strong>过多的长连接会造成 OOM</strong>，解决方案：</p>
<ul>
<li><p>定期断开长连接，使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KILL CONNECTION id</span><br></pre></td></tr></table></figure>
</li>
<li><p>MySQL 5.7 版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源，这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态</p>
</li>
</ul>
<p>SHOW PROCESSLIST：查看当前 MySQL 在进行的线程，可以实时地查看 SQL 的执行情况，其中的 Command 列显示为 Sleep 的这一行，就表示现在系统里面有一个空闲连接</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SHOW_PROCESSLIST%E5%91%BD%E4%BB%A4.png"></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ID</td>
<td>用户登录 mysql 时系统分配的 connection_id，可以使用函数 connection_id() 查看</td>
</tr>
<tr>
<td>User</td>
<td>显示当前用户，如果不是 root，这个命令就只显示用户权限范围的 sql 语句</td>
</tr>
<tr>
<td>Host</td>
<td>显示这个语句是从哪个 ip 的哪个端口上发的，可以用来跟踪出现问题语句的用户</td>
</tr>
<tr>
<td>db</td>
<td>显示这个进程目前连接的是哪个数据库</td>
</tr>
<tr>
<td>Command</td>
<td>显示当前连接的执行的命令，一般取值为休眠 Sleep、查询 Query、连接 Connect 等</td>
</tr>
<tr>
<td>Time</td>
<td>显示这个状态持续的时间，单位是秒</td>
</tr>
<tr>
<td>State</td>
<td>显示使用当前连接的 sql 语句的状态，以查询为例，需要经过 copying to tmp table、sorting result、sending data等状态才可以完成</td>
</tr>
<tr>
<td>Info</td>
<td>显示执行的 sql 语句，是判断问题语句的一个重要依据</td>
</tr>
</tbody></table>
<p><strong>Sending data 状态</strong>表示 MySQL 线程开始访问数据行并把结果返回给客户端，而不仅仅只是返回给客户端，是处于执行器过程中的任意阶段。由于在 Sending data 状态下，MySQL 线程需要做大量磁盘读取操作，所以是整个查询中耗时最长的状态</p>
<hr>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><p>当执行完全相同的 SQL 语句的时候，服务器就会直接从缓存中读取结果，当数据被修改，之前的缓存会失效，修改比较频繁的表不适合做查询缓存</p>
<p>查询过程：</p>
<ol>
<li>客户端发送一条查询给服务器</li>
<li>服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果（一般是 K-V 键值对），否则进入下一阶段</li>
<li>分析器进行 SQL 分析，再由优化器生成对应的执行计划</li>
<li>MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询</li>
<li>将结果返回给客户端</li>
</ol>
<p>大多数情况下不建议使用查询缓存，因为查询缓存往往弊大于利</p>
<ul>
<li>查询缓存的<strong>失效非常频繁</strong>，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能费力地把结果存起来，还没使用就被一个更新全清空了，对于更新压力大的数据库来说，查询缓存的命中率会非常低</li>
<li>除非业务就是有一张静态表，很长时间才会更新一次，比如一个系统配置表，那这张表上的查询才适合使用查询缓存</li>
</ul>
<hr>
<h5 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h5><ol>
<li><p>查看当前 MySQL 数据库是否支持查询缓存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;have_query_cache&#x27;;	-- YES</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前 MySQL 是否开启了查询缓存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;query_cache_type&#x27;;	-- OFF</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><p>OFF 或 0：查询缓存功能关闭</p>
</li>
<li><p>ON 或 1：查询缓存功能打开，查询结果符合缓存条件即会缓存，否则不予缓存；可以显式指定 SQL_NO_CACHE 不予缓存</p>
</li>
<li><p>DEMAND 或 2：查询缓存功能按需进行，显式指定 SQL_CACHE 的 SELECT 语句才缓存，其它不予缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT SQL_CACHE id, name FROM customer; -- SQL_CACHE:查询结果可缓存</span><br><span class="line">SELECT SQL_NO_CACHE id, name FROM customer;-- SQL_NO_CACHE:不使用查询缓存</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>查看查询缓存的占用大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;query_cache_size&#x27;;-- 单位是字节 1048576 / 1024 = 1024 = 1KB</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看查询缓存的状态变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Qcache%&#x27;;</span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-查询缓存的状态变量.png" style="zoom:67%;">

<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Qcache_free_blocks</td>
<td>查询缓存中的可用内存块数</td>
</tr>
<tr>
<td>Qcache_free_memory</td>
<td>查询缓存的可用内存量</td>
</tr>
<tr>
<td>Qcache_hits</td>
<td>查询缓存命中数</td>
</tr>
<tr>
<td>Qcache_inserts</td>
<td>添加到查询缓存的查询数</td>
</tr>
<tr>
<td>Qcache_lowmen_prunes</td>
<td>由于内存不足而从查询缓存中删除的查询数</td>
</tr>
<tr>
<td>Qcache_not_cached</td>
<td>非缓存查询的数量（由于 query_cache_type 设置而无法缓存或未缓存）</td>
</tr>
<tr>
<td>Qcache_queries_in_cache</td>
<td>查询缓存中注册的查询数</td>
</tr>
<tr>
<td>Qcache_total_blocks</td>
<td>查询缓存中的块总数</td>
</tr>
</tbody></table>
</li>
<li><p>配置 my.cnf：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 666 /etc/mysql/my.cnf</span><br><span class="line">vim my.cnf</span><br><span class="line"><span class="comment"># mysqld中配置缓存</span></span><br><span class="line">query_cache_type=1</span><br></pre></td></tr></table></figure>

<p>重启服务既可生效，执行 SQL 语句进行验证 ，执行一条比较耗时的 SQL 语句，然后再多执行几次，查看后面几次的执行时间；获取通过查看查询缓存的缓存命中数，来判定是否走查询缓存</p>
</li>
</ol>
<hr>
<h5 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h5><p>查询缓存失效的情况：</p>
<ul>
<li><p>SQL 语句不一致，要想命中查询缓存，查询的 SQL 语句必须一致，因为<strong>缓存中 key 是查询的语句</strong>，value 是查询结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) from tb_item;</span><br><span class="line">Select count(*) from tb_item;	-- 不走缓存，首字母不一致</span><br></pre></td></tr></table></figure>
</li>
<li><p>当查询语句中有一些不确定查询时，则不会缓存，比如：now()、current_date()、curdate()、curtime()、rand()、uuid()、user()、database() </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tb_item WHERE updatetime &lt; NOW() LIMIT 1;</span><br><span class="line">SELECT USER();</span><br><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure>
</li>
<li><p>不使用任何表查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT &#x27;A&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询 mysql、information_schema、performance_schema 等系统表时，不走查询缓存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.engines;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<strong>跨存储引擎</strong>的存储过程、触发器或存储函数的主体内执行的查询，缓存失效</p>
</li>
<li><p>如果表更改，则使用该表的<strong>所有高速缓存查询都将变为无效</strong>并从高速缓存中删除，包括使用 MERGE 映射到已更改表的表的查询，比如：INSERT、UPDATE、DELETE、ALTER TABLE、DROP TABLE、DROP DATABASE</p>
</li>
</ul>
<hr>
<h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>没有命中查询缓存，就开始了 SQL 的真正执行，分析器会对 SQL 语句做解析</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>解析器：处理语法和解析查询，生成一课对应的解析树</p>
<ul>
<li>先做<strong>词法分析</strong>，输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么代表什么。从输入的 select 这个关键字识别出来这是一个查询语句；把字符串 t 识别成 表名 t，把字符串 id 识别成列 id</li>
<li>然后做<strong>语法分析</strong>，根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果语句不对，就会收到 <code>You have an error in your SQL syntax</code> 的错误提醒</li>
</ul>
<p>预处理器：进一步检查解析树的合法性，比如数据表和数据列是否存在、别名是否有歧义等</p>
<hr>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><h5 id="成本分析"><a href="#成本分析" class="headerlink" title="成本分析"></a>成本分析</h5><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序</p>
<ul>
<li>根据搜索条件找出所有可能的使用的索引</li>
<li>成本分析，执行成本由 I&#x2F;O 成本和 CPU 成本组成，计算全表扫描和使用不同索引执行 SQL 的代价</li>
<li>找到一个最优的执行方案，用最小的代价去执行语句</li>
</ul>
<p>在数据库里面，扫描行数是影响执行代价的因素之一，扫描的行数越少意味着访问磁盘的次数越少，消耗的 CPU 资源越少，优化器还会结合是否使用临时表、是否排序等因素进行综合判断</p>
<hr>
<h5 id="统计数据"><a href="#统计数据" class="headerlink" title="统计数据"></a>统计数据</h5><p>MySQL 中保存着两种统计数据：</p>
<ul>
<li>innodb_table_stats 存储了表的统计数据，每一条记录对应着一个表的统计数据</li>
<li>innodb_index_stats 存储了索引的统计数据，每一条记录对应着一个索引的一个统计项的数据</li>
</ul>
<p>MySQL 在真正执行语句之前，并不能精确地知道满足条件的记录有多少条，只能根据统计信息来估算记录，统计信息就是索引的区分度,一个索引上不同的值的个数（比如性别只能是男女，就是 2 ），称之为基数（cardinality），<strong>基数越大说明区分度越好</strong></p>
<p>通过<strong>采样统计</strong>来获取基数，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数</p>
<p>在 MySQL 中，有两种存储统计数据的方式，可以通过设置参数 <code>innodb_stats_persistent</code> 的值来选择：</p>
<ul>
<li>ON：表示统计信息会持久化存储（默认），采样页数 N 默认为 20，可以通过 <code>innodb_stats_persistent_sample_pages</code> 指定，页数越多统计的数据越准确，但消耗的资源更大</li>
<li>OFF：表示统计信息只存储在内存，采样页数 N 默认为 8，也可以通过系统变量设置（不推荐，每次重新计算浪费资源）</li>
</ul>
<p>数据表是会持续更新的，两种统计信息的更新方式：</p>
<ul>
<li>设置 <code>innodb_stats_auto_recalc</code> 为 1，当发生变动的记录数量超过表大小的 10% 时，自动触发重新计算，不过是<strong>异步进行</strong></li>
<li>调用 <code>ANALYZE TABLE t</code> 手动更新统计信息，只对信息做<strong>重新统计</strong>（不是重建表），没有修改数据，这个过程中加了 MDL 读锁并且是同步进行，所以会暂时阻塞系统</li>
</ul>
<p><strong>EXPLAIN 执行计划在优化器阶段生成</strong>，如果 explain 的结果预估的 rows 值跟实际情况差距比较大，可以执行 analyze 命令重新修正信息</p>
<hr>
<h5 id="错选索引"><a href="#错选索引" class="headerlink" title="错选索引"></a>错选索引</h5><p>采样统计本身是估算数据，或者 SQL 语句中的字段选择有问题时，可能导致 MySQL 没有选择正确的执行索引</p>
<p>解决方法：</p>
<ul>
<li><p>采用 force index 强行选择一个索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> FORCE INDEX(name) <span class="keyword">WHERE</span> NAME<span class="operator">=</span><span class="string">&#x27;seazean&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以考虑修改 SQL 语句，引导 MySQL 使用期望的索引</p>
</li>
<li><p>新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引</p>
</li>
</ul>
<hr>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>开始执行的时候，要先判断一下当前连接对表有没有<strong>执行查询的权限</strong>，如果没有就会返回没有权限的错误，在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。如果有权限，就打开表继续执行，执行器就会根据表的引擎定义，去使用这个引擎提供的接口</p>
<hr>
<h4 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h4><p>Server 层和存储引擎层的交互是<strong>以记录为单位的</strong>，存储引擎会将单条记录返回给 Server 层做进一步处理，并不是直接返回所有的记录</p>
<p>工作流程：</p>
<ul>
<li>首先根据二级索引选择扫描范围，获取第一条符合二级索引条件的记录，进行回表查询，将聚簇索引的记录返回 Server 层，由 Server 判断记录是否符合要求</li>
<li>然后在二级索引上继续扫描下一个符合条件的记录</li>
</ul>
<p>推荐阅读：<a href="https://mp.weixin.qq.com/s/YZ-LckObephrP1f15mzHpA">https://mp.weixin.qq.com/s/YZ-LckObephrP1f15mzHpA</a></p>
<hr>
<h3 id="终止流程"><a href="#终止流程" class="headerlink" title="终止流程"></a>终止流程</h3><h4 id="终止语句"><a href="#终止语句" class="headerlink" title="终止语句"></a>终止语句</h4><p>终止线程中正在执行的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KILL QUERY thread_id</span><br></pre></td></tr></table></figure>

<p>KILL 不是马上终止的意思，而是告诉执行线程这条语句已经不需要继续执行，可以开始执行停止的逻辑（类似于打断）。因为对表做增删改查操作，会在表上加 MDL 读锁，如果线程被 KILL 时就直接终止，那这个 MDL 读锁就没机会被释放了</p>
<p>命令 <code>KILL QUERYthread_id_A</code> 的执行流程：</p>
<ul>
<li>把 session A 的运行状态改成 THD::KILL_QUERY（将变量 killed 赋值为 THD::KILL_QUERY）</li>
<li>给 session A 的执行线程发一个信号，让 session A 来处理这个 THD::KILL_QUERY 状态</li>
</ul>
<p>会话处于等待状态（锁阻塞），必须满足是一个可以被唤醒的等待，必须有机会去<strong>判断线程的状态</strong>，如果不满足就会造成 KILL 失败</p>
<p>典型场景：innodb_thread_concurrency 为 2，代表并发线程上限数设置为 2</p>
<ul>
<li>session A 执行事务，session B 执行事务，达到线程上限；此时 session C 执行事务会阻塞等待，session D 执行 kill query C 无效</li>
<li>C 的逻辑是每 10 毫秒判断是否可以进入 InnoDB 执行，如果不行就调用 nanosleep 函数进入 sleep 状态，没有去判断线程状态</li>
</ul>
<p>补充：执行 Ctrl+C 的时候，是 MySQL 客户端另外启动一个连接，然后发送一个 KILL QUERY 命令</p>
<hr>
<h4 id="终止连接"><a href="#终止连接" class="headerlink" title="终止连接"></a>终止连接</h4><p>断开线程的连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KILL CONNECTION id</span><br></pre></td></tr></table></figure>

<p>断开连接后执行 SHOW PROCESSLIST 命令，如果这条语句的 Command 列显示 Killed，代表线程的状态是 KILL_CONNECTION，说明这个线程有语句正在执行，当前状态是停止语句执行中，终止逻辑耗时较长</p>
<ul>
<li>超大事务执行期间被 KILL，这时回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长</li>
<li>大查询回滚，如果查询过程中生成了比较大的临时文件，删除临时文件可能需要等待 IO 资源，导致耗时较长</li>
<li>DDL 命令执行到最后阶段被 KILL，需要删除中间过程的临时文件，也可能受 IO 资源影响耗时较久</li>
</ul>
<p>总结：KILL CONNECTION 本质上只是把客户端的 SQL 连接断开，后面的终止流程还是要走 KILL QUERY</p>
<p>一个事务被 KILL 之后，持续处于回滚状态，不应该强行重启整个 MySQL 进程，应该等待事务自己执行完成，因为重启后依然继续做回滚操作的逻辑</p>
<hr>
<h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><p>mysql 不是指 mysql 服务，而是指 mysql 的客户端工具</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql [options] [database]</span><br></pre></td></tr></table></figure>

<ul>
<li>-u  –user&#x3D;name：指定用户名</li>
<li>-p  –password[&#x3D;name]：指定密码</li>
<li>-h  –host&#x3D;name：指定服务器IP或域名</li>
<li>-P  –port&#x3D;#：指定连接端口</li>
<li>-e  –execute&#x3D;name：执行SQL语句并退出，在控制台执行SQL语句，而不用连接到数据库执行</li>
</ul>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -P 3306 -u root -p</span><br><span class="line">mysql -uroot -p2143 db01 -e <span class="string">&quot;select * from tb_book&quot;</span>;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h4><p>mysqladmin 是一个执行管理操作的客户端程序，用来检查服务器的配置和当前状态、创建并删除数据库等</p>
<p>通过 <code>mysqladmin --help</code> 指令查看帮助文档</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqladmin -uroot -p2143 create <span class="string">&#x27;test01&#x27;</span>;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p>服务器生成的日志文件以二进制格式保存，如果需要检查这些文本，就要使用 mysqlbinlog 日志管理工具</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlbinlog [options]  log-files1 log-files2 ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-d  –database&#x3D;name：指定数据库名称，只列出指定的数据库相关操作</p>
</li>
<li><p>-o  –offset&#x3D;#：忽略掉日志中的前 n 行命令。</p>
</li>
<li><p>-r  –result-file&#x3D;name：将输出的文本格式日志输出到指定文件。</p>
</li>
<li><p>-s  –short-form：显示简单格式，省略掉一些信息。</p>
</li>
<li><p>–start-datatime&#x3D;date1  –stop-datetime&#x3D;date2：指定日期间隔内的所有日志</p>
</li>
<li><p>–start-position&#x3D;pos1 –stop-position&#x3D;pos2：指定位置间隔内的所有日志</p>
</li>
</ul>
<hr>
<h4 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h4><h5 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h5><p>mysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移，备份内容包含创建表，及插入表的 SQL 语句</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line">mysqldump [options] --database/-B db1 [db2 db3...]</span><br><span class="line">mysqldump [options] --all-databases/-A</span><br></pre></td></tr></table></figure>

<p>连接选项：</p>
<ul>
<li>-u  –user&#x3D;name：指定用户名</li>
<li>-p  –password[&#x3D;name]：指定密码</li>
<li>-h  –host&#x3D;name：指定服务器 IP 或域名</li>
<li>-P  –port&#x3D;#：指定连接端口</li>
</ul>
<p>输出内容选项：</p>
<ul>
<li>–add-drop-database：在每个数据库创建语句前加上 Drop database 语句</li>
<li>–add-drop-table：在每个表创建语句前加上 Drop table 语句 , 默认开启，不开启 (–skip-add-drop-table)</li>
<li>-n  –no-create-db：不包含数据库的创建语句</li>
<li>-t  –no-create-info：不包含数据表的创建语句</li>
<li>-d –no-data：不包含数据</li>
<li>-T, –tab&#x3D;name：自动生成两个文件：一个 .sql 文件，创建表结构的语句；一个 .txt 文件，数据文件，相当于 select into outfile</li>
</ul>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p2143 db01 tb_book --add-drop-database --add-drop-table &gt; a</span><br><span class="line">mysqldump -uroot -p2143 -T /tmp <span class="built_in">test</span> city</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h5><p>命令行方式：</p>
<ul>
<li>备份命令：mysqldump -u root -p 数据库名称 &gt; 文件保存路径</li>
<li>恢复<ol>
<li>登录MySQL数据库：<code>mysql -u root p</code></li>
<li>删除已经备份的数据库</li>
<li>重新创建与备份数据库名称相同的数据库</li>
<li>使用该数据库</li>
<li>导入文件执行：<code>source 备份文件全路径</code></li>
</ol>
</li>
</ul>
<p>更多方式参考：<a href="https://time.geekbang.org/column/article/81925">https://time.geekbang.org/column/article/81925</a></p>
<p>图形化界面：</p>
<ul>
<li><p>备份</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E5%A4%87%E4%BB%BD.png" alt="图形化界面备份"></p>
</li>
<li><p>恢复</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E6%81%A2%E5%A4%8D.png" alt="图形化界面恢复"></p>
</li>
</ul>
<hr>
<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>mysqlimport 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlimport [options]  db_name  textfile1  [textfile2...]</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlimport -uroot -p2143 <span class="built_in">test</span> /tmp/city.txt</span><br></pre></td></tr></table></figure>

<p>导入 sql 文件，可以使用 MySQL 中的 source 指令 : </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source 文件全路径</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="show"><a href="#show" class="headerlink" title="show"></a>show</h4><p>mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlshow [options] [db_name [table_name [col_name]]]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>–count：显示数据库及表的统计信息（数据库，表 均可以不指定）</p>
</li>
<li><p>-i：显示指定数据库或者指定表的状态信息</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询每个数据库的表的数量及表中记录的数量</span></span><br><span class="line">mysqlshow -uroot -p1234 --count</span><br><span class="line"><span class="comment">#查询test库中每个表中的字段书，及行数</span></span><br><span class="line">mysqlshow -uroot -p1234 <span class="built_in">test</span> --count</span><br><span class="line"><span class="comment">#查询test库中book表的详细情况</span></span><br><span class="line">mysqlshow -uroot -p1234 <span class="built_in">test</span> book --count</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="单表操作"><a href="#单表操作" class="headerlink" title="单表操作"></a>单表操作</h2><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul>
<li><p>SQL</p>
<ul>
<li>Structured Query Language：结构化查询语言</li>
<li>定义了操作所有关系型数据库的规则，每种数据库操作的方式可能会存在不一样的地方，称为“方言”</li>
</ul>
</li>
<li><p>SQL 通用语法</p>
<ul>
<li>SQL 语句可以单行或多行书写，以<strong>分号结尾</strong>。</li>
<li>可使用空格和缩进来增强语句的可读性。</li>
<li>MySQL 数据库的 SQL 语句不区分大小写，<strong>关键字建议使用大写</strong>。</li>
<li>数据库的注释：<ul>
<li>单行注释：– 注释内容       #注释内容（MySQL 特有）</li>
<li>多行注释：&#x2F;* 注释内容 *&#x2F;</li>
</ul>
</li>
</ul>
</li>
<li><p>SQL 分类</p>
<ul>
<li><p>DDL（Data Definition Language）数据定义语言</p>
<ul>
<li>用来定义数据库对象：数据库，表，列等。关键字：create、drop,、alter 等</li>
</ul>
</li>
<li><p>DML（Data Manipulation Language）数据操作语言</p>
<ul>
<li>用来对数据库中表的数据进行增删改。关键字：insert、delete、update 等</li>
</ul>
</li>
<li><p>DQL（Data Query Language）数据查询语言</p>
<ul>
<li>用来查询数据库中表的记录(数据)。关键字：select、where 等</li>
</ul>
</li>
<li><p>DCL（Data Control Language）数据控制语言</p>
<ul>
<li>用来定义数据库的访问权限和安全级别，及创建用户。关键字：grant， revoke等</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SQL%E5%88%86%E7%B1%BB.png"></p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><h4 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h4><ul>
<li><p>R(Retrieve)：查询</p>
<ul>
<li><p>查询所有数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询某个数据库的创建语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名称;  <span class="comment">-- 标准语法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE mysql;     <span class="comment">-- 查看mysql数据库的创建格式</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>C(Create)：创建</p>
<ul>
<li><p>创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名称;-- 标准语法</span><br><span class="line"></span><br><span class="line">CREATE DATABASE db1;     -- 创建db1数据库</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库（判断，如果不存在则创建）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS 数据库名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库，并指定字符集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名称 CHARACTER SET 字符集名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例如：创建db4数据库、如果不存在则创建，指定字符集为gbk</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建db4数据库、如果不存在则创建，指定字符集为gbk</span><br><span class="line">CREATE DATABASE IF NOT EXISTS db4 CHARACTER SET gbk;</span><br><span class="line"></span><br><span class="line">-- 查看db4数据库的字符集</span><br><span class="line">SHOW CREATE DATABASE db4;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>U(Update)：修改</p>
<ul>
<li><p>修改数据库的字符集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE 数据库名称 CHARACTER SET 字符集名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用字符集：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--查询所有支持的字符集</span><br><span class="line">SHOW CHARSET;</span><br><span class="line">--查看所有支持的校对规则</span><br><span class="line">SHOW COLLATION;</span><br><span class="line"></span><br><span class="line">-- 字符集: utf8,latinI,GBK,,GBK是utf8的子集</span><br><span class="line">-- 校对规则: ci 大小定不敏感，cs或bin大小写敏感</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>D(Delete)：删除</p>
<ul>
<li><p>删除数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE 数据库名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据库(判断，如果存在则删除)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS 数据库名称;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用数据库：</p>
<ul>
<li><p>查询当前正在使用的数据库名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE 数据库名称； -- 标准语法</span><br><span class="line">USE db4;	   -- 使用db4数据库</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h4><ul>
<li><p>R(Retrieve)：查询</p>
<ul>
<li><p>查询数据库中所有的数据表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE mysql;-- 使用mysql数据库</span><br><span class="line"></span><br><span class="line">SHOW TABLES;-- 查询库中所有的表</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询表结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询表字符集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLE STATUS FROM 库名 LIKE &#x27;表名&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>C(Create)：创建</p>
<ul>
<li><p>创建数据表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    列名1 数据类型1,</span><br><span class="line">    列名2 数据类型2,</span><br><span class="line">    ....</span><br><span class="line">    列名n 数据类型n</span><br><span class="line">);</span><br><span class="line">-- 注意：最后一列，不需要加逗号</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 LIKE 被复制的表名;  -- 标准语法</span><br><span class="line"></span><br><span class="line">CREATE TABLE product2 LIKE product; -- 复制product表到product2表</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据类型</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>INT</td>
<td>整数类型</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>小数类型</td>
</tr>
<tr>
<td>DATE</td>
<td>日期，只包含年月日：yyyy-MM-dd</td>
</tr>
<tr>
<td>DATETIME</td>
<td>日期，包含年月日时分秒：yyyy-MM-dd HH:mm:ss</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>时间戳类型，包含年月日时分秒：yyyy-MM-dd HH:mm:ss<br>如果不给这个字段赋值或赋值为 NULL，则默认使用当前的系统时间</td>
</tr>
<tr>
<td>CHAR</td>
<td>字符串，定长类型</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>字符串，<strong>变长类型</strong><br>name varchar(20) 代表姓名最大 20 个字符：zhangsan 8 个字符，张三 2 个字符</td>
</tr>
</tbody></table>
<p><code>INT(n)</code>：n 代表位数</p>
<ul>
<li>3：int（9）显示结果为 000000010</li>
<li>3：int（3）显示结果为 010</li>
</ul>
<p><code>varchar(n)</code>：n 表示的是字符数</p>
</li>
<li><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 使用db3数据库</span><br><span class="line">USE db3;</span><br><span class="line"></span><br><span class="line">-- 创建一个product商品表</span><br><span class="line">CREATE TABLE product(</span><br><span class="line">	id INT,				-- 商品编号</span><br><span class="line">	NAME VARCHAR(30),	-- 商品名称</span><br><span class="line">	price DOUBLE,		-- 商品价格</span><br><span class="line">	stock INT,			-- 商品库存</span><br><span class="line">	insert_time DATE    -- 上架时间</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>​    </p>
<ul>
<li><p>U(Update)：修改</p>
<ul>
<li><p>修改表名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME TO 新的表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表的字符集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 CHARACTER SET 字符集名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加一列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 列名 数据类型;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改列数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 新数据类型;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改列名称和数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 列名;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>D(Delete)：删除</p>
<ul>
<li><p>删除数据表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据表(判断，如果存在则删除)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS 表名;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><h4 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h4><ul>
<li><p>新增表数据</p>
<ul>
<li><p>新增格式 1：给指定列添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名(列名1,列名2...) VALUES (值1,值2...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增格式 2：默认给全部列添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES (值1,值2,值3,...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增格式 3：批量添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 给指定列批量添加数据</span><br><span class="line">INSERT INTO 表名(列名1,列名2,...) VALUES (值1,值2,...),(值1,值2,...)...;</span><br><span class="line"></span><br><span class="line">-- 默认给所有列批量添加数据 </span><br><span class="line">INSERT INTO 表名 VALUES (值1,值2,值3,...),(值1,值2,值3,...)...;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>字符串拼接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONCAT(string1,string2,&#x27;&#x27;,...)</span><br></pre></td></tr></table></figure>


</li>
<li><p>注意事项</p>
<ul>
<li>列名和值的数量以及数据类型要对应</li>
<li>除了数字类型，其他数据类型的数据都需要加引号(单引双引都可以，推荐单引)</li>
</ul>
</li>
</ul>
<hr>
<h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><ul>
<li><p>修改表数据语法</p>
<ul>
<li><p>标准语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE 表名 SET 列名1 = 值1,列名2 = 值2,... [where 条件];</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改电视的价格为1800、库存为36</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE product SET price=1800,stock=36 WHERE NAME=&#x27;电视&#x27;;</span><br><span class="line">SELECT * FROM product;-- 查看所有商品信息</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>修改语句中必须加条件</li>
<li>如果不加条件，则将所有数据都修改</li>
</ul>
</li>
</ul>
<hr>
<h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><ul>
<li><p>删除表数据语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM 表名 [WHERE 条件];</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项</p>
<ul>
<li>删除语句中必须加条件</li>
<li>如果不加条件，则将所有数据删除</li>
</ul>
</li>
</ul>
<p>​    </p>
<hr>
<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><h4 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h4><p>数据库查询遵循条件在前的原则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT</span><br><span class="line">	&lt;select list&gt;</span><br><span class="line">FROM</span><br><span class="line">	&lt;left_table&gt; &lt;join_type&gt;</span><br><span class="line">JOIN</span><br><span class="line">	&lt;right_table&gt; ON &lt;join_condition&gt;	-- 连接查询在多表查询部分详解</span><br><span class="line">WHERE</span><br><span class="line">	&lt;where_condition&gt;</span><br><span class="line">GROUP BY</span><br><span class="line">	&lt;group_by_list&gt;</span><br><span class="line">HAVING</span><br><span class="line">	&lt;having_condition&gt;</span><br><span class="line">ORDER BY</span><br><span class="line">	&lt;order_by_condition&gt;</span><br><span class="line">LIMIT</span><br><span class="line">	&lt;limit_params&gt;</span><br></pre></td></tr></table></figure>

<p>执行顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM	&lt;left_table&gt;</span><br><span class="line"></span><br><span class="line">ON 		&lt;join_condition&gt;</span><br><span class="line"></span><br><span class="line">&lt;join_type&gt;		JOIN	&lt;right_table&gt;</span><br><span class="line"></span><br><span class="line">WHERE		&lt;where_condition&gt;</span><br><span class="line"></span><br><span class="line">GROUP BY 	&lt;group_by_list&gt;</span><br><span class="line"></span><br><span class="line">HAVING		&lt;having_condition&gt;</span><br><span class="line"></span><br><span class="line">SELECT DISTINCT		&lt;select list&gt;</span><br><span class="line"></span><br><span class="line">ORDER BY	&lt;order_by_condition&gt;</span><br><span class="line"></span><br><span class="line">LIMIT		&lt;limit_params&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="查询全部"><a href="#查询全部" class="headerlink" title="查询全部"></a>查询全部</h4><ul>
<li><p>查询全部的表数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 标准语法</span><br><span class="line">SELECT * FROM 表名;</span><br><span class="line"></span><br><span class="line">-- 查询product表所有数据(常用)</span><br><span class="line">SELECT * FROM product;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询指定字段的表数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名1,列名2,... FROM 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>去除重复查询</strong>：只有值全部重复的才可以去除，需要创建临时表辅助查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT 列名1,列名2,... FROM 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算列的值（四则运算）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名1 运算符(+ - * /) 列名2 FROM 表名;</span><br><span class="line"></span><br><span class="line">/*如果某一列值为null，可以进行替换</span><br><span class="line">	ifnull(表达式1,表达式2)</span><br><span class="line">	表达式1：想替换的列</span><br><span class="line">	表达式2：想替换的值*/</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询商品名称和库存，库存数量在原有基础上加10</span><br><span class="line">SELECT NAME,stock+10 FROM product;</span><br><span class="line"></span><br><span class="line">-- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断</span><br><span class="line">SELECT NAME,IFNULL(stock,0)+10 FROM product;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>起别名</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名1,列名2,... AS 别名 FROM 表名;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断，起别名为getSum,AS可以省略。</span><br><span class="line">SELECT NAME,IFNULL(stock,0)+10 AS getsum FROM product;</span><br><span class="line">SELECT NAME,IFNULL(stock,0)+10 getsum FROM product;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><ul>
<li><p>条件查询语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 WHERE 条件;</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件分类</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt; 或 !&#x3D;</td>
<td>不等于</td>
</tr>
<tr>
<td>BETWEEN … AND …</td>
<td>在某个范围之内(都包含)</td>
</tr>
<tr>
<td>IN(…)</td>
<td>多选一</td>
</tr>
<tr>
<td>LIKE</td>
<td><strong>模糊查询</strong>：_单个任意字符、%任意个字符、[] 匹配集合内的字符<br><code>LIKE &#39;[^AB]%&#39; </code>：不以 A 和 B 开头的任意文本</td>
</tr>
<tr>
<td>IS NULL</td>
<td>是NULL</td>
</tr>
<tr>
<td>IS NOT NULL</td>
<td>不是NULL</td>
</tr>
<tr>
<td>AND 或 &amp;&amp;</td>
<td>并且</td>
</tr>
<tr>
<td>OR 或 ||</td>
<td>或者</td>
</tr>
<tr>
<td>NOT 或 !</td>
<td>非，不是</td>
</tr>
<tr>
<td>UNION</td>
<td>对两个结果集进行<strong>并集操作并进行去重，同时进行默认规则的排序</strong></td>
</tr>
<tr>
<td>UNION ALL</td>
<td>对两个结果集进行并集操作不进行去重，不进行排序</td>
</tr>
</tbody></table>
</li>
<li><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询库存大于20的商品信息</span><br><span class="line">SELECT * FROM product WHERE stock &gt; 20;</span><br><span class="line"></span><br><span class="line">-- 查询品牌为华为的商品信息</span><br><span class="line">SELECT * FROM product WHERE brand=&#x27;华为&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询金额在4000 ~ 6000之间的商品信息</span><br><span class="line">SELECT * FROM product WHERE price &gt;= 4000 AND price &lt;= 6000;</span><br><span class="line">SELECT * FROM product WHERE price BETWEEN 4000 AND 6000;</span><br><span class="line"></span><br><span class="line">-- 查询库存为14、30、23的商品信息</span><br><span class="line">SELECT * FROM product WHERE stock=14 OR stock=30 OR stock=23;</span><br><span class="line">SELECT * FROM product WHERE stock IN(14,30,23);</span><br><span class="line"></span><br><span class="line">-- 查询库存为null的商品信息</span><br><span class="line">SELECT * FROM product WHERE stock IS NULL;</span><br><span class="line">-- 查询库存不为null的商品信息</span><br><span class="line">SELECT * FROM product WHERE stock IS NOT NULL;</span><br><span class="line"></span><br><span class="line">-- 查询名称以&#x27;小米&#x27;为开头的商品信息</span><br><span class="line">SELECT * FROM product WHERE NAME LIKE &#x27;小米%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询名称第二个字是&#x27;为&#x27;的商品信息</span><br><span class="line">SELECT * FROM product WHERE NAME LIKE &#x27;_为%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询名称为四个字符的商品信息 4个下划线</span><br><span class="line">SELECT * FROM product WHERE NAME LIKE &#x27;____&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询名称中包含电脑的商品信息</span><br><span class="line">SELECT * FROM product WHERE NAME LIKE &#x27;%电脑%&#x27;;</span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-DQL数据准备.png" style="zoom: 80%;"></li>
</ul>
<hr>
<h4 id="函数查询"><a href="#函数查询" class="headerlink" title="函数查询"></a>函数查询</h4><h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h5><p>聚合函数：将一列数据作为一个整体，进行纵向的计算</p>
<ul>
<li><p>聚合函数语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 函数名(列名) FROM 表名 [WHERE 条件]</span><br></pre></td></tr></table></figure>
</li>
<li><p>聚合函数分类</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>COUNT(列名)</td>
<td>统计数量（一般选用不为 null 的列）</td>
</tr>
<tr>
<td>MAX(列名)</td>
<td>最大值</td>
</tr>
<tr>
<td>MIN(列名)</td>
<td>最小值</td>
</tr>
<tr>
<td>SUM(列名)</td>
<td>求和</td>
</tr>
<tr>
<td>AVG(列名)</td>
<td>平均值（会忽略 null 行）</td>
</tr>
</tbody></table>
</li>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 计算product表中总记录条数 7</span><br><span class="line">SELECT COUNT(*) FROM product;</span><br><span class="line"></span><br><span class="line">-- 获取最高价格</span><br><span class="line">SELECT MAX(price) FROM product;</span><br><span class="line">-- 获取最高价格的商品名称</span><br><span class="line">SELECT NAME,price FROM product WHERE price = (SELECT MAX(price) FROM product);</span><br><span class="line"></span><br><span class="line">-- 获取最低库存</span><br><span class="line">SELECT MIN(stock) FROM product;</span><br><span class="line">-- 获取最低库存的商品名称</span><br><span class="line">SELECT NAME,stock FROM product WHERE stock = (SELECT MIN(stock) FROM product);</span><br><span class="line"></span><br><span class="line">-- 获取总库存数量</span><br><span class="line">SELECT SUM(stock) FROM product;</span><br><span class="line">-- 获取品牌为小米的平均商品价格</span><br><span class="line">SELECT AVG(price) FROM product WHERE brand=&#x27;小米&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="文本函数"><a href="#文本函数" class="headerlink" title="文本函数"></a>文本函数</h5><p>CONCAT()：用于连接两个字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="built_in">TRIM</span>(col1), <span class="string">&#x27;(&#x27;</span>, <span class="built_in">TRIM</span>(col2), <span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span> concat_col <span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="comment">-- 许多数据库会使用空格把一个值填充为列宽，连接的结果出现一些不必要的空格，使用TRIM()可以去除首尾空格</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数名称</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>LENGTH</td>
<td>计算字符串长度函数，返回字符串的字节长度</td>
</tr>
<tr>
<td>CONCAT</td>
<td>合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个</td>
</tr>
<tr>
<td>INSERT</td>
<td>替换字符串函数</td>
</tr>
<tr>
<td>LOWER</td>
<td>将字符串中的字母转换为小写</td>
</tr>
<tr>
<td>UPPER</td>
<td>将字符串中的字母转换为大写</td>
</tr>
<tr>
<td>LEFT</td>
<td>从左侧字截取符串，返回字符串左边的若干个字符</td>
</tr>
<tr>
<td>RIGHT</td>
<td>从右侧字截取符串，返回字符串右边的若干个字符</td>
</tr>
<tr>
<td>TRIM</td>
<td>删除字符串左右两侧的空格</td>
</tr>
<tr>
<td>REPLACE</td>
<td>字符串替换函数，返回替换后的新字符串</td>
</tr>
<tr>
<td>SUBSTRING</td>
<td>截取字符串，返回从指定位置开始的指定长度的字符换</td>
</tr>
<tr>
<td>REVERSE</td>
<td>字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串</td>
</tr>
</tbody></table>
<hr>
<h5 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h5><table>
<thead>
<tr>
<th>函数名称</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>ABS</td>
<td>求绝对值</td>
</tr>
<tr>
<td>SQRT</td>
<td>求二次方根</td>
</tr>
<tr>
<td>MOD</td>
<td>求余数</td>
</tr>
<tr>
<td>CEIL 和 CEILING</td>
<td>两个函数功能相同，都是返回不小于参数的最小整数，即向上取整</td>
</tr>
<tr>
<td>FLOOR</td>
<td>向下取整，返回值转化为一个BIGINT</td>
</tr>
<tr>
<td>RAND</td>
<td>生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列</td>
</tr>
<tr>
<td>ROUND</td>
<td>对所传参数进行四舍五入</td>
</tr>
<tr>
<td>SIGN</td>
<td>返回参数的符号</td>
</tr>
<tr>
<td>POW 和 POWER</td>
<td>两个函数的功能相同，都是所传参数的次方的结果值</td>
</tr>
<tr>
<td>SIN</td>
<td>求正弦值</td>
</tr>
<tr>
<td>ASIN</td>
<td>求反正弦值，与函数 SIN 互为反函数</td>
</tr>
<tr>
<td>COS</td>
<td>求余弦值</td>
</tr>
<tr>
<td>ACOS</td>
<td>求反余弦值，与函数 COS 互为反函数</td>
</tr>
<tr>
<td>TAN</td>
<td>求正切值</td>
</tr>
<tr>
<td>ATAN</td>
<td>求反正切值，与函数 TAN 互为反函数</td>
</tr>
<tr>
<td>COT</td>
<td>求余切值</td>
</tr>
</tbody></table>
<hr>
<h5 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h5><table>
<thead>
<tr>
<th>函数名称</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>CURDATE 和 CURRENT_DATE</td>
<td>两个函数作用相同，返回当前系统的日期值</td>
</tr>
<tr>
<td>CURTIME 和 CURRENT_TIME</td>
<td>两个函数作用相同，返回当前系统的时间值</td>
</tr>
<tr>
<td>NOW 和  SYSDATE</td>
<td>两个函数作用相同，返回当前系统的日期和时间值</td>
</tr>
<tr>
<td>MONTH</td>
<td>获取指定日期中的月份</td>
</tr>
<tr>
<td>MONTHNAME</td>
<td>获取指定日期中的月份英文名称</td>
</tr>
<tr>
<td>DAYNAME</td>
<td>获取指定曰期对应的星期几的英文名称</td>
</tr>
<tr>
<td>DAYOFWEEK</td>
<td>获取指定日期对应的一周的索引位置值</td>
</tr>
<tr>
<td>WEEK</td>
<td>获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53</td>
</tr>
<tr>
<td>DAYOFYEAR</td>
<td>获取指定曰期是一年中的第几天，返回值范围是1~366</td>
</tr>
<tr>
<td>DAYOFMONTH</td>
<td>获取指定日期是一个月中是第几天，返回值范围是1~31</td>
</tr>
<tr>
<td>YEAR</td>
<td>获取年份，返回值范围是 1970〜2069</td>
</tr>
<tr>
<td>TIME_TO_SEC</td>
<td>将时间参数转换为秒数</td>
</tr>
<tr>
<td>SEC_TO_TIME</td>
<td>将秒数转换为时间，与TIME_TO_SEC 互为反函数</td>
</tr>
<tr>
<td>DATE_ADD 和 ADDDATE</td>
<td>两个函数功能相同，都是向日期添加指定的时间间隔</td>
</tr>
<tr>
<td>DATE_SUB 和 SUBDATE</td>
<td>两个函数功能相同，都是向日期减去指定的时间间隔</td>
</tr>
<tr>
<td>ADDTIME</td>
<td>时间加法运算，在原始时间上添加指定的时间</td>
</tr>
<tr>
<td>SUBTIME</td>
<td>时间减法运算，在原始时间上减去指定的时间</td>
</tr>
<tr>
<td>DATEDIFF</td>
<td>获取两个日期之间间隔，返回参数 1 减去参数 2 的值</td>
</tr>
<tr>
<td>DATE_FORMAT</td>
<td>格式化指定的日期，根据参数返回指定格式的值</td>
</tr>
<tr>
<td>WEEKDAY</td>
<td>获取指定日期在一周内的对应的工作日索引</td>
</tr>
</tbody></table>
<hr>
<h4 id="正则查询"><a href="#正则查询" class="headerlink" title="正则查询"></a>正则查询</h4><p>正则表达式（Regular Expression）是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM emp WHERE name REGEXP &#x27;^T&#x27;;	-- 匹配以T开头的name值</span><br><span class="line">SELECT * FROM emp WHERE name REGEXP &#x27;2$&#x27;;	-- 匹配以2结尾的name值</span><br><span class="line">SELECT * FROM emp WHERE name REGEXP &#x27;[uvw]&#x27;;-- 匹配包含 uvw 的name值</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>在字符串开始处进行匹配</td>
</tr>
<tr>
<td>$</td>
<td>在字符串末尾处进行匹配</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意单个字符, 包括换行符</td>
</tr>
<tr>
<td>[…]</td>
<td>匹配出括号内的任意字符</td>
</tr>
<tr>
<td>[^…]</td>
<td>匹配不出括号内的任意字符</td>
</tr>
<tr>
<td>a*</td>
<td>匹配零个或者多个a(包括空串)</td>
</tr>
<tr>
<td>a+</td>
<td>匹配一个或者多个a(不包括空串)</td>
</tr>
<tr>
<td>a?</td>
<td>匹配零个或者一个a</td>
</tr>
<tr>
<td>a1|a2</td>
<td>匹配a1或a2</td>
</tr>
<tr>
<td>a(m)</td>
<td>匹配m个a</td>
</tr>
<tr>
<td>a(m,)</td>
<td>至少匹配m个a</td>
</tr>
<tr>
<td>a(m,n)</td>
<td>匹配m个a 到 n个a</td>
</tr>
<tr>
<td>a(,n)</td>
<td>匹配0到n个a</td>
</tr>
<tr>
<td>(…)</td>
<td>将模式元素组成单一元素</td>
</tr>
</tbody></table>
<hr>
<h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><ul>
<li><p>排序查询语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 [WHERE 条件] ORDER BY 列名1 排序方式1,列名2 排序方式2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>排序方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASC:升序</span><br><span class="line">DESC:降序</span><br></pre></td></tr></table></figure>

<p>注意：多个排序条件，当前边的条件值一样时，才会判断第二条件</p>
</li>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 按照库存升序排序</span><br><span class="line">SELECT * FROM product ORDER BY stock ASC;</span><br><span class="line"></span><br><span class="line">-- 查询名称中包含手机的商品信息。按照金额降序排序</span><br><span class="line">SELECT * FROM product WHERE NAME LIKE &#x27;%手机%&#x27; ORDER BY price DESC;</span><br><span class="line"></span><br><span class="line">-- 按照金额升序排序，如果金额相同，按照库存降序排列</span><br><span class="line">SELECT * FROM product ORDER BY price ASC,stock DESC;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>分组查询会进行去重</p>
<ul>
<li><p>分组查询语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式];</span><br></pre></td></tr></table></figure>

<p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤</p>
<p>分组规定：</p>
<ul>
<li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前</li>
<li>NULL 的行会单独分为一组</li>
<li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型</li>
</ul>
</li>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 按照品牌分组，获取每组商品的总金额</span><br><span class="line">SELECT brand,SUM(price) FROM product GROUP BY brand;</span><br><span class="line"></span><br><span class="line">-- 对金额大于4000元的商品，按照品牌分组,获取每组商品的总金额</span><br><span class="line">SELECT brand,SUM(price) FROM product WHERE price &gt; 4000 GROUP BY brand;</span><br><span class="line"></span><br><span class="line">-- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的</span><br><span class="line">SELECT brand,SUM(price) AS getSum FROM product WHERE price &gt; 4000 GROUP BY brand HAVING getSum &gt; 7000;</span><br><span class="line"></span><br><span class="line">-- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的、并按照总金额的降序排列</span><br><span class="line">SELECT brand,SUM(price) AS getSum FROM product WHERE price &gt; 4000 GROUP BY brand HAVING getSum &gt; 7000 ORDER BY getSum DESC;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><ul>
<li><p>分页查询语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式] LIMIT 开始索引,查询条数;</span><br></pre></td></tr></table></figure>
</li>
<li><p>公式：开始索引 &#x3D; (当前页码-1) * 每页显示的条数</p>
</li>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM product LIMIT 0,2;  -- 第一页 开始索引=(1-1) * 2</span><br><span class="line">SELECT * FROM product LIMIT 2,2;  -- 第二页 开始索引=(2-1) * 2</span><br><span class="line">SELECT * FROM product LIMIT 4,2;  -- 第三页 开始索引=(3-1) * 2</span><br><span class="line">SELECT * FROM product LIMIT 6,2;  -- 第四页 开始索引=(4-1) * 2</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-DQL%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E5%9B%BE%E8%A7%A3.png"></p>
</li>
</ul>
<hr>
<h2 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h2><h3 id="约束分类"><a href="#约束分类" class="headerlink" title="约束分类"></a>约束分类</h3><h4 id="约束介绍"><a href="#约束介绍" class="headerlink" title="约束介绍"></a>约束介绍</h4><p>约束：对表中的数据进行限定，保证数据的正确性、有效性、完整性</p>
<p>约束的分类：</p>
<table>
<thead>
<tr>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>PRIMARY KEY</td>
<td>主键约束</td>
</tr>
<tr>
<td>PRIMARY KEY AUTO_INCREMENT</td>
<td>主键、自动增长</td>
</tr>
<tr>
<td>UNIQUE</td>
<td>唯一约束</td>
</tr>
<tr>
<td>NOT NULL</td>
<td>非空约束</td>
</tr>
<tr>
<td>FOREIGN KEY</td>
<td>外键约束</td>
</tr>
<tr>
<td>FOREIGN KEY ON UPDATE CASCADE</td>
<td>外键级联更新</td>
</tr>
<tr>
<td>FOREIGN KEY ON DELETE CASCADE</td>
<td>外键级联删除</td>
</tr>
</tbody></table>
<hr>
<h4 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h4><ul>
<li><p>主键约束特点：</p>
<ul>
<li>主键约束默认包含<strong>非空和唯一</strong>两个功能</li>
<li>一张表只能有一个主键</li>
<li>主键一般用于表中数据的唯一标识</li>
</ul>
</li>
<li><p>建表时添加主键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	列名 数据类型 PRIMARY KEY,</span><br><span class="line">    列名 数据类型,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除主键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建表后单独添加主键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型 PRIMARY KEY;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建student表</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">	id INT PRIMARY KEY  -- 给id添加主键约束</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO student VALUES (1),(2);</span><br><span class="line">-- 主键默认唯一，添加重复数据，会报错</span><br><span class="line">INSERT INTO student VALUES (2);</span><br><span class="line">-- 主键默认非空，不能添加null的数据</span><br><span class="line">INSERT INTO student VALUES (NULL);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="主键自增"><a href="#主键自增" class="headerlink" title="主键自增"></a>主键自增</h4><p>主键自增约束可以为空，并自动增长。删除某条数据不影响自增的下一个数值，依然按照前一个值自增</p>
<ul>
<li><p>建表时添加主键自增约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	列名 数据类型 PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    列名 数据类型,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除主键自增约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建表后单独添加主键自增约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型 AUTO_INCREMENT;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建student2表</span><br><span class="line">CREATE TABLE student2(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT    -- 给id添加主键自增约束</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO student2 VALUES (1),(2);</span><br><span class="line">-- 添加null值，会自动增长</span><br><span class="line">INSERT INTO student2 VALUES (NULL),(NULL);-- 3，4</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h4><p>唯一约束：约束不能有重复的数据</p>
<ul>
<li><p>建表时添加唯一约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	列名 数据类型 UNIQUE,</span><br><span class="line">    列名 数据类型,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除唯一约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP INDEX 列名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建表后单独添加唯一约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型 UNIQUE;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h4><ul>
<li><p>建表时添加非空约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	列名 数据类型 NOT NULL,</span><br><span class="line">    列名 数据类型,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除非空约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建表后单独添加非空约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型 NOT NULL;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>  外键约束：让表和表之间产生关系，从而保证数据的准确性</p>
<ul>
<li><p>建表时添加外键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	列名 数据类型 约束,</span><br><span class="line">    ...</span><br><span class="line">    CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除外键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建表后单独添加外键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名);</span><br></pre></td></tr></table></figure>
</li>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建user用户表</span><br><span class="line">CREATE TABLE USER(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,    -- id</span><br><span class="line">	name VARCHAR(20) NOT NULL             -- 姓名</span><br><span class="line">);</span><br><span class="line">-- 添加用户数据</span><br><span class="line">INSERT INTO USER VALUES (NULL,&#x27;张三&#x27;),(NULL,&#x27;李四&#x27;),(NULL,&#x27;王五&#x27;);</span><br><span class="line"></span><br><span class="line">-- 创建orderlist订单表</span><br><span class="line">CREATE TABLE orderlist(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,    -- id</span><br><span class="line">	number VARCHAR(20) NOT NULL,          -- 订单编号</span><br><span class="line">	uid INT,                              -- 订单所属用户</span><br><span class="line">	CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id)   -- 添加外键约束</span><br><span class="line">);</span><br><span class="line">-- 添加订单数据</span><br><span class="line">INSERT INTO orderlist VALUES (NULL,&#x27;hm001&#x27;,1),(NULL,&#x27;hm002&#x27;,1),</span><br><span class="line">(NULL,&#x27;hm003&#x27;,2),(NULL,&#x27;hm004&#x27;,2),</span><br><span class="line">(NULL,&#x27;hm005&#x27;,3),(NULL,&#x27;hm006&#x27;,3);</span><br><span class="line"></span><br><span class="line">-- 添加一个订单，但是没有所属用户。无法添加</span><br><span class="line">INSERT INTO orderlist VALUES (NULL,&#x27;hm007&#x27;,8);</span><br><span class="line">-- 删除王五这个用户，但是订单表中王五还有很多个订单呢。无法删除</span><br><span class="line">DELETE FROM USER WHERE NAME=&#x27;王五&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="外键级联"><a href="#外键级联" class="headerlink" title="外键级联"></a>外键级联</h4><p>级联操作：当把主表中的数据进行删除或更新时，从表中有关联的数据的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION</p>
<ul>
<li><p>RESTRICT 和 NO ACTION相同， 是指限制在子表有关联记录的情况下， 父表不能更新</p>
</li>
<li><p>CASCADE 表示父表在更新或者删除时，更新或者删除子表对应的记录</p>
</li>
<li><p>SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL</p>
</li>
</ul>
<p>级联操作：</p>
<ul>
<li><p>添加级联更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名) ON UPDATE [CASCADE | RESTRICT | SET NULL];</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加级联删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名) ON DELETE CASCADE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同时添加级联更新和级联删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名) ON UPDATE CASCADE ON DELETE CASCADE;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="多表设计"><a href="#多表设计" class="headerlink" title="多表设计"></a>多表设计</h3><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>多表：有多张数据表，而表与表之间有一定的关联关系，通过外键约束实现，分为一对一、一对多、多对多三类</p>
<p>举例：人和身份证</p>
<p>实现原则：在任意一个表建立外键，去关联另外一个表的主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建person表</span><br><span class="line">CREATE TABLE person(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 主键id</span><br><span class="line">	NAME VARCHAR(20)                        -- 姓名</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO person VALUES (NULL,&#x27;张三&#x27;),(NULL,&#x27;李四&#x27;);</span><br><span class="line"></span><br><span class="line">-- 创建card表</span><br><span class="line">CREATE TABLE card(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 主键id</span><br><span class="line">	number VARCHAR(20) UNIQUE NOT NULL,	-- 身份证号</span><br><span class="line">	pid INT UNIQUE,                         -- 外键列</span><br><span class="line">	CONSTRAINT cp_fk1 FOREIGN KEY (pid) REFERENCES person(id)</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO card VALUES (NULL,&#x27;12345&#x27;,1),(NULL,&#x27;56789&#x27;,2);</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E5%A4%9A%E8%A1%A8%E8%AE%BE%E8%AE%A1%E4%B8%80%E5%AF%B9%E4%B8%80.png"></p>
<hr>
<h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>举例：用户和订单、商品分类和商品</p>
<p>实现原则：在多的一方，建立外键约束，来关联一的一方主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建user表</span><br><span class="line">CREATE TABLE USER(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 主键id</span><br><span class="line">	NAME VARCHAR(20)                        -- 姓名</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO USER VALUES (NULL,&#x27;张三&#x27;),(NULL,&#x27;李四&#x27;);</span><br><span class="line"></span><br><span class="line">-- 创建orderlist表</span><br><span class="line">CREATE TABLE orderlist(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 主键id</span><br><span class="line">	number VARCHAR(20),                     -- 订单编号</span><br><span class="line">	uid INT,				-- 外键列</span><br><span class="line">	CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id)</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO orderlist VALUES (NULL,&#x27;hm001&#x27;,1),(NULL,&#x27;hm002&#x27;,1),(NULL,&#x27;hm003&#x27;,2),(NULL,&#x27;hm004&#x27;,2);</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E5%A4%9A%E8%A1%A8%E8%AE%BE%E8%AE%A1%E4%B8%80%E5%AF%B9%E5%A4%9A.png" alt="多表设计一对多"></p>
<hr>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>举例：学生和课程。一个学生可以选择多个课程，一个课程也可以被多个学生选择</p>
<p>实现原则：借助第三张表中间表，中间表至少包含两个列，这两个列作为中间表的外键，分别关联两张表的主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建student表</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 主键id</span><br><span class="line">	NAME VARCHAR(20)			-- 学生姓名</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO student VALUES (NULL,&#x27;张三&#x27;),(NULL,&#x27;李四&#x27;);</span><br><span class="line"></span><br><span class="line">-- 创建course表</span><br><span class="line">CREATE TABLE course(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 主键id</span><br><span class="line">	NAME VARCHAR(10)			-- 课程名称</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO course VALUES (NULL,&#x27;语文&#x27;),(NULL,&#x27;数学&#x27;);</span><br><span class="line"></span><br><span class="line">-- 创建中间表</span><br><span class="line">CREATE TABLE stu_course(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 主键id</span><br><span class="line">	sid INT,  -- 用于和student表中的id进行外键关联</span><br><span class="line">	cid INT,  -- 用于和course表中的id进行外键关联</span><br><span class="line">	CONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id), -- 添加外键约束</span><br><span class="line">	CONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id)   -- 添加外键约束</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO stu_course VALUES (NULL,1,1),(NULL,1,2),(NULL,2,1),(NULL,2,2);</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E5%A4%9A%E8%A1%A8%E8%AE%BE%E8%AE%A1%E5%A4%9A%E5%AF%B9%E5%A4%9A.png"></p>
<hr>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><h4 id="内外连接"><a href="#内外连接" class="headerlink" title="内外连接"></a>内外连接</h4><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>连接查询的是两张表有交集的部分数据，两张表分为<strong>驱动表和被驱动表</strong>，如果结果集中的每条记录都是两个表相互匹配的组合，则称这样的结果集为笛卡尔积</p>
<p>内连接查询，若驱动表中的记录在被驱动表中找不到匹配的记录时，则该记录不会加到最后的结果集</p>
<ul>
<li><p>显式内连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名1 [INNER] JOIN 表名2 ON 条件;</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式内连接：内连接中 WHERE 子句和 ON 子句是等价的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名1,表名2 WHERE 条件;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>STRAIGHT_JOIN与 JOIN 类似，只不过左表始终在右表之前读取，只适用于内连接</p>
<hr>
<h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>外连接查询，若驱动表中的记录在被驱动表中找不到匹配的记录时，则该记录也会加到最后的结果集，只是对于被驱动表中<strong>不匹配过滤条件</strong>的记录，各个字段使用 NULL 填充</p>
<p>应用实例：查学生成绩，也想展示出缺考的人的成绩</p>
<ul>
<li><p>左外连接：选择左侧的表为驱动表，查询左表的全部数据，和左右两张表有交集部分的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名1 LEFT [OUTER] JOIN 表名2 ON 条件;</span><br></pre></td></tr></table></figure>
</li>
<li><p>右外连接：选择右侧的表为驱动表，查询右表的全部数据，和左右两张表有交集部分的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名1 RIGHT [OUTER] JOIN 表名2 ON 条件;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-JOIN%E6%9F%A5%E8%AF%A2%E5%9B%BE.png"></p>
<hr>
<h4 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h4><p>自关联查询：同一张表中有数据关联，可以多次查询这同一个表</p>
<ul>
<li><p>数据准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建员工表</span><br><span class="line">CREATE TABLE employee(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 员工编号</span><br><span class="line">	NAME VARCHAR(20),					-- 员工姓名</span><br><span class="line">	mgr INT,							-- 上级编号</span><br><span class="line">	salary DOUBLE						-- 员工工资</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO employee VALUES (1001,&#x27;孙悟空&#x27;,1005,9000.00),..,(1009,&#x27;宋江&#x27;,NULL,16000.00);</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E8%87%AA%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87.png"></p>
</li>
<li><p>数据查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询所有员工的姓名及其直接上级的姓名，没有上级的员工也需要查询</span><br><span class="line">/*</span><br><span class="line">分析</span><br><span class="line">	员工信息 employee表</span><br><span class="line">	条件：employee.mgr = employee.id</span><br><span class="line">	查询左表的全部数据，和左右两张表有交集部分数据，左外连接</span><br><span class="line">*/</span><br><span class="line">SELECT</span><br><span class="line">	e1.id,</span><br><span class="line">	e1.name,</span><br><span class="line">	e1.mgr,</span><br><span class="line">	e2.id,</span><br><span class="line">	e2.name</span><br><span class="line">FROM</span><br><span class="line">	employee e1</span><br><span class="line">LEFT OUTER JOIN</span><br><span class="line">	employee e2</span><br><span class="line">ON</span><br><span class="line">	e1.mgr = e2.id;	</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id		name	mgr	   id	  name</span><br><span class="line">1001	孙悟空	  1005	1005	唐僧</span><br><span class="line">1002	猪八戒	  1005	1005	唐僧</span><br><span class="line">1003	沙和尚	  1005	1005	唐僧</span><br><span class="line">1004	小白龙	  1005	1005	唐僧</span><br><span class="line">1005	唐僧	   NULL	 NULL	 NULL</span><br><span class="line">1006	武松	   1009	 1009	 宋江</span><br><span class="line">1007	李逵	   1009	 1009	 宋江</span><br><span class="line">1008	林冲	   1009	 1009	 宋江</span><br><span class="line">1009	宋江	   NULL	 NULL	 NULL</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="连接原理"><a href="#连接原理" class="headerlink" title="连接原理"></a>连接原理</h4><p>Index Nested-Loop Join 算法：查询驱动表得到<strong>数据集</strong>，然后根据数据集中的每一条记录的<strong>关联字段再分别</strong>到被驱动表中查找匹配（<strong>走索引</strong>），所以驱动表只需要访问一次，被驱动表要访问多次</p>
<p>MySQL 将查询驱动表后得到的记录成为驱动表的扇出，连接查询的成本：单次访问驱动表的成本 + 扇出值 * 单次访问被驱动表的成本，优化器会选择成本最小的表连接顺序（确定谁是驱动表，谁是被驱动表）生成执行计划，进行连接查询，优化方式：</p>
<ul>
<li>减少驱动表的扇出（让数据量小的表来做驱动表）</li>
<li>降低访问被驱动表的成本</li>
</ul>
<p>说明：STRAIGHT_JOIN 是查一条驱动表，然后根据关联字段去查被驱动表，要访问多次驱动表，所以需要优化为 INL 算法</p>
<p>Block Nested-Loop Join 算法：一种<strong>空间换时间</strong>的优化方式，基于块的循环连接，执行连接查询前申请一块固定大小的内存作为连接缓冲区 Join Buffer，先把若干条驱动表中的扇出暂存在缓冲区，每一条被驱动表中的记录一次性的与 Buffer 中多条记录进行匹配（扫描全部数据，一条一条的匹配），因为是在内存中完成，所以速度快，并且降低了 I&#x2F;O 成本</p>
<p>Join Buffer 可以通过参数 <code>join_buffer_size</code> 进行配置，默认大小是 256 KB</p>
<p>在成本分析时，对于很多张表的连接查询，连接顺序有非常多，MySQL 如果挨着进行遍历计算成本，会消耗很多资源</p>
<ul>
<li><p>提前结束某种连接顺序的成本评估：维护一个全局变量记录当前成本最小的连接方式，如果一种顺序只计算了一部分就已经超过了最小成本，可以提前结束计算</p>
</li>
<li><p>系统变量 optimizer_search_depth：如果连接表的个数小于该变量，就继续穷举分析每一种连接数量，反之只对数量与 depth 值相同的表进行分析，该值越大成本分析的越精确</p>
</li>
<li><p>系统变量 optimizer_prune_level：控制启发式规则的启用，这些规则就是根据以往经验指定的，不满足规则的连接顺序不分析成本</p>
</li>
</ul>
<hr>
<h4 id="连接优化"><a href="#连接优化" class="headerlink" title="连接优化"></a>连接优化</h4><h5 id="BKA"><a href="#BKA" class="headerlink" title="BKA"></a>BKA</h5><p>Batched Key Access 算法是对 NLJ 算法的优化，在读取被驱动表的记录时使用顺序 IO，Extra 信息中会有 Batched Key Access 信息</p>
<p>使用 BKA 的表的 JOIN 过程如下：</p>
<ul>
<li>连接驱动表将满足条件的记录放入 Join Buffer，并将两表连接的字段放入一个 DYNAMIC_ARRAY ranges 中</li>
<li>在进行表的过接过程中，会将 ranges 相关的信息传入 Buffer 中，进行被驱动表主建的查找及排序操作</li>
<li>调用步骤 2 中产生的有序主建，<strong>顺序读取被驱动表的数据</strong></li>
<li>当缓冲区的数据被读完后，会重复进行步骤 2、3，直到记录被读取完</li>
</ul>
<p>使用 BKA 优化需要设进行设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET optimizer_switch=&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;;</span><br></pre></td></tr></table></figure>

<p>说明：前两个参数的作用是启用 MRR，因为 BKA 算法的优化要依赖于 MRR（系统优化 → 内存优化 → Read 详解）</p>
<hr>
<h5 id="BNL"><a href="#BNL" class="headerlink" title="BNL"></a>BNL</h5><h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><p>BNL 即 Block Nested-Loop Join 算法，由于要访问多次被驱动表，会产生两个问题：</p>
<ul>
<li><p>Join 语句多次扫描一个冷表，并且语句执行时间小于 1 秒，就会在再次扫描冷表时，把冷表的数据页移到 LRU 链表头部，导致热数据被淘汰，影响业务的正常运行</p>
<p>这种情况冷表的数据量要小于整个 Buffer Pool 的 old 区域，能够完全放入 old 区，才会再次被读时加到 young，否则读取下一段时就已经把上一段淘汰</p>
</li>
<li><p>Join 语句在循环读磁盘和淘汰内存页，进入 old 区域的数据页很可能在 1 秒之内就被淘汰，就会导致 MySQL 实例的 Buffer Pool 在这段时间内 young 区域的数据页没有被合理地淘汰</p>
</li>
</ul>
<p>大表 Join 操作虽然对 IO 有影响，但是在语句执行结束后对 IO 的影响随之结束。但是对 Buffer Pool 的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率</p>
<h6 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h6><p>将 BNL 算法转成 BKA 算法，优化方向：</p>
<ul>
<li>在被驱动表上建索引，这样就可以根据索引进行顺序 IO</li>
<li>使用临时表，<strong>在临时表上建立索引</strong>，将被驱动表和临时表进行连接查询</li>
</ul>
<p>驱动表 t1，被驱动表 t2，使用临时表的工作流程：</p>
<ul>
<li>把表 t1 中满足条件的数据放在临时表 tmp_t 中</li>
<li>给临时表 tmp_t 的关联字段加上索引，使用 BKA 算法</li>
<li>让表 t2 和 tmp_t 做 Join 操作（临时表是被驱动表）</li>
</ul>
<p>补充：MySQL 8.0 支持 hash join，join_buffer 维护的不再是一个无序数组，而是一个哈希表，查询效率更高，执行效率比临时表更高</p>
<hr>
<h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><h4 id="查询分类"><a href="#查询分类" class="headerlink" title="查询分类"></a>查询分类</h4><p>查询语句中嵌套了查询语句，<strong>将嵌套查询称为子查询</strong>，FROM 子句后面的子查询的结果集称为派生表</p>
<p>根据结果分类：</p>
<ul>
<li><p>结果是单行单列：可以将查询的结果作为另一条语句的查询条件，使用运算符判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 WHERE 列名=(SELECT 列名/聚合函数(列名) FROM 表名 [WHERE 条件]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果是多行单列：可以作为条件，使用运算符 IN 或 NOT IN 进行判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 WHERE 列名 [NOT] IN (SELECT 列名 FROM 表名 [WHERE 条件]); </span><br></pre></td></tr></table></figure>
</li>
<li><p>结果是多行多列：查询的结果可以作为一张虚拟表参与查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 [别名],(SELECT 列名 FROM 表名 [WHERE 条件]) [别名] [WHERE 条件];</span><br><span class="line"></span><br><span class="line">-- 查询订单表orderlist中id大于4的订单信息和所属用户USER信息</span><br><span class="line">SELECT </span><br><span class="line">	* </span><br><span class="line">FROM </span><br><span class="line">	USER u,</span><br><span class="line">	(SELECT * FROM orderlist WHERE id&gt;4) o </span><br><span class="line">WHERE </span><br><span class="line">	u.id=o.uid;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>相关性分类：</p>
<ul>
<li>不相关子查询：子查询不依赖外层查询的值，可以单独运行出结果</li>
<li>相关子查询：子查询的执行需要依赖外层查询的值</li>
</ul>
<hr>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p>不相关子查询的结果集会被写入一个临时表，并且在写入时<strong>去重</strong>，该过程称为<strong>物化</strong>，存储结果集的临时表称为物化表</p>
<p>系统变量 tmp_table_size 或者 max_heap_table_size 为表的最值</p>
<ul>
<li>小于系统变量时，内存中可以保存，会为建立<strong>基于内存</strong>的 MEMORY 存储引擎的临时表，并建立哈希索引</li>
<li>大于任意一个系统变量时，物化表会使用<strong>基于磁盘</strong>的 InnoDB 存储引擎来保存结果集中的记录，索引类型为 B+ 树</li>
</ul>
<p>物化后，嵌套查询就相当于外层查询的表和物化表进行内连接查询，然后经过优化器选择成本最小的表连接顺序执行查询</p>
<p>子查询物化会产生建立临时表的成本，但是将子查询转化为连接查询可以充分发挥优化器的作用，所以引入：半连接</p>
<ul>
<li>t1 和 t2 表进行半连接，对于 t1 表中的某条记录，只需要关心在 t2 表中是否存在，而不需要关心有多少条记录与之匹配，最终结果集只保留 t1 的记录</li>
<li>半连接只是执行子查询的一种方式，MySQL 并没有提供面向用户的半连接语法</li>
</ul>
<p>参考书籍：<a href="https://book.douban.com/subject/35231266/">https://book.douban.com/subject/35231266/</a></p>
<hr>
<h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><p>UNION 是取这两个子查询结果的并集，并进行去重，同时进行默认规则的排序（union 是行加起来，join 是列加起来）</p>
<p>UNION ALL 是对两个结果集进行并集操作不进行去重，不进行排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(select 1000 as f) union (select id from t1 order by id desc limit 2); #t1表中包含id 为 1-1000 的数据</span><br></pre></td></tr></table></figure>

<p>语句的执行流程：</p>
<ul>
<li>创建一个内存临时表，这个临时表只有一个整型字段 f，并且 f 是主键字段</li>
<li>执行第一个子查询，得到 1000 这个值，并存入临时表中</li>
<li>执行第二个子查询，拿到第一行 id&#x3D;1000，试图插入临时表中，但由于 1000 这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行</li>
<li>取到第二行 id&#x3D;999，插入临时表成功</li>
<li>从临时表中按行取出数据，返回结果并删除临时表，结果中包含两行数据分别是 1000 和 999</li>
</ul>
<hr>
<h3 id="查询练习"><a href="#查询练习" class="headerlink" title="查询练习"></a>查询练习</h3><p>数据准备：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建db4数据库</span><br><span class="line">CREATE DATABASE db4;</span><br><span class="line">-- 使用db4数据库</span><br><span class="line">USE db4;</span><br><span class="line"></span><br><span class="line">-- 创建user表</span><br><span class="line">CREATE TABLE USER(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 用户id</span><br><span class="line">	NAME VARCHAR(20),					-- 用户姓名</span><br><span class="line">	age INT                             -- 用户年龄</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 订单表</span><br><span class="line">CREATE TABLE orderlist(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 订单id</span><br><span class="line">	number VARCHAR(30),					-- 订单编号</span><br><span class="line">	uid INT,   							-- 外键字段</span><br><span class="line">	CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 商品分类表</span><br><span class="line">CREATE TABLE category(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,  -- 商品分类id</span><br><span class="line">	NAME VARCHAR(10)                    -- 商品分类名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 商品表</span><br><span class="line">CREATE TABLE product(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,   -- 商品id</span><br><span class="line">	NAME VARCHAR(30),                    -- 商品名称</span><br><span class="line">	cid INT, -- 外键字段</span><br><span class="line">	CONSTRAINT cp_fk1 FOREIGN KEY (cid) REFERENCES category(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 中间表</span><br><span class="line">CREATE TABLE us_pro(</span><br><span class="line">	upid INT PRIMARY KEY AUTO_INCREMENT,  -- 中间表id</span><br><span class="line">	uid INT, 							  -- 外键字段。需要和用户表的主键产生关联</span><br><span class="line">	pid INT,							  -- 外键字段。需要和商品表的主键产生关联</span><br><span class="line">	CONSTRAINT up_fk1 FOREIGN KEY (uid) REFERENCES USER(id),</span><br><span class="line">	CONSTRAINT up_fk2 FOREIGN KEY (pid) REFERENCES product(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E5%A4%9A%E8%A1%A8%E7%BB%83%E4%B9%A0%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png" alt="多表练习架构设计"></p>
<p><strong>数据查询：</strong></p>
<ol>
<li><p>查询用户的编号、姓名、年龄、订单编号</p>
<p>数据：用户的编号、姓名、年龄在 user 表，订单编号在 orderlist 表</p>
<p>条件：user.id &#x3D; orderlist.uid</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	u.*,</span><br><span class="line">	o.number</span><br><span class="line">FROM</span><br><span class="line">	USER u,</span><br><span class="line">	orderlist o</span><br><span class="line">WHERE</span><br><span class="line">	u.id = o.uid;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询所有的用户，显示用户的编号、姓名、年龄、订单编号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	u.*,</span><br><span class="line">	o.number</span><br><span class="line">FROM</span><br><span class="line">	USER u</span><br><span class="line">LEFT OUTER JOIN</span><br><span class="line">	orderlist o</span><br><span class="line">ON</span><br><span class="line">	u.id = o.uid;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询用户年龄大于 23 岁的信息，显示用户的编号、姓名、年龄、订单编号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	u.*,</span><br><span class="line">	o.number</span><br><span class="line">FROM</span><br><span class="line">	USER u,</span><br><span class="line">	orderlist o</span><br><span class="line">WHERE</span><br><span class="line">	u.id = o.uid</span><br><span class="line">	AND</span><br><span class="line">	u.age &gt; 23;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	u.*,</span><br><span class="line">	o.number</span><br><span class="line">FROM</span><br><span class="line">	(SELECT * FROM USER WHERE age &gt; 23) u,-- 嵌套查询</span><br><span class="line">	orderlist o</span><br><span class="line">WHERE</span><br><span class="line">	u.id = o.uid;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询张三和李四用户的信息，显示用户的编号、姓名、年龄、订单编号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	u.*,</span><br><span class="line">	o.number</span><br><span class="line">FROM</span><br><span class="line">	USER u,</span><br><span class="line">	orderlist o</span><br><span class="line">WHERE</span><br><span class="line">	u.id=o.uid</span><br><span class="line">	AND</span><br><span class="line">	u.name IN (&#x27;张三&#x27;,&#x27;李四&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询所有的用户和该用户能查看的所有的商品，显示用户的编号、姓名、年龄、商品名称</p>
<p>数据：用户的编号、姓名、年龄在 user 表，商品名称在 product 表，中间表 us_pro</p>
<p>条件：us_pro.uid &#x3D; user.id AND us_pro.pid &#x3D; product.id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	u.id,</span><br><span class="line">	u.name,</span><br><span class="line">	u.age,</span><br><span class="line">	p.name</span><br><span class="line">FROM</span><br><span class="line">	USER u,</span><br><span class="line">	product p,</span><br><span class="line">	us_pro up</span><br><span class="line">WHERE</span><br><span class="line">	up.uid = u.id</span><br><span class="line">	AND</span><br><span class="line">	up.pid=p.id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询张三和李四这两个用户可以看到的商品，显示用户的编号、姓名、年龄、商品名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	u.id,</span><br><span class="line">	u.name,</span><br><span class="line">	u.age,</span><br><span class="line">	p.name</span><br><span class="line">FROM</span><br><span class="line">	USER u,</span><br><span class="line">	product p,</span><br><span class="line">	us_pro up</span><br><span class="line">WHERE</span><br><span class="line">	up.uid=u.id</span><br><span class="line">	AND</span><br><span class="line">	up.pid=p.id</span><br><span class="line">	AND</span><br><span class="line">	u.name IN (&#x27;张三&#x27;,&#x27;李四&#x27;);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="高级结构"><a href="#高级结构" class="headerlink" title="高级结构"></a>高级结构</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>视图概念：视图是一种虚拟存在的数据表，这个虚拟的表并不在数据库中实际存在</p>
<p>本质：将一条 SELECT 查询语句的结果封装到了一个虚拟表中，所以在创建视图的时候，工作重心要放在这条 SELECT 查询语句上</p>
<p>作用：将一些比较复杂的查询语句的结果，封装到一个虚拟表中，再有相同查询需求时，直接查询该虚拟表</p>
<p>优点：</p>
<ul>
<li><p>简单：使用视图的用户不需要关心表的结构、关联条件和筛选条件，因为虚拟表中已经是过滤好的结果集</p>
</li>
<li><p>安全：使用视图的用户只能访问查询的结果集，对表的权限管理并不能限制到某个行某个列</p>
</li>
<li><p>数据独立，一旦视图的结构确定，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响</p>
</li>
</ul>
<hr>
<h4 id="视图创建"><a href="#视图创建" class="headerlink" title="视图创建"></a>视图创建</h4><ul>
<li><p>创建视图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [OR REPLACE] </span><br><span class="line">VIEW 视图名称 [(列名列表)] </span><br><span class="line">AS 查询语句</span><br><span class="line">[WITH [CASCADED | LOCAL] CHECK OPTION];</span><br></pre></td></tr></table></figure>

<p><code>WITH [CASCADED | LOCAL] CHECK OPTION</code> 决定了是否允许更新数据使记录不再满足视图的条件：</p>
<ul>
<li>LOCAL：只要满足本视图的条件就可以更新</li>
<li>CASCADED：必须满足所有针对该视图的所有视图的条件才可以更新， 默认值</li>
</ul>
</li>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 数据准备 city</span><br><span class="line">id	NAME	cid</span><br><span class="line">1	深圳	 	1</span><br><span class="line">2	上海		1</span><br><span class="line">3	纽约		2</span><br><span class="line">4	莫斯科	    3</span><br><span class="line"></span><br><span class="line">-- 数据准备 country</span><br><span class="line">id	NAME</span><br><span class="line">1	中国</span><br><span class="line">2	美国</span><br><span class="line">3	俄罗斯</span><br><span class="line"></span><br><span class="line">-- 创建city_country视图，保存城市和国家的信息(使用指定列名)</span><br><span class="line">CREATE </span><br><span class="line">VIEW </span><br><span class="line">	city_country (city_id,city_name,country_name)</span><br><span class="line">AS</span><br><span class="line">    SELECT</span><br><span class="line">        c1.id,</span><br><span class="line">        c1.name,</span><br><span class="line">        c2.name</span><br><span class="line">    FROM</span><br><span class="line">        city c1,</span><br><span class="line">        country c2</span><br><span class="line">    WHERE</span><br><span class="line">        c1.cid=c2.id;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="视图查询"><a href="#视图查询" class="headerlink" title="视图查询"></a>视图查询</h4><ul>
<li><p>查询所有数据表，视图也会查询出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLES;</span><br><span class="line">SHOW TABLE STATUS [\G];</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询视图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 视图名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询某个视图创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE VIEW 视图名称;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="视图修改"><a href="#视图修改" class="headerlink" title="视图修改"></a>视图修改</h4><p>视图表数据修改，会<strong>自动修改源表中的数据</strong>，因为更新的是视图中的基表中的数据</p>
<ul>
<li><p>修改视图表中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE 视图名称 SET 列名 = 值 WHERE 条件;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改视图的结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]</span><br><span class="line">VIEW 视图名称 [(列名列表)] </span><br><span class="line">AS 查询语句</span><br><span class="line">[WITH [CASCADED | LOCAL] CHECK OPTION]</span><br><span class="line"></span><br><span class="line">-- 将视图中的country_name修改为name</span><br><span class="line">ALTER </span><br><span class="line">VIEW </span><br><span class="line">	city_country (city_id,city_name,name) </span><br><span class="line">AS</span><br><span class="line">    SELECT</span><br><span class="line">        c1.id,</span><br><span class="line">        c1.name,</span><br><span class="line">        c2.name</span><br><span class="line">    FROM</span><br><span class="line">        city c1,</span><br><span class="line">        country c2</span><br><span class="line">    WHERE</span><br><span class="line">        c1.cid=c2.id;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="视图删除"><a href="#视图删除" class="headerlink" title="视图删除"></a>视图删除</h4><ul>
<li><p>删除视图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW 视图名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果存在则删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW IF EXISTS 视图名称;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>存储过程和函数：存储过程和函数是事先经过编译并存储在数据库中的一段 SQL 语句的集合</p>
<p>存储过程和函数的好处：</p>
<ul>
<li>提高代码的复用性</li>
<li>减少数据在数据库和应用服务器之间的传输，提高传输效率</li>
<li>减少代码层面的业务处理</li>
<li><strong>一次编译永久有效</strong></li>
</ul>
<p>存储过程和函数的区别：</p>
<ul>
<li>存储函数必须有返回值</li>
<li>存储过程可以没有返回值</li>
</ul>
<hr>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>DELIMITER：</p>
<ul>
<li><p>DELIMITER 关键字用来声明 sql 语句的分隔符，告诉 MySQL 该段命令已经结束</p>
</li>
<li><p>MySQL 语句默认的分隔符是分号，但是有时需要一条功能 sql 语句中包含分号，但是并不作为结束标识，这时使用 DELIMITER 来指定分隔符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER 分隔符</span><br></pre></td></tr></table></figure></li>
</ul>
<p>存储过程的创建调用查看和删除：</p>
<ul>
<li><p>创建存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 修改分隔符为$</span><br><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">-- 标准语法</span><br><span class="line">CREATE PROCEDURE 存储过程名称(参数...)</span><br><span class="line">BEGIN</span><br><span class="line">	sql语句;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">-- 修改分隔符为分号</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL 存储过程名称(实际参数);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM mysql.proc WHERE db=&#x27;数据库名称&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除存储过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE [IF EXISTS] 存储过程名称;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>练习：</p>
<ul>
<li><p>数据准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	NAME	age		gender	score</span><br><span class="line">1	张三		23		男		95</span><br><span class="line">2	李四		24		男		98</span><br><span class="line">3	王五		25		女		100</span><br><span class="line">4	赵六		26		女		90</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 stu_group() 存储过程，封装分组查询总成绩，并按照总成绩升序排序的功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE stu_group()</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT gender,SUM(score) getSum FROM student GROUP BY gender ORDER BY getSum ASC; </span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">-- 调用存储过程</span><br><span class="line">CALL stu_group();</span><br><span class="line">-- 删除存储过程</span><br><span class="line">DROP PROCEDURE IF EXISTS stu_group;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="存储语法"><a href="#存储语法" class="headerlink" title="存储语法"></a>存储语法</h4><h5 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h5><p>存储过程是可以进行编程的，意味着可以使用变量、表达式、条件控制语句等，来完成比较复杂的功能</p>
<ul>
<li><p>定义变量：DECLARE 定义的是局部变量，只能用在 BEGIN END 范围之内</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 变量名 数据类型 [DEFAULT 默认值];</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量的赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET 变量名 = 变量值;</span><br><span class="line">SELECT 列名 INTO 变量名 FROM 表名 [WHERE 条件];</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据准备：表 student</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	NAME	age		gender	score</span><br><span class="line">1	张三		23		男		95</span><br><span class="line">2	李四		24		男		98</span><br><span class="line">3	王五		25		女		100</span><br><span class="line">4	赵六		26		女		90</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义两个 int 变量，用于存储男女同学的总分数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_test3()</span><br><span class="line">BEGIN</span><br><span class="line">	-- 定义两个变量</span><br><span class="line">	DECLARE men,women INT;</span><br><span class="line">	-- 查询男同学的总分数，为men赋值</span><br><span class="line">	SELECT SUM(score) INTO men FROM student WHERE gender=&#x27;男&#x27;;</span><br><span class="line">	-- 查询女同学的总分数，为women赋值</span><br><span class="line">	SELECT SUM(score) INTO women FROM student WHERE gender=&#x27;女&#x27;;</span><br><span class="line">	-- 使用变量</span><br><span class="line">	SELECT men,women;</span><br><span class="line">END$</span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用存储过程</span><br><span class="line">CALL pro_test3();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="IF语句"><a href="#IF语句" class="headerlink" title="IF语句"></a>IF语句</h5><ul>
<li><p>if 语句标准语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IF 判断条件1 THEN 执行的sql语句1;</span><br><span class="line">[ELSEIF 判断条件2 THEN 执行的sql语句2;]</span><br><span class="line">...</span><br><span class="line">[ELSE 执行的sql语句n;]</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据准备：表 student</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	NAME	age		gender	score</span><br><span class="line">1	张三		23		男		95</span><br><span class="line">2	李四		24		男		98</span><br><span class="line">3	王五		25		女		100</span><br><span class="line">4	赵六		26		女		90</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据总成绩判断：全班 380 分及以上学习优秀、320 ~ 380 学习良好、320 以下学习一般</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_test4()</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE total INT;							-- 定义总分数变量</span><br><span class="line">	DECLARE description VARCHAR(10);			-- 定义分数描述变量</span><br><span class="line">	SELECT SUM(score) INTO total FROM student; 	-- 为总分数变量赋值</span><br><span class="line">	-- 判断总分数</span><br><span class="line">	IF total &gt;= 380 THEN</span><br><span class="line">		SET description = &#x27;学习优秀&#x27;;</span><br><span class="line">	ELSEIF total &gt;=320 AND total &lt; 380 THEN</span><br><span class="line">		SET description = &#x27;学习良好&#x27;;</span><br><span class="line">	ELSE</span><br><span class="line">		SET description = &#x27;学习一般&#x27;;</span><br><span class="line">	END IF;</span><br><span class="line">END$</span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用pro_test4存储过程</span><br><span class="line">CALL pro_test4();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5><ul>
<li><p>参数传递的语法</p>
<p>IN：代表输入参数，需要由调用者传递实际数据，默认的<br>OUT：代表输出参数，该参数可以作为返回值<br>INOUT：代表既可以作为输入参数，也可以作为输出参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">-- 标准语法</span><br><span class="line">CREATE PROCEDURE 存储过程名称([IN|OUT|INOUT] 参数名 数据类型)</span><br><span class="line">BEGIN</span><br><span class="line">	执行的sql语句;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入总成绩变量，代表学生总成绩，输出分数描述变量，代表学生总成绩的描述</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE pro_test6(IN total INT, OUT description VARCHAR(10))</span><br><span class="line">BEGIN</span><br><span class="line">	-- 判断总分数</span><br><span class="line">	IF total &gt;= 380 THEN </span><br><span class="line">		SET description = &#x27;学习优秀&#x27;;</span><br><span class="line">	ELSEIF total &gt;= 320 AND total &lt; 380 THEN </span><br><span class="line">		SET description = &#x27;学习不错&#x27;;</span><br><span class="line">	ELSE </span><br><span class="line">		SET description = &#x27;学习一般&#x27;;</span><br><span class="line">	END IF;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用pro_test6存储过程</span><br><span class="line">CALL pro_test6(310,@description);</span><br><span class="line">CALL pro_test6((SELECT SUM(score) FROM student), @description);</span><br><span class="line">-- 查询总成绩描述</span><br><span class="line">SELECT @description;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看参数方法</p>
<ul>
<li>@变量名 : <strong>用户会话变量</strong>，代表整个会话过程他都是有作用的，类似于全局变量</li>
<li>@@变量名 : <strong>系统变量</strong></li>
</ul>
</li>
</ul>
<hr>
<h5 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h5><ul>
<li><p>标准语法 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE 表达式</span><br><span class="line">    WHEN 值1 THEN 执行sql语句1;</span><br><span class="line">    [WHEN 值2 THEN 执行sql语句2;]</span><br><span class="line">    ...</span><br><span class="line">    [ELSE 执行sql语句n;]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>标准语法 2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sCASE</span><br><span class="line">    WHEN 判断条件1 THEN 执行sql语句1;</span><br><span class="line">    [WHEN 判断条件2 THEN 执行sql语句2;]</span><br><span class="line">    ...</span><br><span class="line">    [ELSE 执行sql语句n;]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>演示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_test7(IN total INT)</span><br><span class="line">BEGIN</span><br><span class="line">	-- 定义变量</span><br><span class="line">	DECLARE description VARCHAR(10);</span><br><span class="line">	-- 使用case判断</span><br><span class="line">	CASE</span><br><span class="line">	WHEN total &gt;= 380 THEN</span><br><span class="line">		SET description = &#x27;学习优秀&#x27;;</span><br><span class="line">	WHEN total &gt;= 320 AND total &lt; 380 THEN</span><br><span class="line">		SET description = &#x27;学习不错&#x27;;</span><br><span class="line">	ELSE </span><br><span class="line">		SET description = &#x27;学习一般&#x27;;</span><br><span class="line">	END CASE;</span><br><span class="line">	</span><br><span class="line">	-- 查询分数描述信息</span><br><span class="line">	SELECT description;</span><br><span class="line">END$</span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用pro_test7存储过程</span><br><span class="line">CALL pro_test7(390);</span><br><span class="line">CALL pro_test7((SELECT SUM(score) FROM student));</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="WHILE"><a href="#WHILE" class="headerlink" title="WHILE"></a>WHILE</h5><ul>
<li><p>while 循环语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHILE 条件判断语句 DO</span><br><span class="line">	循环体语句;</span><br><span class="line">	条件控制语句;</span><br><span class="line">END WHILE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算 1~100 之间的偶数和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_test6()</span><br><span class="line">BEGIN</span><br><span class="line">	-- 定义求和变量</span><br><span class="line">	DECLARE result INT DEFAULT 0;</span><br><span class="line">	-- 定义初始化变量</span><br><span class="line">	DECLARE num INT DEFAULT 1;</span><br><span class="line">	-- while循环</span><br><span class="line">	WHILE num &lt;= 100 DO</span><br><span class="line">		IF num % 2 = 0 THEN</span><br><span class="line">			SET result = result + num;</span><br><span class="line">		END IF;</span><br><span class="line">		SET num = num + 1;</span><br><span class="line">	END WHILE;</span><br><span class="line">	-- 查询求和结果</span><br><span class="line">	SELECT result;</span><br><span class="line">END$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">-- 调用pro_test6存储过程</span><br><span class="line">CALL pro_test6();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="REPEAT"><a href="#REPEAT" class="headerlink" title="REPEAT"></a>REPEAT</h5><ul>
<li><p>repeat 循环标准语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line">REPEAT</span><br><span class="line">	循环体语句;</span><br><span class="line">	条件控制语句;</span><br><span class="line">	UNTIL 条件判断语句</span><br><span class="line">END REPEAT;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算 1~10 之间的和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_test9()</span><br><span class="line">BEGIN</span><br><span class="line">	-- 定义求和变量</span><br><span class="line">	DECLARE result INT DEFAULT 0;</span><br><span class="line">	-- 定义初始化变量</span><br><span class="line">	DECLARE num INT DEFAULT 1;</span><br><span class="line">	-- repeat循环</span><br><span class="line">	REPEAT</span><br><span class="line">		-- 累加</span><br><span class="line">		SET result = result + num;</span><br><span class="line">		-- 让num+1</span><br><span class="line">		SET num = num + 1;</span><br><span class="line">		-- 停止循环</span><br><span class="line">		UNTIL num &gt; 10</span><br><span class="line">	END REPEAT;</span><br><span class="line">	-- 查询求和结果</span><br><span class="line">	SELECT result;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用pro_test9存储过程</span><br><span class="line">CALL pro_test9();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="LOOP"><a href="#LOOP" class="headerlink" title="LOOP"></a>LOOP</h5><p>LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，如果不加退出循环的语句，那么就变成了死循环</p>
<ul>
<li><p>loop 循环标准语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[循环名称:] LOOP</span><br><span class="line">	条件判断语句</span><br><span class="line">		[LEAVE 循环名称;]</span><br><span class="line">	循环体语句;</span><br><span class="line">	条件控制语句;</span><br><span class="line">END LOOP 循环名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算 1~10 之间的和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE pro_test10()</span><br><span class="line">BEGIN</span><br><span class="line">	-- 定义求和变量</span><br><span class="line">	DECLARE result INT DEFAULT 0;</span><br><span class="line">	-- 定义初始化变量</span><br><span class="line">	DECLARE num INT DEFAULT 1;</span><br><span class="line">	-- loop循环</span><br><span class="line">	l:LOOP</span><br><span class="line">		-- 条件成立，停止循环</span><br><span class="line">		IF num &gt; 10 THEN</span><br><span class="line">			LEAVE l;</span><br><span class="line">		END IF;</span><br><span class="line">		-- 累加</span><br><span class="line">		SET result = result + num;</span><br><span class="line">		-- 让num+1</span><br><span class="line">		SET num = num + 1;</span><br><span class="line">	END LOOP l;</span><br><span class="line">	-- 查询求和结果</span><br><span class="line">	SELECT result;</span><br><span class="line">END$</span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用pro_test10存储过程</span><br><span class="line">CALL pro_test10();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h5><p>游标是用来存储查询结果集的数据类型，在存储过程和函数中可以使用光标对结果集进行循环的处理</p>
<ul>
<li>游标可以遍历返回的多行结果，每次拿到一整行数据</li>
<li>简单来说游标就类似于集合的迭代器遍历</li>
<li>MySQL 中的游标只能用在存储过程和函数中</li>
</ul>
<p>游标的语法</p>
<ul>
<li><p>创建游标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 游标名称 CURSOR FOR 查询sql语句;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开游标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPEN 游标名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用游标获取数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FETCH 游标名称 INTO 变量名1,变量名2,...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭游标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLOSE 游标名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Mysql 通过一个 Error handler 声明来判断指针是否到尾部，并且必须和创建游标的 SQL 语句声明在一起：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE EXIT HANDLER FOR NOT FOUND (do some action，一般是设置标志变量)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>游标的基本使用</p>
<ul>
<li><p>数据准备：表 student</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	NAME	age		gender	score</span><br><span class="line">1	张三		23		男		95</span><br><span class="line">2	李四		24		男		98</span><br><span class="line">3	王五		25		女		100</span><br><span class="line">4	赵六		26		女		90</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 stu_score 表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE stu_score(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	score INT</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将student表中所有的成绩保存到stu_score表中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE pro_test12()</span><br><span class="line">BEGIN</span><br><span class="line">	-- 定义成绩变量</span><br><span class="line">	DECLARE s_score INT;</span><br><span class="line">	-- 定义标记变量</span><br><span class="line">	DECLARE flag INT DEFAULT 0;</span><br><span class="line">	</span><br><span class="line">	-- 创建游标，查询所有学生成绩数据</span><br><span class="line">	DECLARE stu_result CURSOR FOR SELECT score FROM student;</span><br><span class="line">	-- 游标结束后，将标记变量改为1  这两个必须声明在一起</span><br><span class="line">	DECLARE EXIT HANDLER FOR NOT FOUND SET flag = 1;</span><br><span class="line">	</span><br><span class="line">	-- 开启游标</span><br><span class="line">	OPEN stu_result;</span><br><span class="line">	-- 循环使用游标</span><br><span class="line">	REPEAT</span><br><span class="line">		-- 使用游标，遍历结果,拿到数据</span><br><span class="line">		FETCH stu_result INTO s_score;</span><br><span class="line">		-- 将数据保存到stu_score表中</span><br><span class="line">		INSERT INTO stu_score VALUES (NULL,s_score);</span><br><span class="line">	UNTIL flag=1</span><br><span class="line">	END REPEAT;</span><br><span class="line">	-- 关闭游标</span><br><span class="line">	CLOSE stu_result;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">-- 调用pro_test12存储过程</span><br><span class="line">CALL pro_test12();</span><br><span class="line">-- 查询stu_score表</span><br><span class="line">SELECT * FROM stu_score;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h4><p>存储函数和存储过程是非常相似的，存储函数可以做的事情，存储过程也可以做到</p>
<p>存储函数有返回值，存储过程没有返回值（参数的 out 其实也相当于是返回数据了）</p>
<ul>
<li><p>创建存储函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">-- 标准语法</span><br><span class="line">CREATE FUNCTION 函数名称(参数 数据类型)</span><br><span class="line">RETURNS 返回值类型</span><br><span class="line">BEGIN</span><br><span class="line">	执行的sql语句;</span><br><span class="line">	RETURN 结果;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用存储函数，因为有返回值，所以使用 SELECT 调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 函数名称(实际参数);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除存储函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP FUNCTION 函数名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义存储函数，获取学生表中成绩大于95分的学生数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">CREATE FUNCTION fun_test()</span><br><span class="line">RETURN INT</span><br><span class="line">BEGIN</span><br><span class="line">	-- 定义统计变量</span><br><span class="line">	DECLARE result INT;</span><br><span class="line">	-- 查询成绩大于95分的学生数量，给统计变量赋值</span><br><span class="line">	SELECT COUNT(score) INTO result FROM student WHERE score &gt; 95;</span><br><span class="line">	-- 返回统计结果</span><br><span class="line">	SELECT result;</span><br><span class="line">END</span><br><span class="line">DELIMITER ;</span><br><span class="line">-- 调用fun_test存储函数</span><br><span class="line">SELECT fun_test();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>触发器是与表有关的数据库对象，在 insert&#x2F;update&#x2F;delete 之前或之后触发并执行触发器中定义的 SQL 语句</p>
<ul>
<li>触发器的这种特性可以协助应用在数据库端确保数据的完整性 、日志记录 、数据校验等操作</li>
</ul>
<ul>
<li>使用别名 NEW 和 OLD 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的</li>
<li>现在触发器还只支持行级触发，不支持语句级触发</li>
</ul>
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>OLD的含义</th>
<th>NEW的含义</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT 型触发器</td>
<td>无 (因为插入前状态无数据)</td>
<td>NEW 表示将要或者已经新增的数据</td>
</tr>
<tr>
<td>UPDATE 型触发器</td>
<td>OLD 表示修改之前的数据</td>
<td>NEW 表示将要或已经修改后的数据</td>
</tr>
<tr>
<td>DELETE 型触发器</td>
<td>OLD 表示将要或者已经删除的数据</td>
<td>无 (因为删除后状态无数据)</td>
</tr>
</tbody></table>
<hr>
<h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li><p>创建触发器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER 触发器名称</span><br><span class="line">BEFORE|AFTER  INSERT|UPDATE|DELETE</span><br><span class="line">ON 表名</span><br><span class="line">[FOR EACH ROW]  -- 行级触发器</span><br><span class="line">BEGIN</span><br><span class="line">	触发器要执行的功能;</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看触发器的状态、语法等信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TRIGGERS;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除触发器，如果没有指定 schema_name，默认为当前数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TRIGGER [schema_name.]trigger_name;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="触发演示"><a href="#触发演示" class="headerlink" title="触发演示"></a>触发演示</h4><p>通过触发器记录账户表的数据变更日志。包含：增加、修改、删除</p>
<ul>
<li><p>数据准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建db9数据库</span><br><span class="line">CREATE DATABASE db9;</span><br><span class="line">-- 使用db9数据库</span><br><span class="line">USE db9;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建账户表account</span><br><span class="line">CREATE TABLE account(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 账户id</span><br><span class="line">	NAME VARCHAR(20),					-- 姓名</span><br><span class="line">	money DOUBLE						-- 余额</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO account VALUES (NULL,&#x27;张三&#x27;,1000),(NULL,&#x27;李四&#x27;,2000);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建日志表account_log</span><br><span class="line">CREATE TABLE account_log(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,	-- 日志id</span><br><span class="line">	operation VARCHAR(20),				-- 操作类型 (insert update delete)</span><br><span class="line">	operation_time DATETIME,			-- 操作时间</span><br><span class="line">	operation_id INT,					-- 操作表的id</span><br><span class="line">	operation_params VARCHAR(200)       -- 操作参数</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 INSERT 型触发器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER account_insert</span><br><span class="line">AFTER INSERT</span><br><span class="line">ON account</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO account_log VALUES (NULL,&#x27;INSERT&#x27;,NOW(),new.id,CONCAT(&#x27;插入后&#123;id=&#x27;,new.id,&#x27;,name=&#x27;,new.name,&#x27;,money=&#x27;,new.money,&#x27;&#125;&#x27;));</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 向account表添加记录</span><br><span class="line">INSERT INTO account VALUES (NULL,&#x27;王五&#x27;,3000);</span><br><span class="line"></span><br><span class="line">-- 查询日志表</span><br><span class="line">SELECT * FROM account_log;</span><br><span class="line">/*</span><br><span class="line">id	operation	operation_time		operation_id	operation_params</span><br><span class="line">1	INSERT	   	2021-01-26 19:51:11		3	     插入后&#123;id=3,name=王五money=2000&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>


</li>
<li><p>创建 UPDATE 型触发器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER account_update</span><br><span class="line">AFTER UPDATE</span><br><span class="line">ON account</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO account_log VALUES (NULL,&#x27;UPDATE&#x27;,NOW(),new.id,CONCAT(&#x27;修改前&#123;id=&#x27;,old.id,&#x27;,name=&#x27;,old.name,&#x27;,money=&#x27;,old.money,&#x27;&#125;&#x27;,&#x27;修改后&#123;id=&#x27;,new.id,&#x27;,name=&#x27;,new.name,&#x27;,money=&#x27;,new.money,&#x27;&#125;&#x27;));</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 修改account表</span><br><span class="line">UPDATE account SET money=3500 WHERE id=3;</span><br><span class="line"></span><br><span class="line">-- 查询日志表</span><br><span class="line">SELECT * FROM account_log;</span><br><span class="line">/*</span><br><span class="line">id	operation	operation_time		operation_id	  operation_params</span><br><span class="line">2	UPDATE	   	2021-01-26 19:58:54		2		 更新前&#123;id=2,name=李四money=1000&#125;</span><br><span class="line">												 更新后&#123;id=2,name=李四money=200&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>


</li>
<li><p>创建 DELETE 型触发器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER account_delete</span><br><span class="line">AFTER DELETE</span><br><span class="line">ON account</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO account_log VALUES (NULL,&#x27;DELETE&#x27;,NOW(),old.id,CONCAT(&#x27;删除前&#123;id=&#x27;,old.id,&#x27;,name=&#x27;,old.name,&#x27;,money=&#x27;,old.money,&#x27;&#125;&#x27;));</span><br><span class="line">END$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 删除account表数据</span><br><span class="line">DELETE FROM account WHERE id=3;</span><br><span class="line"></span><br><span class="line">-- 查询日志表</span><br><span class="line">SELECT * FROM account_log;</span><br><span class="line">/*</span><br><span class="line">id	operation	operation_time		operation_id	operation_params</span><br><span class="line">3	DELETE		2021-01-26 20:02:48		3	    删除前&#123;id=3,name=王五money=2000&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>对比其他数据库，MySQL 的架构可以在不同场景应用并发挥良好作用，主要体现在存储引擎，插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取分离，可以针对不同的存储需求可以选择最优的存储引擎</p>
<p>存储引擎的介绍：</p>
<ul>
<li>MySQL 数据库使用不同的机制存取表文件 , 机制的差别在于不同的存储方式、索引技巧、锁定水平等不同的功能和能力，在 MySQL 中，将这些不同的技术及配套的功能称为存储引擎</li>
<li>Oracle、SqlServer 等数据库只有一种存储引擎，MySQL <strong>提供了插件式的存储引擎架构</strong>，所以 MySQL 存在多种存储引擎 , 就会让数据库采取了不同的处理数据的方式和扩展功能</li>
<li>在关系型数据库中数据的存储是以表的形式存进行，所以存储引擎也称为表类型（存储和操作此表的类型）</li>
<li>通过选择不同的引擎，能够获取最佳的方案,  也能够获得额外的速度或者功能，提高程序的整体效果。</li>
</ul>
<p>MySQL 支持的存储引擎：</p>
<ul>
<li>MySQL 支持的引擎包括：InnoDB、MyISAM、MEMORY、Archive、Federate、CSV、BLACKHOLE 等</li>
<li>MySQL5.5 之前的默认存储引擎是 MyISAM，5.5 之后就改为了 InnoDB</li>
</ul>
<hr>
<h3 id="引擎对比"><a href="#引擎对比" class="headerlink" title="引擎对比"></a>引擎对比</h3><p>MyISAM 存储引擎：</p>
<ul>
<li>特点：不支持事务和外键，读取速度快，节约资源</li>
<li>应用场景：查询和插入操作为主，只有很少更新和删除操作，并对事务的完整性、并发性要求不高</li>
<li>存储方式：<ul>
<li>每个 MyISAM 在磁盘上存储成 3 个文件，其文件名都和表名相同，拓展名不同</li>
<li>表的定义保存在 .frm 文件，表数据保存在 .MYD (MYData) 文件中，索引保存在 .MYI (MYIndex) 文件中</li>
</ul>
</li>
</ul>
<p>InnoDB 存储引擎：(MySQL5.5 版本后默认的存储引擎)</p>
<ul>
<li>特点：<strong>支持事务</strong>和外键操作，支持并发控制。对比 MyISAM 的存储引擎，InnoDB 写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引</li>
<li>应用场景：对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，读写频繁的操作</li>
<li>存储方式：<ul>
<li>使用共享表空间存储， 这种方式创建的表的表结构保存在 .frm 文件中， 数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中，可以是多个文件</li>
<li>使用多表空间存储，创建的表的表结构存在 .frm 文件中，每个表的数据和索引单独保存在 .ibd 中</li>
</ul>
</li>
</ul>
<p>MEMORY 存储引擎：</p>
<ul>
<li>特点：每个 MEMORY 表实际对应一个磁盘文件 ，该文件中只存储表的结构，表数据保存在内存中，且默认<strong>使用 HASH 索引</strong>，所以数据默认就是无序的，但是在需要快速定位记录可以提供更快的访问，<strong>服务一旦关闭，表中的数据就会丢失</strong>，存储不安全</li>
<li>应用场景：通常用于更新不太频繁的小表，用以快速得到访问结果，类似缓存</li>
<li>存储方式：表结构保存在 .frm 中</li>
</ul>
<p>MERGE 存储引擎：</p>
<ul>
<li><p>特点：</p>
<ul>
<li>是一组 MyISAM 表的组合，这些 MyISAM 表必须结构完全相同，通过将不同的表分布在多个磁盘上</li>
<li>MERGE 表本身并没有存储数据，对 MERGE 类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的 MyISAM 表进行的</li>
</ul>
</li>
<li><p>应用场景：将一系列等同的 MyISAM 表以逻辑方式组合在一起，并作为一个对象引用他们，适合做数据仓库</p>
</li>
<li><p>操作方式：</p>
<ul>
<li>插入操作是通过 INSERT_METHOD 子句定义插入的表，使用 FIRST 或 LAST 值使得插入操作被相应地作用在第一或者最后一个表上；不定义这个子句或者定义为 NO，表示不能对 MERGE 表执行插入操作</li>
<li>对 MERGE 表进行 DROP 操作，但是这个操作只是删除 MERGE 表的定义，对内部的表是没有任何影响的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE order_1(</span><br><span class="line">)ENGINE = MyISAM DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE order_2(</span><br><span class="line">)ENGINE = MyISAM DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE order_all(</span><br><span class="line">	-- 结构与MyISAM表相同</span><br><span class="line">)ENGINE = MERGE UNION = (order_1,order_2) INSERT_METHOD=LAST DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MERGE.png"></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>MEMORY</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>有（平台对文件系统大小的限制）</td>
<td>64TB</td>
<td>有（平台的内存限制）</td>
</tr>
<tr>
<td><strong>事务安全</strong></td>
<td><strong>不支持</strong></td>
<td><strong>支持</strong></td>
<td><strong>不支持</strong></td>
</tr>
<tr>
<td><strong>锁机制</strong></td>
<td><strong>表锁</strong></td>
<td><strong>表锁&#x2F;行锁</strong></td>
<td><strong>表锁</strong></td>
</tr>
<tr>
<td>B+Tree 索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>哈希索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>集群索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>数据索引</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>数据缓存</td>
<td>不支持</td>
<td>支持</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>索引缓存</td>
<td>支持</td>
<td>支持</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>数据可压缩</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>空间使用</td>
<td>低</td>
<td>高</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>内存使用</td>
<td>低</td>
<td>高</td>
<td>中等</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>高</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td><strong>外键</strong></td>
<td><strong>不支持</strong></td>
<td><strong>支持</strong></td>
<td><strong>不支持</strong></td>
</tr>
</tbody></table>
<p>MyISAM 和 InnoDB 的区别？</p>
<ul>
<li><p>事务：InnoDB 支持事务，MyISAM 不支持事务</p>
</li>
<li><p>外键：InnoDB 支持外键，MyISAM 不支持外键</p>
</li>
<li><p>索引：InnoDB 是聚集（聚簇）索引，MyISAM 是非聚集（非聚簇）索引</p>
</li>
<li><p>锁粒度：InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁</p>
</li>
<li><p>存储结构：参考本节上半部分</p>
</li>
</ul>
<hr>
<h3 id="引擎操作"><a href="#引擎操作" class="headerlink" title="引擎操作"></a>引擎操作</h3><ul>
<li><p>查询数据库支持的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW ENGINES;</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%storage_engine%&#x27;; -- 查看Mysql数据库默认的存储引擎 </span><br></pre></td></tr></table></figure>
</li>
<li><p>查询某个数据库中所有数据表的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLE STATUS FROM 数据库名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询某个数据库中某个数据表的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLE STATUS FROM 数据库名称 WHERE NAME = &#x27;数据表名称&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据表，指定存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	列名,数据类型,</span><br><span class="line">    ...</span><br><span class="line">)ENGINE = 引擎名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改数据表的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE = 引擎名称;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="索引机制"><a href="#索引机制" class="headerlink" title="索引机制"></a>索引机制</h2><h3 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h3><h4 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>MySQL 官方对索引的定义为：索引（index）是帮助 MySQL 高效获取数据的一种数据结构，<strong>本质是排好序的快速查找数据结构。</strong>在表数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引</p>
<p><strong>索引是在存储引擎层实现的</strong>，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样</p>
<p>索引使用：一张数据表，用于保存数据；一个索引配置文件，用于保存索引；每个索引都指向了某一个数据<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%8B%E7%BB%8D.png"></p>
<p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据的物理地址的指针，这样就可以运用二叉查找快速获取到相应数据</p>
<p>索引的优点：</p>
<ul>
<li>类似于书籍的目录索引，提高数据检索的效率，降低数据库的 IO 成本</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 的消耗</li>
</ul>
<p>索引的缺点：</p>
<ul>
<li>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式<strong>存储在磁盘</strong>上</li>
<li>虽然索引大大提高了查询效率，同时却也降低更新表的速度。对表进行 INSERT、UPDATE、DELETE 操作，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，还会调整因为更新所带来的键值变化后的索引信息，<strong>但是更新数据也需要先从数据库中获取</strong>，索引加快了获取速度，所以可以相互抵消一下。</li>
<li>索引会影响到 WHERE 的查询条件和排序 ORDER BY 两大功能</li>
</ul>
<hr>
<h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><p>索引一般的分类如下：</p>
<ul>
<li><p>功能分类 </p>
<ul>
<li>主键索引：一种特殊的唯一索引，不允许有空值，一般在建表时同时创建主键索引</li>
<li>单列索引：一个索引只包含单个列，一个表可以有多个单列索引（普通索引）</li>
<li>联合索引：顾名思义，就是将单列索引进行组合</li>
<li>唯一索引：索引列的值必须唯一，<strong>允许有空值</strong>，如果是联合索引，则列值组合必须唯一<ul>
<li>NULL 值可以出现多次，因为两个 NULL 比较的结果既不相等，也不不等，结果仍然是未知</li>
<li>可以声明不允许存储 NULL 值的非空唯一索引</li>
</ul>
</li>
<li>外键索引：只有 InnoDB 引擎支持外键索引，用来保证数据的一致性、完整性和实现级联操作</li>
</ul>
</li>
<li><p>结构分类</p>
<ul>
<li>BTree 索引：MySQL 使用最频繁的一个索引数据结构，是 InnoDB 和 MyISAM 存储引擎默认的索引类型，底层基于 B+Tree</li>
<li>Hash 索引：MySQL中 Memory 存储引擎默认支持的索引类型</li>
<li>R-tree 索引（空间索引）：空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型</li>
<li>Full-text 索引（全文索引）：快速匹配全部文档的方式。MyISAM 支持， InnoDB 不支持 FULLTEXT 类型的索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，MEMORY 引擎不支持</li>
</ul>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>BTREE</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>HASH</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-tree</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6 版本之后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
</li>
</ul>
<p>联合索引图示：根据身高年龄建立的组合索引（height、age）</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E5%9B%BE.png"></p>
<hr>
<h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><p>索引在创建表的时候可以同时创建， 也可以随时增加新的索引</p>
<ul>
<li><p>创建索引：如果一个表中有一列是主键，那么会<strong>默认为其创建主键索引</strong>（主键列不需要单独创建索引）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [UNIQUE|FULLTEXT] INDEX 索引名称 [USING 索引类型] ON 表名(列名...);</span><br><span class="line">-- 索引类型默认是 B+TREE</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 单列索引</span><br><span class="line">ALTER TABLE 表名 ADD INDEX 索引名称(列名);</span><br><span class="line"></span><br><span class="line">-- 组合索引</span><br><span class="line">ALTER TABLE 表名 ADD INDEX 索引名称(列名1,列名2,...);</span><br><span class="line"></span><br><span class="line">-- 主键索引</span><br><span class="line">ALTER TABLE 表名 ADD PRIMARY KEY(主键列名); </span><br><span class="line"></span><br><span class="line">-- 外键索引(添加外键约束，就是外键索引)</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名);</span><br><span class="line"></span><br><span class="line">-- 唯一索引</span><br><span class="line">ALTER TABLE 表名 ADD UNIQUE 索引名称(列名);</span><br><span class="line"></span><br><span class="line">-- 全文索引(mysql只支持文本类型)</span><br><span class="line">ALTER TABLE 表名 ADD FULLTEXT 索引名称(列名);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX 索引名称 ON 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>案例练习</p>
<p>数据准备：student</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	NAME	 age	score</span><br><span class="line">1	张三		23		99</span><br><span class="line">2	李四		24		95</span><br><span class="line">3	王五		25		98</span><br><span class="line">4	赵六		26		97</span><br></pre></td></tr></table></figure>

<p>索引操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 为student表中姓名列创建一个普通索引</span><br><span class="line">CREATE INDEX idx_name ON student(NAME);</span><br><span class="line"></span><br><span class="line">-- 为student表中年龄列创建一个唯一索引</span><br><span class="line">CREATE UNIQUE INDEX idx_age ON student(age);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><h4 id="索引对比"><a href="#索引对比" class="headerlink" title="索引对比"></a>索引对比</h4><p>聚簇索引是一种数据存储方式，并不是一种单独的索引类型</p>
<ul>
<li><p>聚簇索引的叶子节点存放的是主键值和数据行，支持覆盖索引</p>
</li>
<li><p>非聚簇索引的叶子节点存放的是主键值或指向数据行的指针（由存储引擎决定）</p>
</li>
</ul>
<p>在 Innodb 下主键索引是聚簇索引，在 MyISAM 下主键索引是非聚簇索引</p>
<hr>
<h4 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h4><h5 id="聚簇索引-1"><a href="#聚簇索引-1" class="headerlink" title="聚簇索引"></a>聚簇索引</h5><p>在 Innodb 存储引擎，B+ 树索引可以分为聚簇索引（也称聚集索引、clustered index）和辅助索引（也称非聚簇索引或二级索引、secondary index、non-clustered index）</p>
<p>InnoDB 中，聚簇索引是按照每张表的主键构造一颗 B+ 树，叶子节点中存放的就是整张表的数据，将聚簇索引的叶子节点称为数据页</p>
<ul>
<li>这个特性决定了<strong>数据也是索引的一部分</strong>，所以一张表只能有一个聚簇索引</li>
<li>辅助索引的存在不影响聚簇索引中数据的组织，所以一张表可以有多个辅助索引</li>
</ul>
<p>聚簇索引的优点：</p>
<ul>
<li>数据访问更快，聚簇索引将索引和数据保存在同一个 B+ 树中，因此从聚簇索引中获取数据比非聚簇索引更快</li>
<li>聚簇索引对于主键的排序查找和范围查找速度非常快</li>
</ul>
<p>聚簇索引的缺点：</p>
<ul>
<li><p>插入速度严重依赖于插入顺序，按照主键的顺序（递增）插入是最快的方式，否则将会出现页分裂，严重影响性能，所以对于 InnoDB 表，一般都会定义一个自增的 ID 列为主键</p>
</li>
<li><p>更新主键的代价很高，将会导致被更新的行移动，所以对于 InnoDB 表，一般定义主键为不可更新</p>
</li>
<li><p>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据</p>
</li>
</ul>
<hr>
<h5 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h5><p>在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引等</p>
<p>辅助索引叶子节点存储的是主键值，而不是数据的物理地址，所以访问数据需要二次查找，推荐使用覆盖索引，可以减少回表查询</p>
<p><strong>检索过程</strong>：辅助索引找到主键值，再通过聚簇索引（二分）找到数据页，最后通过数据页中的 Page Directory（二分）找到对应的数据分组，遍历组内所所有的数据找到数据行</p>
<p>补充：无索引走全表查询，查到数据页后和上述步骤一致</p>
<hr>
<h5 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h5><p>InnoDB 使用 B+Tree 作为索引结构，并且 InnoDB 一定有索引</p>
<p>主键索引：</p>
<ul>
<li><p>在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这个索引的 key 是数据表的主键，叶子节点 data 域保存了完整的数据记录</p>
</li>
<li><p>InnoDB 的表数据文件<strong>通过主键聚集数据</strong>，如果没有定义主键，会选择非空唯一索引代替，如果也没有这样的列，MySQL 会自动为 InnoDB 表生成一个<strong>隐含字段 row_id</strong> 作为主键，这个字段长度为 6 个字节，类型为长整形</p>
</li>
</ul>
<p>辅助索引：</p>
<ul>
<li><p>InnoDB 的所有辅助索引（二级索引）都引用主键作为 data 域</p>
</li>
<li><p>InnoDB 表是基于聚簇索引建立的，因此 InnoDB 的索引能提供一种非常快速的主键查找性能。不过辅助索引也会包含主键列，所以不建议使用过长的字段作为主键，<strong>过长的主索引会令辅助索引变得过大</strong></p>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB%E8%81%9A%E7%B0%87%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png"></p>
<hr>
<h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><h5 id="非聚簇"><a href="#非聚簇" class="headerlink" title="非聚簇"></a>非聚簇</h5><p>MyISAM 的主键索引使用的是非聚簇索引，索引文件和数据文件是分离的，<strong>索引文件仅保存数据的地址</strong></p>
<ul>
<li>主键索引 B+ 树的节点存储了主键，辅助键索引 B+ 树存储了辅助键，表数据存储在独立的地方，这两颗 B+ 树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别</li>
<li>由于索引树是独立的，通过辅助索引检索<strong>无需回表查询</strong>访问主键的索引树</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E6%A3%80%E9%94%81%E6%95%B0%E6%8D%AE%E5%9B%BE.jpg"></p>
<hr>
<h5 id="索引实现-1"><a href="#索引实现-1" class="headerlink" title="索引实现"></a>索引实现</h5><p>MyISAM 的索引方式也叫做非聚集的，之所以这么称呼是为了与 InnoDB 的聚集索引区分</p>
<p>主键索引：MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址</p>
<p>辅助索引：MyISAM 中主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM%E4%B8%BB%E9%94%AE%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png"></p>
<p>参考文章：<a href="https://blog.csdn.net/lm1060891265/article/details/81482136">https://blog.csdn.net/lm1060891265/article/details/81482136</a></p>
<hr>
<h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><h4 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h4><p>文件系统的最小单元是块（block），一个块的大小是 4K，系统从磁盘读取数据到内存时是以磁盘块为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么</p>
<p>InnoDB 存储引擎中有页（Page）的概念，页是 MySQL 磁盘管理的最小单位</p>
<ul>
<li><strong>InnoDB 存储引擎中默认每个页的大小为 16KB，索引中一个节点就是一个数据页</strong>，所以会一次性读取 16KB 的数据到内存</li>
<li>InnoDB 引擎将若干个地址连接磁盘块，以此来达到页的大小 16KB</li>
<li>在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I&#x2F;O 次数，提高查询效率</li>
</ul>
<p>超过 16KB 的一条记录，主键索引页只会存储部分数据和指向<strong>溢出页</strong>的指针，剩余数据都会分散存储在溢出页中</p>
<p>数据页物理结构，从上到下：</p>
<ul>
<li>File Header：上一页和下一页的指针、该页的类型（索引页、数据页、日志页等）、<strong>校验和</strong>、LSN（最近一次修改当前页面时的系统 lsn 值，事务持久性部分详解）等信息</li>
<li>Page Header：记录状态信息</li>
<li>Infimum + Supremum：当前页的最小记录和最大记录（头尾指针），Infimum 所在分组只有一条记录，Supremum 所在分组可以有 1 ~ 8 条记录，剩余的分组可以有 4 ~ 8 条记录</li>
<li>User Records：存储数据的记录</li>
<li>Free Space：尚未使用的存储空间</li>
<li>Page Directory：分组的目录，可以通过目录快速定位（二分法）数据的分组</li>
<li>File Trailer：检验和字段，在刷脏过程中，页首和页尾的校验和一致才能说明页面刷新成功，二者不同说明刷新期间发生了错误；LSN 字段，也是用来校验页面的完整性</li>
</ul>
<p>数据页中包含数据行，数据的存储是基于数据行的，数据行有 next_record 属性指向下一个行数据，所以是可以遍历的，但是一组数据至多 8 个行，通过 Page Directory 先定位到组，然后遍历获取所需的数据行即可</p>
<p>数据行中有三个隐藏字段：trx_id、roll_pointer、row_id（在事务章节会详细介绍它们的作用）</p>
<hr>
<h4 id="BTree"><a href="#BTree" class="headerlink" title="BTree"></a>BTree</h4><p>BTree 的索引类型是基于 B+Tree 树型数据结构的，B+Tree 又是 BTree 数据结构的变种，用在数据库和操作系统中的文件系统，特点是能够保持数据稳定有序</p>
<p>BTree 又叫多路平衡搜索树，一颗 m 叉的 BTree 特性如下：</p>
<ul>
<li>树中每个节点最多包含 m 个孩子</li>
<li>除根节点与叶子节点外，每个节点至少有 [ceil(m&#x2F;2)] 个孩子</li>
<li>若根节点不是叶子节点，则至少有两个孩子</li>
<li>所有的叶子节点都在同一层</li>
<li>每个非叶子节点由 n 个 key 与 n+1 个指针组成，其中 [ceil(m&#x2F;2)-1] &lt;&#x3D; n &lt;&#x3D; m-1</li>
</ul>
<p>5 叉，key 的数量 [ceil(m&#x2F;2)-1] &lt;&#x3D; n &lt;&#x3D; m-1 为 2 &lt;&#x3D; n &lt;&#x3D;4 ，当 n&gt;4 时中间节点分裂到父节点，两边节点分裂</p>
<p>插入 C N G A H E K Q M F W L T Z D P R X Y S 数据的工作流程：</p>
<ul>
<li><p>插入前 4 个字母 C N G A </p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B1.png"></p>
</li>
<li><p>插入 H，n&gt;4，中间元素 G 字母向上分裂到新的节点</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B2.png"></p>
</li>
<li><p>插入 E、K、Q 不需要分裂</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B3.png"></p>
</li>
<li><p>插入 M，中间元素 M 字母向上分裂到父节点 G</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B4.png"></p>
</li>
<li><p>插入 F，W，L，T 不需要分裂</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B5.png"></p>
</li>
<li><p>插入 Z，中间元素 T 向上分裂到父节点中</p>
</li>
</ul>
<p>  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B6.png"></p>
<ul>
<li><p>插入 D，中间元素 D 向上分裂到父节点中，然后插入 P，R，X，Y 不需要分裂</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B7.png"></p>
</li>
<li><p>最后插入 S，NPQR 节点 n&gt;5，中间节点 Q 向上分裂，但分裂后父节点 DGMT 的 n&gt;5，中间节点 M 向上分裂</p>
</li>
</ul>
<p>  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B8.png"></p>
<p>BTree 树就已经构建完成了，BTree 树和二叉树相比， 查询数据的效率更高， 因为对于相同的数据量来说，<strong>BTree 的层级结构比二叉树少</strong>，所以搜索速度快</p>
<p>BTree 结构的数据可以让系统高效的找到数据所在的磁盘块，定义一条记录为一个二元组 [key, data] ，key 为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key 值互不相同，BTree 中的每个节点根据实际情况可以包含大量的关键字信息和分支<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%861.png"></p>
<p>缺点：当进行范围查找时会出现回旋查找</p>
<hr>
<h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p>BTree 数据结构中每个节点中不仅包含数据的 key 值，还有 data 值。磁盘中每一页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I&#x2F;O 次数，进而影响查询效率，所以引入 B+Tree</p>
<p>B+Tree 为 BTree 的变种，B+Tree 与 BTree 的区别为：</p>
<ul>
<li>n 叉 B+Tree 最多含有 n 个 key（哈希值），而 BTree 最多含有 n-1 个 key</li>
</ul>
<ul>
<li>所有<strong>非叶子节点只存储键值 key</strong> 信息，只进行数据索引，使每个非叶子节点所能保存的关键字大大增加</li>
<li>所有<strong>数据都存储在叶子节点</strong>，所以每次数据查询的次数都一样</li>
<li><strong>叶子节点按照 key 大小顺序排列，左边结尾数据都会保存右边节点开始数据的指针，形成一个链表</strong></li>
<li>所有节点中的 key 在叶子节点中也存在（比如 5)，<strong>key 允许重复</strong>，B 树不同节点不存在重复的 key</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-B加Tree数据结构.png" style="zoom:67%;">

<p>B* 树：是 B+ 树的变体，在 B+ 树的非根和非叶子结点再增加指向兄弟的指针</p>
<hr>
<h5 id="优化结构"><a href="#优化结构" class="headerlink" title="优化结构"></a>优化结构</h5><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化，在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，<strong>提高区间访问的性能，防止回旋查找</strong></p>
<p>区间访问的意思是访问索引为 5 - 15 的数据，可以直接根据相邻节点的指针遍历</p>
<p>B+ 树的<strong>叶子节点是数据页</strong>（page），一个页里面可以存多个数据行</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%862.png"></p>
<p>通常在 B+Tree 上有两个头指针，<strong>一个指向根节点，另一个指向关键字最小的叶子节点</strong>，而且所有叶子节点（即数据节点）之间是一种链式环结构。可以对 B+Tree 进行两种查找运算：</p>
<ul>
<li>有范围：对于主键的范围查找和分页查找</li>
<li>有顺序：从根节点开始，进行随机查找，顺序查找</li>
</ul>
<p>InnoDB 中每个数据页的大小默认是 16KB，</p>
<ul>
<li>索引行：一般表的主键类型为 INT（4 字节）或 BIGINT（8 字节），指针大小在 InnoDB 中设置为 6 字节节，也就是说一个页大概存储 16KB&#x2F;(8B+6B)&#x3D;1K 个键值（估值）。则一个深度为 3 的 B+Tree 索引可以维护 <code>10^3 * 10^3 * 10^3 = 10亿</code> 条记录</li>
<li>数据行：一行数据的大小可能是 1k，一个数据页可以存储 16 行</li>
</ul>
<p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2-4 层。MySQL 的 InnoDB 存储引擎在设计时是<strong>将根节点常驻内存的</strong>，也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘 I&#x2F;O 操作</p>
<p>B+Tree 优点：提高查询速度，减少磁盘的 IO 次数，树形结构较小</p>
<hr>
<h5 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h5><p>B+ 树为了保持索引的有序性，在插入新值的时候需要做相应的维护</p>
<p>每个索引中每个块存储在磁盘页中，可能会出现以下两种情况：</p>
<ul>
<li>如果所在的数据页已经满了，这时候需要申请一个新的数据页，然后挪动部分数据过去，这个过程称为<strong>页分裂</strong>，原本放在一个页的数据现在分到两个页中，降低了空间利用率</li>
<li>当相邻两个页由于删除了数据，利用率很低之后，会将数据页做<strong>页合并</strong>，合并的过程可以认为是分裂过程的逆过程</li>
<li>这两个情况都是由 B+ 树的结构决定的</li>
</ul>
<p>一般选用数据小的字段做索引，字段长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</p>
<p>自增主键的插入数据模式，可以让主键索引尽量地保持递增顺序插入，不涉及到挪动其他记录，<strong>避免了页分裂</strong>，页分裂的目的就是保证后一个数据页中的所有行主键值比前一个数据页中主键值大</p>
<p>参考文章：<a href="https://developer.aliyun.com/article/919861">https://developer.aliyun.com/article/919861</a></p>
<hr>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率</p>
<p>创建索引时的原则：</p>
<ul>
<li>对查询频次较高，且数据量比较大的表建立索引</li>
<li>使用唯一索引，区分度越高，使用索引的效率越高</li>
<li>索引字段的选择，最佳候选列应当从 where 子句的条件中提取，使用覆盖索引</li>
<li>使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的 I&#x2F;O 效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升 MySQL 访问索引的 I&#x2F;O 效率</li>
<li>索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价越高。对于插入、更新、删除等 DML 操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低 DML 操作的效率，增加相应操作的时间消耗；另外索引过多的话，MySQL 也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但提高了选择的代价</li>
</ul>
<ul>
<li><p>MySQL 建立联合索引时会遵守<strong>最左前缀匹配原则</strong>，即最左优先，在检索数据时从联合索引的最左边开始匹配</p>
<p>N 个列组合而成的组合索引，相当于创建了 N 个索引，如果查询时 where 句中使用了组成该索引的<strong>前</strong>几个字段，那么这条查询 SQL 可以利用组合索引来提升查询效率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 对name、address、phone列建一个联合索引</span><br><span class="line">ALTER TABLE user ADD INDEX index_three(name,address,phone);</span><br><span class="line">-- 查询语句执行时会依照最左前缀匹配原则，检索时分别会使用索引进行数据匹配。</span><br><span class="line">(name,address,phone)</span><br><span class="line">(name,address)</span><br><span class="line">(name,phone)	-- 只有name字段走了索引</span><br><span class="line">(name)</span><br><span class="line"></span><br><span class="line">-- 索引的字段可以是任意顺序的，优化器会帮助我们调整顺序，下面的SQL语句可以命中索引</span><br><span class="line">SELECT * FROM user WHERE address = &#x27;北京&#x27; AND phone = &#x27;12345&#x27; AND name = &#x27;张三&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 如果联合索引中最左边的列不包含在条件查询中，SQL语句就不会命中索引，比如：</span><br><span class="line">SELECT * FROM user WHERE address = &#x27;北京&#x27; AND phone = &#x27;12345&#x27;; </span><br></pre></td></tr></table></figure></li>
</ul>
<p>哪些情况不要建立索引：</p>
<ul>
<li>记录太少的表</li>
<li>经常增删改的表</li>
<li>频繁更新的字段不适合创建索引</li>
<li>where 条件里用不到的字段不创建索引</li>
</ul>
<hr>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>覆盖索引：包含所有满足查询需要的数据的索引（SELECT 后面的字段刚好是索引字段），可以利用该索引返回 SELECT 列表的字段，而不必根据索引去聚簇索引上读取数据文件</p>
<p>回表查询：要查找的字段不在非主键索引树上时，需要通过叶子节点的主键值去主键索引上获取对应的行数据</p>
<p>使用覆盖索引，防止回表查询：</p>
<ul>
<li><p>表 user 主键为 id，普通索引为 age，查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user WHERE age = 30;</span><br></pre></td></tr></table></figure>

<p>查询过程：先通过普通索引 age&#x3D;30 定位到主键值 id&#x3D;1，再通过聚集索引 id&#x3D;1 定位到行记录数据，需要两次扫描 B+ 树</p>
</li>
<li><p>使用覆盖索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX idx_age ON user;</span><br><span class="line">CREATE INDEX idx_age_name ON user(age,name);</span><br><span class="line">SELECT id,age FROM user WHERE age = 30;</span><br></pre></td></tr></table></figure>

<p>在一棵索引树上就能获取查询所需的数据，无需回表速度更快</p>
</li>
</ul>
<p>使用覆盖索引，要注意 SELECT 列表中只取出需要的列，不可用 SELECT *，所有字段一起做索引会导致索引文件过大，查询性能下降</p>
<hr>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>索引条件下推优化（Index Condition Pushdown，ICP）是 MySQL5.6 添加，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</p>
<p>索引下推充分利用了索引中的数据，在查询出整行数据之前过滤掉无效的数据，再去主键索引树上查找</p>
<ul>
<li><p>不使用索引下推优化时存储引擎通过索引检索到数据，然后回表查询记录返回给 Server 层，<strong>服务器判断数据是否符合条件</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.png"></p>
</li>
<li><p>使用索引下推优化时，如果<strong>存在某些被索引的列的判断条件</strong>时，由存储引擎在索引遍历的过程中判断数据是否符合传递的条件，将符合条件的数据进行回表，检索出来返回给服务器，由此减少 IO 次数</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.png"></p>
</li>
</ul>
<p><strong>适用条件</strong>：</p>
<ul>
<li>需要存储引擎将索引中的数据与条件进行判断（所以<strong>条件列必须都在同一个索引中</strong>），所以优化是基于存储引擎的，只有特定引擎可以使用，适用于 InnoDB 和 MyISAM</li>
<li>存储引擎没有调用跨存储引擎的能力，跨存储引擎的功能有存储过程、触发器、视图，所以调用这些功能的不可以进行索引下推优化</li>
<li>对于 InnoDB 引擎只适用于二级索引，InnoDB 的聚簇索引会将整行数据读到缓冲区，不再需要去回表查询了</li>
</ul>
<p>工作过程：用户表 user，(name, age) 是联合索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user WHERE name LIKE &#x27;张%&#x27; AND　age = 10;	-- 头部模糊匹配会造成索引失效</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优化前：在非主键索引树上找到满足第一个条件的行，然后通过叶子节点记录的主键值再回到主键索引树上查找到对应的行数据，再对比 AND 后的条件是否符合，符合返回数据，需要 4 次回表</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E4%BC%98%E5%8C%961.png"></p>
</li>
<li><p>优化后：检查索引中存储的列信息是否符合索引条件，然后交由存储引擎用剩余的判断条件判断此行数据是否符合要求，<strong>不满足条件的不去读取表中的数据</strong>，满足下推条件的就根据主键值进行回表查询，2 次回表<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E4%BC%98%E5%8C%962.png"></p>
</li>
</ul>
<p>当使用 EXPLAIN 进行分析时，如果使用了索引条件下推，Extra 会显示 Using index condition</p>
<p>参考文章：<a href="https://blog.csdn.net/sinat_29774479/article/details/103470244">https://blog.csdn.net/sinat_29774479/article/details/103470244</a></p>
<p>参考文章：<a href="https://time.geekbang.org/column/article/69636">https://time.geekbang.org/column/article/69636</a></p>
<hr>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当要索引的列字符很多时，索引会变大变慢，可以只索引列开始的部分字符串，节约索引空间，提高索引效率</p>
<p>注意：使用前缀索引就系统就忽略覆盖索引对查询性能的优化了</p>
<p>优化原则：<strong>降低重复的索引值</strong></p>
<p>比如地区表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">area			gdp		code</span><br><span class="line">chinaShanghai	100		aaa</span><br><span class="line">chinaDalian		200		bbb</span><br><span class="line">usaNewYork		300		ccc</span><br><span class="line">chinaFuxin		400		ddd</span><br><span class="line">chinaBeijing	500		eee</span><br></pre></td></tr></table></figure>

<p>发现 area 字段很多都是以 china 开头的，那么如果以前 1-5 位字符做前缀索引就会出现大量索引值重复的情况，索引值重复性越低，查询效率也就越高，所以需要建立前 6 位字符的索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_area ON table_name(area(7));</span><br></pre></td></tr></table></figure>

<p>场景：存储身份证</p>
<ul>
<li>直接创建完整索引，这样可能比较占用空间</li>
<li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引</li>
<li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题（前 6 位相同的很多）</li>
<li>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描</li>
</ul>
<hr>
<h4 id="索引合并"><a href="#索引合并" class="headerlink" title="索引合并"></a>索引合并</h4><p>使用多个索引来完成一次查询的执行方法叫做索引合并 index merge</p>
<ul>
<li><p>Intersection 索引合并：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_test <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key3 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>; # key1 和 key3 列都是单列索引、二级索引</span><br></pre></td></tr></table></figure>

<p>从不同索引中扫描到的记录的 id 值取<strong>交集</strong>（相同 id），然后执行回表操作，要求从每个二级索引获取到的记录都是按照主键值排序</p>
</li>
<li><p>Union 索引合并：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_test <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>从不同索引中扫描到的记录的 id 值取<strong>并集</strong>，然后执行回表操作，要求从每个二级索引获取到的记录都是按照主键值排序</p>
</li>
<li><p>Sort-Union 索引合并</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_test <span class="keyword">WHERE</span> key1 <span class="operator">&lt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">&gt;</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>先将从不同索引中扫描到的记录的主键值进行排序，再按照 Union 索引合并的方式进行查询</p>
</li>
</ul>
<p>索引合并算法的效率并不好，通过将其中的一个索引改成联合索引会优化效率</p>
<hr>
<h2 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h2><h3 id="表优化"><a href="#表优化" class="headerlink" title="表优化"></a>表优化</h3><h4 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h4><h5 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>分区表是将大表的数据按分区字段分成许多小的子集，建立一个以 ftime 年份为分区的表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">    `ftime` datetime NOT NULL,</span><br><span class="line">    `c` int(11) DEFAULT NULL,</span><br><span class="line">    KEY (`ftime`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1</span><br><span class="line">PARTITION BY RANGE (YEAR(ftime))</span><br><span class="line">(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB);</span><br><span class="line">INSERT INTO t VALUES(&#x27;2017-4-1&#x27;,1),(&#x27;2018-4-1&#x27;,1);-- 这两行记录分别落在 p_2018 和 p_2019 这两个分区上</span><br></pre></td></tr></table></figure>

<p>这个表包含了一个.frm 文件和 4 个.ibd 文件，每个分区对应一个.ibd 文件</p>
<ul>
<li>对于引擎层来说，这是 4 个表，针对每个分区表的操作不会相互影响</li>
<li>对于 Server 层来说，这是 1 个表</li>
</ul>
<hr>
<h5 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h5><p>打开表行为：第一次访问一个分区表时，MySQL 需要<strong>把所有的分区都访问一遍</strong>，如果分区表的数量很多，超过了 open_files_limit 参数（默认值 1024），那么就会在访问这个表时打开所有的文件，导致打开表文件的个数超过了上限而报错</p>
<p>通用分区策略：MyISAM 分区表使用的分区策略，每次访问分区都由 Server 层控制，在文件管理、表管理的实现上很粗糙，因此有比较严重的性能问题</p>
<p>本地分区策略：从 MySQL 5.7.9 开始，InnoDB 引擎内部自己管理打开分区的行为，InnoDB 引擎打开文件超过 innodb_open_files 时就会<strong>关掉一些之前打开的文件</strong>，所以即使分区个数大于 open_files_limit，也不会报错</p>
<p>从 MySQL 8.0 版本开始，就不允许创建 MyISAM 分区表，只允许创建已经实现了本地分区策略的引擎，目前只有 InnoDB 和 NDB 这两个引擎支持了本地分区策略</p>
<hr>
<h5 id="Server-层"><a href="#Server-层" class="headerlink" title="Server 层"></a>Server 层</h5><p>从 Server 层看一个分区表就只是一个表</p>
<ul>
<li><p>Session A：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t WHERE ftime = &#x27;2018-4-1&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Session B：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE t TRUNCATE PARTITION p_2017; -- blocked</span><br></pre></td></tr></table></figure></li>
</ul>
<p>现象：Session B 只操作 p_2017 分区，但是由于 Session A 持有整个表 t 的 MDL 读锁，就导致 B 的 ALTER 语句获取 MDL 写锁阻塞</p>
<p>分区表的特点：</p>
<ul>
<li>第一次访问的时候需要访问所有分区</li>
<li>在 Server 层认为这是同一张表，因此<strong>所有分区共用同一个 MDL 锁</strong></li>
<li>在引擎层认为这是不同的表，因此 MDL 锁之后的执行过程，会根据分区表规则，只访问需要的分区</li>
</ul>
<hr>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>分区表的优点：</p>
<ul>
<li><p>对业务透明，相对于用户分表来说，使用分区表的业务代码更简洁</p>
</li>
<li><p>分区表可以很方便的清理历史数据。按照时间分区的分区表，就可以直接通过 <code>alter table t drop partition</code> 这个语法直接删除分区文件，从而删掉过期的历史数据，与使用 drop 语句删除数据相比，优势是速度快、对系统影响小</p>
</li>
</ul>
<p>使用分区表，不建议创建太多的分区，注意事项：</p>
<ul>
<li>分区并不是越细越好，单表或者单分区的数据一千万行，只要没有特别大的索引，对于现在的硬件能力来说都已经是小表</li>
<li>分区不要提前预留太多，在使用之前预先创建即可。比如是按月分区，每年年底时再把下一年度的 12 个新分区创建上即可，并且对于没有数据的历史分区，要及时的 drop 掉</li>
</ul>
<p>参考文档：<a href="https://time.geekbang.org/column/article/82560">https://time.geekbang.org/column/article/82560</a></p>
<hr>
<h4 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h4><h5 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>临时表分为内部临时表和用户临时表</p>
<ul>
<li><p>内部临时表：系统执行 SQL 语句优化时产生的表，例如 Join 连接查询、去重查询等</p>
</li>
<li><p>用户临时表：用户主动创建的临时表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TEMPORARY TABLE temp_t like table_1;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>临时表可以是内存表，也可以是磁盘表（多表操作 → 嵌套查询章节提及）</p>
<ul>
<li>内存表指的是使用 Memory 引擎的表，建立哈希索引，建表语法是 <code>create table … engine=memory</code>，这种表的数据都保存在内存里，系统重启时会被清空，但是表结构还在</li>
<li>磁盘表是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，建立 B+ 树索引，写数据的时候是写到磁盘上的</li>
</ul>
<p>临时表的特点：</p>
<ul>
<li>一个临时表只能被创建它的 session 访问，对其他线程不可见，所以不同 session 的临时表是<strong>可以重名</strong>的</li>
<li>临时表可以与普通表同名，会话内有同名的临时表和普通表时，执行 show create 语句以及增删改查语句访问的都是临时表</li>
<li>show tables 命令不显示临时表</li>
<li>数据库发生异常重启不需要担心数据删除问题，临时表会<strong>自动回收</strong></li>
</ul>
<hr>
<h5 id="重名原理"><a href="#重名原理" class="headerlink" title="重名原理"></a>重名原理</h5><p>执行创建临时表的 SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create temporary table temp_t(id int primary key)engine=innodb;</span><br></pre></td></tr></table></figure>

<p>MySQL 给 InnoDB 表创建一个 frm 文件保存表结构定义，在 ibd 保存表数据。frm 文件放在临时文件目录下，文件名的后缀是 .frm，<strong>前缀是</strong> <code>#sql&#123;进程 id&#125;_&#123;线程 id&#125;_ 序列号</code>，使用 <code>select @@tmpdir</code> 命令，来显示实例的临时文件目录</p>
<p>MySQL 维护数据表，除了物理磁盘上的文件外，内存里也有一套机制区别不同的表，每个表都对应一个 table_def_key</p>
<ul>
<li>一个普通表的 table_def_key 的值是由 <code>库名 + 表名</code> 得到的，所以如果在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现 table_def_key 已经存在了</li>
<li>对于临时表，table_def_key 在 <code>库名 + 表名</code> 基础上，又加入了 <code>server_id + thread_id</code>，所以不同线程之间，临时表可以重名</li>
</ul>
<p>实现原理：每个线程都维护了自己的临时表链表，每次 session 内操作表时，先遍历链表，检查是否有这个名字的临时表，如果有就<strong>优先操作临时表</strong>，如果没有再操作普通表；在 session 结束时对链表里的每个临时表，执行 <code>DROP TEMPORARY TABLE + 表名</code> 操作</p>
<p>执行 rename table 语句无法修改临时表，因为会按照 <code>库名 / 表名.frm</code> 的规则去磁盘找文件，但是临时表文件名的规则是 <code>#sql&#123;进程 id&#125;_&#123;线程 id&#125;_ 序列号.frm</code>，因此会报找不到文件名的错误</p>
<hr>
<h5 id="主备复制"><a href="#主备复制" class="headerlink" title="主备复制"></a>主备复制</h5><p>创建临时表的语句会传到备库执行，因此备库的同步线程就会创建这个临时表。主库在线程退出时会自动删除临时表，但备库同步线程是持续在运行的并不会退出，所以这时就需要在主库上再写一个 DROP TEMPORARY TABLE 传给备库执行</p>
<p>binlog 日志写入规则：</p>
<ul>
<li>binlog_format&#x3D;row，跟临时表有关的语句就不会记录到 binlog</li>
<li>binlog_format&#x3D;statment&#x2F;mixed，binlog 中才会记录临时表的操作，也就会记录 <code>DROP TEMPORARY TABLE</code> 这条命令</li>
</ul>
<p>主库上不同的线程创建同名的临时表是不冲突的，但是备库只有一个执行线程，所以 MySQL 在记录 binlog 时会把主库执行这个语句的线程 id 写到 binlog 中，在备库的应用线程就可以获取执行每个语句的主库线程 id，并利用这个线程 id 来构造临时表的 table_def_key</p>
<ul>
<li>session A 的临时表 t1，在备库的 table_def_key 就是：<code>库名 + t1 +“M 的 serverid&quot; + &quot;session A 的 thread_id”</code></li>
<li>session B 的临时表 t1，在备库的 table_def_key 就是 ：<code>库名 + t1 +&quot;M 的 serverid&quot; + &quot;session B 的 thread_id&quot;</code></li>
</ul>
<p>MySQL 在记录 binlog 的时不论是 create table 还是 alter table 语句都是原样记录，但是如果执行 drop table，系统记录 binlog 就会被服务端改写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE `t_normal` /* generated by server */</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="跨库查询"><a href="#跨库查询" class="headerlink" title="跨库查询"></a>跨库查询</h5><p>分库分表系统的跨库查询使用临时表不用担心线程之间的重名冲突，分库分表就是要把一个逻辑上的大表分散到不同的数据库实例上</p>
<p>比如将一个大表 ht，按照字段 f，拆分成 1024 个分表，分布到 32 个数据库实例上，一般情况下都有一个中间层 proxy 解析 SQL 语句，通过分库规则通过分表规则（比如 N%1024）确定将这条语句路由到哪个分表做查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select v from ht where f=N;</span><br></pre></td></tr></table></figure>

<p>如果这个表上还有另外一个索引 k，并且查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select v from ht where k &gt;= M order by t_modified desc limit 100;</span><br></pre></td></tr></table></figure>

<p>查询条件里面没有用到分区字段 f，只能<strong>到所有的分区</strong>中去查找满足条件的所有行，然后统一做 order by 操作，两种方式：</p>
<ul>
<li>在 proxy 层的进程代码中实现排序，拿到分库的数据以后，直接在内存中参与计算，但是对 proxy 端的压力比较大，很容易出现内存不够用和 CPU 瓶颈问题</li>
<li>把各个分库拿到的数据，汇总到一个 MySQL 实例的一个表中，然后在这个汇总实例上做逻辑操作，执行流程：<ul>
<li>在汇总库上创建一个临时表 temp_ht，表里包含三个字段 v、k、t_modified</li>
<li>在各个分库执行：<code>select v,k,t_modified from ht_x where k &gt;= M order by t_modified desc limit 100</code></li>
<li>把分库执行的结果插入到 temp_ht 表中</li>
<li>在临时表上执行：<code>select v from temp_ht order by t_modified desc limit 100</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h3><h4 id="执行频率"><a href="#执行频率" class="headerlink" title="执行频率"></a>执行频率</h4><p>MySQL 客户端连接成功后，查询服务器状态信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW [SESSION|GLOBAL] STATUS LIKE &#x27;&#x27;;</span><br><span class="line">-- SESSION: 显示当前会话连接的统计结果，默认参数</span><br><span class="line">-- GLOBAL: 显示自数据库上次启动至今的统计结果</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查看 SQL 执行频率：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Com_____&#x27;;</span><br></pre></td></tr></table></figure>

<p>Com_xxx 表示每种语句执行的次数</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A2%91%E7%8E%87.png"></p>
</li>
<li><p>查询 SQL 语句影响的行数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Innodb_rows_%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SQL%E8%AF%AD%E5%8F%A5%E5%BD%B1%E5%93%8D%E7%9A%84%E8%A1%8C%E6%95%B0.png"></p>
</li>
</ul>
<p>Com_xxxx：这些参数对于所有存储引擎的表操作都会进行累计</p>
<p>Innodb_xxxx：这几个参数只是针对 InnoDB 存储引擎的，累加的算法也略有不同</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Com_select</td>
<td>执行 SELECT 操作的次数，一次查询只累加 1</td>
</tr>
<tr>
<td align="left">Com_insert</td>
<td>执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次</td>
</tr>
<tr>
<td align="left">Com_update</td>
<td>执行 UPDATE 操作的次数</td>
</tr>
<tr>
<td align="left">Com_delete</td>
<td>执行 DELETE 操作的次数</td>
</tr>
<tr>
<td align="left">Innodb_rows_read</td>
<td>执行 SELECT 查询返回的行数</td>
</tr>
<tr>
<td align="left">Innodb_rows_inserted</td>
<td>执行 INSERT 操作插入的行数</td>
</tr>
<tr>
<td align="left">Innodb_rows_updated</td>
<td>执行 UPDATE 操作更新的行数</td>
</tr>
<tr>
<td align="left">Innodb_rows_deleted</td>
<td>执行 DELETE 操作删除的行数</td>
</tr>
<tr>
<td align="left">Connections</td>
<td>试图连接 MySQL 服务器的次数</td>
</tr>
<tr>
<td align="left">Uptime</td>
<td>服务器工作时间</td>
</tr>
<tr>
<td align="left">Slow_queries</td>
<td>慢查询的次数</td>
</tr>
</tbody></table>
<hr>
<h4 id="定位低效"><a href="#定位低效" class="headerlink" title="定位低效"></a>定位低效</h4><p>SQL 执行慢有两种情况：</p>
<ul>
<li>偶尔慢：DB 在刷新脏页（学完事务就懂了）<ul>
<li>redo log 写满了</li>
<li>内存不够用，要从 LRU 链表中淘汰</li>
<li>MySQL 认为系统空闲的时候</li>
<li>MySQL 关闭时</li>
</ul>
</li>
<li>一直慢的原因：索引没有设计好、SQL 语句没写好、MySQL 选错了索引</li>
</ul>
<p>通过以下两种方式定位执行效率较低的 SQL 语句</p>
<ul>
<li><p>慢日志查询： 慢查询日志在查询结束以后才记录，执行效率出现问题时查询日志并不能定位问题</p>
<p>配置文件修改：修改 .cnf 文件 <code>vim /etc/mysql/my.cnf</code>，重启 MySQL 服务器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slow_query_log=ON</span><br><span class="line">slow_query_log_file=/usr/local/mysql/var/localhost-slow.log</span><br><span class="line">long_query_time=1	<span class="comment">#记录超过long_query_time秒的SQL语句的日志</span></span><br><span class="line">log-queries-not-using-indexes = 1</span><br></pre></td></tr></table></figure>

<p>使用命令配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET slow_query_log=ON;</span><br><span class="line">mysql&gt; SET GLOBAL slow_query_log=ON;</span><br></pre></td></tr></table></figure>

<p>查看是否配置成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%query%&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SHOW PROCESSLIST：<strong>实时查看</strong>当前 MySQL 在进行的连接线程，包括线程的状态、是否锁表、SQL 的执行情况，同时对一些锁表操作进行优化</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SHOW_PROCESSLIST%E5%91%BD%E4%BB%A4.png"></p>
</li>
</ul>
<hr>
<h4 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h4><h5 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h5><p>通过 EXPLAIN 命令获取执行 SQL 语句的信息，包括在 SELECT 语句执行过程中如何连接和连接的顺序，执行计划在优化器优化完成后、执行器之前生成，然后执行器会调用存储引擎检索数据</p>
<p>查询 SQL 语句的执行计划：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM table_1 WHERE id = 1;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-explain%E6%9F%A5%E8%AF%A2SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>SELECT 的序列号</td>
</tr>
<tr>
<td>select_type</td>
<td>表示 SELECT 的类型</td>
</tr>
<tr>
<td>table</td>
<td>访问数据库中表名称，有时可能是简称或者临时表名称（<table_name>）</table_name></td>
</tr>
<tr>
<td>type</td>
<td>表示表的连接类型</td>
</tr>
<tr>
<td>possible_keys</td>
<td>表示查询时，可能使用的索引</td>
</tr>
<tr>
<td>key</td>
<td>表示实际使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>索引字段的长度</td>
</tr>
<tr>
<td>ref</td>
<td>表示与索引列进行等值匹配的对象，常数、某个列、函数等，type 必须在（range, const] 之间，左闭右开</td>
</tr>
<tr>
<td>rows</td>
<td>扫描出的行数，表示 MySQL 根据表统计信息及索引选用情况，<strong>估算</strong>的找到所需的记录扫描的行数</td>
</tr>
<tr>
<td>filtered</td>
<td>条件过滤的行百分比，单表查询没意义，用于连接查询中对驱动表的扇出进行过滤，查询优化器预测所有扇出值满足剩余查询条件的百分比，相乘以后表示多表查询中还要对被驱动执行查询的次数</td>
</tr>
<tr>
<td>extra</td>
<td>执行情况的说明和描述</td>
</tr>
</tbody></table>
<p>MySQL <strong>执行计划的局限</strong>：</p>
<ul>
<li>只是计划，不是执行 SQL 语句，可以随着底层优化器输入的更改而更改</li>
<li>EXPLAIN 不会告诉显示关于触发器、存储过程的信息对查询的影响情况， 不考虑各种 Cache</li>
<li>EXPLAIN 不能显示 MySQL 在执行查询时的动态，因为执行计划在执行<strong>查询之前生成</strong></li>
<li>EXPALIN 只能解释 SELECT 操作，其他操作要重写为 SELECT 后查看执行计划</li>
<li>EXPLAIN PLAN 显示的是在解释语句时数据库将如何运行 SQL 语句，由于执行环境和 EXPLAIN PLAN 环境的不同，此计划可能与 SQL 语句<strong>实际的执行计划不同</strong>，部分统计信息是估算的，并非精确值</li>
</ul>
<p>SHOW WARINGS：在使用 EXPALIN 命令后执行该语句，可以查询与执行计划相关的拓展信息，展示出 Level、Code、Message 三个字段，当 Code 为 1003 时，Message 字段展示的信息类似于将查询语句重写后的信息，但是不是等价，不能执行复制过来运行</p>
<p>环境准备：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87.png"></p>
<hr>
<h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>id 代表 SQL 执行的顺序的标识，每个 SELECT 关键字对应一个唯一 id，所以在同一个 SELECT 关键字中的表的 id 都是相同的。SELECT 后的 FROM 可以跟随多个表，每个表都会对应一条记录，这些记录的 id 都是相同的，</p>
<ul>
<li><p>id 相同时，执行顺序由上至下。连接查询的执行计划，记录的 id 值都是相同的，出现在前面的表为驱动表，后面为被驱动表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t_role r, t_user u, user_role ur WHERE r.id = ur.role_id AND u.id = ur.user_id ;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-explain%E4%B9%8Bid%E7%9B%B8%E5%90%8C.png"></p>
</li>
<li><p>id 不同时，id 值越大优先级越高，越先被执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t_role WHERE id = (SELECT role_id FROM user_role WHERE user_id = (SELECT id FROM t_user WHERE username = &#x27;stu1&#x27;))</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-explain%E4%B9%8Bid%E4%B8%8D%E5%90%8C.png"></p>
</li>
<li><p>id 有相同也有不同时，id 相同的可以认为是一组，从上往下顺序执行；在所有的组中，id 的值越大的组，优先级越高，越先执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t_role r , (SELECT * FROM user_role ur WHERE ur.`user_id` = &#x27;2&#x27;) a WHERE r.id = a.role_id ; </span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-explain%E4%B9%8Bid%E7%9B%B8%E5%90%8C%E5%92%8C%E4%B8%8D%E5%90%8C.png"></p>
</li>
<li><p>id 为 NULL 时代表的是临时表</p>
</li>
</ul>
<hr>
<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>表示查询中每个 select 子句的类型（简单 OR 复杂）</p>
<table>
<thead>
<tr>
<th>select_type</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>简单的 SELECT 查询，查询中不包含子查询或者 UNION</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>查询中若包含任何复杂的子查询，最外层（也就是最左侧）查询标记为该标识</td>
</tr>
<tr>
<td>UNION</td>
<td>对于 UNION 或者 UNION ALL 的复杂查询，除了最左侧的查询，其余的小查询都是 UNION</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>UNION 需要使用临时表进行去重，临时表的是 UNION RESULT</td>
</tr>
<tr>
<td>DEPENDENT UNION</td>
<td>对于 UNION 或者 UNION ALL 的复杂查询，如果各个小查询都依赖外层查询，是相关子查询，除了最左侧的小查询为 DEPENDENT SUBQUERY，其余都是 DEPENDENT UNION</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>子查询不是相关子查询，该子查询第一个 SELECT 代表的查询就是这种类型，会进行物化（该子查询只需要执行一次）</td>
</tr>
<tr>
<td>DEPENDENT SUBQUERY</td>
<td>子查询是相关子查询，该子查询第一个 SELECT 代表的查询就是这种类型，不会物化（该子查询需要执行多次）</td>
</tr>
<tr>
<td>DERIVED</td>
<td>在 FROM 列表中包含的子查询，被标记为 DERIVED（衍生），也就是生成物化派生表的这个子查询</td>
</tr>
<tr>
<td>MATERIALIZED</td>
<td>将子查询物化后与与外层进行连接查询，生成物化表的子查询</td>
</tr>
</tbody></table>
<p>子查询为 DERIVED：<code>SELECT * FROM (SELECT key1 FROM t1) AS derived_1 WHERE key1 &gt; 10</code></p>
<p>子查询为 MATERIALIZED：<code>SELECT * FROM t1 WHERE key1 IN (SELECT key1 FROM t2)</code></p>
<hr>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>对表的访问方式，表示 MySQL 在表中找到所需行的方式，又称访问类型</p>
<table>
<thead>
<tr>
<th>type</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ALL</td>
<td>全表扫描，如果是 InnoDB 引擎是扫描聚簇索引</td>
</tr>
<tr>
<td>index</td>
<td>可以使用覆盖索引，但需要扫描全部索引</td>
</tr>
<tr>
<td>range</td>
<td>索引范围扫描，常见于 between、&lt;、&gt; 等的查询</td>
</tr>
<tr>
<td>index_subquery</td>
<td>子查询可以普通索引，则子查询的 type 为 index_subquery</td>
</tr>
<tr>
<td>unique_subquery</td>
<td>子查询可以使用主键或唯一二级索引，则子查询的 type 为 index_subquery</td>
</tr>
<tr>
<td>index_merge</td>
<td>索引合并</td>
</tr>
<tr>
<td>ref_or_null</td>
<td>非唯一性索引（普通二级索引）并且可以存储 NULL，进行等值匹配</td>
</tr>
<tr>
<td>ref</td>
<td>非唯一性索引与常量等值匹配</td>
</tr>
<tr>
<td>eq_ref</td>
<td>唯一性索引（主键或不存储 NULL 的唯一二级索引）进行等值匹配，如果二级索引是联合索引，那么所有联合的列都要进行等值匹配</td>
</tr>
<tr>
<td>const</td>
<td>通过主键或者唯一二级索引与常量进行等值匹配</td>
</tr>
<tr>
<td>system</td>
<td>system 是 const 类型的特例，当查询的表只有一条记录的情况下，使用 system</td>
</tr>
<tr>
<td>NULL</td>
<td>MySQL 在优化过程中分解语句，执行时甚至不用访问表或索引</td>
</tr>
</tbody></table>
<p>从上到下，性能从差到好，一般来说需要保证查询至少达到 range 级别， 最好达到 ref </p>
<hr>
<h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p>possible_keys：</p>
<ul>
<li>指出 MySQL 能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</li>
<li>如果该列是 NULL，则没有相关的索引</li>
</ul>
<p>key：</p>
<ul>
<li>显示 MySQL 在查询中实际使用的索引，若没有使用索引，显示为 NULL</li>
<li>查询中若使用了<strong>覆盖索引</strong>，则该索引可能出现在 key 列表，不出现在 possible_keys</li>
</ul>
<p>key_len：</p>
<ul>
<li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</li>
<li>key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，即 key_len 是根据表定义计算而得，不是通过表内检索出的</li>
<li>在不损失精确性的前提下，长度越短越好</li>
</ul>
<hr>
<h5 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h5><p>其他的额外的执行计划信息，在该列展示：</p>
<ul>
<li>No tables used：查询语句中使用 FROM dual 或者没有 FROM 语句</li>
<li>Impossible WHERE：查询语句中的 WHERE 子句条件永远为 FALSE，会导致没有符合条件的行</li>
<li>Using index：该值表示相应的 SELECT 操作中使用了<strong>覆盖索引</strong>（Covering Index）</li>
<li>Using index condition：第一种情况是搜索条件中虽然出现了索引列，但是部分条件无法形成扫描区间（<strong>索引失效</strong>），会根据可用索引的条件先搜索一遍再匹配无法使用索引的条件，回表查询数据；第二种是使用了<strong>索引条件下推</strong>优化</li>
<li>Using where：搜索的数据需要在 Server 层判断，无法使用索引下推</li>
<li>Using join buffer：连接查询被驱动表无法利用索引，需要连接缓冲区来存储中间结果</li>
<li>Using filesort：无法利用索引完成排序（优化方向），需要对数据使用外部排序算法，将取得的数据在内存或磁盘中进行排序</li>
<li>Using temporary：表示 MySQL 需要使用临时表来存储结果集，常见于<strong>排序、去重（UNION）、分组</strong>等场景</li>
<li>Select tables optimized away：说明仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</li>
<li>No tables used：Query 语句中使用 from dual 或不含任何 from 子句</li>
</ul>
<p>参考文章：<a href="https://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765237.html">https://www.cnblogs.com/ggjucheng/archive/2012/11/11/2765237.html</a></p>
<hr>
<h4 id="PROFILES"><a href="#PROFILES" class="headerlink" title="PROFILES"></a>PROFILES</h4><p>SHOW PROFILES 能够在做 SQL 优化时分析当前会话中语句执行的<strong>资源消耗</strong>情况</p>
<ul>
<li><p>通过 have_profiling 参数，能够看到当前 MySQL 是否支持 profile：<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-have_profiling.png"></p>
</li>
<li><p>默认 profiling 是关闭的，可以通过 set 语句在 Session 级别开启 profiling：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-profiling.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET profiling=1; #开启profiling 开关；</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 SHOW PROFILES 指令， 来查看 SQL 语句执行的耗时:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW PROFILES;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%9F%A5%E7%9C%8BSQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%80%97%E6%97%B6.png"></p>
</li>
<li><p>查看到该 SQL 执行过程中每个线程的状态和消耗的时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW PROFILE FOR QUERY query_id;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SQL%E6%89%A7%E8%A1%8C%E6%AF%8F%E4%B8%AA%E7%8A%B6%E6%80%81%E6%B6%88%E8%80%97%E7%9A%84%E6%97%B6%E9%97%B4.png"></p>
</li>
<li><p>在获取到最消耗时间的线程状态后，MySQL 支持选择 all、cpu、block io 、context switch、page faults 等类型查看 MySQL 在使用什么资源上耗费了过高的时间。例如，选择查看 CPU 的耗费时间：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-SQL%E6%89%A7%E8%A1%8C%E6%AF%8F%E4%B8%AA%E7%8A%B6%E6%80%81%E6%B6%88%E8%80%97%E7%9A%84CPU.png"></p>
<ul>
<li>Status：SQL 语句执行的状态</li>
<li>Durationsql：执行过程中每一个步骤的耗时</li>
<li>CPU_user：当前用户占有的 CPU</li>
<li>CPU_system：系统占有的 CPU</li>
</ul>
</li>
</ul>
<hr>
<h4 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h4><p>MySQL 提供了对 SQL 的跟踪， 通过 trace 文件可以查看优化器<strong>生成执行计划的过程</strong></p>
<ul>
<li><p>打开 trace 功能，设置格式为 JSON，并设置 trace 的最大使用内存，避免解析过程中因默认内存过小而不能够完整展示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=ON;	-- 会话内有效</span><br><span class="line">SET optimizer_trace_max_mem_size=1000000;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 SQL 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tb_item WHERE id &lt; 4;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查 information_schema.optimizer_trace：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.optimizer_trace \G; -- \G代表竖列展示</span><br></pre></td></tr></table></figure>

<p>执行信息主要有三个阶段：prepare 阶段、optimize 阶段（成本分析）、execute 阶段（执行）</p>
</li>
</ul>
<hr>
<h3 id="索引优化-1"><a href="#索引优化-1" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>索引是数据库优化最重要的手段之一，通过索引通常可以帮助用户解决大多数的 MySQL 的性能优化问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tb_seller` (</span><br><span class="line">	`sellerid` varchar (100),</span><br><span class="line">	`name` varchar (100),</span><br><span class="line">	`nickname` varchar (50),</span><br><span class="line">	`password` varchar (60),</span><br><span class="line">	`status` varchar (1),</span><br><span class="line">	`address` varchar (100),</span><br><span class="line">	`createtime` datetime,</span><br><span class="line">    PRIMARY KEY(`sellerid`)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8mb4;</span><br><span class="line">INSERT INTO `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values(&#x27;xiaomi&#x27;,&#x27;小米科技&#x27;,&#x27;小米官方旗舰店&#x27;,&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;,&#x27;1&#x27;,&#x27;西安市&#x27;,&#x27;2088-01-01 12:00:00&#x27;);</span><br><span class="line">CREATE INDEX idx_seller_name_sta_addr ON tb_seller(name, status, address); # 联合索引</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87.png"></p>
<hr>
<h4 id="避免失效"><a href="#避免失效" class="headerlink" title="避免失效"></a>避免失效</h4><h5 id="语句错误"><a href="#语句错误" class="headerlink" title="语句错误"></a>语句错误</h5><ul>
<li><p>全值匹配：对索引中所有列都指定具体值，这种情况索引生效，执行效率高</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status=&#x27;1&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%951.png"></p>
</li>
<li><p><strong>最左前缀法则</strong>：联合索引遵守最左前缀法则</p>
<p>匹配最左前缀法则，走索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27;;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status=&#x27;1&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%952.png"></p>
<p>违法最左前缀法则 ， 索引失效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE status=&#x27;1&#x27;;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE status=&#x27;1&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%953.png"></p>
<p>如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%954.png"></p>
<p>虽然索引列失效，但是系统会<strong>使用了索引下推进行了优化</strong></p>
</li>
<li><p><strong>范围查询</strong>右边的列，不能使用索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status&gt;&#x27;1&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure>

<p>根据前面的两个字段 name ， status 查询是走索引的， 但是最后一个条件 address 没有用到索引，使用了索引下推</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%955.png"></p>
</li>
<li><p>在索引列上<strong>函数或者运算（+ - 数值）操作</strong>， 索引将失效：会破坏索引值的有序性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE SUBSTRING(name,3,2) = &#x27;科技&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%956.png"></p>
</li>
<li><p><strong>字符串不加单引号</strong>，造成索引失效：隐式类型转换，当字符串和数字比较时会<strong>把字符串转化为数字</strong></p>
<p>在查询时，没有对字符串加单引号，查询优化器会调用 CAST 函数将 status 转换为 int 进行比较，造成索引失效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status = 1;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%957.png"></p>
<p>如果 status 是 int 类型，SQL 为 <code>SELECT * FROM tb_seller WHERE status = &#39;1&#39; </code> 并不会造成索引失效，因为会将 <code>&#39;1&#39;</code> 转换为 <code>1</code>，并<strong>不会对索引列产生操作</strong></p>
</li>
<li><p>多表连接查询时，如果两张表的<strong>字符集不同</strong>，会造成索引失效，因为会进行类型转换</p>
<p>解决方法：CONVERT 函数是加在输入参数上、修改表的字符集</p>
</li>
<li><p><strong>用 OR 分割条件，索引失效</strong>，导致全表查询：</p>
<p>OR 前的条件中的列有索引而后面的列中没有索引或 OR 前后两个列是同一个复合索引，都造成索引失效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;阿里巴巴&#x27; OR createtime = &#x27;2088-01-01 12:00:00&#x27;;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; OR status=&#x27;1&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9510.png"></p>
<p><strong>AND 分割的条件不影响</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;阿里巴巴&#x27; AND createtime = &#x27;2088-01-01 12:00:00&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9511.png"></p>
</li>
<li><p><strong>以 % 开头的 LIKE 模糊查询</strong>，索引失效：</p>
<p>如果是尾部模糊匹配，索引不会失效；如果是头部模糊匹配，索引失效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name like &#x27;%科技%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9512.png"></p>
<p>解决方案：通过覆盖索引来解决 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT sellerid,name,status FROM tb_seller WHERE name like &#x27;%科技%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9513.png"></p>
<p>原因：在覆盖索引的这棵 B+ 数上只需要进行 like 的匹配，或者是基于覆盖索引查询再进行 WHERE 的判断就可以获得结果</p>
</li>
</ul>
<hr>
<h5 id="系统优化-1"><a href="#系统优化-1" class="headerlink" title="系统优化"></a>系统优化</h5><p>系统优化为全表扫描：</p>
<ul>
<li><p>如果 MySQL 评估使用索引比全表更慢，则不使用索引，索引失效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_address ON tb_seller(address);</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE address=&#x27;西安市&#x27;;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE address=&#x27;北京市&#x27;;</span><br></pre></td></tr></table></figure>

<p>北京市的键值占 9&#x2F;10（区分度低），所以优化为全表扫描，type &#x3D; ALL</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9514.png"></p>
</li>
<li><p>IS  NULL、IS NOT NULL  <strong>有时</strong>索引失效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name IS NULL;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name IS NOT NULL;</span><br></pre></td></tr></table></figure>

<p>NOT NULL 失效的原因是 name 列全部不是 null，优化为全表扫描，当 NULL 过多时，IS NULL 失效</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9515.png"></p>
</li>
<li><p>IN 肯定会走索引，但是当 IN 的取值范围较大时会导致索引失效，走全表扫描：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE sellerId IN (&#x27;alibaba&#x27;,&#x27;huawei&#x27;);-- 都走索引</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE sellerId NOT IN (&#x27;alibaba&#x27;,&#x27;huawei&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://time.geekbang.org/column/article/74687">MySQL 实战 45 讲</a>该章节最后提出了一种场景，获取到数据以后 Server 层还会做判断</p>
</li>
</ul>
<hr>
<h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><p>索引失效一般是针对联合索引，联合索引一般由几个字段组成，排序方式是先按照第一个字段进行排序，然后排序第二个，依此类推，图示（a, b）索引，<strong>a 相等的情况下 b 是有序的</strong></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-索引失效底层原理1.png" style="zoom:67%;">

<ul>
<li><p>最左前缀法则：当不匹配前面的字段的时候，后面的字段都是无序的。这种无序不仅体现在叶子节点，也会<strong>导致查询时扫描的非叶子节点也是无序的</strong>，因为索引树相当于忽略的第一个字段，就无法使用二分查找</p>
</li>
<li><p>范围查询右边的列，不能使用索引，比如语句： <code>WHERE a &gt; 1 AND b = 1 </code>，在 a 大于 1 的时候，b 是无序的，a &gt; 1 是扫描时有序的，但是找到以后进行寻找 b 时，索引树就不是有序的了</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-索引失效底层原理2.png" style="zoom:67%;">
</li>
<li><p>以 % 开头的 LIKE 模糊查询，索引失效，比如语句：<code>WHERE a LIKE &#39;%d&#39;</code>，前面的不确定，导致不符合最左匹配，直接去索引中搜索以 d 结尾的节点，所以没有顺序<br>                            <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%863.png"></p>
</li>
</ul>
<p>参考文章：<a href="https://mp.weixin.qq.com/s/B_M09dzLe9w7cT46rdGIeQ">https://mp.weixin.qq.com/s/B_M09dzLe9w7cT46rdGIeQ</a></p>
<hr>
<h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Handler_read%&#x27;;	</span><br><span class="line">SHOW GLOBAL STATUS LIKE &#x27;Handler_read%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5.png"></p>
<ul>
<li><p>Handler_read_first：索引中第一条被读的次数，如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）</p>
</li>
<li><p>Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，值越低表示索引不经常使用（这个值越高越好）</p>
</li>
<li><p>Handler_read_next：按照键顺序读下一行的请求数，如果范围约束或执行索引扫描来查询索引列，值增加</p>
</li>
<li><p>Handler_read_prev：按照键顺序读前一行的请求数，该读方法主要用于优化 ORDER BY … DESC</p>
</li>
<li><p>Handler_read_rnd：根据固定位置读一行的请求数，如果执行大量查询并对结果进行排序则该值较高，可能是使用了大量需要 MySQL 扫描整个表的查询或连接，这个值较高意味着运行效率低，应该建立索引来解决</p>
</li>
<li><p>Handler_read_rnd_next：在数据文件中读下一行的请求数，如果正进行大量的表扫描，该值较高，说明表索引不正确或写入的查询没有利用索引</p>
</li>
</ul>
<hr>
<h3 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h3><h4 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h4><h5 id="自增机制"><a href="#自增机制" class="headerlink" title="自增机制"></a>自增机制</h5><p>自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，因此索引更紧凑</p>
<p>表的结构定义存放在后缀名为.frm 的文件中，但是并不会保存自增值，不同的引擎对于自增值的保存策略不同：</p>
<ul>
<li>MyISAM 引擎的自增值保存在数据文件中</li>
<li>InnoDB 引擎的自增值保存在了内存里，每次打开表都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为当前的自增值；8.0 版本后，才有了自增值持久化的能力，将自增值的变更记录在了 redo log 中，重启的时候依靠 redo log 恢复重启之前的值</li>
</ul>
<p>在插入一行数据的时候，自增值的行为如下：</p>
<ul>
<li>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段</li>
<li>如果插入数据时 id 字段指定了具体的值，比如某次要插入的值是 X，当前的自增值是 Y<ul>
<li>如果 X&lt;Y，那么这个表的自增值不变</li>
<li>如果 X≥Y，就需要把当前自增值修改为新的自增值</li>
</ul>
</li>
</ul>
<p>参数说明：auto_increment_offset 和 auto_increment_increment 分别表示自增的初始值和步长，默认值都是 1</p>
<p>语句执行失败也不回退自增 id，所以保证了自增 id 是递增的，但不保证是连续的（不能回退，所以有些回滚事务的自增 id 就不会重新使用，导致出现不连续）</p>
<hr>
<h5 id="自增-ID"><a href="#自增-ID" class="headerlink" title="自增 ID"></a>自增 ID</h5><p>MySQL 不同的自增 id 在达到上限后的表现不同：</p>
<ul>
<li><p>表的自增 id 如果是 int 类型，达到上限 2^32-1 后，再申请时值就不会改变，进而导致继续插入数据时报主键冲突的错误</p>
</li>
<li><p>row_id 长度为 6 个字节，达到上限后则会归 0 再重新递增，如果出现相同的 row_id，后写的数据会覆盖之前的数据，造成旧数据丢失，影响的是数据可靠性，所以应该在 InnoDB 表中主动创建自增主键报主键冲突，插入失败影响的是可用性，而一般情况下，<strong>可靠性优先于可用性</strong></p>
</li>
<li><p>Xid 长度 8 字节，由 Server 层维护，只需要不在同一个 binlog 文件中出现重复值即可，虽然理论上会出现重复值，但是概率极小</p>
</li>
<li><p>InnoDB 的 max_trx_id 递增值每次 MySQL 重启都会被保存起来，重启也不会重置为 0，所以会导致一直增加到达上限，然后从 0 开始，这时原事务 0 修改的数据对当前事务就是可见的，产生脏读的现象</p>
<p>只读事务不分配 trx_id，所以 trx_id 的增加速度变慢了</p>
</li>
<li><p>thread_id 长度 4 个字节，到达上限后就会重置为 0，MySQL 设计了一个唯一数组的逻辑，给新线程分配 thread_id 时做判断，保证不会出现两个相同的 thread_id：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	new_id = thread_id_counter++;</span><br><span class="line">&#125; <span class="keyword">while</span> (!thread_ids.<span class="built_in">insert_unique</span>(new_id).second);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>参考文章：<a href="https://time.geekbang.org/column/article/83183">https://time.geekbang.org/column/article/83183</a></p>
<hr>
<h4 id="覆盖索引-1"><a href="#覆盖索引-1" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>复合索引叶子节点不仅保存了复合索引的值，还有主键索引，所以使用覆盖索引的时候，加上主键也会用到索引</p>
<p>尽量使用覆盖索引，避免 SELECT *：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT name,status,address FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status=&#x27;1&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%958.png"></p>
<p>如果查询列，超出索引列，也会降低性能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT name,status,address,password FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status=&#x27;1&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%959.png"></p>
<hr>
<h4 id="减少访问"><a href="#减少访问" class="headerlink" title="减少访问"></a>减少访问</h4><p>避免对数据进行重复检索：能够一次连接就获取到结果的，就不用两次连接，这样可以大大减少对数据库无用的重复请求</p>
<ul>
<li><p>查询数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id,name FROM tb_book;</span><br><span class="line">SELECT id,status FROM tb_book; -- 向数据库提交两次请求，数据库就要做两次查询操作</span><br><span class="line">-- &gt; 优化为:</span><br><span class="line">SELECT id,name,statu FROM tb_book;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb_test VALUES(1,&#x27;Tom&#x27;);</span><br><span class="line">INSERT INTO tb_test VALUES(2,&#x27;Cat&#x27;);</span><br><span class="line">INSERT INTO tb_test VALUES(3,&#x27;Jerry&#x27;);	-- 连接三次数据库</span><br><span class="line">-- &gt;优化为</span><br><span class="line">INSERT INTO tb_test VALUES(1,&#x27;Tom&#x27;),(2,&#x27;Cat&#x27;)，(3,&#x27;Jerry&#x27;);	-- 连接一次</span><br></pre></td></tr></table></figure>
</li>
<li><p>在事务中进行数据插入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">INSERT INTO tb_test VALUES(1,&#x27;Tom&#x27;);</span><br><span class="line">INSERT INTO tb_test VALUES(2,&#x27;Cat&#x27;);</span><br><span class="line">INSERT INTO tb_test VALUES(3,&#x27;Jerry&#x27;);</span><br><span class="line">commit;	-- 手动提交，分段提交</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据有序插入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb_test VALUES(1,&#x27;Tom&#x27;);</span><br><span class="line">INSERT INTO tb_test VALUES(2,&#x27;Cat&#x27;);</span><br><span class="line">INSERT INTO tb_test VALUES(3,&#x27;Jerry&#x27;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>增加 cache 层：在应用中增加缓存层来达到减轻数据库负担的目的。可以部分数据从数据库中抽取出来放到应用端以文本方式存储，或者使用框架（Mybatis）提供的一级缓存 &#x2F; 二级缓存，或者使用 Redis 数据库来缓存数据 </p>
<hr>
<h4 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h4><p>当使用 load 命令导入数据的时候，适当的设置可以提高导入的效率：</p>
<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> load data.png)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD DATA LOCAL INFILE = &#x27;/home/seazean/sql1.log&#x27; INTO TABLE `tb_user_1` FIELD TERMINATED BY &#x27;,&#x27; LINES TERMINATED BY &#x27;\n&#x27;; -- 文件格式如上图</span><br></pre></td></tr></table></figure>

<p>对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率：</p>
<ol>
<li><p><strong>主键顺序插入</strong>：因为 InnoDB 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率，如果 InnoDB 表没有主键，那么系统会自动默认创建一个内部列作为主键</p>
<p>主键是否连续对性能影响不大，只要是递增的就可以，比如雪花算法产生的 ID 不是连续的，但是是递增的，因为递增可以让主键索引尽量地保持顺序插入，<strong>避免了页分裂</strong>，因此索引更紧凑</p>
<ul>
<li>插入 ID 顺序排列数据：</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E6%8F%92%E5%85%A5ID%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E6%95%B0%E6%8D%AE.png"></p>
<ul>
<li>插入 ID 无序排列数据：</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E6%8F%92%E5%85%A5ID%E6%97%A0%E5%BA%8F%E6%8E%92%E5%88%97%E6%95%B0%E6%8D%AE.png"></p>
</li>
<li><p><strong>关闭唯一性校验</strong>：在导入数据前执行 <code>SET UNIQUE_CHECKS=0</code>，关闭唯一性校验；导入结束后执行 <code>SET UNIQUE_CHECKS=1</code>，恢复唯一性校验，可以提高导入的效率。</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E5%85%B3%E9%97%AD%E5%94%AF%E4%B8%80%E6%80%A7%E6%A0%A1%E9%AA%8C.png"></p>
</li>
<li><p><strong>手动提交事务</strong>：如果应用使用自动提交的方式，建议在导入前执行<code>SET AUTOCOMMIT=0</code>，关闭自动提交；导入结束后再打开自动提交，可以提高导入的效率。</p>
<p>事务需要控制大小，事务太大可能会影响执行的效率。MySQL 有 innodb_log_buffer_size 配置项，超过这个值的日志会写入磁盘数据，效率会下降，所以在事务大小达到配置项数据级前进行事务提交可以提高效率</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1.png"></p>
</li>
</ol>
<hr>
<h4 id="分组排序"><a href="#分组排序" class="headerlink" title="分组排序"></a>分组排序</h4><h5 id="ORDER"><a href="#ORDER" class="headerlink" title="ORDER"></a>ORDER</h5><p>数据准备：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `emp` (</span><br><span class="line">  `id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` VARCHAR(100) NOT NULL,</span><br><span class="line">  `age` INT(3) NOT NULL,</span><br><span class="line">  `salary` INT(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB DEFAULT CHARSET=utf8mb4;</span><br><span class="line">INSERT INTO `emp` (`id`, `name`, `age`, `salary`) VALUES(&#x27;1&#x27;,&#x27;Tom&#x27;,&#x27;25&#x27;,&#x27;2300&#x27;);-- ...</span><br><span class="line">CREATE INDEX idx_emp_age_salary ON emp(age, salary);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一种是通过对返回数据进行排序，所有不通过索引直接返回结果的排序都叫 FileSort 排序，会在内存中重新排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM emp ORDER BY age DESC;	-- 年龄降序</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> ORDER BY排序1.png)</p>
</li>
<li><p>第二种通过有序索引顺序扫描直接返回<strong>有序数据</strong>，这种情况为 Using index，不需要额外排序，操作效率高</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT id, age, salary FROM emp ORDER BY age DESC;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> ORDER BY排序2.png)</p>
</li>
<li><p>多字段排序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT id,age,salary FROM emp ORDER BY age DESC, salary DESC;</span><br><span class="line">EXPLAIN SELECT id,age,salary FROM emp ORDER BY salary DESC, age DESC;</span><br><span class="line">EXPLAIN SELECT id,age,salary FROM emp ORDER BY age DESC, salary ASC;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> ORDER BY排序3.png)</p>
<p>尽量减少额外的排序，通过索引直接返回有序数据。<strong>需要满足 Order by 使用相同的索引、Order By 的顺序和索引顺序相同、Order  by 的字段都是升序或都是降序</strong>，否则需要额外的操作，就会出现 FileSort</p>
</li>
<li><p>ORDER BY RAND() 命令用来进行随机排序，会使用了临时内存表，临时内存表排序的时使用 rowid 排序方法</p>
</li>
</ul>
<p>优化方式：创建合适的索引能够减少 Filesort 的出现，但是某些情况下条件限制不能让 Filesort 消失，就要加快 Filesort 的排序操作</p>
<p>内存临时表，MySQL 有两种 Filesort 排序算法：</p>
<ul>
<li><p>rowid 排序：首先根据条件取出排序字段和信息，然后在<strong>排序区 sort buffer（Server 层）</strong>中排序，如果 sort buffer 不够，则在临时表 temporary table 中存储排序结果。完成排序后再根据行指针<strong>回表读取记录</strong>，该操作可能会导致大量随机 I&#x2F;O 操作</p>
<p>说明：对于临时内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，不会导致多访问磁盘，优先选择该方式</p>
</li>
<li><p>全字段排序：一次性取出满足条件的所有数据，需要回表，然后在排序区 sort  buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法高</p>
</li>
</ul>
<p>具体的选择方式：</p>
<ul>
<li><p>MySQL 通过比较系统变量 max_length_for_sort_data 的大小和 Query 语句取出的字段的大小，来判定使用哪种排序算法。如果前者大，则说明 sort  buffer 空间足够，使用第二种优化之后的算法，否则使用第一种。</p>
</li>
<li><p>可以适当提高 sort_buffer_size  和 max_length_for_sort_data 系统变量，来增大排序区的大小，提高排序的效率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @@max_length_for_sort_data = 10000; 		-- 设置全局变量</span><br><span class="line">SET max_length_for_sort_data = 10240; 			-- 设置会话变量</span><br><span class="line">SHOW VARIABLES LIKE &#x27;max_length_for_sort_data&#x27;;	-- 默认1024</span><br><span class="line">SHOW VARIABLES LIKE &#x27;sort_buffer_size&#x27;;			-- 默认262114</span><br></pre></td></tr></table></figure></li>
</ul>
<p>磁盘临时表：排序使用优先队列（堆）的方式</p>
<hr>
<h5 id="GROUP"><a href="#GROUP" class="headerlink" title="GROUP"></a>GROUP</h5><p>GROUP BY 也会进行排序操作，与 ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作，所以在 GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引</p>
<ul>
<li><p>分组查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX idx_emp_age_salary ON emp;</span><br><span class="line">EXPLAIN SELECT age,COUNT(*) FROM emp GROUP BY age;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> GROUP BY排序1.png)</p>
<p>Using temporary：表示 MySQL 需要使用临时表（不是 sort buffer）来存储结果集，常见于排序和分组查询</p>
</li>
<li><p>查询包含 GROUP BY 但是用户想要避免排序结果的消耗， 则可以执行 ORDER BY NULL 禁止排序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT age,COUNT(*) FROM emp GROUP BY age ORDER BY NULL;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> GROUP BY排序2.png)</p>
</li>
<li><p>创建索引：索引本身有序，不需要临时表，也不需要再额外排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_emp_age_salary ON emp(age, salary);</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> GROUP BY排序3.png)</p>
</li>
<li><p>数据量很大时，使用 SQL_BIG_RESULT 提示优化器直接使用直接用磁盘临时表</p>
</li>
</ul>
<hr>
<h4 id="联合查询-1"><a href="#联合查询-1" class="headerlink" title="联合查询"></a>联合查询</h4><p>对于包含 OR 的查询子句，如果要利用索引，则 OR 之间的<strong>每个条件列都必须用到索引，而且不能使用到条件之间的复合索引</strong>，如果没有索引，则应该考虑增加索引</p>
<ul>
<li><p>执行查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM emp WHERE id = 1 OR age = 30;	-- 两个索引，并且不是复合索引</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> OR条件查询1.png)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Extra: Using sort_union(idx_emp_age_salary,PRIMARY); Using <span class="built_in">where</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 UNION 替换 OR，求并集：</p>
<p>注意：该优化只针对多个索引列有效，如果有列没有被索引，查询效率可能会因为没有选择 OR 而降低</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM emp WHERE id = 1 UNION SELECT * FROM emp WHERE age = 30;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-优化SQL</a> OR条件查询2.png)</p>
</li>
<li><p>UNION 要优于 OR 的原因：</p>
<ul>
<li>UNION 语句的 type 值为 ref，OR 语句的 type 值为 range</li>
<li>UNION 语句的 ref 值为 const，OR 语句的 ref 值为 null，const 表示是常量值引用，非常快</li>
</ul>
</li>
</ul>
<hr>
<h4 id="嵌套查询-1"><a href="#嵌套查询-1" class="headerlink" title="嵌套查询"></a>嵌套查询</h4><p>MySQL 4.1 版本之后，开始支持 SQL 的子查询</p>
<ul>
<li>可以使用 SELECT 语句来创建一个单列的查询结果，然后把结果作为过滤条件用在另一个查询中</li>
<li>使用子查询可以一次性的完成逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死</li>
<li>在有些情况下，<strong>子查询是可以被更高效的连接（JOIN）替代</strong></li>
</ul>
<p>例如查找有角色的所有的用户信息：</p>
<ul>
<li><p>执行计划：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t_user WHERE id IN (SELECT user_id FROM user_role);</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A21.png"></p>
</li>
<li><p>优化后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t_user u , user_role ur WHERE u.id = ur.user_id;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A22.png"></p>
<p>连接查询之所以效率更高 ，是因为<strong>不需要在内存中创建临时表</strong>来完成逻辑上需要两个步骤的查询工作</p>
</li>
</ul>
<hr>
<h4 id="分页查询-1"><a href="#分页查询-1" class="headerlink" title="分页查询"></a>分页查询</h4><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能</p>
<p>一个常见的问题是 <code>LIMIT 200000,10</code>，此时需要 MySQL 扫描前 200010 记录，仅仅返回 200000 - 200010 之间的记录，其他记录丢弃，查询排序的代价非常大</p>
<ul>
<li><p>分页查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_user_1 LIMIT 200000,10;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A21.png"></p>
</li>
<li><p>优化方式一：内连接查询，在索引列 id 上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_user_1 t,(SELECT id FROM tb_user_1 ORDER BY id LIMIT 200000,10) a WHERE t.id = a.id;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A22.png"></p>
</li>
<li><p>优化方式二：方案适用于主键自增的表，可以把 LIMIT 查询转换成某个位置的查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_user_1 WHERE id &gt; 200000 LIMIT 10;			-- 写法 1</span><br><span class="line">EXPLAIN SELECT * FROM tb_user_1 WHERE id BETWEEN 200000 and 200010;	-- 写法 2</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A23.png"></p>
</li>
</ul>
<hr>
<h4 id="使用提示"><a href="#使用提示" class="headerlink" title="使用提示"></a>使用提示</h4><p>SQL 提示，是优化数据库的一个重要手段，就是在 SQL 语句中加入一些提示来达到优化操作的目的</p>
<ul>
<li><p>USE INDEX：在查询语句中表名的后面添加 USE INDEX 来提供 MySQL 去参考的索引列表，可以让 MySQL 不再考虑其他可用的索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_seller_name ON tb_seller(name);</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller USE INDEX(idx_seller_name) WHERE name=&#x27;小米科技&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E6%8F%90%E7%A4%BA1.png"></p>
</li>
<li><p>IGNORE INDEX：让 MySQL 忽略一个或者多个索引，则可以使用 IGNORE INDEX 作为提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller IGNORE INDEX(idx_seller_name) WHERE name = &#x27;小米科技&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E6%8F%90%E7%A4%BA2.png"></p>
</li>
<li><p>FORCE INDEX：强制 MySQL 使用一个特定的索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller FORCE INDEX(idx_seller_name_sta_addr) WHERE NAME=&#x27;小米科技&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E6%8F%90%E7%A4%BA3.png"></p>
</li>
</ul>
<hr>
<h4 id="统计计数"><a href="#统计计数" class="headerlink" title="统计计数"></a>统计计数</h4><p>在不同的 MySQL 引擎中，count(*) 有不同的实现方式：</p>
<ul>
<li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高，但不支持事务</li>
<li>show table status 命令通过采样估算可以快速获取，但是不准确</li>
<li>InnoDB 表执行 count(*) 会遍历全表，虽然结果准确，但会导致性能问题</li>
</ul>
<p>解决方案：</p>
<ul>
<li><p>计数保存在 Redis 中，但是更新 MySQL 和 Redis 的操作不是原子的，会存在数据一致性的问题</p>
</li>
<li><p>计数直接放到数据库里单独的一张计数表中，利用事务解决计数精确问题：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-计数count优化.png" style="zoom: 50%;">

<p>会话 B 的读操作在 T3 执行的，这时更新事务还没有提交，所以计数值加 1 这个操作对会话 B 还不可见，因此会话 B 查询的计数值和最近 100 条记录，返回的结果逻辑上就是一致的</p>
<p>并发系统性能的角度考虑，应该先插入操作记录再更新计数表，因为更新计数表涉及到行锁的竞争，<strong>先插入再更新能最大程度地减少事务之间的锁等待，提升并发度</strong></p>
</li>
</ul>
<p>count 函数的按照效率排序：<code>count(字段) &lt; count(主键id) &lt; count(1) ≈ count(*)</code>，所以建议尽量使用 count(*)</p>
<ul>
<li>count(主键 id)：InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来返回给 Server 层，Server 判断 id 不为空就按行累加</li>
<li>count(1)：InnoDB 引擎遍历整张表但不取值，Server 层对于返回的每一行，放一个数字 1 进去，判断不为空就按行累加</li>
<li>count(字段)：如果这个字段是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个字段定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加</li>
<li>count(*)：不取值，按行累加</li>
</ul>
<p>参考文章：<a href="https://time.geekbang.org/column/article/72775">https://time.geekbang.org/column/article/72775</a></p>
<hr>
<h3 id="缓冲优化"><a href="#缓冲优化" class="headerlink" title="缓冲优化"></a>缓冲优化</h3><h4 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h4><p>三个原则：</p>
<ul>
<li>将尽量多的内存分配给 MySQL 做缓存，但也要给操作系统和其他程序预留足够内存</li>
<li>MyISAM 存储引擎的数据文件读取依赖于操作系统自身的 IO 缓存，如果有 MyISAM 表，就要预留更多的内存给操作系统做 IO 缓存</li>
<li>排序区、连接区等缓存是分配给每个数据库会话（Session）专用的，值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发数较高时会导致物理内存耗尽</li>
</ul>
<hr>
<h4 id="缓冲内存"><a href="#缓冲内存" class="headerlink" title="缓冲内存"></a>缓冲内存</h4><p>Buffer Pool 本质上是 InnoDB 向操作系统申请的一段连续的内存空间。InnoDB 的数据是按数据页为单位来读写，每个数据页的大小默认是 16KB。数据是存放在磁盘中，每次读写数据都需要进行磁盘 IO 将数据读入内存进行操作，效率会很低，所以提供了 Buffer Pool 来暂存这些数据页，缓存中的这些页又叫缓冲页</p>
<p>工作原理：</p>
<ul>
<li>从数据库读取数据时，会首先从缓存中读取，如果缓存中没有，则从磁盘读取后放入 Buffer Pool</li>
<li>向数据库写入数据时，会写入缓存，缓存中修改的数据会<strong>定期刷新</strong>到磁盘，这一过程称为刷脏</li>
</ul>
<p>Buffer Pool 中每个缓冲页都有对应的控制信息，包括表空间编号、页号、偏移量、链表信息等，控制信息存放在占用的内存称为控制块，控制块与缓冲页是一一对应的，但并不是物理上相连的，都在缓冲池中</p>
<p>MySQL 提供了缓冲页的快速查找方式：<strong>哈希表</strong>，使用表空间号和页号作为 Key，缓冲页控制块的地址作为 Value 创建一个哈希表，获取数据页时根据 Key 进行哈希寻址：</p>
<ul>
<li>如果不存在对应的缓存页，就从 free 链表中选一个空闲缓冲页，把磁盘中的对应页加载到该位置</li>
<li>如果存在对应的缓存页，直接获取使用，提高查询数据的效率</li>
</ul>
<p>当内存数据页跟磁盘数据页内容不一致时，称这个内存页为脏页；内存数据写入磁盘后，内存和磁盘上的数据页一致，称为干净页</p>
<hr>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><h5 id="Free-链表"><a href="#Free-链表" class="headerlink" title="Free 链表"></a>Free 链表</h5><p>MySQL 启动时完成对 Buffer Pool 的初始化，先向操作系统申请连续的内存空间，然后将内存划分为若干对控制块和缓冲页。为了区分空闲和已占用的数据页，将所有空闲缓冲页对应的<strong>控制块作为一个节点</strong>放入一个链表中，就是 Free 链表（<strong>空闲链表</strong>）</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-空闲链表.png" style="zoom: 50%;">

<p>基节点：是一块单独申请的内存空间（占 40 字节），并不在 Buffer Pool 的那一大片连续内存空间里</p>
<p>磁盘加载页的流程：</p>
<ul>
<li>从 Free 链表中取出一个空闲的缓冲页</li>
<li>把缓冲页对应的控制块的信息填上（页所在的表空间、页号之类的信息）</li>
<li>把缓冲页对应的 Free 链表节点（控制块）从链表中移除，表示该缓冲页已经被使用</li>
</ul>
<p>参考文章：<a href="https://blog.csdn.net/li1325169021/article/details/121124440">https://blog.csdn.net/li1325169021/article/details/121124440</a></p>
<hr>
<h5 id="Flush-链表"><a href="#Flush-链表" class="headerlink" title="Flush 链表"></a>Flush 链表</h5><p>Flush 链表是一个用来<strong>存储脏页</strong>的链表，对于已经修改过的缓冲脏页，第一次修改后加入到<strong>链表头部</strong>，以后每次修改都不会重新加入，只修改部分控制信息，出于性能考虑并不是直接更新到磁盘，而是在未来的某个时间进行刷脏</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-脏页链表.png" style="zoom:50%;">

<p><strong>后台有专门的线程每隔一段时间把脏页刷新到磁盘</strong>：</p>
<ul>
<li>从 Flush 链表中刷新一部分页面到磁盘：<ul>
<li><strong>后台线程定时</strong>从 Flush 链表刷脏，根据系统的繁忙程度来决定刷新速率，这种方式称为 BUF_FLUSH_LIST</li>
<li>线程刷脏的比较慢，导致用户线程加载一个新的数据页时发现没有空闲缓冲页，此时会尝试从 LRU 链表尾部寻找缓冲页直接释放，如果该页面是已经修改过的脏页就<strong>同步刷新</strong>到磁盘，速度较慢，这种方式称为 BUF_FLUSH_SINGLE_PAGE</li>
</ul>
</li>
<li>从 LRU 链表的冷数据中刷新一部分页面到磁盘，即：BUF_FLUSH_LRU<ul>
<li>后台线程会定时从 LRU 链表的尾部开始扫描一些页面，扫描的页面数量可以通过系统变量 <code>innodb_lru_scan_depth</code> 指定，如果在 LRU 链表中发现脏页，则把它们刷新到磁盘，这种方式称为 BUF_FLUSH_LRU</li>
<li>控制块里会存储该缓冲页是否被修改的信息，所以可以很容易的获取到某个缓冲页是否是脏页</li>
</ul>
</li>
</ul>
<p>参考文章：<a href="https://blog.csdn.net/li1325169021/article/details/121125765">https://blog.csdn.net/li1325169021/article/details/121125765</a></p>
<hr>
<h5 id="LRU-链表"><a href="#LRU-链表" class="headerlink" title="LRU 链表"></a>LRU 链表</h5><p>当 Buffer Pool 中没有空闲缓冲页时就需要淘汰掉最近最少使用的部分缓冲页，为了实现这个功能，MySQL 创建了一个 LRU 链表，当访问某个页时：</p>
<ul>
<li>如果该页不在 Buffer Pool 中，把该页从磁盘加载进来后会将该缓冲页对应的控制块作为节点放入 <strong>LRU 链表的头部</strong></li>
<li>如果该页在 Buffer Pool 中，则直接把该页对应的控制块移动到 LRU 链表的头部，所以 LRU 链表尾部就是最近最少使用的缓冲页</li>
</ul>
<p>MySQL 基于局部性原理提供了预读功能：</p>
<ul>
<li>线性预读：系统变量 <code>innodb_read_ahead_threshold</code>，如果顺序访问某个区（extent：16 KB 的页，连续 64 个形成一个区，一个区默认 1MB 大小）的页面数超过了该系统变量值，就会触发一次<strong>异步读取</strong>下一个区中全部的页面到 Buffer Pool 中</li>
<li>随机预读：如果某个区 13 个连续的页面都被加载到 Buffer Pool，无论这些页面是否是顺序读取，都会触发一次<strong>异步读取</strong>本区所有的其他页面到 Buffer Pool 中</li>
</ul>
<p>预读会造成加载太多用不到的数据页，造成那些使用<strong>频率很高的数据页被挤到 LRU 链表尾部</strong>，所以 InnoDB 将 LRU 链表分成两段：</p>
<ul>
<li>一部分存储使用频率很高的数据页，这部分链表也叫热数据，young 区，靠近链表头部的区域</li>
<li>一部分存储使用频率不高的冷数据，old 区，靠近链表尾部，默认占 37%，可以通过系统变量 <code>innodb_old_blocks_pct</code> 指定</li>
</ul>
<p>当磁盘上的某数据页被初次加载到 Buffer Pool 中会被放入 old 区，淘汰时优先淘汰 old 区</p>
<ul>
<li>当对 old 区的数据进行访问时，会在控制块记录下访问时间，等待后续的访问时间与第一次访问的时间是否在某个时间间隔内，通过系统变量 <code>innodb_old_blocks_time</code> 指定时间间隔，默认 1000ms，成立就<strong>移动到 young 区的链表头部</strong></li>
<li><code>innodb_old_blocks_time</code> 为 0 时，每次访问一个页面都会放入 young 区的头部</li>
</ul>
<hr>
<h4 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h4><p>InnoDB 用一块内存区做 IO 缓存池，该缓存池不仅用来缓存 InnoDB 的索引块，也用来缓存 InnoDB 的数据块，可以通过下面的指令查看 Buffer Pool 的状态信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure>

<p><code>Buffer pool hit rate</code> 字段代表<strong>内存命中率</strong>，表示 Buffer Pool 对查询的加速效果</p>
<p>核心参数：</p>
<ul>
<li><p><code>innodb_buffer_pool_size</code>：该变量决定了 Innodb 存储引擎表数据和索引数据的最大缓存区大小，默认 128M</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_buffer_pool_size&#x27;;</span><br></pre></td></tr></table></figure>

<p>在保证操作系统及其他程序有足够内存可用的情况下，<code>innodb_buffer_pool_size</code> 的值越大，缓存命中率越高，建议设置成可用物理内存的 60%~80%</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">innodb_buffer_pool_size=512M</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>innodb_log_buffer_size</code>：该值决定了 Innodb 日志缓冲区的大小，保存要写入磁盘上的日志文件数据</p>
<p>对于可能产生大量更新记录的大事务，增加该值的大小，可以避免 Innodb 在事务提交前就执行不必要的日志写入磁盘操作，影响执行效率，通过配置文件修改：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">innodb_log_buffer_size=10M</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在多线程下，访问 Buffer Pool 中的各种链表都需要加锁，所以将 Buffer Pool 拆成若干个小实例，<strong>每个线程对应一个实例</strong>，独立管理内存空间和各种链表（类似 ThreadLocal），多线程访问各自实例互不影响，提高了并发能力</p>
<p>MySQL 5.7.5 之前 <code>innodb_buffer_pool_size</code> 只支持在系统启动时修改，现在已经支持运行时修改 Buffer Pool 的大小，但是每次调整参数都会重新向操作系统申请一块连续的内存空间，<strong>将旧的缓冲池的内容拷贝到新空间</strong>非常耗时，所以 MySQL 开始以一个 chunk 为单位向操作系统申请内存，所以一个 Buffer Pool 实例可以由多个 chunk 组成</p>
<ul>
<li>在系统启动时设置系统变量 <code>innodb_buffer_pool_instance</code> 可以指定 Buffer Pool 实例的个数，但是当 Buffer Pool 小于 1GB 时，设置多个实例时无效的</li>
<li>指定系统变量 <code>innodb_buffer_pool_chunk_size</code> 来改变 chunk 的大小，只能在启动时修改，运行中不能修改，而且该变量并不包含缓冲页的控制块的内存大小</li>
<li><code>innodb_buffer_pool_size</code> 必须是 <code>innodb_buffer_pool_chunk_size × innodb_buffer_pool_instance</code> 的倍数，默认值是 <code>128M × 16 = 2G</code>，Buffer Pool 必须是 2G 的整数倍，如果指定 5G，会自动调整成 6G</li>
<li>如果启动时 <code>chunk × instances</code> &gt; <code>pool_size</code>，那么 chunk 的值会自动设置为 <code>pool_size ÷ instances</code></li>
</ul>
<hr>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><h4 id="Change"><a href="#Change" class="headerlink" title="Change"></a>Change</h4><p>InnoDB 管理的 Buffer Pool 中有一块内存叫 Change Buffer 用来对<strong>增删改操作</strong>提供缓存，参数 <code>innodb_change_buffer_max_size </code> 来动态设置，设置为 50 时表示 Change Buffer 的大小最多只能占用 Buffer Pool 的 50%</p>
<ul>
<li>唯一索引的更新不能使用 Change Buffer，需要将数据页读入内存，判断没有冲突在写入</li>
<li>普通索引可以使用 Change Buffer，<strong>直接写入 Buffer 就结束</strong>，不用校验唯一性</li>
</ul>
<p>Change Buffer 并不是数据页，只是对操作的缓存，所以需要将 Change Buffer 中的操作应用到旧数据页，得到新的数据页（脏页）的过程称为 Merge</p>
<ul>
<li>触发时机：访问数据页时会触发 Merge、后台有定时线程进行 Merge、在数据库正常关闭（shutdown）的过程中也会触发</li>
<li>工作流程：首先从磁盘读入数据页到内存（因为 Buffer Pool 中不一定存在对应的数据页），从 Change Buffer 中找到对应的操作应用到数据页，得到新的数据页即为脏页，然后写入 redo log，等待刷脏即可</li>
</ul>
<p>说明：Change Buffer 中的记录，在事务提交时也会写入 redo log，所以是可以保证不丢失的</p>
<p>业务场景：</p>
<ul>
<li><p>对于<strong>写多读少</strong>的业务来说，页面在写完以后马上被访问到的概率比较小，此时 Change Buffer 的使用效果最好，常见的就是账单类、日志类的系统</p>
</li>
<li><p>一个业务的更新模式是写入后马上做查询，那么即使满足了条件，将更新先记录在 Change Buffer，但之后由于马上要访问这个数据页，会立即触发 Merge 过程，这样随机访问 IO 的次数不会减少，并且增加了 Change Buffer 的维护代价</p>
</li>
</ul>
<p>补充：Change Buffer 的前身是 Insert Buffer，只能对 Insert 操作优化，后来增加了 Update&#x2F;Delete 的支持，改为 Change Buffer</p>
<hr>
<h4 id="Net"><a href="#Net" class="headerlink" title="Net"></a>Net</h4><p>Server 层针对优化<strong>查询</strong>的内存为 Net Buffer，内存的大小是由参数 <code>net_buffer_length</code>定义，默认 16k，实现流程：</p>
<ul>
<li>获取一行数据写入 Net Buffer，重复获取直到 Net Buffer 写满，调用网络接口发出去</li>
<li>若发送成功就清空 Net Buffer，然后继续取下一行；若发送函数返回 EAGAIN 或 WSAEWOULDBLOCK，表示本地网络栈 <code>socket send buffer</code> 写满了，<strong>进入等待</strong>，直到网络栈重新可写再继续发送</li>
</ul>
<p>MySQL 采用的是边读边发的逻辑，因此对于数据量很大的查询来说，不会在 Server 端保存完整的结果集，如果客户端读结果不及时，会堵住 MySQL 的查询过程，但是<strong>不会把内存打爆导致 OOM</strong></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-查询内存优化.png" style="zoom:50%;">

<p>SHOW PROCESSLIST 获取线程信息后，处于 Sending to client 状态代表服务器端的网络栈写满，等待客户端接收数据</p>
<p>假设有一个业务的逻辑比较复杂，每读一行数据以后要处理很久的逻辑，就会导致客户端要过很久才会去取下一行数据，导致 MySQL 的阻塞，一直处于 Sending to client 的状态</p>
<p>解决方法：如果一个查询的返回结果很是很多，建议使用 mysql_store_result 这个接口，直接把查询结果保存到本地内存</p>
<p>参考文章：<a href="https://blog.csdn.net/qq_33589510/article/details/117673449">https://blog.csdn.net/qq_33589510/article/details/117673449</a></p>
<hr>
<h4 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h4><p>read_rnd_buffer 是 MySQL 的随机读缓冲区，当按任意顺序读取记录行时将分配一个随机读取缓冲区，进行排序查询时，MySQL 会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，大小是由 read_rnd_buffer_size 参数控制的</p>
<p><strong>Multi-Range Read 优化</strong>，将随机 IO 转化为顺序 IO 以降低查询过程中 IO 开销，因为大多数的数据都是按照主键递增顺序插入得到，所以按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能</p>
<p>二级索引为 a，聚簇索引为 id，优化回表流程：</p>
<ul>
<li>根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中</li>
<li>将 read_rnd_buffer 中的 id 进行<strong>递增排序</strong></li>
<li>排序后的 id 数组，依次回表到主键 id 索引中查记录，并作为结果返回</li>
</ul>
<p>说明：如果步骤 1 中 read_rnd_buffer 放满了，就会先执行步骤 2 和 3，然后清空 read_rnd_buffer，之后继续找索引 a 的下个记录</p>
<p>使用 MRR 优化需要设进行设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET optimizer_switch=&#x27;mrr_cost_based=off&#x27;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h4><p>MyISAM 存储引擎使用 key_buffer 缓存索引块，加速 MyISAM 索引的读写速度。对于 MyISAM 表的数据块没有特别的缓存机制，完全依赖于操作系统的 IO 缓存</p>
<ul>
<li><p>key_buffer_size：该变量决定 MyISAM 索引块缓存区的大小，直接影响到 MyISAM 表的存取效率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;key_buffer_size&#x27;;	-- 单位是字节</span><br></pre></td></tr></table></figure>

<p>在 MySQL 配置文件中设置该值，建议至少将1&#x2F;4可用内存分配给 key_buffer_size：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/mysql/my.cnf</span><br><span class="line">key_buffer_size=1024M</span><br></pre></td></tr></table></figure>
</li>
<li><p>read_buffer_size：如果需要经常顺序扫描 MyISAM 表，可以通过增大 read_buffer_size 的值来改善性能。但 read_buffer_size 是每个 Session 独占的，如果默认值设置太大，并发环境就会造成内存浪费</p>
</li>
<li><p>read_rnd_buffer_size：对于需要做排序的 MyISAM 表的查询，如带有 ORDER BY 子句的语句，适当增加该的值，可以改善此类的 SQL 的性能，但是 read_rnd_buffer_size 是每个 Session 独占的，如果默认值设置太大，就会造成内存浪费</p>
</li>
</ul>
<hr>
<h3 id="存储优化"><a href="#存储优化" class="headerlink" title="存储优化"></a>存储优化</h3><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><p>系统表空间是用来放系统信息的，比如数据字典什么的，对应的磁盘文件是 ibdata，数据表空间是一个个的表数据文件，对应的磁盘文件就是表名.ibd</p>
<p>表数据既可以存在共享表空间里，也可以是单独的文件，这个行为是由参数 innodb_file_per_table 控制的：</p>
<ul>
<li>OFF：表示表的数据放在系统共享表空间，也就是跟数据字典放在一起</li>
<li>ON ：表示每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中（默认）</li>
</ul>
<p>一个表单独存储为一个文件更容易管理，在不需要这个表时通过 drop table 命令，系统就会直接删除这个文件；如果是放在共享表空间中，即使表删掉了，空间也是不会回收的</p>
<hr>
<h4 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h4><p>MySQL 的数据删除就是移除掉某个记录后，该位置就被标记为<strong>可复用</strong>，如果有符合范围条件的数据可以插入到这里。符合范围条件的意思是假设删除记录 R4，之后要再插入一个 ID 在 300 和 600 之间的记录时，就会复用这个位置</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-删除数据.png" style="zoom:50%;">

<p>InnoDB 的数据是按页存储的如果删掉了一个数据页上的所有记录，整个数据页就可以被复用了，如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用</p>
<p>删除命令其实只是把记录的位置，或者<strong>数据页标记为了可复用，但磁盘文件的大小是不会变的</strong>，这些可以复用还没有被使用的空间，看起来就像是空洞，造成数据库的稀疏，因此需要进行紧凑处理</p>
<hr>
<h4 id="重建数据"><a href="#重建数据" class="headerlink" title="重建数据"></a>重建数据</h4><p>重建表就是按照主键 ID 递增的顺序，把数据一行一行地从旧表中读出来再插入到新表中，让数据更加紧凑。重建表时 MySQL 会自动完成转存数据、交换表名、删除旧表的操作，线上操作会阻塞大量的线程增删改查的操作</p>
<p>重建命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> A ENGINE<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure>

<p>工作流程：新建临时表 tmp_table B（在 Server 层创建的），把表 A 中的数据导入到表 B 中，操作完成后用表 B 替换表 A，完成重建</p>
<p>重建表的步骤需要 DDL 不是 Online 的，因为在导入数据的过程有新的数据要写入到表 A 的话，就会造成数据丢失</p>
<p>MySQL 5.6 版本开始引入的 <strong>Online DDL</strong>，重建表的命令默认执行此步骤：</p>
<ul>
<li>建立一个临时文件 tmp_file（InnoDB 创建），扫描表 A 主键的所有数据页</li>
<li>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中</li>
<li>生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态</li>
<li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3</li>
<li>用临时文件替换表 A 的数据文件</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-重建表.png" style="zoom: 67%;">

<p>Online DDL 操作会先获取 MDL 写锁，再退化成 MDL 读锁。但 MDL 写锁持有时间比较短，所以可以称为 Online； 而 MDL 读锁，不阻止数据增删查改，但会阻止其它线程修改表结构（可以对比 <code>ANALYZE TABLE t</code>  命令）</p>
<p>问题：重建表可以收缩表空间，但是执行指令后整体占用空间增大</p>
<p>原因：在重建表后 InnoDB 不会把整张表占满，每个页留了 1&#x2F;16 给后续的更新使用。表在未整理之前页已经占用 15&#x2F;16 以上，收缩之后需要保持数据占用空间在 15&#x2F;16，所以文件占用空间更大才能保持</p>
<p>注意：临时文件也要占用空间，如果空间不足会重建失败</p>
<hr>
<h4 id="原地置换"><a href="#原地置换" class="headerlink" title="原地置换"></a>原地置换</h4><p>DDL 中的临时表 tmp_table 是在 Server 层创建的，Online DDL 中的临时文件 tmp_file 是 InnoDB 在内部创建出来的，整个 DDL 过程都在 InnoDB 内部完成，对于 Server 层来说，没有把数据挪动到临时表，是一个原地操作，这就是 inplace</p>
<p>两者的关系：</p>
<ul>
<li>DDL 过程如果是 Online 的，就一定是 inplace 的</li>
<li>inplace 的 DDL，有可能不是 Online 的，截止到 MySQL 8.0，全文索引（FULLTEXT）和空间索引（SPATIAL）属于这种情况</li>
</ul>
<hr>
<h3 id="并发优化"><a href="#并发优化" class="headerlink" title="并发优化"></a>并发优化</h3><p>MySQL Server 是多线程结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。在 MySQL 中，控制并发连接和线程的主要参数：</p>
<ul>
<li><p>max_connections：控制允许连接到 MySQL 数据库的最大连接数，默认值是 151</p>
<p>如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这时可以考虑增大 max_connections 的值</p>
<p>MySQL 最大可支持的连接数取决于很多因素，包括操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度、期望的响应时间等。在 Linux 平台下，性能好的服务器，可以支持 500-1000 个连接，需要根据服务器性能进行评估设定</p>
</li>
<li><p>innodb_thread_concurrency：并发线程数，代表系统内同时运行的线程数量（已经被移除）</p>
</li>
<li><p>back_log：控制 MySQL 监听 TCP 端口时的积压请求栈的大小</p>
<p>如果 Mysql 的连接数达到 max_connections 时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即 back_log。如果等待连接的数量超过 back_log，将不被授予连接资源直接报错</p>
<p>5.6.6 版本之前默认值为 50，之后的版本默认为 <code>50 + (max_connections/5)</code>，但最大不超过900，如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大 back_log 的值</p>
</li>
<li><p>table_open_cache：控制所有 SQL 语句执行线程可打开表缓存的数量</p>
<p>在执行 SQL 语句时，每个执行线程至少要打开1个表缓存，该参数的值应该根据设置的最大连接数以及每个连接执行关联查询中涉及的表的最大数量来设定：<code>max_connections * N</code></p>
</li>
<li><p>thread_cache_size：可控制 MySQL 缓存客户服务线程的数量</p>
<p>为了加快连接数据库的速度，MySQL 会缓存一定数量的客户服务线程以备重用，池化思想</p>
</li>
<li><p>innodb_lock_wait_timeout：设置 InnoDB 事务等待行锁的时间，默认值是 50ms</p>
<p>对于需要快速反馈的业务系统，可以将行锁的等待时间调小，以避免事务被长时间挂起； 对于后台运行的批量处理程序来说，可以将行锁的等待时间调大，以避免发生大的回滚操作</p>
</li>
</ul>
<hr>
<h2 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h2><h3 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>事务（Transaction）是访问和更新数据库的程序执行单元；事务中可能包含一个或多个 SQL 语句，这些语句要么都执行，要么都不执行，作为一个关系型数据库，MySQL 支持事务。</p>
<p>单元中的每条 SQL 语句都相互依赖，形成一个整体</p>
<ul>
<li><p>如果某条 SQL 语句执行失败或者出现错误，那么整个单元就会回滚，撤回到事务最初的状态</p>
</li>
<li><p>如果单元中所有的 SQL 语句都执行成功，则事务就顺利执行</p>
</li>
</ul>
<p>事务的四大特征：ACID</p>
<ul>
<li>原子性 (atomicity)</li>
<li>一致性 (consistency)</li>
<li>隔离性 (isolaction)</li>
<li>持久性 (durability)</li>
</ul>
<p>事务的几种状态：</p>
<ul>
<li>活动的（active）：事务对应的数据库操作正在执行中</li>
<li>部分提交的（partially committed）：事务的最后一个操作执行完，但是内存还没刷新至磁盘</li>
<li>失败的（failed）：当事务处于活动状态或部分提交状态时，如果数据库遇到了错误或刷脏失败，或者用户主动停止当前的事务</li>
<li>中止的（aborted）：失败状态的事务回滚完成后的状态</li>
<li>提交的（committed）：当处于部分提交状态的事务刷脏成功，就处于提交状态</li>
</ul>
<hr>
<h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><p>事务管理的三个步骤</p>
<ol>
<li><p>开启事务：记录回滚点，并通知服务器，将要执行一组操作，要么同时成功、要么同时失败</p>
</li>
<li><p>执行 SQL 语句：执行具体的一条或多条 SQL 语句</p>
</li>
<li><p>结束事务（提交|回滚）</p>
<ul>
<li>提交：没出现问题，数据进行更新</li>
<li>回滚：出现问题，数据恢复到开启事务时的状态</li>
</ul>
</li>
</ol>
<p>事务操作：</p>
<ul>
<li><p>显式开启事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION [READ ONLY|READ WRITE|WITH CONSISTENT SNAPSHOT]; #可以跟一个或多个状态，最后的是一致性读</span><br><span class="line">BEGIN [WORK];</span><br></pre></td></tr></table></figure>

<p>说明：不填状态默认是读写事务</p>
</li>
<li><p>回滚事务，用来手动中止事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交事务，显示执行是手动提交，MySQL 默认为自动提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存点：在事务的执行过程中设置的还原点，调用 ROLLBACK 时可以指定回滚到哪个点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAVEPOINT point_name;						#设置保存点</span><br><span class="line">RELEASE point_name							#删除保存点</span><br><span class="line">ROLLBACK [WORK] TO [SAVEPOINT] point_name	#回滚至某个保存点，不填默认回滚到事务执行之前的状态</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作演示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 开启事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 张三给李四转账500元</span><br><span class="line">-- 1.张三账户-500</span><br><span class="line">UPDATE account SET money=money-500 WHERE NAME=&#x27;张三&#x27;;</span><br><span class="line">-- 2.李四账户+500</span><br><span class="line">UPDATE account SET money=money+500 WHERE NAME=&#x27;李四&#x27;;</span><br><span class="line"></span><br><span class="line">-- 回滚事务(出现问题)</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 提交事务(没出现问题)</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h4><p>提交方式的相关语法：</p>
<ul>
<li><p>查看事务提交方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@AUTOCOMMIT;  		-- 会话，1 代表自动提交    0 代表手动提交</span><br><span class="line">SELECT @@GLOBAL.AUTOCOMMIT;	-- 系统</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改事务提交方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @@AUTOCOMMIT=数字;	-- 系统</span><br><span class="line">SET AUTOCOMMIT=数字;		-- 会话</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>系统变量的操作</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] 变量名 <span class="operator">=</span> 值;					<span class="comment">-- 默认是会话</span></span><br><span class="line"><span class="keyword">SET</span> @@[(<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION).]变量名 <span class="operator">=</span> 值;				<span class="comment">-- 默认是系统</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] VARIABLES [<span class="keyword">LIKE</span> <span class="string">&#x27;变量%&#x27;</span>];	  <span class="comment">-- 默认查看会话内系统变量值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>工作原理：</p>
<ul>
<li>自动提交：如果没有 START TRANSACTION 显式地开始一个事务，那么<strong>每条 SQL 语句都会被当做一个事务执行提交操作</strong>；显式开启事务后，会在本次事务结束（提交或回滚）前暂时关闭自动提交</li>
<li>手动提交：不需要显式的开启事务，所有的 SQL 语句都在一个事务中，直到执行了提交或回滚，然后进入下一个事务</li>
<li>隐式提交：存在一些特殊的命令，在事务中执行了这些命令会马上<strong>强制执行 COMMIT 提交事务</strong><ul>
<li><strong>DDL 语句</strong> (CREATE&#x2F;DROP&#x2F;ALTER)、LOCK TABLES 语句、LOAD DATA 导入数据语句、主从复制语句等</li>
<li>当一个事务还没提交或回滚，显式的开启一个事务会隐式的提交上一个事务</li>
</ul>
</li>
</ul>
<hr>
<h4 id="事务-ID"><a href="#事务-ID" class="headerlink" title="事务 ID"></a>事务 ID</h4><p>事务在执行过程中对某个表执行了<strong>增删改操作或者创建表</strong>，就会为当前事务分配一个独一无二的事务 ID（对临时表并不会分配 ID），如果当前事务没有被分配 ID，默认是 0</p>
<p>说明：只读事务不能对普通的表进行增删改操作，但是可以对临时表增删改，读写事务可以对数据表执行增删改查操作</p>
<p>事务 ID 本质上就是一个数字，服务器在内存中维护一个全局变量：</p>
<ul>
<li>每当需要为某个事务分配 ID，就会把全局变量的值赋值给事务 ID，然后变量自增 1</li>
<li>每当变量值为 256 的倍数时，就将该变量的值刷新到系统表空间的 Max Trx ID 属性中，该属性占 8 字节</li>
<li>系统再次启动后，会读取表空间的 Max Trx ID 属性到内存，加上 256 后赋值给全局变量，因为关机时的事务 ID 可能并不是 256 的倍数，会比 Max Trx ID 大，所以需要加上 256 保持事务 ID 是一个<strong>递增的数字</strong></li>
</ul>
<p><strong>聚簇索引</strong>的行记录除了完整的数据，还会自动添加 trx_id、roll_pointer 隐藏列，如果表中没有主键并且没有非空唯一索引，也会添加一个 row_id 的隐藏列作为聚簇索引</p>
<hr>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><h4 id="四种级别"><a href="#四种级别" class="headerlink" title="四种级别"></a>四种级别</h4><p>事务的隔离级别：多个客户端操作时，各个客户端的事务之间应该是隔离的，<strong>不同的事务之间不该互相影响</strong>，而如果多个事务操作同一批数据时，则需要设置不同的隔离级别，否则就会产生问题。</p>
<p>隔离级别分类：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>名称</th>
<th>会引发的问题</th>
<th>数据库默认隔离级别</th>
</tr>
</thead>
<tbody><tr>
<td>Read Uncommitted</td>
<td>读未提交</td>
<td>脏读、不可重复读、幻读</td>
<td></td>
</tr>
<tr>
<td>Read Committed</td>
<td>读已提交</td>
<td>不可重复读、幻读</td>
<td>Oracle &#x2F; SQL Server</td>
</tr>
<tr>
<td>Repeatable Read</td>
<td>可重复读</td>
<td>幻读</td>
<td>MySQL</td>
</tr>
<tr>
<td>Serializable</td>
<td>可串行化</td>
<td>无</td>
<td></td>
</tr>
</tbody></table>
<p>一般来说，隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差</p>
<ul>
<li><p>脏写 (Dirty Write)：当两个或多个事务选择同一行，最初的事务修改的值被后面事务修改的值覆盖，所有的隔离级别都可以避免脏写（又叫丢失更新），因为有行锁</p>
</li>
<li><p>脏读 (Dirty Reads)：在一个事务处理过程中读取了另一个<strong>未提交</strong>的事务中修改过的数据</p>
</li>
<li><p>不可重复读 (Non-Repeatable Reads)：在一个事务处理过程中读取了另一个事务中修改并<strong>已提交</strong>的数据</p>
<blockquote>
<p>可重复读的意思是不管读几次，结果都一样，可以重复的读，可以理解为快照读，要读的数据集不会发生变化</p>
</blockquote>
</li>
<li><p>幻读 (Phantom Reads)：在事务中按某个条件先后两次查询数据库，后一次查询查到了前一次查询没有查到的行，<strong>数据条目</strong>发生了变化。比如查询某数据不存在，准备插入此记录，但执行插入时发现此记录已存在，无法插入</p>
</li>
</ul>
<p>隔离级别操作语法：</p>
<ul>
<li><p>查询数据库隔离级别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@TX_ISOLATION;			-- 会话</span><br><span class="line">SELECT @@GLOBAL.TX_ISOLATION;	-- 系统</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改数据库隔离级别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL 级别字符串;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h4><p>InnoDB 存储引擎支持事务，所以加锁分析是基于该存储引擎</p>
<ul>
<li><p>Read Uncommitted 级别，任何操作都不会加锁</p>
</li>
<li><p>Read Committed 级别，增删改操作会加写锁（行锁），读操作不加锁</p>
<p>在 Server 层过滤条件时发现不满足的记录会调用 unlock_row 方法释放该记录的行锁，保证最后只有满足条件的记录加锁，但是扫表过程中每条记录的<strong>加锁操作不能省略</strong>。所以对数据量很大的表做批量修改时，如果无法使用相应的索引（全表扫描），在 Server 过滤数据时就会特别慢，出现虽然没有修改某些行的数据，但是还是被锁住了的现象（锁表），这种情况同样适用于  RR</p>
</li>
<li><p>Repeatable Read 级别，增删改操作会加写锁，读操作不加锁。因为读写锁不兼容，<strong>加了读锁后其他事务就无法修改数据</strong>，影响了并发性能，为了保证隔离性和并发性，MySQL 通过 MVCC 解决了读写冲突。RR 级别下的锁有很多种，锁机制章节详解</p>
</li>
<li><p>Serializable 级别，读加共享锁，写加排他锁，读写互斥，使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差</p>
<ul>
<li>串行化：让所有事务按顺序单独执行，写操作会加写锁，读操作会加读锁</li>
<li>可串行化：让所有操作相同数据的事务顺序执行，通过加锁实现</li>
</ul>
</li>
</ul>
<p>参考文章：<a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">https://tech.meituan.com/2014/08/20/innodb-lock.html</a></p>
<hr>
<h3 id="原子特性"><a href="#原子特性" class="headerlink" title="原子特性"></a>原子特性</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>原子性是指事务是一个不可分割的工作单位，事务的操作如果成功就必须要完全应用到数据库，失败则不能对数据库有任何影响。比如事务中一个 SQL 语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态</p>
<p>InnoDB 存储引擎提供了两种事务日志：redo log（重做日志）和 undo log（回滚日志）</p>
<ul>
<li>redo log 用于保证事务持久性</li>
<li>undo log 用于保证事务原子性和隔离性</li>
</ul>
<p>undo log 属于逻辑日志，根据每行操作进行记录，记录了 SQL 执行相关的信息，用来回滚行记录到某个版本</p>
<p>当事务对数据库进行修改时，InnoDB 会先记录对应的 undo log，如果事务执行失败或调用了 rollback 导致事务回滚，InnoDB 会根据 undo log 的内容<strong>做与之前相反的操作</strong>：</p>
<ul>
<li><p>对于每个 insert，回滚时会执行 delete</p>
</li>
<li><p>对于每个 delete，回滚时会执行 insert</p>
</li>
<li><p>对于每个 update，回滚时会执行一个相反的 update，把数据修改回去</p>
</li>
</ul>
<p>参考文章：<a href="https://www.cnblogs.com/kismetv/p/10331633.html">https://www.cnblogs.com/kismetv/p/10331633.html</a></p>
<hr>
<h4 id="DML-解析"><a href="#DML-解析" class="headerlink" title="DML 解析"></a>DML 解析</h4><h5 id="INSERT-1"><a href="#INSERT-1" class="headerlink" title="INSERT"></a>INSERT</h5><p>乐观插入：当前数据页的剩余空间充足，直接将数据进行插入</p>
<p>悲观插入：当前数据页的剩余空间不足，需要进行页分裂，申请一个新的页面来插入数据，会造成更多的 redo log，undo log 影响不大</p>
<p>当向某个表插入一条记录，实际上需要向聚簇索引和所有二级索引都插入一条记录，但是 undo log <strong>只针对聚簇索引记录</strong>，在回滚时会根据聚簇索引去所有的二级索引进行回滚操作</p>
<p>roll_pointer 是一个指针，<strong>指向记录对应的 undo log 日志</strong>，一条记录就是一个数据行，行格式中的 roll_pointer 就指向 undo log</p>
<hr>
<h5 id="DELETE-1"><a href="#DELETE-1" class="headerlink" title="DELETE"></a>DELETE</h5><p>插入到页面中的记录会根据 next_record 属性组成一个单向链表，这个链表称为正常链表，被删除的记录也会通过 next_record 组成一个垃圾链表，该链表中所占用的存储空间可以被重新利用，并不会直接清除数据</p>
<p>在页面 Page Header 中，PAGE_FREE 属性指向垃圾链表的头节点，删除的工作过程：</p>
<ul>
<li><p>将要删除的记录的 delete_flag 位置为 1，其他不做修改，这个过程叫 <strong>delete mark</strong></p>
</li>
<li><p>在事务提交前，delete_flag &#x3D; 1 的记录一直都会处于中间状态</p>
</li>
<li><p>事务提交后，有专门的线程将 delete_flag &#x3D; 1 的记录从正常链表移除并加入垃圾链表，这个过程叫 <strong>purge</strong></p>
<p>purge 线程在执行删除操作时会创建一个 ReadView，根据事务的可见性移除数据（隔离特性部分详解）</p>
</li>
</ul>
<p>当有新插入的记录时，首先判断 PAGE_FREE 指向的头节点是否足够容纳新纪录：</p>
<ul>
<li>如果可以容纳新纪录，就会直接重用已删除的记录的存储空间，然后让 PAGE_FREE 指向垃圾链表的下一个节点</li>
<li>如果不能容纳新纪录，就直接向页面申请新的空间存储，并不会遍历垃圾链表</li>
</ul>
<p>重用已删除的记录空间，可能会造成空间碎片，当数据页容纳不了一条记录时，会判断将碎片空间加起来是否可以容纳，判断为真就会重新组织页内的记录：</p>
<ul>
<li>开辟一个临时页面，将页内记录一次插入到临时页面，此时临时页面时没有碎片的</li>
<li>把临时页面的内容复制到本页，这样就解放出了内存碎片，但是会耗费很大的性能资源</li>
</ul>
<hr>
<h5 id="UPDATE-1"><a href="#UPDATE-1" class="headerlink" title="UPDATE"></a>UPDATE</h5><p>执行 UPDATE 语句，对于更新主键和不更新主键有两种不同的处理方式</p>
<p>不更新主键的情况：</p>
<ul>
<li><p>就地更新（in-place update），如果更新后的列和更新前的列占用的存储空间一样大，就可以直接在原记录上修改</p>
</li>
<li><p>先删除旧纪录，再插入新纪录，这里的删除不是 delete mark，而是直接将记录加入垃圾链表，并且修改页面的相应的控制信息，执行删除的线程不是 purge，是执行更新的用户线程，插入新记录时可能造成页空间不足，从而导致页分裂</p>
</li>
</ul>
<p>更新主键的情况：</p>
<ul>
<li>将旧纪录进行 delete mark，在更新语句提交后由 purge 线程移入垃圾链表</li>
<li>根据更新的各列的值创建一条新纪录，插入到聚簇索引中</li>
</ul>
<p>在对一条记录修改前会<strong>将记录的隐藏列 trx_id 和 roll_pointer 的旧值记录到 undo log 对应的属性中</strong>，这样当前记录的 roll_pointer 指向当前 undo log 记录，当前 undo log 记录的 roll_pointer 指向旧的 undo log 记录，<strong>形成一个版本链</strong></p>
<p>UPDATE、DELETE 操作产生的 undo 日志会用于其他事务的 MVCC 操作，所以不能立即删除，INSERT 可以删除的原因是 MVCC 是对现有数据的快照</p>
<hr>
<h4 id="回滚日志"><a href="#回滚日志" class="headerlink" title="回滚日志"></a>回滚日志</h4><p>undo log 是采用段的方式来记录，Rollback Segement 称为回滚段，本质上就是一个类型是 Rollback Segement Header 的页面</p>
<p>每个回滚段中有 1024 个 undo slot，每个 slot 存放 undo 链表页面的头节点页号，每个链表对应一个叫 undo log segment 的段</p>
<ul>
<li>在以前老版本，只支持 1 个 Rollback Segement，只能记录 1024 个 undo log segment</li>
<li>MySQL5.5 开始支持 128 个 Rollback Segement，支持 128*1024 个 undo 操作</li>
</ul>
<p>工作流程：</p>
<ul>
<li><p>事务执行前需要到系统表空间第 5 号页面中分配一个回滚段（页），获取一个 Rollback Segement Header 页面的地址</p>
</li>
<li><p>回滚段页面有 1024 个 undo slot，首先去回滚段的两个 cached 链表获取缓存的 slot，缓存中没有就在回滚段页面中找一个可用的 undo slot 分配给当前事务</p>
</li>
<li><p>如果是缓存中获取的 slot，则该 slot 对应的 undo log segment 已经分配了，需要重新分配，然后从 undo log segment 中申请一个页面作为日志链表的头节点，并填入对应的 slot 中</p>
</li>
<li><p>每个事务 undo 日志在记录的时候<strong>占用两个 undo 页面的组成链表</strong>，分别为 insert undo 链表和 update undo 链表，链表的头节点页面为 first undo page 会包含一些管理信息，其他页面为 normal undo page</p>
<p>说明：事务执行过程的临时表也需要两个 undo 链表，不和普通表共用，这些链表并不是事务开始就分配，而是按需分配</p>
</li>
</ul>
<hr>
<h3 id="隔离特性"><a href="#隔离特性" class="headerlink" title="隔离特性"></a>隔离特性</h3><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><p>隔离性是指，事务内部的操作与其他事务是隔离的，多个并发事务之间要相互隔离，不能互相干扰</p>
<ul>
<li><p>严格的隔离性，对应了事务隔离级别中的 serializable，实际应用中对性能考虑很少使用可串行化</p>
</li>
<li><p>与原子性、持久性侧重于研究事务本身不同，隔离性研究的是<strong>不同事务</strong>之间的相互影响</p>
</li>
</ul>
<p>隔离性让并发情形下的事务之间互不干扰：</p>
<ul>
<li>一个事务的写操作对另一个事务的写操作（写写）：锁机制保证隔离性</li>
<li>一个事务的写操作对另一个事务的读操作（读写）：MVCC 保证隔离性</li>
</ul>
<p>锁机制：事务在修改数据之前，需要先获得相应的锁，获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁（详解见锁机制）</p>
<hr>
<h4 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h4><p>MVCC 全称 Multi-Version Concurrency Control，即多版本并发控制，用来<strong>解决读写冲突的无锁并发控制</strong>，可以在发生读写请求冲突时不用加锁解决，这个读是指的快照读（也叫一致性读或一致性无锁读），而不是当前读：</p>
<ul>
<li>快照读：实现基于 MVCC，因为是多版本并发，所以快照读读到的数据不一定是当前最新的数据，有可能是历史版本的数据</li>
<li>当前读：又叫加锁读，读取数据库记录是当前<strong>最新的版本</strong>（产生幻读、不可重复读），可以对读取的数据进行加锁，防止其他事务修改数据，是悲观锁的一种操作，读写操作加共享锁或者排他锁和串行化事务的隔离级别都是当前读</li>
</ul>
<p>数据库并发场景：</p>
<ul>
<li><p>读-读：不存在任何问题，也不需要并发控制</p>
</li>
<li><p>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</p>
</li>
<li><p>写-写：有线程安全问题，可能会存在脏写（丢失更新）问题</p>
</li>
</ul>
<p>MVCC 的优点：</p>
<ul>
<li>在并发读写数据库时，做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了并发读写的性能</li>
<li>可以解决脏读，不可重复读等事务隔离问题（加锁也能解决），但不能解决更新丢失问题（写锁会解决）</li>
</ul>
<p>提高读写和写写的并发性能：</p>
<ul>
<li>MVCC + 悲观锁：MVCC 解决读写冲突，悲观锁解决写写冲突</li>
<li>MVCC + 乐观锁：MVCC 解决读写冲突，乐观锁解决写写冲突</li>
</ul>
<p>参考文章：<a href="https://www.jianshu.com/p/8845ddca3b23">https://www.jianshu.com/p/8845ddca3b23</a></p>
<hr>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h5><p>实现原理主要是隐藏字段，undo日志，Read View 来实现的</p>
<p>InnoDB 存储引擎，数据库中的<strong>聚簇索引</strong>每行数据，除了自定义的字段，还有数据库隐式定义的字段：</p>
<ul>
<li>DB_TRX_ID：最近修改事务 ID，记录创建该数据或最后一次修改该数据的事务 ID</li>
<li>DB_ROLL_PTR：回滚指针，<strong>指向记录对应的 undo log 日志</strong>，undo log 中又指向上一个旧版本的 undo log</li>
<li>DB_ROW_ID：隐含的自增 ID（<strong>隐藏主键</strong>），如果数据表没有主键，InnoDB 会自动以 DB_ROW_ID 作为聚簇索引</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MVCC%E7%89%88%E6%9C%AC%E9%93%BE%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5.png"></p>
<hr>
<h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>undo log 是逻辑日志，记录的是每个事务对数据执行的操作，而不是记录的全部数据，要<strong>根据 undo log 逆推出以往事务的数据</strong></p>
<p>undo log 的作用：</p>
<ul>
<li>保证事务进行 rollback 时的原子性和一致性，当事务进行回滚的时候可以用 undo log 的数据进行恢复</li>
<li>用于 MVCC 快照读，通过读取 undo log 的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本</li>
</ul>
<p>undo log 主要分为两种：</p>
<ul>
<li><p>insert undo log：事务在 insert 新记录时产生的 undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p>
</li>
<li><p>update undo log：事务在进行 update 或 delete 时产生的 undo log，在事务回滚时需要，在快照读时也需要。不能随意删除，只有在当前读或事务回滚不涉及该日志时，对应的日志才会被 purge 线程统一清除</p>
</li>
</ul>
<p>每次对数据库记录进行改动，都会产生的新版本的 undo log，随着更新次数的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，把这个链表称之为<strong>版本链</strong>，版本链的头节点就是当前的最新的 undo log，链尾就是最早的旧 undo log</p>
<p>说明：因为 DELETE 删除记录，都是移动到垃圾链表中，不是真正的删除，所以才可以通过版本链访问原始数据</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MVCC版本链.png" style="zoom: 80%;">

<p>注意：undo 是逻辑日志，这里只是直观的展示出来</p>
<p>工作流程：</p>
<ul>
<li>有个事务插入 persion 表一条新记录，name 为 Jerry，age 为 24</li>
<li>事务 1 修改该行数据时，数据库会先对该行加排他锁，然后先记录 undo log，然后修改该行 name 为 Tom，并且修改隐藏字段的事务 ID 为当前事务 1 的 ID（默认为 1 之后递增），回滚指针指向拷贝到 undo log 的副本记录，事务提交后，释放锁</li>
<li>以此类推</li>
</ul>
<hr>
<h5 id="读视图"><a href="#读视图" class="headerlink" title="读视图"></a>读视图</h5><p>Read View 是事务进行读数据操作时产生的读视图，该事务执行快照读的那一刻会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的 ID，用来做可见性判断，根据视图判断当前事务能够看到哪个版本的数据</p>
<p>注意：这里的快照并不是把所有的数据拷贝一份副本，而是由 undo log 记录的逻辑日志，根据库中的数据进行计算出历史数据</p>
<p>工作流程：将版本链的头节点的事务 ID（最新数据事务 ID，大概率不是当前线程）DB_TRX_ID 取出来，与系统当前活跃事务的 ID 对比进行可见性分析，不可见就通过 DB_ROLL_PTR 回滚指针去取出 undo log 中的下一个 DB_TRX_ID 比较，直到找到最近的满足可见性的 DB_TRX_ID，该事务 ID 所在的旧记录就是当前事务能看见的最新的记录</p>
<p>Read View 几个属性：</p>
<ul>
<li>m_ids：生成 Read View 时当前系统中活跃的事务 id 列表（未提交的事务集合，当前事务也在其中）</li>
<li>min_trx_id：生成 Read View 时当前系统中活跃的最小的事务 id，也就是 m_ids 中的最小值（已提交的事务集合）</li>
<li>max_trx_id：生成 Read View 时当前系统应该分配给下一个事务的 id 值，m_ids 中的最大值加 1（未开始事务）</li>
<li>creator_trx_id：生成该 Read View 的事务的事务 id，就是判断该 id 的事务能读到什么数据</li>
</ul>
<p>creator 创建一个 Read View，进行可见性算法分析：（解决了读未提交）</p>
<ul>
<li><p>db_trx_id &#x3D;&#x3D; creator_trx_id：表示这个数据就是当前事务自己生成的，自己生成的数据自己肯定能看见，所以此数据对 creator 是可见的</p>
</li>
<li><p>db_trx_id &lt;  min_trx_id：该版本对应的事务 ID 小于 Read view 中的最小活跃事务 ID，则这个事务在当前事务之前就已经被提交了，对 creator 可见（因为比已提交的最大事务 ID 小的并不一定已经提交，所以应该判断是否在活跃事务列表）</p>
</li>
<li><p>db_trx_id &gt;&#x3D; max_trx_id：该版本对应的事务 ID 大于 Read view 中当前系统的最大事务 ID，则说明该数据是在当前 Read view 创建之后才产生的，对 creator 不可见</p>
</li>
<li><p>min_trx_id&lt;&#x3D; db_trx_id &lt; max_trx_id：判断 db_trx_id 是否在活跃事务列表 m_ids 中</p>
<ul>
<li>在列表中，说明该版本对应的事务正在运行，数据不能显示（<strong>不能读到未提交的数据</strong>）</li>
<li>不在列表中，说明该版本对应的事务已经被提交，数据可以显示（<strong>可以读到已经提交的数据</strong>）</li>
</ul>
</li>
</ul>
<hr>
<h5 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h5><p>表 user 数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span>		name		age</span><br><span class="line">1		张三		   18	</span><br></pre></td></tr></table></figure>

<p>Transaction 20：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;	-- 开启事务</span><br><span class="line">UPDATE user SET name = &#x27;李四&#x27; WHERE id = 1;</span><br><span class="line">UPDATE user SET name = &#x27;王五&#x27; WHERE id = 1;</span><br></pre></td></tr></table></figure>

<p>Transaction 60：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;	-- 开启事务</span><br><span class="line">-- 操作表的其他数据</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MVCC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B1.png"></p>
<p>ID 为 0 的事务创建 Read View：</p>
<ul>
<li>m_ids：20、60</li>
<li>min_trx_id：20</li>
<li>max_trx_id：61</li>
<li>creator_trx_id：0</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MVCC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B2.png"></p>
<p>只有红框部分才复合条件，所以只有张三对应的版本的数据可以被看到</p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1t5411u7Fg">https://www.bilibili.com/video/BV1t5411u7Fg</a></p>
<hr>
<h5 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h5><p>只有在聚簇索引中才有 trx_id 和 roll_pointer 的隐藏列，对于二级索引判断可见性的方式：</p>
<ul>
<li>二级索引页面的 Page Header 中有一个 PAGE_MAX_TRX_ID 属性，代表修改当前页面的最大的事务 ID，SELECT 语句访问某个二级索引时会判断 ReadView 的 min_trx_id 是否大于该属性，大于说明该页面的所有属性对 ReadView 可见</li>
<li>如果属性判断不可见，就需要利用二级索引获取主键值进行<strong>回表操作</strong>，得到聚簇索引后按照聚簇索引的可见性判断的方法操作</li>
</ul>
<hr>
<h4 id="RC-RR"><a href="#RC-RR" class="headerlink" title="RC RR"></a>RC RR</h4><p>Read View 用于支持 RC（Read Committed，读已提交）和 RR（Repeatable Read，可重复读）隔离级别的实现，所以 <strong>SELECT 在 RC 和 RR 隔离级别使用 MVCC 读取记录</strong></p>
<p>RR、RC 生成时机：</p>
<ul>
<li>RC 隔离级别下，每次读取数据前都会生成最新的 Read View（当前读）</li>
<li>RR 隔离级别下，在第一次数据读取时才会创建 Read View（快照读）</li>
</ul>
<p>RC、RR 级别下的 InnoDB 快照读区别</p>
<ul>
<li><p>RC 级别下，事务中每次快照读都会新生成一个 Read View，这就是在 RC 级别下的事务中可以看到别的事务提交的更新的原因</p>
</li>
<li><p>RR 级别下，某个事务的对某条记录的<strong>第一次快照读</strong>会创建一个 Read View， 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，使用的是同一个 Read View，所以一个事务的查询结果每次都是相同的</p>
<p>RR 级别下，通过 <code>START TRANSACTION WITH CONSISTENT SNAPSHOT</code> 开启事务，会在执行该语句后立刻生成一个 Read View，不是在执行第一条 SELECT 语句时生成（所以说 <code>START TRANSACTION</code> 并不是事务的起点，执行第一条语句才算起点）</p>
</li>
</ul>
<p>解决幻读问题：</p>
<ul>
<li><p>快照读：通过 MVCC 来进行控制的，在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，但是<strong>并不能完全避免幻读</strong></p>
<p>场景：RR 级别，T1 事务开启，创建 Read View，此时 T2 去 INSERT 新的一行然后提交，然后 T1 去 UPDATE 该行会发现更新成功，并且把这条新记录的 trx_id 变为当前的事务 id，所以对当前事务就是可见的。因为 <strong>Read View 并不能阻止事务去更新数据，更新数据都是先读后写并且是当前读</strong>，读取到的是最新版本的数据</p>
</li>
<li><p>当前读：通过 next-key 锁（行锁 + 间隙锁）来解决问题</p>
</li>
</ul>
<hr>
<h3 id="持久特性"><a href="#持久特性" class="headerlink" title="持久特性"></a>持久特性</h3><h4 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h4><p>持久性是指一个事务一旦被提交了，那么对数据库中数据的改变就是永久性的，接下来的其他操作或故障不应该对其有任何影响。</p>
<p>Buffer Pool 的使用提高了读写数据的效率，但是如果 MySQL 宕机，此时 Buffer Pool 中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证，所以引入了 redo log 日志：</p>
<ul>
<li>redo log <strong>记录数据页的物理修改</strong>，而不是某一行或某几行的修改，用来恢复提交后的数据页，只能<strong>恢复到最后一次提交</strong>的位置</li>
<li>redo log 采用的是 WAL（Write-ahead logging，<strong>预写式日志</strong>），所有修改要先写入日志，再更新到磁盘，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求</li>
<li>简单的 redo log 是纯粹的物理日志，复杂的 redo log 会存在物理日志和逻辑日志</li>
</ul>
<p>工作过程：MySQL 发生了宕机，InnoDB 会判断一个数据页在崩溃恢复时丢失了更新，就会将它读到内存，然后根据 redo log 内容更新内存，更新完成后，内存页变成脏页，然后进行刷脏</p>
<p>缓冲池的<strong>刷脏策略</strong>：</p>
<ul>
<li>redo log 文件是固定大小的，如果写满了就要擦除以前的记录，在擦除之前需要把对应的更新持久化到磁盘中</li>
<li>Buffer Pool 内存不足，需要淘汰部分数据页（LRU 链表尾部），如果淘汰的是脏页，就要先将脏页写到磁盘（要避免大事务）</li>
<li>系统空闲时，后台线程会自动进行刷脏（Flush 链表部分已经详解）</li>
<li>MySQL 正常关闭时，会把内存的脏页都刷新到磁盘上</li>
</ul>
<hr>
<h4 id="重做日志"><a href="#重做日志" class="headerlink" title="重做日志"></a>重做日志</h4><h5 id="日志缓冲"><a href="#日志缓冲" class="headerlink" title="日志缓冲"></a>日志缓冲</h5><p>服务器启动时会向操作系统申请一片连续内存空间作为 redo log buffer（重做日志缓冲区），可以通过 <code>innodb_log_buffer_size</code> 系统变量指定 redo log buffer 的大小，默认是 16MB</p>
<p>log buffer 被划分为若干 redo log block（块，类似数据页的概念），每个默认大小 512 字节，每个 block 由 12 字节的 log block head、496 字节的 log block body、4 字节的 log block trailer 组成</p>
<ul>
<li>当数据修改时，先修改 Change Buffer 中的数据，然后在 redo log buffer 记录这次操作，写入 log buffer 的过程是<strong>顺序写入</strong>的（先写入前面的 block，写满后继续写下一个）</li>
<li>log buffer 中有一个指针 buf_free，来标识该位置之前都是填满的 block，该位置之后都是空闲区域（<strong>碰撞指针</strong>）</li>
</ul>
<p>MySQL 规定对底层页面的一次原子访问称为一个 Mini-Transaction（MTR），比如在 B+ 树上插入一条数据就算一个 MTR</p>
<ul>
<li><p>一个事务包含若干个 MTR，一个 MTR 对应一组若干条 redo log，一组 redo log 是不可分割的，在进行数据恢复时也把一组 redo log 当作一个不可分割的整体处理</p>
</li>
<li><p>所以不是每生成一条 redo 日志就将其插入到 log buffer 中，而是一个 MTR 结束后<strong>将一组 redo 日志写入 log buffer</strong></p>
</li>
</ul>
<p>InnoDB 的 redo log 是<strong>固定大小</strong>的，redo 日志在磁盘中以文件组的形式存储，同一组中的每个文件大小一样格式一样，</p>
<ul>
<li><code>innodb_log_group_home_dir</code> 代表磁盘存储 redo log 的文件目录，默认是当前数据目录</li>
<li><code>innodb_log_file_size</code> 代表文件大小，默认 48M，<code>innodb_log_files_in_group</code> 代表文件个数，默认 2 最大 100，所以日志的文件大小为 <code>innodb_log_file_size * innodb_log_files_in_group</code></li>
</ul>
<p>redo 日志文件也是由若干个 512 字节的 block 组成，日志文件的前 2048 个字节（前 4 个 block）用来存储一些管理信息，以后的用来存储 log buffer 中的 block 镜像</p>
<p>注意：block 并不代表一组 redo log，一组日志可能占用不到一个 block 或者几个 block，依赖于 MTR 的大小</p>
<hr>
<h5 id="日志刷盘"><a href="#日志刷盘" class="headerlink" title="日志刷盘"></a>日志刷盘</h5><p>redo log 需要在事务提交时将日志写入磁盘，但是比将内存中的 Buffer Pool 修改的数据写入磁盘的速度快，原因：</p>
<ul>
<li>刷脏是随机 IO，因为每次修改的数据位置随机；redo log 和 binlog 都是<strong>顺序写</strong>，磁盘的顺序 IO 比随机 IO 速度要快</li>
<li>刷脏是以数据页（Page）为单位的，一个页上的一个小修改都要整页写入；redo log 中只包含真正需要写入的部分，减少无效 IO</li>
<li><strong>组提交机制</strong>，可以大幅度降低磁盘的 IO 消耗</li>
</ul>
<p>InnoDB 引擎会在适当的时候，把内存中 redo log buffer 持久化（fsync）到磁盘，具体的<strong>刷盘策略</strong>：</p>
<ul>
<li>在事务提交时需要进行刷盘，通过修改参数 <code>innodb_flush_log_at_trx_commit</code> 设置：<ul>
<li>0：表示当提交事务时，并不将缓冲区的 redo 日志写入磁盘，而是等待<strong>后台线程每秒刷新一次</strong></li>
<li>1：在事务提交时将缓冲区的 redo 日志<strong>同步写入</strong>到磁盘，保证一定会写入成功（默认值）</li>
<li>2：在事务提交时将缓冲区的 redo 日志异步写入到磁盘，不能保证提交时肯定会写入，只是有这个动作。日志已经在操作系统的缓存，如果操作系统没有宕机而 MySQL 宕机，也是可以恢复数据的</li>
</ul>
</li>
<li>写入 redo log buffer 的日志超过了总容量的一半，就会将日志刷入到磁盘文件，这会影响执行效率，所以开发中应<strong>避免大事务</strong></li>
<li>服务器关闭时</li>
<li>checkpoint 时（下小节详解）</li>
<li>并行的事务提交（组提交）时，会将将其他事务的 redo log 持久化到磁盘。假设事务 A 已经写入 redo log  buffer 中，这时另外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是 1，那么事务 B 要把 redo log buffer 里的日志全部持久化到磁盘，<strong>因为多个事务共用一个 redo log buffer</strong>，所以一次 fsync 可以刷盘多个事务的 redo log，提升了并发量</li>
</ul>
<p>服务器启动后 redo 磁盘空间不变，所以 redo 磁盘中的日志文件是被<strong>循环使用</strong>的，采用循环写数据的方式，写完尾部重新写头部，所以要确保头部 log 对应的修改已经持久化到磁盘</p>
<hr>
<h5 id="日志序号"><a href="#日志序号" class="headerlink" title="日志序号"></a>日志序号</h5><p>lsn (log sequence number) 代表已经写入的 redo 日志量、flushed_to_disk_lsn 指刷新到磁盘中的 redo 日志量，两者都是<strong>全局变量</strong>，如果两者的值相同，说明 log buffer 中所有的 redo 日志都已经持久化到磁盘</p>
<p>工作过程：写入 log buffer 数据时，buf_free 会进行偏移，偏移量就会加到 lsn 上</p>
<p>MTR 的执行过程中修改过的页对应的控制块会加到 Buffer Pool 的 flush 链表中，链表中脏页是按照第一次修改的时间进行排序的（头插），控制块中有两个指针用来记录脏页被修改的时间：</p>
<ul>
<li>oldest_modification：第一次修改 Buffer Pool 中某个缓冲页时，将修改该页的 MTR <strong>开始时</strong>对应的 lsn 值写入这个属性</li>
<li>newest_modification：每次修改页面，都将 MTR 结束时全局的 lsn 值写入这个属性，所以该值是该页面最后一次修改后的 lsn 值</li>
</ul>
<p>全局变量 checkpoint_lsn 表示<strong>当前系统可以被覆盖的 redo 日志总量</strong>，当 redo 日志对应的脏页已经被刷新到磁盘后，该文件空间就可以被覆盖重用，此时执行一次 checkpoint 来更新 checkpoint_lsn 的值存入管理信息（刷脏和执行一次 checkpoint 并不是同一个线程），该值的增量就代表磁盘文件中当前位置向后可以被覆盖的文件的量，所以该值是一直增大的</p>
<p><strong>checkpoint</strong>：从 flush 链表尾部中找出还未刷脏的页面，该页面是当前系统中最早被修改的脏页，该页面之前产生的脏页都已经刷脏，然后将该页 oldest_modification 值赋值给 checkpoint_lsn，因为 lsn 小于该值时产生的 redo 日志都可以被覆盖了</p>
<p>但是在系统忙碌时，后台线程的刷脏操作不能将脏页快速刷出，导致系统无法及时执行 checkpoint ，这时需要用户线程从 flush 链表中把最早修改的脏页刷新到磁盘中，然后执行 checkpoint</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">write pos ------- checkpoint_lsn <span class="comment">// 两值之间的部分表示可以写入的日志量，当 pos 追赶上 lsn 时必须执行 checkpoint</span></span><br></pre></td></tr></table></figure>

<p>使用命令可以查看当前 InnoDB 存储引擎各种 lsn 的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h5><p>恢复的起点：在从 redo 日志文件组的管理信息中获取最近发生 checkpoint 的信息，<strong>从 checkpoint_lsn 对应的日志文件开始恢复</strong></p>
<p>恢复的终点：扫描日志文件的 block，block 的头部记录着当前 block 使用了多少字节，填满的 block 总是 512 字节， 如果某个 block 不是 512 字节，说明该 block 就是需要恢复的最后一个 block</p>
<p>恢复的过程：按照 redo log 依次执行恢复数据，优化方式</p>
<ul>
<li>使用哈希表：根据 redo log 的 space id 和 page number 属性计算出哈希值，将对同一页面的修改放入同一个槽里，可以一次性完成对某页的恢复，<strong>避免了随机 IO</strong></li>
<li>跳过已经刷新到磁盘中的页面：数据页的 File Header 中的 FILE_PAGE_LSN 属性（类似 newest_modification）表示最近一次修改页面时的 lsn 值，数据页被刷新到磁盘中，那么该页 lsn 属性肯定大于 checkpoint_lsn</li>
</ul>
<p>参考书籍：<a href="https://book.douban.com/subject/35231266/">https://book.douban.com/subject/35231266/</a></p>
<hr>
<h4 id="工作流程-2"><a href="#工作流程-2" class="headerlink" title="工作流程"></a>工作流程</h4><h5 id="日志对比"><a href="#日志对比" class="headerlink" title="日志对比"></a>日志对比</h5><p>MySQL 中还存在 binlog（二进制日志）也可以记录写操作并用于数据的恢复，<strong>保证数据不丢失</strong>，二者的区别是：</p>
<ul>
<li>作用不同：redo log 是用于 crash recovery （故障恢复），保证 MySQL 宕机也不会影响持久性；binlog 是用于 point-in-time recovery 的，保证服务器可以基于时间点恢复数据，此外 binlog 还用于主从复制</li>
<li>层次不同：redo log 是 InnoDB 存储引擎实现的，而 binlog 是MySQL的 Server 层实现的，同时支持 InnoDB 和其他存储引擎</li>
<li>内容不同：redo log 是物理日志，内容基于磁盘的 Page；binlog 的内容是二进制的，根据 binlog_format 参数的不同，可能基于SQL 语句、基于数据本身或者二者的混合（日志部分详解）</li>
<li>写入时机不同：binlog 在事务提交时一次写入；redo log 的写入时机相对多元</li>
</ul>
<p>binlog 为什么不支持崩溃恢复？</p>
<ul>
<li>binlog 记录的是语句，并不记录数据页级的数据（哪个页改了哪些地方），所以没有能力恢复数据页</li>
<li>binlog 是追加写，保存全量的日志，没有标志确定从哪个点开始的数据是已经刷盘了，而 redo log 只要在 checkpoint_lsn 后面的就是没有刷盘的</li>
</ul>
<hr>
<h5 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h5><p>更新一条记录的过程：写之前一定先读</p>
<ul>
<li><p>在 B+ 树中定位到该记录，如果该记录所在的页面不在 Buffer Pool 里，先将其加载进内存</p>
</li>
<li><p>首先更新该记录对应的聚簇索引，更新聚簇索引记录时：</p>
<ul>
<li><p>更新记录前向 undo 页面写 undo 日志，由于这是更改页面，所以需要记录一下相应的 redo 日志</p>
<p>注意：修改 undo页面也是在<strong>修改页面</strong>，事务凡是修改页面就需要先记录相应的 redo 日志</p>
</li>
<li><p>然后<strong>先记录对应的的 redo 日志</strong>（等待 MTR 提交后写入 redo log buffer），<strong>最后进行真正的更新记录</strong></p>
</li>
</ul>
</li>
<li><p>更新其他的二级索引记录，不会再记录 undo log，只记录 redo log 到 buffer 中</p>
</li>
<li><p>在一条更新语句执行完成后（也就是将所有待更新记录都更新完了），就会开始记录该语句对应的 binlog 日志，此时记录的 binlog 并没有刷新到硬盘上，还在内存中，在事务提交时才会统一将该事务运行过程中的所有 binlog 日志刷新到硬盘</p>
</li>
</ul>
<p>假设表中有字段 id 和 a，存在一条 <code>id = 1, a = 2</code> 的记录，此时执行更新语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> a<span class="operator">=</span><span class="number">2</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>InnoDB 会真正的去执行把值修改成 (1,2) 这个操作，先加行锁，在去更新，并不会提前判断相同就不修改了</p>
<p>参考文章：<a href="https://mp.weixin.qq.com/s/wcJ2KisSaMnfP4nH5NYaQA">https://mp.weixin.qq.com/s/wcJ2KisSaMnfP4nH5NYaQA</a></p>
<hr>
<h5 id="两段提交"><a href="#两段提交" class="headerlink" title="两段提交"></a>两段提交</h5><p>当客户端执行 COMMIT 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，分两阶段来完成 XA 事务的提交：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-update的执行流程.png" style="zoom: 33%;">

<p>流程说明：执行引擎将这行新数据读入到内存中（Buffer Pool）后，先将此次更新操作记录到 redo log buffer 里，然后更新记录。最后将 redo log 刷盘后事务处于 prepare 状态，执行器会生成这个操作的 binlog，并<strong>把 binlog 写入磁盘</strong>，完成提交</p>
<p>两阶段：</p>
<ul>
<li>Prepare 阶段：存储引擎将该事务的 <strong>redo 日志刷盘</strong>，并且将本事务的状态设置为 PREPARE，代表执行完成随时可以提交事务</li>
<li>Commit 阶段：先将事务执行过程中产生的 binlog 刷新到硬盘，再执行存储引擎的提交工作，引擎把 redo log 改成提交状态</li>
</ul>
<p>redo log 和 binlog 都可以用于表示事务的提交状态，而<strong>两阶段提交就是让这两个状态保持逻辑上的一致</strong>，也有利于主从复制，更好的保持主从数据的一致性</p>
<hr>
<h5 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h5><p>系统崩溃前没有提交的事务的 redo log 可能已经刷盘（定时线程或者 checkpoint），怎么处理崩溃恢复？</p>
<p>工作流程：获取 undo 链表首节点页面的 undo segement header 中的 TRX_UNDO_STATE 属性，表示当前链表的事务属性，事务状态是活跃（未提交）的就全部回滚，如果是 PREPARE 状态，就需要根据 binlog 的状态进行判断：</p>
<ul>
<li>如果在时刻 A 发生了崩溃（crash），由于此时 binlog 还没完成，所以需要进行回滚</li>
<li>如果在时刻 B 发生了崩溃，redo log 和 binlog 有一个共<strong>同的数据字段叫 XID</strong>，崩溃恢复的时候，会按顺序扫描 redo log：<ul>
<li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，说明 binlog 也已经记录完整，直接从 redo log 恢复数据</li>
<li>如果 redo log 里面的事务只有 prepare，就根据 XID 去 binlog 中判断对应的事务是否存在并完整，如果完整可以恢复数据</li>
</ul>
</li>
</ul>
<p>判断一个事务的 binlog 是否完整的方法：</p>
<ul>
<li>statement 格式的 binlog，最后会有 COMMIT</li>
<li>row 格式的 binlog，最后会有一个 XID event</li>
<li>MySQL 5.6.2 版本以后，引入了 binlog-checksum 参数用来验证 binlog 内容的正确性（可能日志中间出错）</li>
</ul>
<p>参考文章：<a href="https://time.geekbang.org/column/article/73161">https://time.geekbang.org/column/article/73161</a></p>
<hr>
<h4 id="刷脏优化"><a href="#刷脏优化" class="headerlink" title="刷脏优化"></a>刷脏优化</h4><p>系统在进行刷脏时会占用一部分系统资源，会影响系统的性能，<strong>产生系统抖动</strong></p>
<ul>
<li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长</li>
<li>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的</li>
</ul>
<p>InnoDB 刷脏页的控制策略：</p>
<ul>
<li><code>innodb_io_capacity</code> 参数代表磁盘的读写能力，建议设置成磁盘的 IOPS（每秒的 IO 次数）</li>
<li>刷脏速度参考两个因素：脏页比例和 redo log 写盘速度<ul>
<li>参数 <code>innodb_max_dirty_pages_pct</code> 是脏页比例上限，默认值是 75%，InnoDB 会根据当前的脏页比例，算出一个范围在 0 到 100 之间的数字</li>
<li>InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，InnoDB 根据差值算出一个范围在 0 到 100 之间的数字</li>
<li>两者较大的值记为 R，执行引擎按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度</li>
</ul>
</li>
<li><code>innodb_flush_neighbors</code> 参数置为 1 代表控制刷脏时检查相邻的数据页，如果也是脏页就一起刷脏，并检查邻居的邻居，这个行为会一直蔓延直到不是脏页，在 MySQL 8.0 中该值的默认值是 0，不建议开启此功能</li>
</ul>
<hr>
<h3 id="一致特性"><a href="#一致特性" class="headerlink" title="一致特性"></a>一致特性</h3><p>一致性是指事务执行前后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</p>
<p>数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）</p>
<p>实现一致性的措施：</p>
<ul>
<li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证</li>
<li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等</li>
<li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致</li>
</ul>
<hr>
<h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><h3 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>锁机制：数据库为了保证数据的一致性，在共享的资源被并发访问时变得安全有序所设计的一种规则</p>
<p>利用 MVCC 性质进行读取的操作叫<strong>一致性读</strong>，读取数据前加锁的操作叫<strong>锁定读</strong></p>
<p>锁的分类：</p>
<ul>
<li>按操作分类：<ul>
<li>共享锁：也叫读锁。对同一份数据，多个事务读操作可以同时加锁而不互相影响 ，但不能修改数据</li>
<li>排他锁：也叫写锁。当前的操作没有完成前，会阻断其他操作的读取和写入</li>
</ul>
</li>
<li>按粒度分类：<ul>
<li>表级锁：会锁定整个表，开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低，偏向 MyISAM</li>
<li>行级锁：会锁定当前操作行，开销大，加锁慢；会出现死锁；锁定力度小，发生锁冲突概率低，并发度高，偏向 InnoDB</li>
<li>页级锁：锁的力度、发生冲突的概率和加锁开销介于表锁和行锁之间，会出现死锁，并发性能一般</li>
</ul>
</li>
<li>按使用方式分类：<ul>
<li>悲观锁：每次查询数据时都认为别人会修改，很悲观，所以查询时加锁</li>
<li>乐观锁：每次查询数据时都认为别人不会修改，很乐观，但是更新时会判断一下在此期间别人有没有去更新这个数据</li>
</ul>
</li>
</ul>
<ul>
<li><p>不同存储引擎支持的锁</p>
<table>
<thead>
<tr>
<th>存储引擎</th>
<th>表级锁</th>
<th>行级锁</th>
<th>页级锁</th>
</tr>
</thead>
<tbody><tr>
<td>MyISAM</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>InnoDB</td>
<td><strong>支持</strong></td>
<td><strong>支持</strong></td>
<td>不支持</td>
</tr>
<tr>
<td>MEMORY</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>BDB</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
</li>
</ul>
<p>从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如 Web 应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理系统</p>
<hr>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>对一条记录加锁的本质就是<strong>在内存中</strong>创建一个锁结构与之关联，结构包括</p>
<ul>
<li>事务信息：锁对应的事务信息，一个锁属于一个事务</li>
<li>索引信息：对于行级锁，需要记录加锁的记录属于哪个索引</li>
<li>表锁和行锁信息：表锁记录着锁定的表，行锁记录了 Space ID 所在表空间、Page Number 所在的页号、n_bits 使用了多少比特</li>
<li>type_mode：一个 32 比特的数，被分成 lock_mode、lock_type、rec_lock_type 三个部分<ul>
<li>lock_mode：锁模式，记录是共享锁、排他锁、意向锁之类</li>
<li>lock_type：代表表级锁还是行级锁</li>
<li>rec_lock_type：代表行锁的具体类型和 is_waiting 属性，is_waiting &#x3D; true 时表示当前事务尚未获取到锁，处于等待状态。事务获取锁后的锁结构是 is_waiting 为 false，释放锁时会检查是否与当前记录关联的锁结构，如果有就唤醒对应事务的线程</li>
</ul>
</li>
</ul>
<p>一个事务可能操作多条记录，为了节省内存，满足下面条件的锁使用同一个锁结构：</p>
<ul>
<li>在同一个事务中的加锁操作</li>
<li>被加锁的记录在同一个页面中</li>
<li>加锁的类型是一样的</li>
<li>加锁的状态是一样的</li>
</ul>
<hr>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)</p>
<p>MDL 叫元数据锁，主要用来保护 MySQL 内部对象的元数据，保证数据读写的正确性，<strong>当对一个表做增删改查的时候，加 MDL 读锁；当要对表做结构变更操作 DDL 的时候，加 MDL 写锁</strong>，两种锁不相互兼容，所以可以保证 DDL、DML、DQL 操作的安全</p>
<p>说明：DDL 操作执行前会隐式提交当前会话的事务，因为 DDL 一般会在若干个特殊事务中完成，开启特殊事务前需要提交到其他事务</p>
<p>MDL 锁的特性：</p>
<ul>
<li><p>MDL 锁不需要显式使用，在访问一个表的时候会被自动加上，在事务开始时申请，整个事务提交后释放（执行完单条语句不释放）</p>
</li>
<li><p>MDL 锁是在 Server 中实现，不是 InnoDB 存储引擎层能直接实现的锁</p>
</li>
<li><p>MDL 锁还能实现其他粒度级别的锁，比如全局锁、库级别的锁、表空间级别的锁</p>
</li>
</ul>
<p>FLUSH TABLES WITH READ LOCK 简称（FTWRL），全局读锁，让整个库处于只读状态，DDL DML 都被阻塞，工作流程：</p>
<ol>
<li>上全局读锁（lock_global_read_lock）</li>
<li>清理表缓存（close_cached_tables）</li>
<li>上全局 COMMIT 锁（make_global_read_lock_block_commit）</li>
</ol>
<p>该命令主要用于备份工具做<strong>一致性备份</strong>，由于 FTWRL 需要持有两把全局的 MDL 锁，并且还要关闭所有表对象，因此杀伤性很大</p>
<hr>
<h3 id="MyISAM-1"><a href="#MyISAM-1" class="headerlink" title="MyISAM"></a>MyISAM</h3><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>MyISAM 存储引擎只支持表锁，这也是 MySQL 开始几个版本中唯一支持的锁类型</p>
<p>MyISAM 引擎在执行查询语句之前，会<strong>自动</strong>给涉及到的所有表加读锁，在执行增删改之前，会<strong>自动</strong>给涉及的表加写锁，这个过程并不需要用户干预，所以用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁</p>
<ul>
<li><p>加锁命令：（对 InnoDB 存储引擎也适用）</p>
<p>读锁：所有连接只能读取数据，不能修改</p>
<p>写锁：其他连接不能查询和修改数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 读锁</span><br><span class="line">LOCK TABLE table_name READ;</span><br><span class="line"></span><br><span class="line">-- 写锁</span><br><span class="line">LOCK TABLE table_name WRITE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解锁命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 将当前会话所有的表进行解锁</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>锁的兼容性：</p>
<ul>
<li>对 MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求</li>
<li>对 MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作</li>
</ul>
<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 锁的兼容性.png)</p>
<p>锁调度：<strong>MyISAM 的读写锁调度是写优先</strong>，因为写锁后其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞，所以 MyISAM 不适合做写为主的表的存储引擎</p>
<hr>
<h4 id="锁操作"><a href="#锁操作" class="headerlink" title="锁操作"></a>锁操作</h4><h5 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h5><p>两个客户端操作 Client 1和 Client 2，简化为 C1、C2</p>
<ul>
<li><p>数据准备：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tb_book` (</span><br><span class="line">  `id` INT(11) AUTO_INCREMENT,</span><br><span class="line">  `name` VARCHAR(50) DEFAULT NULL,</span><br><span class="line">  `publish_time` DATE DEFAULT NULL,</span><br><span class="line">  `status` CHAR(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=MYISAM DEFAULT CHARSET=utf8 ;</span><br><span class="line"></span><br><span class="line">INSERT INTO tb_book (id, NAME, publish_time, STATUS) VALUES(NULL,&#x27;java编程思想&#x27;,&#x27;2088-08-01&#x27;,&#x27;1&#x27;);</span><br><span class="line">INSERT INTO tb_book (id, NAME, publish_time, STATUS) VALUES(NULL,&#x27;mysql编程思想&#x27;,&#x27;2088-08-08&#x27;,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>C1、C2 加读锁，同时查询可以正常查询出数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCK TABLE tb_book READ;	-- C1、C2</span><br><span class="line">SELECT * FROM tb_book;		-- C1、C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 读锁1.png)</p>
</li>
<li><p>C1 加读锁，C1、C2 查询未锁定的表，C1 报错，C2 正常查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCK TABLE tb_book READ;	-- C1</span><br><span class="line">SELECT * FROM tb_user;		-- C1、C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 读锁2.png)</p>
<p>C1、C2 执行插入操作，C1 报错，C2 等待获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb_book VALUES(NULL,&#x27;Spring高级&#x27;,&#x27;2088-01-01&#x27;,&#x27;1&#x27;);	-- C1、C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 读锁3.png)</p>
<p>当在 C1 中释放锁指令 UNLOCK TABLES，C2 中的 INSERT 语句立即执行</p>
</li>
</ul>
<hr>
<h5 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h5><p>两个客户端操作 Client 1和 Client 2，简化为 C1、C2</p>
<ul>
<li><p>C1 加写锁，C1、C2查询表，C1 正常查询，C2 需要等待</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCK TABLE tb_book WRITE;	-- C1</span><br><span class="line">SELECT * FROM tb_book;		-- C1、C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 写锁1.png)</p>
<p>当在 C1 中释放锁指令 UNLOCK TABLES，C2 中的 SELECT 语句立即执行</p>
</li>
<li><p>C1、C2 同时加写锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCK TABLE tb_book WRITE;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 写锁2.png)</p>
</li>
<li><p>C1 加写锁，C1、C2查询未锁定的表，C1 报错，C2 正常查询</p>
</li>
</ul>
<hr>
<h4 id="锁状态"><a href="#锁状态" class="headerlink" title="锁状态"></a>锁状态</h4><ul>
<li><p>查看锁竞争：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW OPEN TABLES;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E9%94%81%E4%BA%89%E7%94%A8%E6%83%85%E5%86%B5%E6%9F%A5%E7%9C%8B1.png"></p>
<p>In_user：表当前被查询使用的次数，如果该数为零，则表是打开的，但是当前没有被使用</p>
<p>Name_locked：表名称是否被锁定，名称锁定用于取消表或对表进行重命名等操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCK TABLE tb_book READ;	-- 执行命令</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E9%94%81%E4%BA%89%E7%94%A8%E6%83%85%E5%86%B5%E6%9F%A5%E7%9C%8B2.png"></p>
</li>
<li><p>查看锁状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Table_locks%&#x27;;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-MyISAM</a> 锁状态.png)</p>
<p>Table_locks_immediate：指的是能立即获得表级锁的次数，每立即获取锁，值加 1</p>
<p>Table_locks_waited：指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加 1，此值高说明存在着较为严重的表级锁争用情况</p>
</li>
</ul>
<hr>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><h5 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h5><p>InnoDB 与 MyISAM 的最大不同有两点：一是支持事务；二是采用了行级锁，<strong>InnoDB 同时支持表锁和行锁</strong></p>
<p>行级锁，也称为记录锁（Record Lock），InnoDB  实现了以下两种类型的行锁：</p>
<ul>
<li>共享锁 (S)：又称为读锁，简称 S 锁，多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改</li>
<li>排他锁 (X)：又称为写锁，简称 X 锁，不能与其他锁并存，获取排他锁的事务是可以对数据读取和修改</li>
</ul>
<p>RR 隔离界别下，对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会<strong>自动给涉及数据集加排他锁</strong>（行锁），在 commit 时自动释放；对于普通 SELECT 语句，不会加任何锁（只是针对 InnoDB 层来说的，因为在 Server 层会<strong>加 MDL 读锁</strong>），通过 MVCC 防止并发冲突</p>
<p>在事务中加的锁，并不是不需要了就释放，而是在事务中止或提交时自动释放，这个就是<strong>两阶段锁协议</strong>。所以一般将更新共享资源（并发高）的 SQL 放到事务的最后执行，可以让其他线程尽量的减少等待时间</p>
<p>锁的兼容性：</p>
<ul>
<li>共享锁和共享锁     兼容</li>
<li>共享锁和排他锁     冲突</li>
<li>排他锁和排他锁     冲突</li>
<li>排他锁和共享锁     冲突</li>
</ul>
<p>显式给数据集加共享锁或排他锁：<strong>加锁读就是当前读，读取的是最新数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE	-- 共享锁</span><br><span class="line">SELECT * FROM table_name WHERE ... FOR UPDATE			-- 排他锁</span><br></pre></td></tr></table></figure>

<p>注意：<strong>锁默认会锁聚簇索引（锁就是加在索引上）</strong>，但是当使用覆盖索引时，加共享锁只锁二级索引，不锁聚簇索引</p>
<hr>
<h5 id="锁操作-1"><a href="#锁操作-1" class="headerlink" title="锁操作"></a>锁操作</h5><p>两个客户端操作 Client 1和 Client 2，简化为 C1、C2</p>
<ul>
<li><p>环境准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_innodb_lock(</span><br><span class="line">	id INT(11),</span><br><span class="line">	name VARCHAR(16),</span><br><span class="line">	sex VARCHAR(1)</span><br><span class="line">)ENGINE = INNODB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO test_innodb_lock VALUES(1,&#x27;100&#x27;,&#x27;1&#x27;);</span><br><span class="line">-- ..........</span><br><span class="line"></span><br><span class="line">CREATE INDEX idx_test_innodb_lock_id ON test_innodb_lock(id);</span><br><span class="line">CREATE INDEX idx_test_innodb_lock_name ON test_innodb_lock(name);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭自动提交功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET AUTOCOMMIT=0;	-- C1、C2</span><br></pre></td></tr></table></figure>

<p>正常查询数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM test_innodb_lock;	-- C1、C2</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询 id 为 3 的数据，正常查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM test_innodb_lock WHERE id=3;	-- C1、C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁操作1.png)</p>
</li>
<li><p>C1 更新 id 为 3 的数据，但不提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET name=&#x27;300&#x27; WHERE id=3;	-- C1</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁操作2.png)</p>
<p>C2 查询不到 C1 修改的数据，因为隔离界别为 REPEATABLE READ，C1 提交事务，C2 查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMIT;	-- C1</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁操作3.png)</p>
<p>提交后仍然查询不到 C1 修改的数据，因为隔离级别可以防止脏读、不可重复读，所以 C2 需要提交才可以查询到其他事务对数据的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMIT;	-- C2</span><br><span class="line">SELECT * FROM test_innodb_lock WHERE id=3;	-- C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁操作4.png)</p>
</li>
<li><p>C1 更新 id 为 3 的数据，但不提交，C2 也更新 id 为 3 的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET name=&#x27;3&#x27; WHERE id=3;	-- C1</span><br><span class="line">UPDATE test_innodb_lock SET name=&#x27;30&#x27; WHERE id=3;	-- C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁操作5.png)</p>
<p>当 C1 提交，C2 直接解除阻塞，直接更新</p>
</li>
<li><p>操作不同行的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET name=&#x27;10&#x27; WHERE id=1;	-- C1</span><br><span class="line">UPDATE test_innodb_lock SET name=&#x27;30&#x27; WHERE id=3;	-- C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁操作6.png)</p>
<p>由于 C1、C2 操作的不同行，获取不同的行锁，所以都可以正常获取行锁</p>
</li>
</ul>
<hr>
<h4 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h4><h5 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h5><p>InnoDB 会对间隙（GAP）进行加锁，就是间隙锁 （RR 隔离级别下才有该锁）。间隙锁之间不存在冲突关系，<strong>多个事务可以同时对一个间隙加锁</strong>，但是间隙锁会阻止往这个间隙中插入一个记录的操作</p>
<p>InnoDB 加锁的基本单位是 next-key lock，该锁是行锁和 gap lock 的组合（X or S 锁），但是加锁过程是分为间隙锁和行锁两段执行</p>
<ul>
<li>可以<strong>保护当前记录和前面的间隙</strong>，遵循左开右闭原则，单纯的是间隙锁左开右开</li>
<li>假设有 10、11、13，那么可能的间隙锁包括：(负无穷,10]、(10,11]、(11,13]、(13,正无穷)</li>
</ul>
<p>几种索引的加锁情况：</p>
<ul>
<li>唯一索引加锁在值存在时是行锁，next-key lock 会退化为行锁，值不存在会变成间隙锁</li>
<li>普通索引加锁会继续向右遍历到不满足条件的值为止，next-key lock 退化为间隙锁</li>
<li>范围查询无论是否是唯一索引，都需要访问到不满足条件的第一个值为止</li>
<li>对于联合索引且是唯一索引，如果 where 条件只包括联合索引的一部分，那么会加间隙锁</li>
</ul>
<p>间隙锁优点：RR 级别下间隙锁可以解决事务的一部分的<strong>幻读问题</strong>，通过对间隙加锁，可以防止读取过程中数据条目发生变化。一部分的意思是不会对全部间隙加锁，只能加锁一部分的间隙</p>
<p>间隙锁危害：</p>
<ul>
<li>当锁定一个范围的键值后，即使某些不存在的键值也会被无辜的锁定，造成在锁定的时候无法插入锁定键值范围内的任何数据，在某些场景下这可能会对性能造成很大的危害，影响并发度</li>
<li>事务 A B 同时锁住一个间隙后，A 往当前间隙插入数据时会被 B 的间隙锁阻塞，B 也执行插入间隙数据的操作时就会<strong>产生死锁</strong></li>
</ul>
<p>现场演示：</p>
<ul>
<li><p>关闭自动提交功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET AUTOCOMMIT=0;	-- C1、C2</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询数据表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM test_innodb_lock;</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 间隙锁1.png)</p>
</li>
<li><p>C1 根据 id 范围更新数据，C2 插入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET name=&#x27;8888&#x27; WHERE id &lt; 4;	-- C1</span><br><span class="line">INSERT INTO test_innodb_lock VALUES(2,&#x27;200&#x27;,&#x27;2&#x27;);		-- C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 间隙锁2.png)</p>
<p>出现间隙锁，C2 被阻塞，等待 C1 提交事务后才能更新</p>
</li>
</ul>
<hr>
<h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p>InnoDB 为了支持多粒度的加锁，允许行锁和表锁同时存在，支持在不同粒度上的加锁操作，InnoDB 增加了意向锁（Intention Lock）</p>
<p>意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁，意向锁分为两种：</p>
<ul>
<li>意向共享锁（IS）：事务有意向对表加共享锁</li>
<li>意向排他锁（IX）：事务有意向对表加排他锁</li>
</ul>
<p><strong>IX，IS 是表级锁</strong>，不会和行级的 X，S 锁发生冲突，意向锁是在加表级锁之前添加，为了在加表级锁时可以快速判断表中是否有记录被上锁，比如向一个表添加表级 X 锁的时：</p>
<ul>
<li>没有意向锁，则需要遍历整个表判断是否有锁定的记录</li>
<li>有了意向锁，首先判断是否存在意向锁，然后判断该意向锁与即将添加的表级锁是否兼容即可，因为意向锁的存在代表有表级锁的存在或者即将有表级锁的存在</li>
</ul>
<p>兼容性如下所示：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%84%8F%E5%90%91%E9%94%81%E5%85%BC%E5%AE%B9%E6%80%A7.png"></p>
<p><strong>插入意向锁</strong> Insert Intention Lock 是在插入一行记录操作之前设置的一种间隙锁，是行级锁</p>
<p>插入意向锁释放了一种插入信号，即多个事务在相同的索引间隙插入时如果不是插入相同的间隙位置就不需要互相等待。假设某列有索引，只要两个事务插入位置不同，如事务 A 插入 3，事务 B 插入 4，那么就可以同时插入</p>
<hr>
<h5 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h5><p>系统会自动给 AUTO_INCREMENT 修饰的列进行递增赋值，实现方式：</p>
<ul>
<li>AUTO_INC 锁：表级锁，执行插入语句时会自动添加，在该语句执行完成后释放，并不是事务结束</li>
<li>轻量级锁：为插入语句生成 AUTO_INCREMENT 修饰的列时获取该锁，生成以后释放掉，不需要等到插入语句执行完后释放</li>
</ul>
<p>系统变量 <code>innodb_autoinc_lock_mode</code> 控制采取哪种方式：</p>
<ul>
<li>0：全部采用 AUTO_INC 锁</li>
<li>1：全部采用轻量级锁</li>
<li>2：混合使用，在插入记录的数量确定时采用轻量级锁，不确定时采用 AUTO_INC 锁</li>
</ul>
<hr>
<h5 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h5><p>一般情况下 INSERT 语句是不需要在内存中生成锁结构的，会进行隐式的加锁，保护的是插入后的安全</p>
<p>注意：如果插入的间隙被其他事务加了间隙锁，此次插入会被阻塞，并在该间隙插入一个插入意向锁</p>
<ul>
<li>聚簇索引：索引记录有 trx_id 隐藏列，表示最后改动该记录的事务 id，插入数据后事务 id 就是当前事务。其他事务想获取该记录的锁时会判断当前记录的事务 id 是否是活跃的，如果不是就可以正常加锁；如果是就创建一个 X 的锁结构，该锁的 is_waiting 是 false，为自己的事务创建一个锁结构，is_waiting 是 true（类似 Java 中的锁升级）</li>
<li>二级索引：获取数据页 Page Header 中的 PAGE_MAX_TRX_ID 属性，代表修改当前页面的最大的事务 ID，如果小于当前活跃的最小事务 id，就证明插入该数据的事务已经提交，否则就需要获取到主键值进行回表操作</li>
</ul>
<p>隐式锁起到了延迟生成锁的效果，如果其他事务与隐式锁没有冲突，就可以避免锁结构的生成，节省了内存资源</p>
<p>INSERT 在两种情况下会生成锁结构：</p>
<ul>
<li><p>重复键：在插入主键或唯一二级索引时遇到重复的键值会报错，在报错前需要对对应的聚簇索引进行加锁</p>
<ul>
<li>隔离级别 &lt;&#x3D; Read Uncommitted，加 S 型 Record Lock</li>
<li>隔离级别 &gt;&#x3D; Repeatable Read，加 S 型 next_key 锁</li>
</ul>
</li>
<li><p>外键检查：如果待插入的记录在父表中可以找到，会对父表的记录加 S 型 Record Lock。如果待插入的记录在父表中找不到</p>
<ul>
<li>隔离级别 &lt;&#x3D; Read Committed，不加锁</li>
<li>隔离级别 &gt;&#x3D; Repeatable Read，加间隙锁</li>
</ul>
</li>
</ul>
<hr>
<h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><h5 id="优化锁"><a href="#优化锁" class="headerlink" title="优化锁"></a>优化锁</h5><p>InnoDB 存储引擎实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高，但是在整体并发处理能力方面要远远优于 MyISAM 的表锁，当系统并发量较高的时候，InnoDB 的整体性能远远好于 MyISAM</p>
<p>但是使用不当可能会让 InnoDB 的整体性能表现不仅不能比 MyISAM 高，甚至可能会更差</p>
<p>优化建议：</p>
<ul>
<li>尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁</li>
<li>合理设计索引，尽量缩小锁的范围</li>
<li>尽可能减少索引条件及索引范围，避免间隙锁</li>
<li>尽量控制事务大小，减少锁定资源量和时间长度</li>
<li>尽可使用低级别事务隔离（需要业务层面满足需求）</li>
</ul>
<hr>
<h5 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h5><p>索引失效造成<strong>行锁升级为表锁</strong>，不通过索引检索数据，全局扫描的过程中 InnoDB 会将对表中的所有记录加锁，实际效果和<strong>表锁</strong>一样，实际开发过程应避免出现索引失效的状况</p>
<ul>
<li><p>查看当前表的索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM test_innodb_lock;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭自动提交功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET AUTOCOMMIT=0;	-- C1、C2</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行更新语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET sex=&#x27;2&#x27; WHERE name=10;	-- C1</span><br><span class="line">UPDATE test_innodb_lock SET sex=&#x27;2&#x27; WHERE id=3;		-- C2</span><br></pre></td></tr></table></figure>

<p>![](<a href="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB">https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB</a> 锁升级.png)</p>
<p>索引失效：执行更新时 name 字段为 varchar 类型，造成索引失效，最终行锁变为表锁</p>
</li>
</ul>
<hr>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>不同事务由于互相持有对方需要的锁而导致事务都无法继续执行的情况称为死锁</p>
<p>死锁情况：线程 A 修改了 id &#x3D; 1 的数据，请求修改 id &#x3D; 2 的数据，线程 B 修改了 id &#x3D; 2 的数据，请求修改 id &#x3D; 1 的数据，产生死锁</p>
<p>解决策略：</p>
<ul>
<li><p>直接进入等待直到超时，超时时间可以通过参数 innodb_lock_wait_timeout 来设置，默认 50 秒，但是时间的设置不好控制，超时可能不是因为死锁，而是因为事务处理比较慢，所以一般不采取该方式</p>
</li>
<li><p>主动死锁检测，发现死锁后<strong>主动回滚死锁链条中较小的一个事务</strong>，让其他事务得以继续执行，将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启该功能（事务较小的意思就是事务执行过程中插入、删除、更新的记录条数）</p>
<p>死锁检测并不是每个语句都要检测，只有在加锁访问的行上已经有锁时，当前事务被阻塞了才会检测，也是从当前事务开始进行检测</p>
</li>
</ul>
<p>通过执行 <code>SHOW ENGINE INNODB STATUS</code> 可以查看最近发生的一次死循环，全局系统变量 <code>innodb_print_all_deadlocks</code> 设置为 on，就可以将每个死锁信息都记录在 MySQL 错误日志中</p>
<p>死锁一般是行级锁，当表锁发生死锁时，会在事务中访问其他表时<strong>直接报错</strong>，破坏了持有并等待的死锁条件</p>
<hr>
<h4 id="锁状态-1"><a href="#锁状态-1" class="headerlink" title="锁状态"></a>锁状态</h4><p>查看锁信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;innodb_row_lock%&#x27;;</span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB 锁争用.png" style="zoom: 80%;">

<p>参数说明：</p>
<ul>
<li><p>Innodb_row_lock_current_waits：当前正在等待锁定的数量</p>
</li>
<li><p>Innodb_row_lock_time：从系统启动到现在锁定总时间长度</p>
</li>
<li><p>Innodb_row_lock_time_avg：每次等待所花平均时长</p>
</li>
<li><p>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间</p>
</li>
<li><p>Innodb_row_lock_waits：系统启动后到现在总共等待的次数</p>
</li>
</ul>
<p>当等待的次数很高，而且每次等待的时长也不短的时候，就需要分析系统中为什么会有如此多的等待，然后根据分析结果制定优化计划</p>
<p>查看锁状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.innodb_locks;	#锁的概况</span><br><span class="line">SHOW ENGINE INNODB STATUS\G; #InnoDB整体状态，其中包括锁的情况</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-InnoDB%E6%9F%A5%E7%9C%8B%E9%94%81%E7%8A%B6%E6%80%81.png"></p>
<p>lock_id 是锁 id；lock_trx_id 为事务 id；lock_mode 为 X 代表排它锁（写锁）；lock_type 为 RECORD 代表锁为行锁（记录锁）</p>
<hr>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>悲观锁：在整个数据处理过程中，将数据处于锁定状态，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据，修改删除数据时也加锁，其它事务同样无法读取这些数据</p>
<p>悲观锁和乐观锁使用前提：</p>
<ul>
<li>对于读的操作远多于写的操作的时候，一个更新操作加锁会阻塞所有的读取操作，降低了吞吐量，最后需要释放锁，锁是需要一些开销的，这时候可以选择乐观锁</li>
<li>如果是读写比例差距不是非常大或者系统没有响应不及时，吞吐量瓶颈的问题，那就不要去使用乐观锁，它增加了复杂度，也带来了业务额外的风险，这时候可以选择悲观锁</li>
</ul>
<p>乐观锁的实现方式：就是 CAS，比较并交换</p>
<ul>
<li><p>版本号</p>
<ol>
<li><p>给数据表中添加一个 version 列，每次更新后都将这个列的值加 1</p>
</li>
<li><p>读取数据时，将版本号读取出来，在执行更新的时候，比较版本号</p>
</li>
<li><p>如果相同则执行更新，如果不相同，说明此条数据已经发生了变化</p>
</li>
<li><p>用户自行根据这个通知来决定怎么处理，比如重新开始一遍，或者放弃本次更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建city表</span><br><span class="line">CREATE TABLE city(</span><br><span class="line">	id INT PRIMARY KEY AUTO_INCREMENT,  -- 城市id</span><br><span class="line">	NAME VARCHAR(20),                   -- 城市名称</span><br><span class="line">	VERSION INT                         -- 版本号</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO city VALUES (NULL,&#x27;北京&#x27;,1),(NULL,&#x27;上海&#x27;,1),(NULL,&#x27;广州&#x27;,1),(NULL,&#x27;深圳&#x27;,1);</span><br><span class="line"></span><br><span class="line">-- 修改北京为北京市</span><br><span class="line">-- 1.查询北京的version</span><br><span class="line">SELECT VERSION FROM city WHERE NAME=&#x27;北京&#x27;;</span><br><span class="line">-- 2.修改北京为北京市，版本号+1。并对比版本号</span><br><span class="line">UPDATE city SET NAME=&#x27;北京市&#x27;,VERSION=VERSION+1 WHERE NAME=&#x27;北京&#x27; AND VERSION=1;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>时间戳</p>
<ul>
<li>和版本号方式基本一样，给数据表中添加一个列，名称无所谓，数据类型需要是 <strong>timestamp</strong></li>
<li>每次更新后都将最新时间插入到此列</li>
<li>读取数据时，将时间读取出来，在执行更新的时候，比较时间</li>
<li>如果相同则执行更新，如果不相同，说明此条数据已经发生了变化</li>
</ul>
</li>
</ul>
<p>乐观锁的异常情况：如果 version 被其他事务抢先更新，则在当前事务中更新失败，trx_id 没有变成当前事务的 ID，当前事务再次查询还是旧值，就会出现<strong>值没变但是更新不了</strong>的现象（anomaly）</p>
<p>解决方案：每次 CAS 更新不管成功失败，就结束当前事务；如果失败则重新起一个事务进行查询更新</p>
<hr>
<h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><h3 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步</p>
<p>MySQL 支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制</p>
<p>MySQL 复制的优点主要包含以下三个方面：</p>
<ul>
<li><p>主库出现问题，可以快速切换到从库提供服务</p>
</li>
<li><p>可以在从库上执行查询操作，从主库中更新，实现读写分离</p>
</li>
<li><p>可以在从库中执行备份，以避免备份期间影响主库的服务（备份时会加全局读锁）</p>
</li>
</ul>
<hr>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h4 id="主从结构"><a href="#主从结构" class="headerlink" title="主从结构"></a>主从结构</h4><p>MySQL 的主从之间维持了一个<strong>长连接</strong>。主库内部有一个线程，专门用于服务从库的长连接，连接过程：</p>
<ul>
<li>从库执行 change master 命令，设置主库的 IP、端口、用户名、密码以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量</li>
<li>从库执行 start slave 命令，这时从库会启动两个线程，就是图中的 io_thread 和 sql_thread，其中 io_thread 负责与主库建立连接</li>
<li>主库校验完用户名、密码后，开始按照从传过来的位置，从本地读取 binlog 发给从库，开始主从复制</li>
</ul>
<p>主从复制原理图：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E5%9B%BE.jpg"></p>
<p>主从复制主要依赖的是 binlog，MySQL 默认是异步复制，需要三个线程：</p>
<ul>
<li>binlog thread：在主库事务提交时，负责把数据变更记录在二进制日志文件 binlog 中，并通知 slave 有数据更新</li>
<li>I&#x2F;O thread：负责从主服务器上<strong>拉取二进制日志</strong>，并将 binlog 日志内容依次写到 relay log 中转日志的最末端，并将新的 binlog 文件名和 offset 记录到 master-info 文件中，以便下一次读取日志时从指定 binlog 日志文件及位置开始读取新的 binlog 日志内容</li>
<li>SQL thread：监测本地 relay log 中新增了日志内容，读取中继日志并重做其中的 SQL 语句，从库在 relay-log.info 中记录当前应用中继日志的文件名和位点以便下一次执行</li>
</ul>
<p>同步与异步：</p>
<ul>
<li>异步复制有数据丢失风险，例如数据还未同步到从库，主库就给客户端响应，然后主库挂了，此时从库晋升为主库的话数据是缺失的</li>
<li>同步复制，主库需要将 binlog 复制到所有从库，等所有从库响应了之后主库才进行其他逻辑，这样的话性能很差，一般不会选择</li>
<li>MySQL 5.7 之后出现了半同步复制，有参数可以选择成功同步几个从库就返回响应</li>
</ul>
<hr>
<h4 id="主主结构"><a href="#主主结构" class="headerlink" title="主主结构"></a>主主结构</h4><p>主主结构就是两个数据库之间总是互为主从关系，这样在切换的时候就不用再修改主从关系</p>
<p>循环复制：在库 A 上更新了一条语句，然后把生成的 binlog 发给库 B，库 B 执行完这条更新语句后也会生成 binlog，会再发给 A</p>
<p>解决方法：</p>
<ul>
<li>两个库的 server id 必须不同，如果相同则它们之间不能设定为主主关系</li>
<li>一个库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog</li>
<li>每个库在收到从主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志</li>
</ul>
<hr>
<h3 id="主从延迟"><a href="#主从延迟" class="headerlink" title="主从延迟"></a>主从延迟</h3><h4 id="延迟原因"><a href="#延迟原因" class="headerlink" title="延迟原因"></a>延迟原因</h4><p>正常情况主库执行更新生成的所有 binlog，都可以传到从库并被正确地执行，从库就能达到跟主库一致的状态，这就是最终一致性</p>
<p>主从延迟是主从之间是存在一定时间的数据不一致，就是同一个事务在从库执行完成的时间和主库执行完成的时间的差值，即 T2-T1</p>
<ul>
<li>主库 A 执行完成一个事务，写入 binlog，该时刻记为 T1</li>
<li>日志传给从库 B，从库 B 执行完这个事务，该时刻记为 T2</li>
</ul>
<p>通过在从库执行 <code>show slave status</code> 命令，返回结果会显示 seconds_behind_master 表示当前从库延迟了多少秒</p>
<ul>
<li>每一个事务的 binlog 都有一个时间字段，用于记录主库上写入的时间</li>
<li>从库取出当前正在执行的事务的时间字段，跟系统的时间进行相减，得到的就是 seconds_behind_master</li>
</ul>
<p>主从延迟的原因：</p>
<ul>
<li>从库的机器性能比主库的差，导致从库的复制能力弱</li>
<li>从库的查询压力大，建立一主多从的结构</li>
<li>大事务的执行，主库必须要等到事务完成之后才会写入 binlog，导致从节点出现应用 binlog 延迟</li>
<li>主库的 DDL，从库与主库的 DDL 同步是串行进行，DDL 在主库执行时间很长，那么从库也会消耗同样的时间</li>
<li>锁冲突问题也可能导致从节点的 SQL 线程执行慢</li>
</ul>
<p>主从同步问题永远都是<strong>一致性和性能的权衡</strong>，需要根据实际的应用场景，可以采取下面的办法：</p>
<ul>
<li><p>优化 SQL，避免慢 SQL，减少批量操作</p>
</li>
<li><p>降低多线程大事务并发的概率，优化业务逻辑</p>
</li>
<li><p>业务中大多数情况查询操作要比更新操作更多，搭建<strong>一主多从</strong>结构，让这些从库来分担读的压力</p>
</li>
<li><p>尽量采用短的链路，主库和从库服务器的距离尽量要短，提升端口带宽，减少 binlog 传输的网络延时</p>
</li>
<li><p>实时性要求高的业务读强制走主库，从库只做备份</p>
</li>
</ul>
<hr>
<h4 id="并行复制"><a href="#并行复制" class="headerlink" title="并行复制"></a>并行复制</h4><h5 id="MySQL5-6"><a href="#MySQL5-6" class="headerlink" title="MySQL5.6"></a>MySQL5.6</h5><p>高并发情况下，主库的会产生大量的 binlog，在从库中有两个线程 IO Thread 和 SQL Thread 单线程执行，会导致主库延迟变大。为了改善复制延迟问题，MySQL 5.6 版本增加了并行复制功能，以采用多线程机制来促进执行</p>
<p>coordinator 就是原来的 SQL Thread，并行复制中它不再直接更新数据，<strong>只负责读取中转日志和分发事务</strong>：</p>
<ul>
<li>线程分配完成并不是立即执行，为了防止造成更新覆盖，更新同一 DB 的两个事务必须被分发到同一个工作线程</li>
<li>同一个事务不能被拆开，必须放到同一个工作线程</li>
</ul>
<p>MySQL 5.6 版本的策略：每个线程对应一个 hash 表，用于保存当前这个线程的执行队列里的事务所涉及的表，hash 表的 key 是数据库 名，value 是一个数字，表示队列中有多少个事务修改这个库，适用于主库上有多个 DB 的情况</p>
<p>每个事务在分发的时候，跟线程的<strong>冲突</strong>（事务操作的是同一个库）关系包括以下三种情况：</p>
<ul>
<li>如果跟所有线程都不冲突，coordinator 线程就会把这个事务分配给最空闲的线程</li>
<li>如果只跟一个线程冲突，coordinator 线程就会把这个事务分配给这个存在冲突关系的线程</li>
<li>如果跟多于一个线程冲突，coordinator 线程就进入等待状态，直到和这个事务存在冲突关系的线程只剩下 1 个</li>
</ul>
<p>优缺点：</p>
<ul>
<li>构造 hash 值的时候很快，只需要库名，而且一个实例上 DB 数也不会很多，不会出现需要构造很多个项的情况</li>
<li>不要求 binlog 的格式，statement 格式的 binlog 也可以很容易拿到库名（日志章节详解了 binlog）</li>
<li>主库上的表都放在同一个 DB 里面，这个策略就没有效果了；或者不同 DB 的热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果，需要<strong>把相同热度的表均匀分到这些不同的 DB 中</strong>，才可以使用这个策略</li>
</ul>
<hr>
<h5 id="MySQL5-7"><a href="#MySQL5-7" class="headerlink" title="MySQL5.7"></a>MySQL5.7</h5><p>MySQL 5.7 由参数 slave-parallel-type 来控制并行复制策略：</p>
<ul>
<li>配置为 DATABASE，表示使用 MySQL 5.6 版本的<strong>按库（DB）并行策略</strong></li>
<li>配置为 LOGICAL_CLOCK，表示的<strong>按提交状态并行</strong>执行</li>
</ul>
<p>按提交状态并行复制策略的思想是：</p>
<ul>
<li>所有处于 commit 状态的事务可以并行执行；同时处于 prepare 状态的事务，在从库执行时是可以并行的</li>
<li>处于 prepare 状态的事务，与处于 commit 状态的事务之间，在从库执行时也是可以并行的</li>
</ul>
<p>MySQL 5.7.22 版本里，MySQL 增加了一个新的并行复制策略，基于 WRITESET 的并行复制，新增了一个参数 binlog-transaction-dependency-tracking，用来控制是否启用这个新策略：</p>
<ul>
<li><p>COMMIT_ORDER：表示根据同时进入 prepare 和 commit 来判断是否可以并行的策略</p>
</li>
<li><p>WRITESET：表示的是对于每个事务涉及更新的每一行，计算出这一行的 hash 值，组成该事务的 writeset 集合，如果两个事务没有操作相同的行，也就是说它们的 writeset 没有交集，就可以并行（<strong>按行并行</strong>）</p>
<p>为了唯一标识，这个 hash 表的值是通过 <code>库名 + 表名 + 索引名 + 值</code>（表示的是某一行）计算出来的</p>
</li>
<li><p>WRITESET_SESSION：是在 WRITESET 的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序</p>
</li>
</ul>
<p>MySQL 5.7.22 按行并发的优势：</p>
<ul>
<li>writeset 是在主库生成后直接写入到 binlog 里面的，这样在备库执行的时候，不需要解析 binlog 内容，节省了计算量</li>
<li>不需要把整个事务的 binlog 都扫一遍才能决定分发到哪个线程，更省内存</li>
<li>从库的分发策略不依赖于 binlog 内容，所以 binlog 是 statement 格式也可以，更节约内存（因为 row 才记录更改的行）</li>
</ul>
<p>MySQL 5.7.22 的并行复制策略在通用性上是有保证的，但是对于表上没主键、唯一和外键约束的场景，WRITESET 策略也是没法并行的，也会暂时退化为单线程模型</p>
<p>参考文章：<a href="https://time.geekbang.org/column/article/77083">https://time.geekbang.org/column/article/77083</a></p>
<hr>
<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><h4 id="读写延迟"><a href="#读写延迟" class="headerlink" title="读写延迟"></a>读写延迟</h4><p>读写分离：可以降低主库的访问压力，提高系统的并发能力</p>
<ul>
<li>主库不建查询的索引，从库建查询的索引。因为索引需要维护的，比如插入一条数据，不仅要在聚簇索引上面插入，对应的二级索引也得插入</li>
<li>将读操作分到从库了之后，可以在主库把查询要用的索引删了，减少写操作对主库的影响</li>
</ul>
<p>读写分离产生了读写延迟，造成数据的不一致性。假如客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，可能读到的还是以前的数据，叫过期读</p>
<p>解决方案：</p>
<ul>
<li>强制将写之后<strong>立刻读的操作转移到主库</strong>，比如刚注册的用户，直接登录从库查询可能查询不到，先走主库登录</li>
<li><strong>二次查询</strong>，如果从库查不到数据，则再去主库查一遍，由 API 封装，比较简单，但导致主库压力大</li>
<li>更新主库后，读从库之前先 sleep 一下，类似于执行一条 <code>select sleep(1)</code> 命令，大多数情况下主备延迟在 1 秒之内</li>
</ul>
<hr>
<h4 id="确保机制"><a href="#确保机制" class="headerlink" title="确保机制"></a>确保机制</h4><h5 id="无延迟"><a href="#无延迟" class="headerlink" title="无延迟"></a>无延迟</h5><p>确保主备无延迟的方法：</p>
<ul>
<li>每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0，如果不等于那就等到参数变为 0 执行查询请求</li>
<li>对比位点，Master_Log_File 和 Read_Master_Log_Pos 表示的是读到的主库的最新位点，Relay_Master_Log_File 和 Exec_Master_Log_Pos 表示的是备库执行的最新位点，这两组值完全相同就说明接收到的日志已经同步完成</li>
<li>对比 GTID 集合，Retrieved_Gtid_Set 是备库收到的所有日志的 GTID 集合，Executed_Gtid_Set 是备库所有已经执行完成的 GTID 集合，如果这两个集合相同也表示备库接收到的日志都已经同步完成</li>
</ul>
<hr>
<h5 id="半同步"><a href="#半同步" class="headerlink" title="半同步"></a>半同步</h5><p>半同步复制就是 semi-sync replication，适用于一主一备的场景，工作流程：</p>
<ul>
<li>事务提交的时候，主库把 binlog 发给从库</li>
<li>从库收到 binlog 以后，发回给主库一个 ack，表示收到了</li>
<li>主库收到这个 ack 以后，才能给客户端返回事务完成的确认</li>
</ul>
<p>在一主多从场景中，主库只要等到一个从库的 ack，就开始给客户端返回确认，这时在从库上执行查询请求，有两种情况：</p>
<ul>
<li>如果查询是落在这个响应了 ack 的从库上，是能够确保读到最新数据</li>
<li>如果查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题</li>
</ul>
<p>在业务更新的高峰期，主库的位点或者 GTID 集合更新很快，导致从库来不及处理，那么两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况</p>
<hr>
<h5 id="等位点"><a href="#等位点" class="headerlink" title="等位点"></a>等位点</h5><p>在<strong>从库执行判断位点</strong>的命令，参数 file 和 pos 指的是主库上的文件名和位置，timeout 可选，设置为正整数 N 表示最多等待 N 秒</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT master_pos_wait(file, pos[, timeout]);</span><br></pre></td></tr></table></figure>

<p>命令正常返回的结果是一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务</p>
<ul>
<li>如果执行期间，备库同步线程发生异常，则返回 NULL</li>
<li>如果等待超过 N 秒，就返回 -1</li>
<li>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回 0</li>
</ul>
<p>工作流程：先执行 trx1，再执行一个查询请求的逻辑，要<strong>保证能够查到正确的数据</strong></p>
<ul>
<li>trx1 事务更新完成后，马上执行 <code>show master status</code> 得到当前主库执行到的 File 和 Position</li>
<li>选定一个从库执行判断位点语句，如果返回值是 &gt;&#x3D;0 的正整数，说明从库已经同步完事务，可以在这个从库执行查询语句</li>
<li>如果出现其他情况，需要到主库执行查询语句</li>
</ul>
<p>注意：如果所有的从库都延迟超过 timeout  秒，查询压力就都跑到主库上，所以需要进行权衡</p>
<hr>
<h5 id="等GTID"><a href="#等GTID" class="headerlink" title="等GTID"></a>等GTID</h5><p>数据库开启了 GTID 模式，MySQL 提供了判断 GTID 的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT wait_for_executed_gtid_set(gtid_set [, timeout])</span><br></pre></td></tr></table></figure>

<ul>
<li>等待直到这个库执行的事务中包含传入的 gtid_set，返回 0</li>
<li>超时返回 1</li>
</ul>
<p>工作流程：先执行 trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据</p>
<ul>
<li>trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid</li>
<li>选定一个从库执行查询语句，如果返回值是 0，则在这个从库执行查询语句，否则到主库执行查询语句</li>
</ul>
<p>对比等待位点方法，减少了一次 <code>show master status</code> 的方法，将参数 session_track_gtids 设置为 OWN_GTID，然后通过 API 接口 mysql_session_track_get_first 从返回包解析出 GTID 的值即可</p>
<p>总结：所有的等待无延迟的方法，都需要根据具体的业务场景去判断实施</p>
<p>参考文章：<a href="https://time.geekbang.org/column/article/77636">https://time.geekbang.org/column/article/77636</a></p>
<hr>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>负载均衡是应用中使用非常普遍的一种优化方法，机制就是利用某种均衡算法，将固定的负载量分布到不同的服务器上，以此来降低单台服务器的负载，达到优化的效果</p>
<ul>
<li><p>分流查询：通过 MySQL 的主从复制，实现读写分离，使增删改操作走主节点，查询操作走从节点，从而可以降低单台服务器的读写压力</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.jpg"></p>
</li>
<li><p>分布式数据库架构：适合大数据量、负载高的情况，具有良好的拓展性和高可用性。通过在多台服务器之间分布数据，可以实现在多台服务器之间的负载均衡，提高访问效率</p>
</li>
</ul>
<hr>
<h3 id="主从搭建"><a href="#主从搭建" class="headerlink" title="主从搭建"></a>主从搭建</h3><h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><ol>
<li><p>在master 的配置文件（&#x2F;etc&#x2F;mysql&#x2F;my.cnf）中，配置如下内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mysql 服务ID,保证整个集群环境中唯一</span></span><br><span class="line">server-id=1</span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql binlog 日志的存储路径和文件名</span></span><br><span class="line">log-bin=/var/lib/mysql/mysqlbin</span><br><span class="line"></span><br><span class="line"><span class="comment">#错误日志,默认已经开启</span></span><br><span class="line"><span class="comment">#log-err</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql的安装目录</span></span><br><span class="line"><span class="comment">#basedir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql的临时目录</span></span><br><span class="line"><span class="comment">#tmpdir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql的数据存放目录</span></span><br><span class="line"><span class="comment">#datadir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否只读,1 代表只读, 0 代表读写</span></span><br><span class="line">read-only=0</span><br><span class="line"></span><br><span class="line"><span class="comment">#忽略的数据, 指不需要同步的数据库</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定同步的数据库</span></span><br><span class="line"><span class="comment">#binlog-do-db=db01</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行完毕之后，需要重启 MySQL</p>
</li>
<li><p>创建同步数据的账户，并且进行授权操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;seazean&#x27;@&#x27;192.168.0.137&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 master 状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW MASTER STATUS;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%9F%A5%E7%9C%8Bmaster%E7%8A%B6%E6%80%81.jpg"></p>
<ul>
<li>File：从哪个日志文件开始推送日志文件 </li>
<li>Position：从哪个位置开始推送日志</li>
<li>Binlog_Ignore_DB：指定不需要同步的数据库</li>
</ul>
</li>
</ol>
<hr>
<h4 id="slave"><a href="#slave" class="headerlink" title="slave"></a>slave</h4><ol>
<li><p>在 slave 端配置文件中，配置如下内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mysql服务端ID,唯一</span></span><br><span class="line">server-id=2</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定binlog日志</span></span><br><span class="line">log-bin=/var/lib/mysql/mysqlbin</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行完毕之后，需要重启 MySQL</p>
</li>
<li><p>指定当前从库对应的主库的IP地址、用户名、密码，从哪个日志文件开始的那个位置开始同步推送日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST= &#x27;192.168.0.138&#x27;, MASTER_USER=&#x27;seazean&#x27;, MASTER_PASSWORD=&#x27;seazean&#x27;, MASTER_LOG_FILE=&#x27;mysqlbin.000001&#x27;, MASTER_LOG_POS=413;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启同步操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START SLAVE;</span><br><span class="line">SHOW SLAVE STATUS;</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止同步操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STOP SLAVE;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ol>
<li><p>在主库中创建数据库，创建表并插入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE db01;</span><br><span class="line">USE db01;</span><br><span class="line">CREATE TABLE user(</span><br><span class="line">	id INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">	name VARCHAR(50) NOT NULL,</span><br><span class="line">	sex VARCHAR(1),</span><br><span class="line">	PRIMARY KEY (id)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO user(id,NAME,sex) VALUES(NULL,&#x27;Tom&#x27;,&#x27;1&#x27;);</span><br><span class="line">INSERT INTO user(id,NAME,sex) VALUES(NULL,&#x27;Trigger&#x27;,&#x27;0&#x27;);</span><br><span class="line">INSERT INTO user(id,NAME,sex) VALUES(NULL,&#x27;Dawn&#x27;,&#x27;1&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在从库中查询数据，进行验证：</p>
<p>在从库中，可以查看到刚才创建的数据库：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%AA%8C%E8%AF%811.jpg"></p>
<p>在该数据库中，查询表中的数据：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%AA%8C%E8%AF%812.jpg"></p>
</li>
</ol>
<hr>
<h3 id="主从切换"><a href="#主从切换" class="headerlink" title="主从切换"></a>主从切换</h3><h4 id="正常切换"><a href="#正常切换" class="headerlink" title="正常切换"></a>正常切换</h4><p>正常切换步骤：</p>
<ul>
<li><p>在开始切换之前先对主库进行锁表 <code>flush tables with read lock</code>，然后等待所有语句执行完成，切换完成后可以释放锁</p>
</li>
<li><p>检查 slave 同步状态，在 slave 执行 <code>show processlist</code></p>
</li>
<li><p>停止 slave io 线程，执行命令 <code>STOP SLAVE IO_THREAD</code></p>
</li>
<li><p>提升 slave 为 master</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Stop slave;</span><br><span class="line">Reset master;</span><br><span class="line">Reset slave <span class="keyword">all</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> read_only<span class="operator">=</span>off;	<span class="comment">-- 设置为可更新状态</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将原来 master 变为 slave（参考搭建流程中的 slave 方法）</p>
</li>
</ul>
<p><strong>可靠性优先策略</strong>：</p>
<ul>
<li>判断备库 B 现在的 seconds_behind_master，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步</li>
<li>把主库 A 改成只读状态，即把 readonly 设置为 true</li>
<li>判断备库 B 的 seconds_behind_master 的值，直到这个值变成 0 为止（该步骤比较耗时，所以步骤 1 中要尽量等待该值变小）</li>
<li>把备库 B 改成可读写状态，也就是把 readonly 设置为 false</li>
<li>把业务请求切到备库 B</li>
</ul>
<p>可用性优先策略：先做最后两步，会造成主备数据不一致的问题</p>
<p>参考文章：<a href="https://time.geekbang.org/column/article/76795">https://time.geekbang.org/column/article/76795</a></p>
<hr>
<h4 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h4><p>主库发生故障后从库会上位，<strong>其他从库指向新的主库</strong>，所以需要一个健康检测的机制来判断主库是否宕机</p>
<ul>
<li><p>select 1 判断，但是高并发下检测不出线程的锁等待的阻塞问题</p>
</li>
<li><p>查表判断，在系统库（mysql 库）里创建一个表，比如命名为 health_check，里面只放一行数据，然后定期执行。但是当 binlog 所在磁盘的空间占用率达到 100%，所有的更新和事务提交语句都被阻塞，查询语句可以继续运行</p>
</li>
<li><p>更新判断，在健康检测表中放一个 timestamp 字段，用来表示最后一次执行检测的时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE mysql.health_check SET t_modified=now();</span><br></pre></td></tr></table></figure>

<p>节点可用性的检测都应该包含主库和备库，为了让主备之间的更新不产生冲突，可以在 mysql.health_check 表上存入多行数据，并用主备的 server_id 做主键，保证主、备库各自的检测命令不会发生冲突</p>
</li>
</ul>
<hr>
<h4 id="基于位点"><a href="#基于位点" class="headerlink" title="基于位点"></a>基于位点</h4><p>主库上位后，从库 B 执行 CHANGE MASTER TO 命令，指定 MASTER_LOG_FILE、MASTER_LOG_POS 表示从新主库 A 的哪个文件的哪个位点开始同步，这个位置就是<strong>同步位点</strong>，对应主库的文件名和日志偏移量</p>
<p>寻找位点需要找一个稍微往前的，然后再通过判断跳过那些在从库 B 上已经执行过的事务，获取位点方法：</p>
<ul>
<li>等待新主库 A 把中转日志（relay log）全部同步完成</li>
<li>在 A 上执行 show master status 命令，得到当前 A 上最新的 File 和 Position</li>
<li>取原主库故障的时刻 T，用 mysqlbinlog 工具解析新主库 A 的 File，得到 T 时刻的位点</li>
</ul>
<p>通常情况下该值并不准确，在切换的过程中会发生错误，所以要先主动跳过这些错误：</p>
<ul>
<li><p>切换过程中，可能会重复执行一个事务，所以需要主动跳过所有重复的事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL sql_slave_skip_counter=1;</span><br><span class="line">START SLAVE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 slave_skip_errors 参数，直接设置跳过指定的错误，保证主从切换的正常进行</p>
<ul>
<li>1062 错误是插入数据时唯一键冲突</li>
<li>1032 错误是删除数据时找不到行</li>
</ul>
<p>该方法针对的是主备切换时，由于找不到精确的同步位点，只能采用这种方法来创建从库和新主库的主备关系。等到主备间的同步关系建立完成并稳定执行一段时间后，还需要把这个参数设置为空，以免真的出现了主从数据不一致也跳过了</p>
</li>
</ul>
<hr>
<h4 id="基于GTID"><a href="#基于GTID" class="headerlink" title="基于GTID"></a>基于GTID</h4><h5 id="GTID"><a href="#GTID" class="headerlink" title="GTID"></a>GTID</h5><p>GTID 的全称是 Global Transaction Identifier，全局事务 ID，是一个事务<strong>在提交时生成</strong>的，是这个事务的唯一标识，组成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GTID=source_id:transaction_id</span><br></pre></td></tr></table></figure>

<ul>
<li>source_id：是一个实例第一次启动时自动生成的，是一个全局唯一的值</li>
<li>transaction_id：初始值是 1，每次提交事务的时候分配给这个事务，并加 1，是连续的（区分事务 ID，事务 ID 是在执行时生成）</li>
</ul>
<p>启动 MySQL 实例时，加上参数 <code>gtid_mode=on</code> 和 <code>enforce_gtid_consistency=on</code> 就可以启动 GTID 模式，每个事务都会和一个 GTID 一一对应，每个 MySQL 实例都维护了一个 GTID 集合，用来存储当前实例<strong>执行过的所有事务</strong></p>
<p>GTID 有两种生成方式，使用哪种方式取决于 session 变量 gtid_next：</p>
<ul>
<li><p><code>gtid_next=automatic</code>：使用默认值，把 source_id:transaction_id （递增）分配给这个事务，然后加入本实例的 GTID 集合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@@SESSION.GTID_NEXT = &#x27;source_id:transaction_id&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>gtid_next=GTID</code>：指定的 GTID 的值，如果该值已经存在于实例的 GTID 集合中，接下来执行的事务会直接被系统忽略；反之就将该值分配给接下来要执行的事务，系统不需要给这个事务生成新的 GTID，也不用加 1</p>
<p>注意：一个 GTID 只能给一个事务使用，所以执行下一个事务，要把 gtid_next 设置成另外一个 GTID 或者 automatic</p>
</li>
</ul>
<p>业务场景：</p>
<ul>
<li><p>主库 X 和从库 Y 执行一条相同的指令后进行事务同步</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO t VALUES(1,1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>当 Y 同步 X 时，会出现主键冲突，导致实例 X 的同步线程停止，解决方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET gtid_next=&#x27;(这里是主库 X 的 GTID 值)&#x27;;</span><br><span class="line">BEGIN;</span><br><span class="line">COMMIT;</span><br><span class="line">SET gtid_next=automatic;</span><br><span class="line">START SLAVE;</span><br></pre></td></tr></table></figure>

<p>前三条语句通过<strong>提交一个空事务</strong>，把 X 的 GTID 加到实例 Y 的 GTID 集合中，实例 Y 就会直接跳过这个事务</p>
</li>
</ul>
<hr>
<h5 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h5><p>在 GTID 模式下，CHANGE MASTER TO 不需要指定日志名和日志偏移量，指定 <code>master_auto_position=1</code> 代表使用 GTID 模式</p>
<p>新主库实例 A 的 GTID 集合记为 set_a，从库实例 B 的 GTID 集合记为 set_b，主备切换逻辑：</p>
<ul>
<li>实例 B 指定主库 A，基于主备协议建立连接，实例 B 并把 set_b 发给主库 A</li>
<li>实例 A 算出 set_a 与 set_b 的差集，就是所有存在于 set_a 但不存在于 set_b 的 GTID 的集合，判断 A 本地是否包含了这个<strong>差集</strong>需要的所有 binlog 事务<ul>
<li>如果不包含，表示 A 已经把实例 B 需要的 binlog 给删掉了，直接返回错误</li>
<li>如果确认全部包含，A 从自己的 binlog 文件里面，找出第一个不在 set_b 的事务，发给 B</li>
</ul>
</li>
<li>实例 A 之后就从这个事务开始，往后读文件，按顺序取 binlog 发给 B 去执行</li>
</ul>
<p>参考文章：<a href="https://time.geekbang.org/column/article/77427">https://time.geekbang.org/column/article/77427</a></p>
<hr>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h3><p>在任何一种数据库中，都会有各种各样的日志，记录着数据库工作的过程，可以帮助数据库管理员追踪数据库曾经发生过的各种事件</p>
<p>MySQL日志主要包括六种：</p>
<ol>
<li>重做日志（redo log）</li>
<li>回滚日志（undo log）</li>
<li>归档日志（binlog）（二进制日志）</li>
<li>错误日志（errorlog）</li>
<li>慢查询日志（slow query log）</li>
<li>一般查询日志（general log）</li>
<li>中继日志（relay log）</li>
</ol>
<hr>
<h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志是 MySQL 中最重要的日志之一，记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，可以首先查看此日志</p>
<p>该日志是默认开启的，默认位置是：<code>/var/log/mysql/error.log</code></p>
<p>查看指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;log_error%&#x27;;</span><br></pre></td></tr></table></figure>

<p>查看日志内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f /var/log/mysql/error.log</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="归档日志"><a href="#归档日志" class="headerlink" title="归档日志"></a>归档日志</h3><h4 id="基本介绍-10"><a href="#基本介绍-10" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>归档日志（BINLOG）也叫二进制日志，是因为采用二进制进行存储，记录了所有的 DDL（数据定义语言）语句和 DML（数据操作语言）语句，但<strong>不包括数据查询语句，在事务提交前的最后阶段写入</strong></p>
<p>作用：<strong>灾难时的数据恢复和 MySQL 的主从复制</strong></p>
<p>归档日志默认情况下是没有开启的，需要在 MySQL 配置文件中开启，并配置 MySQL 日志的格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/mysql</span><br><span class="line">vim my.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如: mysqlbin.000001</span></span><br><span class="line">log_bin=mysqlbin</span><br><span class="line"><span class="comment"># 配置二进制日志的格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br></pre></td></tr></table></figure>

<p>日志存放位置：配置时给定了文件名但是没有指定路径，日志默认写入MySQL 的数据目录</p>
<p>日志格式：</p>
<ul>
<li><p>STATEMENT：该日志格式在日志文件中记录的都是 <strong>SQL 语句</strong>，每一条对数据进行修改的 SQL 都会记录在日志文件中，通过 mysqlbinlog 工具，可以查看到每条语句的文本。主从复制时，从库会将日志解析为原语句，并在从库重新执行一遍</p>
<p>缺点：可能会导致主备不一致，因为记录的 SQL 在不同的环境中可能选择的索引不同，导致结果不同</p>
</li>
<li><p>ROW：该日志格式在日志文件中记录的是每一行的<strong>数据变更</strong>，而不是记录 SQL 语句。比如执行 SQL 语句 <code>update tb_book set status=&#39;1&#39;</code>，如果是 STATEMENT，在日志中会记录一行 SQL 语句； 如果是 ROW，由于是对全表进行更新，就是每一行记录都会发生变更，ROW 格式的日志中会记录每一行的数据变更</p>
<p>缺点：记录的数据比较多，占用很多的存储空间</p>
</li>
<li><p>MIXED：这是 MySQL 默认的日志格式，混合了STATEMENT 和 ROW 两种格式，MIXED 格式能尽量利用两种模式的优点，而避开它们的缺点</p>
</li>
</ul>
<hr>
<h4 id="日志刷盘-1"><a href="#日志刷盘-1" class="headerlink" title="日志刷盘"></a>日志刷盘</h4><p>事务执行过程中，先将日志写（write）到 binlog cache，事务提交时再把 binlog cache 写（fsync）到 binlog 文件中，一个事务的 binlog 是不能被拆开的，所以不论这个事务多大也要确保一次性写入</p>
<p>事务提交时执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache</p>
<p>write 和 fsync 的时机由参数 sync_binlog 控制的：</p>
<ul>
<li>sync_binlog&#x3D;0：表示每次提交事务都只 write，不 fsync</li>
<li>sync_binlog&#x3D;1：表示每次提交事务都会执行 fsync</li>
<li>sync_binlog&#x3D;N(N&gt;1)：表示每次提交事务都 write，但累积 N 个事务后才 fsync，但是如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志</li>
</ul>
<hr>
<h4 id="日志读取"><a href="#日志读取" class="headerlink" title="日志读取"></a>日志读取</h4><p>日志文件存储位置：&#x2F;var&#x2F;lib&#x2F;mysql</p>
<p>由于日志以二进制方式存储，不能直接读取，需要用 mysqlbinlog 工具来查看，语法如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlbinlog log-file;</span><br></pre></td></tr></table></figure>

<p>查看 STATEMENT 格式日志：</p>
<ul>
<li><p>执行插入语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb_book VALUES(NULL,&#x27;Lucene&#x27;,&#x27;2088-05-01&#x27;,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>cd /var/lib/mysql</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-rw-r-----  1 mysql mysql      177 5月  23 21:08 mysqlbin.000001</span><br><span class="line">-rw-r-----  1 mysql mysql       18 5月  23 21:04 mysqlbin.index</span><br></pre></td></tr></table></figure>

<p>mysqlbin.index：该文件是日志索引文件 ， 记录日志的文件名；</p>
<p>mysqlbing.000001：日志文件</p>
</li>
<li><p>查看日志内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlbinlog mysqlbing.000001;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%961.png"></p>
<p>日志结尾有 COMMIT</p>
</li>
</ul>
<p>查看 ROW 格式日志：</p>
<ul>
<li><p>修改配置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置二进制日志的格式</span></span><br><span class="line">binlog_format=ROW</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb_book VALUES(NULL,&#x27;SpringCloud实战&#x27;,&#x27;2088-05-05&#x27;,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看日志内容：日志格式 ROW，直接查看数据是乱码，可以在 mysqlbinlog 后面加上参数 -vv </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqlbinlog -vv mysqlbin.000002</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%962.png"></p>
</li>
</ul>
<hr>
<h4 id="日志删除"><a href="#日志删除" class="headerlink" title="日志删除"></a>日志删除</h4><p>对于比较繁忙的系统，生成日志量大，这些日志如果长时间不清除，将会占用大量的磁盘空间，需要删除日志</p>
<ul>
<li><p>Reset Master 指令删除全部 binlog 日志，删除之后，日志编号将从 xxxx.000001重新开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reset Master	-- MySQL指令</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行指令 <code>PURGE MASTER LOGS TO &#39;mysqlbin.***</code>，该命令将删除 <code> ***</code> 编号之前的所有日志</p>
</li>
<li><p>执行指令 <code>PURGE MASTER LOGS BEFORE &#39;yyyy-mm-dd hh:mm:ss&#39;</code> ，该命令将删除日志为 <code>yyyy-mm-dd hh:mm:ss</code> 之前产生的日志</p>
</li>
<li><p>设置参数 <code>--expire_logs_days=#</code>，此参数的含义是设置日志的过期天数，过了指定的天数后日志将会被自动删除，这样做有利于减少管理日志的工作量，配置 my.cnf 文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">log_bin=mysqlbin</span><br><span class="line">binlog_format=ROW</span><br><span class="line">--expire_logs_days=3</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="数据恢复-1"><a href="#数据恢复-1" class="headerlink" title="数据恢复"></a>数据恢复</h4><p>误删库或者表时，需要根据 binlog 进行数据恢复</p>
<p>一般情况下数据库有定时的全量备份，假如每天 0 点定时备份，12 点误删了库，恢复流程：</p>
<ul>
<li>取最近一次全量备份，用备份恢复出一个临时库</li>
<li>从日志文件中取出凌晨 0 点之后的日志</li>
<li>把除了误删除数据的语句外日志，全部应用到临时库</li>
</ul>
<p>跳过误删除语句日志的方法：</p>
<ul>
<li>如果原实例没有使用 GTID 模式，只能在应用到包含 12 点的 binlog 文件的时候，先用 –stop-position 参数执行到误操作之前的日志，然后再用 –start-position 从误操作之后的日志继续执行</li>
<li>如果实例使用了 GTID 模式，假设误操作命令的 GTID 是 gtid1，那么只需要提交一个空事务先将这个 GTID 加到临时实例的 GTID 集合，之后按顺序执行 binlog 的时就会自动跳过误操作的语句</li>
</ul>
<hr>
<h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的 SQL 语句</p>
<p>默认情况下，查询日志是未开启的。如果需要开启查询日志，配置 my.cnf：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该选项用来开启查询日志，可选值0或者1，0代表关闭，1代表开启 </span></span><br><span class="line">general_log=1</span><br><span class="line"><span class="comment"># 设置日志的文件名，如果没有指定，默认的文件名为host_name.log，存放在/var/lib/mysql</span></span><br><span class="line">general_log_file=mysql_query.log</span><br></pre></td></tr></table></figure>

<p>配置完毕之后，在数据库执行以下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tb_book;</span><br><span class="line">SELECT * FROM tb_book WHERE id = 1;</span><br><span class="line">UPDATE tb_book SET name = &#x27;lucene入门指南&#x27; WHERE id = 5;</span><br><span class="line">SELECT * FROM tb_book WHERE id &lt; 8</span><br></pre></td></tr></table></figure>

<p>执行完毕之后， 再次来查询日志文件：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97.png"></p>
<hr>
<h3 id="慢日志"><a href="#慢日志" class="headerlink" title="慢日志"></a>慢日志</h3><p>慢查询日志记录所有执行时间超过 long_query_time 并且扫描记录数不小于 min_examined_row_limit 的所有的 SQL 语句的日志long_query_time 默认为 10 秒，最小为 0， 精度到微秒</p>
<p>慢查询日志默认是关闭的，可以通过两个参数来控制慢查询日志，配置文件 <code>/etc/mysql/my.cnf</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该参数用来控制慢查询日志是否开启，可选值0或者1，0代表关闭，1代表开启 </span></span><br><span class="line">slow_query_log=1 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 该参数用来指定慢查询日志的文件名，存放在 /var/lib/mysql</span></span><br><span class="line">slow_query_log_file=slow_query.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该选项用来配置查询的时间限制，超过这个时间将认为值慢查询，将需要进行日志记录，默认10s</span></span><br><span class="line">long_query_time=10</span><br></pre></td></tr></table></figure>

<p>日志读取：</p>
<ul>
<li><p>直接通过 cat 指令查询该日志文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> slow_query.log</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%85%A2%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%961.png"></p>
</li>
<li><p>如果慢查询日志内容很多，直接查看文件比较繁琐，可以借助 mysql 自带的 mysqldumpslow 工具对慢查询日志进行分类汇总：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqldumpslow slow_query.log</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/MySQL-%E6%85%A2%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%962.png"></p>
</li>
</ul>
<hr>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>建立科学的，<strong>规范的数据表</strong>就需要满足一些规则来优化数据的设计和存储，这些规则就称为范式</p>
<p><strong>1NF：</strong>数据库表的每一列都是不可分割的原子数据项，不能是集合、数组等非原子数据项。即表中的某个列有多个值时，必须拆分为不同的列。简而言之，<strong>第一范式每一列不可再拆分，称为原子性</strong></p>
<p>基本表：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E6%99%AE%E9%80%9A%E8%A1%A8.png"></p>
<p>第一范式表：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F.png"></p>
<hr>
<h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p><strong>2NF：</strong>在满足第一范式的基础上，非主属性完全依赖于主码（主关键字、主键），消除非主属性对主码的部分函数依赖。简而言之，<strong>表中的每一个字段 （所有列）都完全依赖于主键，记录的唯一性</strong></p>
<p>作用：遵守第二范式减少数据冗余，通过主键区分相同数据。</p>
<ol>
<li>函数依赖：A → B，如果通过 A 属性(属性组)的值，可以确定唯一 B 属性的值，则称 B 依赖于 A<ul>
<li>学号 → 姓名；(学号，课程名称) → 分数</li>
</ul>
</li>
<li>完全函数依赖：A → B，如果A是一个属性组，则 B 属性值的确定需要依赖于 A 属性组的所有属性值<ul>
<li>(学号，课程名称) → 分数</li>
</ul>
</li>
<li>部分函数依赖：A → B，如果 A 是一个属性组，则 B 属性值的确定只需要依赖于 A 属性组的某些属性值<ul>
<li>(学号，课程名称) → 姓名</li>
</ul>
</li>
<li>传递函数依赖：A → B，B → C，如果通过A属性(属性组)的值，可以确定唯一 B 属性的值，在通过 B 属性(属性组)的值，可以确定唯一 C 属性的值，则称 C 传递函数依赖于 A<ul>
<li>学号 → 系名，系名 → 系主任</li>
</ul>
</li>
<li>码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码<ul>
<li>该表中的码：(学号，课程名称)</li>
<li>主属性：码属性组中的所有属性</li>
<li>非主属性：除码属性组以外的属性</li>
</ul>
</li>
</ol>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F.png"></p>
<hr>
<h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p><strong>3NF：</strong>在满足第二范式的基础上，表中的任何属性不依赖于其它非主属性，消除传递依赖。简而言之，<strong>非主键都直接依赖于主键，而不是通过其它的键来间接依赖于主键</strong>。</p>
<p>作用：可以通过主键 id 区分相同数据，修改数据的时候只需要修改一张表（方便修改），反之需要修改多表。</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F.png"></p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F.png"></p>
<hr>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>NoSQL（Not-Only SQL）：泛指非关系型的数据库，作为关系型数据库的补充</p>
<p>MySQL 支持 ACID 特性，保证可靠性和持久性，读取性能不高，因此需要缓存的来减缓数据库的访问压力</p>
<p>作用：应对基于海量用户和海量数据前提下的数据处理问题</p>
<p>特征：</p>
<ul>
<li>可扩容，可伸缩，SQL 数据关系过于复杂，Nosql 不存关系，只存数据</li>
<li>大数据量下高性能，数据不存取在磁盘 IO，存取在内存</li>
<li>灵活的数据模型，设计了一些数据存储格式，能保证效率上的提高</li>
<li>高可用，集群</li>
</ul>
<p>常见的 NoSQL：Redis、memcache、HBase、MongoDB</p>
<p>参考书籍：<a href="https://book.douban.com/subject/25900156/">https://book.douban.com/subject/25900156/</a></p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1CJ411m7Gc">https://www.bilibili.com/video/BV1CJ411m7Gc</a></p>
<hr>
<h3 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h3><p>Redis (REmote DIctionary Server) ：用 C 语言开发的一个开源的高性能键值对（key-value）数据库</p>
<p>特征：</p>
<ul>
<li>数据间没有必然的关联关系，<strong>不存关系，只存数据</strong></li>
<li>数据<strong>存储在内存</strong>，存取速度快，解决了磁盘 IO 速度慢的问题</li>
<li>内部采用<strong>单线程</strong>机制进行工作</li>
<li>高性能，官方测试数据，50 个并发执行 100000 个请求，读的速度是 110000 次&#x2F;s，写的速度是 81000 次&#x2F;s</li>
<li>多数据类型支持<ul>
<li>字符串类型：string（String）</li>
<li>列表类型：list（LinkedList）</li>
<li>散列类型：hash（HashMap）</li>
<li>集合类型：set（HashSet）</li>
<li>有序集合类型：zset&#x2F;sorted_set（TreeSet）</li>
</ul>
</li>
<li>支持持久化，可以进行数据灾难恢复</li>
</ul>
<hr>
<h3 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h3><p>安装：</p>
<ul>
<li><p>Redis 5.0 被包含在默认的 Ubuntu 20.04 软件源中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install redis-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查 Redis 状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl status redis-server</span><br></pre></td></tr></table></figure></li>
</ul>
<p>启动：</p>
<ul>
<li><p>启动服务器——参数启动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server [--port port]</span><br><span class="line"><span class="comment">#redis-server --port 6379</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务器——配置文件启动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server config_file_name</span><br><span class="line"><span class="comment">#redis-server /etc/redis/conf/redis-6397.conf</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动客户端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli [-h host] [-p port]</span><br><span class="line"><span class="comment">#redis-cli -h 192.168.2.185 -p 6397</span></span><br></pre></td></tr></table></figure>

<p>注意：服务器启动指定端口使用的是–port，客户端启动指定端口使用的是-p</p>
</li>
</ul>
<hr>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><h4 id="系统目录"><a href="#系统目录" class="headerlink" title="系统目录"></a>系统目录</h4><ol>
<li><p>创建文件结构</p>
<p>创建配置文件存储目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> conf</span><br></pre></td></tr></table></figure>

<p>创建服务器文件存储目录（包含日志、数据、临时配置文件等）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> data</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建配置文件副本放入 conf 目录，Ubuntu 系统配置文件 redis.conf 在目录 <code>/etc/redis</code> 中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> redis.conf | grep -v <span class="string">&quot;#&quot;</span> | grep -v <span class="string">&quot;^$&quot;</span> -&gt; /conf/redis-6379.conf</span><br></pre></td></tr></table></figure>

<p>去除配置文件的注释和空格，输出到新的文件，命令方式采用 redis-port.conf</p>
</li>
</ol>
<hr>
<h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><ul>
<li><p>设置服务器以守护进程的方式运行，关闭后服务器控制台中将打印服务器运行信息（同日志内容相同）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">daemonize <span class="built_in">yes</span>|no</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定主机地址，绑定本地IP地址，否则SSH无法访问：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> ip</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置服务器端口：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">port port</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置服务器文件保存地址：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span> path</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置数据库的数量：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">databases 16</span><br></pre></td></tr></table></figure>
</li>
<li><p>多服务器快捷配置：</p>
<p>导入并加载指定配置文件信息，用于快速创建 redis 公共配置较多的 redis 实例配置文件，便于维护</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">include /path/conf_name.conf</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul>
<li><p>服务器允许客户端连接最大数量，默认 0，表示无限制，当客户端连接到达上限后，Redis 会拒绝新的连接：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">maxclients count</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端闲置等待最大时长，达到最大值后关闭对应连接，如需关闭该功能，设置为 0：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">timeout</span> seconds</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h4><p>设置日志记录</p>
<ul>
<li><p>设置服务器以指定日志记录级别</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">loglevel debug|verbose|notice|warning</span><br></pre></td></tr></table></figure>
</li>
<li><p>日志记录文件名</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">logfile filename</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意：日志级别开发期设置为 verbose 即可，生产环境中配置为 notice，简化日志输出量，降低写日志 IO 的频度</p>
<p><strong>配置文件：</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> 192.168.2.185</span><br><span class="line">port 6379</span><br><span class="line"><span class="comment">#timeout 0</span></span><br><span class="line">daemonize no</span><br><span class="line">logfile /etc/redis/data/redis-6379.<span class="built_in">log</span></span><br><span class="line"><span class="built_in">dir</span> /etc/redis/data</span><br><span class="line">dbfilename <span class="string">&quot;dump-6379.rdb&quot;</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h4><p>帮助信息：</p>
<ul>
<li><p>获取命令帮助文档</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span> [<span class="built_in">command</span>]</span><br><span class="line"><span class="comment">#help set</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取组中所有命令信息名称</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span> [@group-name]</span><br><span class="line"><span class="comment">#help @string</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>退出服务</p>
<ul>
<li><p>退出客户端：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">quit</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>退出客户端服务器快捷键：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Ctrl+C</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="数据库-2"><a href="#数据库-2" class="headerlink" title="数据库"></a>数据库</h2><h3 id="服务器-1"><a href="#服务器-1" class="headerlink" title="服务器"></a>服务器</h3><p>Redis 服务器将所有数据库保存在<strong>服务器状态 redisServer 结构</strong>的 db 数组中，数组的每一项都是 redisDb 结构，代表一个数据库，每个数据库之间相互独立，**共用 **Redis 内存，不区分大小。在初始化服务器时，根据 dbnum 属性决定创建数据库的数量，该属性由服务器配置的 database 选项决定，默认 16</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 保存服务器所有的数据库</span></span><br><span class="line">    redisDB *db;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器数据库的数量</span></span><br><span class="line">    <span class="type">int</span> dbnum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-服务器数据库.png" style="zoom: 67%;">

<p><strong>在服务器内部</strong>，客户端状态 redisClient 结构的 db 属性记录了目标数据库，是一个指向 redisDb 结构的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录客户端正在使用的数据库，指向 redisServer.db 数组中的某一个 db</span></span><br><span class="line">    redisDB *db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个 Redis 客户端都有目标数据库，执行数据库读写命令时目标数据库就会成为这些命令的操作对象，默认情况下 Redis 客户端的目标数据库为 0 号数据库，客户端可以执行 SELECT 命令切换目标数据库，原理是通过修改 redisClient.db 指针指向服务器中不同数据库</p>
<p>命令操作：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">select index	<span class="comment">#切换数据库，index从0-15取值</span></span><br><span class="line">move key db		<span class="comment">#数据移动到指定数据库，db是数据库编号</span></span><br><span class="line">ping			<span class="comment">#测试数据库是否连接正常，返回PONG</span></span><br><span class="line"><span class="built_in">echo</span> message	<span class="comment">#控制台输出信息</span></span><br></pre></td></tr></table></figure>

<p>Redis 没有可以返回客户端目标数据库的命令，但是 redis-cli 客户端旁边会提示当前所使用的目标数据库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SELECT 1 </span><br><span class="line">OK </span><br><span class="line">redis[1]&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="键空间"><a href="#键空间" class="headerlink" title="键空间"></a>键空间</h3><h4 id="key-space"><a href="#key-space" class="headerlink" title="key space"></a>key space</h4><p>Redis 是一个键值对（key-value pair）数据库服务器，每个数据库都由一个 redisDb 结构表示，redisDb.dict <strong>字典中保存了数据库的所有键值对</strong>，将这个字典称为键空间（key space）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDB</span> &#123;</span></span><br><span class="line">    <span class="comment">// 数据库键空间，保存所有键值对</span></span><br><span class="line">    dict *dict</span><br><span class="line">&#125; redisDB;</span><br></pre></td></tr></table></figure>

<p>键空间和用户所见的数据库是直接对应的：</p>
<ul>
<li>键空间的键就是数据库的键，每个键都是一个字符串对象</li>
<li>键空间的值就是数据库的值，每个值可以是任意一种 Redis 对象</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%AE%E7%A9%BA%E9%97%B4.png"></p>
<p>当使用 Redis 命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会<strong>进行一些维护操作</strong>：</p>
<ul>
<li>在读取一个键后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中 hit 次数或键空间不命中 miss 次数，这两个值可以在 <code>INFO stats</code> 命令的 keyspace_hits 属性和 keyspace_misses 属性中查看</li>
<li>更新键的 LRU（最后使用）时间，该值可以用于计算键的闲置时间，使用 <code>OBJECT idletime key</code> 查看键 key 的闲置时间</li>
<li>如果在读取一个键时发现该键已经过期，服务器会<strong>先删除过期键</strong>，再执行其他操作</li>
<li>如果客户端使用 WATCH 命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务注意到这个键已经被修改过</li>
<li>服务器每次修改一个键之后，都会对 dirty 键计数器的值增1，该计数器会触发服务器的持久化以及复制操作</li>
<li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知</li>
</ul>
<hr>
<h4 id="读写指令"><a href="#读写指令" class="headerlink" title="读写指令"></a>读写指令</h4><p>常见键操作指令：</p>
<ul>
<li><p>增加指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">  <span class="built_in">set</span> key value				<span class="comment">#添加一个字符串类型的键值对</span></span><br><span class="line"></span><br><span class="line">* 删除指令</span><br><span class="line"></span><br><span class="line">  ```sh</span><br><span class="line">  del key						<span class="comment">#删除指定key</span></span><br><span class="line">  <span class="built_in">unlink</span> key   				<span class="comment">#非阻塞删除key，真正的删除会在后续异步操作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rename key newkey			<span class="comment">#改名</span></span><br><span class="line">renamenx key newkey			<span class="comment">#改名</span></span><br></pre></td></tr></table></figure>

<p>值得更新需要参看具体得 Redis 对象得操作方式，比如字符串对象执行 <code>SET key value</code> 就可以完成修改</p>
</li>
<li><p>查询指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">exists key					<span class="comment">#获取key是否存在</span></span><br><span class="line">randomkey					<span class="comment">#随机返回一个键</span></span><br><span class="line">keys pattern				<span class="comment">#查询key</span></span><br></pre></td></tr></table></figure>

<p>KEYS 命令需要<strong>遍历存储的键值对</strong>，操作延时高，一般不被建议用于生产环境中</p>
<p>查询模式规则：* 匹配任意数量的任意符号、? 配合一个任意符号、[] 匹配一个指定符号</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">keys *						<span class="comment">#查询所有key</span></span><br><span class="line">keys aa*					<span class="comment">#查询所有以aa开头</span></span><br><span class="line">keys *bb					<span class="comment">#查询所有以bb结尾</span></span><br><span class="line">keys ??cc					<span class="comment">#查询所有前面两个字符任意，后面以cc结尾 </span></span><br><span class="line">keys user:?					<span class="comment">#查询所有以user:开头，最后一个字符任意</span></span><br><span class="line">keys u[st]er:1				<span class="comment">#查询所有以u开头，以er:1结尾，中间包含一个字母，s或t</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>其他指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> key					<span class="comment">#获取key的类型</span></span><br><span class="line">dbsize						<span class="comment">#获取当前数据库的数据总量，即key的个数</span></span><br><span class="line">flushdb						<span class="comment">#清除当前数据库的所有数据(慎用)</span></span><br><span class="line">flushall					<span class="comment">#清除所有数据(慎用)</span></span><br></pre></td></tr></table></figure>

<p>在执行 FLUSHDB 这样的危险命令之前，最好先执行一个 SELECT 命令，保证当前所操作的数据库是目标数据库</p>
</li>
</ul>
<hr>
<h4 id="时效设置"><a href="#时效设置" class="headerlink" title="时效设置"></a>时效设置</h4><p>客户端可以以秒或毫秒的精度为数据库中的某个键设置生存时间（TimeTo Live, TTL），在经过指定时间之后，服务器就会自动删除生存时间为 0 的键；也可以以 UNIX 时间戳的方式设置过期时间（expire time），当键的过期时间到达，服务器会自动删除这个键</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">expire key seconds			<span class="comment">#为指定key设置生存时间，单位为秒</span></span><br><span class="line">pexpire key milliseconds	<span class="comment">#为指定key设置生存时间，单位为毫秒</span></span><br><span class="line">expireat key timestamp		<span class="comment">#为指定key设置过期时间，单位为时间戳</span></span><br><span class="line">pexpireat key mil-timestamp	<span class="comment">#为指定key设置过期时间，单位为毫秒时间戳</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实际上 EXPIRE、EXPIRE、EXPIREAT 三个命令<strong>底层都是转换为 PEXPIREAT 命令</strong>来实现的</li>
<li>SETEX 命令可以在设置一个字符串键的同时为键设置过期时间，但是该命令是一个类型限定命令</li>
</ul>
<p>redisDb 结构的 expires 字典保存了数据库中所有键的过期时间，字典称为过期字典：</p>
<ul>
<li>键是一个指针，指向键空间中的某个键对象（复用键空间的对象，不会产生内存浪费）</li>
<li>值是一个 long long 类型的整数，保存了键的过期时间，是一个毫秒精度的 UNIX 时间戳</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDB</span> &#123;</span></span><br><span class="line">    <span class="comment">// 过期字典，保存所有键的过期时间</span></span><br><span class="line">    dict *expires</span><br><span class="line">&#125; redisDB;</span><br></pre></td></tr></table></figure>

<p>客户端执行 PEXPIREAT 命令，服务器会在数据库的过期字典中关联给定的数据库键和过期时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">PEXPIREAT</span>(<span class="params">key, expire_time_in_ms</span>):</span><br><span class="line">	<span class="comment"># 如果给定的键不存在于键空间，那么不能设置过期时间</span></span><br><span class="line">	<span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> redisDb.<span class="built_in">dict</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment"># 在过期字典中关联键和过期时间</span></span><br><span class="line">	redisDB.expires[key] = expire_time_in_ms</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 过期时间设置成功</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="时效状态"><a href="#时效状态" class="headerlink" title="时效状态"></a>时效状态</h4><p>TTL 和 PTTL 命令通过计算键的过期时间和当前时间之间的差，返回这个键的剩余生存时间</p>
<ul>
<li>返回正数代表该数据在内存中还能存活的时间</li>
<li>返回 -1 代表永久性，返回 -2 代表键不存在</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ttl key			<span class="comment">#获取key的剩余时间，每次获取会自动变化(减小)，类似于倒计时</span></span><br><span class="line">pttl key		<span class="comment">#获取key的剩余时间，单位是毫秒，每次获取会自动变化(减小)</span></span><br></pre></td></tr></table></figure>

<p>PERSIST 是 PEXPIREAT 命令的反操作，在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">persist key		<span class="comment">#切换key从时效性转换为永久性</span></span><br></pre></td></tr></table></figure>

<p>Redis 通过过期字典可以检查一个给定键是否过期：</p>
<ul>
<li>检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间</li>
<li>检查当前 UNIX 时间戳是否大于键的过期时间：如果是那么键已经过期，否则键未过期</li>
</ul>
<p>补充：AOF、RDB 和复制功能对过期键的处理</p>
<ul>
<li>RDB ：<ul>
<li>生成 RDB 文件，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的 RDB 文件中</li>
<li>载入 RDB 文件，如果服务器以主服务器模式运行，那么在载入时会对键进行检查，过期键会被忽略；如果服务器以从服务器模式运行，会载入所有键，包括过期键，但是主从服务器进行数据同步时就会删除这些键</li>
</ul>
</li>
<li>AOF：<ul>
<li>写入 AOF 文件，如果数据库中的某个键已经过期，但还没有被删除，那么 AOF 文件不会因为这个过期键而产生任何影响；当该过期键被删除，程序会向 AOF 文件追加一条 DEL 命令，显式的删除该键</li>
<li>AOF 重写，会对数据库中的键进行检查，忽略已经过期的键</li>
</ul>
</li>
<li>复制：当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制<ul>
<li>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个 DEL 命令，告知从服务器删除这个过期键</li>
<li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，会当作未过期键处理，只有在接到主服务器发来的 DEL 命令之后，才会删除过期键（数据不一致）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="过期删除"><a href="#过期删除" class="headerlink" title="过期删除"></a>过期删除</h3><h4 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h4><p>删除策略就是<strong>针对已过期数据的处理策略</strong>，已过期的数据不一定被立即删除，在不同的场景下使用不同的删除方式会有不同效果，在内存占用与 CPU 占用之间寻找一种平衡，顾此失彼都会造成整体 Redis 性能的下降，甚至引发服务器宕机或内存泄露</p>
<p>针对过期数据有三种删除策略：</p>
<ul>
<li>定时删除</li>
<li>惰性删除</li>
<li>定期删除</li>
</ul>
<p>Redis 采用惰性删除和定期删除策略的结合使用</p>
<hr>
<h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><p>在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间到达时，立即执行对键的删除操作</p>
<ul>
<li>优点：节约内存，到时就删除，快速释放掉不必要的内存占用</li>
<li>缺点：对 CPU 不友好，无论 CPU 此时负载多高均占用 CPU，会影响 Redis 服务器响应时间和指令吞吐量</li>
<li>总结：用处理器性能换取存储空间（拿时间换空间）</li>
</ul>
<p>创建一个定时器需要用到 Redis 服务器中的时间事件，而时间事件的实现方式是无序链表，查找一个事件的时间复杂度为 O(N)，并不能高效地处理大量时间事件，所以采用这种方式并不现实</p>
<hr>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>数据到达过期时间不做处理，等下次访问到该数据时执行 <strong>expireIfNeeded()</strong> 判断：</p>
<ul>
<li>如果输入键已经过期，那么 expireIfNeeded 函数将输入键从数据库中删除，接着访问就会返回空</li>
<li>如果输入键未过期，那么 expireIfNeeded 函数不做动作</li>
</ul>
<p>所有的 Redis 读写命令在执行前都会调用 expireIfNeeded 函数进行检查，该函数就像一个过滤器，在命令真正执行之前过滤掉过期键</p>
<p>惰性删除的特点： </p>
<ul>
<li>优点：节约 CPU 性能，删除的目标仅限于当前处理的键，不会在删除其他无关的过期键上花费任何 CPU 时间</li>
<li>缺点：内存压力很大，出现长期占用内存的数据，如果过期键永远不被访问，这种情况相当于内存泄漏</li>
<li>总结：用存储空间换取处理器性能（拿空间换时间）</li>
</ul>
<hr>
<h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>定期删除策略是每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响</p>
<ul>
<li>如果删除操作执行得太频繁，或者执行时间太长，就会退化成定时删除策略，将 CPU 时间过多地消耗在删除过期键上</li>
<li>如果删除操作执行得太少，或者执行时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况</li>
</ul>
<p>定期删除是<strong>周期性轮询 Redis 库中的时效性</strong>数据，从过期字典中随机抽取一部分键检查，利用过期数据占比的方式控制删除频度</p>
<ul>
<li><p>Redis 启动服务器初始化时，读取配置 server.hz 的值，默认为 10，执行指令 info server 可以查看，每秒钟执行 server.hz 次 <code>serverCron() → activeExpireCycle()</code></p>
</li>
<li><p>activeExpireCycle() 对某个数据库中的每个 expires 进行检测，工作模式：</p>
<ul>
<li><p>轮询每个数据库，从数据库中取出一定数量的随机键进行检查，并删除其中的过期键</p>
</li>
<li><p>全局变量 current_db 用于记录 activeExpireCycle() 的检查进度（哪一个数据库），下一次调用时接着该进度处理</p>
</li>
<li><p>随着函数的不断执行，服务器中的所有数据库都会被检查一遍，这时将 current_db 重置为 0，然后再次开始新一轮的检查</p>
</li>
</ul>
</li>
</ul>
<p>定期删除特点：</p>
<ul>
<li>CPU 性能占用设置有峰值，检测频度可自定义设置</li>
<li>内存压力不是很大，长期占用内存的<strong>冷数据会被持续清理</strong></li>
<li>周期性抽查存储空间（随机抽查，重点抽查）</li>
</ul>
<hr>
<h3 id="数据淘汰"><a href="#数据淘汰" class="headerlink" title="数据淘汰"></a>数据淘汰</h3><h4 id="逐出算法"><a href="#逐出算法" class="headerlink" title="逐出算法"></a>逐出算法</h4><p>数据淘汰策略：当新数据进入 Redis 时，在执行每一个命令前，会调用 <strong>freeMemoryIfNeeded()</strong> 检测内存是否充足。如果内存不满足新加入数据的最低存储要求，Redis 要临时删除一些数据为当前指令清理存储空间，清理数据的策略称为<strong>逐出算法</strong></p>
<p>逐出数据的过程不是 100% 能够清理出足够的可使用的内存空间，如果不成功则反复执行，当对所有数据尝试完毕，如不能达到内存清理的要求，<strong>出现 Redis 内存打满异常</strong>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(error) OOM <span class="built_in">command</span> not allowed when used memory &gt;<span class="string">&#x27;maxmemory&#x27;</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="策略配置"><a href="#策略配置" class="headerlink" title="策略配置"></a>策略配置</h4><p>Redis 如果不设置最大内存大小或者设置最大内存大小为 0，在 64 位操作系统下不限制内存大小，在 32 位操作系统默认为 3GB 内存，一般推荐设置 Redis 内存为最大物理内存的四分之三</p>
<p>内存配置方式：</p>
<ul>
<li><p>通过修改文件配置（永久生效）：修改配置文件 maxmemory 字段，单位为字节</p>
</li>
<li><p>通过命令修改（重启失效）：</p>
<ul>
<li><p><code>config set maxmemory 104857600</code>：设置 Redis 最大占用内存为 100MB</p>
</li>
<li><p><code>config get maxmemory</code>：获取 Redis 最大占用内存</p>
</li>
<li><p><code>info</code> ：可以查看 Redis 内存使用情况，<code>used_memory_human</code> 字段表示实际已经占用的内存，<code>maxmemory</code> 表示最大占用内存</p>
</li>
</ul>
</li>
</ul>
<p>影响数据淘汰的相关配置如下，配置 conf 文件：</p>
<ul>
<li><p>每次选取待删除数据的个数，采用随机获取数据的方式作为待检测删除数据，防止全库扫描，导致严重的性能消耗，降低读写性能</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">maxmemory-samples count</span><br></pre></td></tr></table></figure>
</li>
<li><p>达到最大内存后的，对被挑选出来的数据进行删除的策略</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">maxmemory-policy policy</span><br></pre></td></tr></table></figure>

<p>数据删除的策略 policy：3 类 8 种</p>
<p>第一类：检测易失数据（可能会过期的数据集 server.db[i].expires）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">volatile-lru	<span class="comment"># 对设置了过期时间的 key 选择最近最久未使用使用的数据淘汰</span></span><br><span class="line">volatile-lfu	<span class="comment"># 对设置了过期时间的 key 选择最近使用次数最少的数据淘汰</span></span><br><span class="line">volatile-ttl	<span class="comment"># 对设置了过期时间的 key 选择将要过期的数据淘汰</span></span><br><span class="line">volatile-random	<span class="comment"># 对设置了过期时间的 key 选择任意数据淘汰</span></span><br></pre></td></tr></table></figure>

<p>第二类：检测全库数据（所有数据集 server.db[i].dict ）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">allkeys-lru		<span class="comment"># 对所有 key 选择最近最少使用的数据淘汰</span></span><br><span class="line">allkeLyRs-lfu	<span class="comment"># 对所有 key 选择最近使用次数最少的数据淘汰</span></span><br><span class="line">allkeys-random	<span class="comment"># 对所有 key 选择任意数据淘汰，相当于随机</span></span><br></pre></td></tr></table></figure>

<p>第三类：放弃数据驱逐</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">no-enviction	<span class="comment">#禁止驱逐数据(redis4.0中默认策略)，会引发OOM(Out Of Memory)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>数据淘汰策略配置依据：使用 INFO 命令输出监控信息，查询缓存 hit 和 miss 的次数，根据需求调优 Redis 配置</p>
<hr>
<h3 id="排序机制"><a href="#排序机制" class="headerlink" title="排序机制"></a>排序机制</h3><h4 id="基本介绍-11"><a href="#基本介绍-11" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Redis 的 SORT 命令可以对列表键、集合键或者有序集合键的值进行排序，并不更改集合中的数据位置，只是查询</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SORT key [ASC/DESC]			<span class="comment">#对key中数据排序，默认对数字排序，并不更改集合中的数据位置，只是查询</span></span><br><span class="line">SORT key ALPHA				<span class="comment">#对key中字母排序，按照字典序</span></span><br></pre></td></tr></table></figure>





<hr>
<h4 id="SORT"><a href="#SORT" class="headerlink" title="SORT"></a>SORT</h4><p><code>SORT &lt;key&gt;</code> 命令可以对一个包含数字值的键 key 进行排序</p>
<p>假设 <code>RPUSH numbers 3 1 2</code>，执行 <code>SORT numbers</code> 的详细步骤：</p>
<ul>
<li><p>创建一个和 key 列表长度相同的数组，数组每项都是 redisSortObject 结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisSortObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 被排序键的值</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 权重</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="comment">// 排序数字值时使用</span></span><br><span class="line">        <span class="type">double</span> score;</span><br><span class="line">        <span class="comment">// 排序带有 BY 选项的字符串</span></span><br><span class="line">        robj *cmpobj;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历数组，将各个数组项的 obj 指针分别指向 numbers 列表的各个项</p>
</li>
<li><p>遍历数组，将 obj 指针所指向的列表项转换成一个 double 类型的浮点数，并将浮点数保存在对应数组项的 u.score 属性里</p>
</li>
<li><p>根据数组项 u.score 属性的值，对数组进行数字值排序，排序后的数组项按 u.score 属性的值<strong>从小到大排列</strong></p>
</li>
<li><p>遍历数组，将各个数组项的 obj 指针所指向的值作为排序结果返回给客户端，程序首先访问数组的索引 0，依次向后访问</p>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-sort%E6%8E%92%E5%BA%8F.png"></p>
<p>对于 <code>SORT key [ASC/DESC]</code> 函数：</p>
<ul>
<li>在执行升序排序时，排序算法使用的对比函数产生升序对比结果</li>
<li>在执行降序排序时，排序算法使用的对比函数产生降序对比结果</li>
</ul>
<hr>
<h4 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h4><p>SORT 命令默认使用被排序键中包含的元素作为排序的权重，元素本身决定了元素在排序之后所处的位置，通过使用 BY 选项，SORT 命令可以指定某些字符串键，或者某个哈希键所包含的某些域（field）来作为元素的权重，对一个键进行排序</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SORT &lt;key&gt; BY &lt;pattern&gt;			<span class="comment"># 数值</span></span><br><span class="line">SORT &lt;key&gt; BY &lt;pattern&gt; ALPHA	<span class="comment"># 字符</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SADD fruits <span class="string">&quot;apple&quot;</span> <span class="string">&quot;banana&quot;</span> <span class="string">&quot;cherry&quot;</span> </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; SORT fruits ALPHA</span><br><span class="line">1)	<span class="string">&quot;apple&quot;</span></span><br><span class="line">2)	<span class="string">&quot;banana&quot;</span></span><br><span class="line">3)	<span class="string">&quot;cherry&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; MSET apple-price 8 banana-price 5.5 cherry-price 7 </span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 使用水果的价钱进行排序</span></span><br><span class="line">redis&gt; SORT fruits BY *-price</span><br><span class="line">1)	<span class="string">&quot;banana&quot;</span></span><br><span class="line">2)	<span class="string">&quot;cherry&quot;</span></span><br><span class="line">3)	<span class="string">&quot;apple&quot;</span></span><br></pre></td></tr></table></figure>

<p>实现原理：排序时的 u.score 属性就会被设置为对应的权重</p>
<hr>
<h4 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h4><p>SORT 命令默认会将排序后的所有元素都返回给客户端，通过 LIMIT 选项可以让 SORT 命令只返回其中一部分已排序的元素</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">LIMIT &lt;offset&gt; &lt;count&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>offset 参数表示要跳过的已排序元素数量</li>
<li>count 参数表示跳过给定数量的元素后，要返回的已排序元素数量</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对应 a b c d e f  g</span></span><br><span class="line">redis&gt; SORT alphabet ALPHA LIMIT 2 3</span><br><span class="line">1) 	<span class="string">&quot;c&quot;</span></span><br><span class="line">2) 	<span class="string">&quot;d&quot;</span></span><br><span class="line">3) 	<span class="string">&quot;e&quot;</span></span><br></pre></td></tr></table></figure>

<p>实现原理：在排序后的 redisSortObject 结构数组中，将指针移动到数组的索引 2 上，依次访问 array[2]、array[3]、array[4] 这 3 个数组项，并将数组项的 obj 指针所指向的元素返回给客户端</p>
<hr>
<h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>SORT 命令默认在对键进行排序后，返回被排序键本身所包含的元素，通过使用 GET 选项， 可以在对键进行排序后，根据被排序的元素以及 GET 选项所指定的模式，查找并返回某些键的值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SORT &lt;key&gt; GET &lt;pattern&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SADD students <span class="string">&quot;tom&quot;</span> <span class="string">&quot;jack&quot;</span> <span class="string">&quot;sea&quot;</span></span><br><span class="line"><span class="comment">#设置全名</span></span><br><span class="line">redis&gt; SET tom-name <span class="string">&quot;Tom Li&quot;</span> </span><br><span class="line">OK </span><br><span class="line">redis&gt; SET jack-name <span class="string">&quot;Jack Wang&quot;</span> </span><br><span class="line">OK </span><br><span class="line">redis&gt; SET sea-name <span class="string">&quot;Sea Zhang&quot;</span></span><br><span class="line">OK </span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SORT students ALPHA GET *-name</span><br><span class="line">1)	<span class="string">&quot;Jack Wang&quot;</span></span><br><span class="line">2)	<span class="string">&quot;Sea Zhang&quot;</span></span><br><span class="line">3) 	<span class="string">&quot;Tom Li&quot;</span></span><br></pre></td></tr></table></figure>

<p>实现原理：对 students 进行排序后，对于 jack 元素和 *-name 模式，查找程序返回键 jack-name，然后获取 jack-name 键对应的值</p>
<hr>
<h4 id="STORE"><a href="#STORE" class="headerlink" title="STORE"></a>STORE</h4><p>SORT 命令默认只向客户端返回排序结果，而不保存排序结果，通过使用 STORE 选项可以将排序结果保存在指定的键里面</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SORT &lt;key&gt; STORE &lt;sort_key&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SADD students <span class="string">&quot;tom&quot;</span> <span class="string">&quot;jack&quot;</span> <span class="string">&quot;sea&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3 </span><br><span class="line">redis&gt; SORT students ALPHA STORE sorted_students </span><br><span class="line">(<span class="built_in">integer</span>) 3 </span><br></pre></td></tr></table></figure>

<p>实现原理：排序后，检查 sorted_students 键是否存在，如果存在就删除该键，设置 sorted_students 为空白的列表键，遍历排序数组将元素依次放入</p>
<hr>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>调用 SORT 命令，除了 GET 选项之外，改变其他选项的摆放顺序并不会影响命令执行选项的顺序</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SORT &lt;key&gt; ALPHA [ASC/DESC] BY &lt;by-pattern&gt; LIMIT &lt;offset&gt; &lt;count&gt; GET &lt;get-pattern&gt; STORE &lt;store_key&gt;</span><br></pre></td></tr></table></figure>

<p>执行顺序：</p>
<ul>
<li>排序：命令会使用 ALPHA 、ASC 或 DESC、BY 这几个选项，对输入键进行排序，并得到一个排序结果集</li>
<li>限制排序结果集的长度：使用 LIMIT 选项，对排序结果集的长度进行限制</li>
<li>获取外部键：根据排序结果集中的元素以及 GET 选项指定的模式，查找并获取指定键的值，并用这些值来作为新的排序结果集</li>
<li>保存排序结果集：使用 STORE 选项，将排序结果集保存到指定的键上面去</li>
<li>向客户端返回排序结果集：最后一步命令遍历排序结果集，并依次向客户端返回排序结果集中的元素</li>
</ul>
<hr>
<h3 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h3><p>数据库通知是可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况</p>
<ul>
<li>关注某个键执行了什么命令的通知称为键空间通知（key-space notification）</li>
<li>关注某个命令被什么键执行的通知称为键事件通知（key-event notification）</li>
</ul>
<p>图示订阅 0 号数据库 message 键：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-数据库通知.png" style="zoom: 67%;">

<p>服务器配置的 notify-keyspace-events 选项决定了服务器所发送通知的类型</p>
<ul>
<li>AKE 代表服务器发送所有类型的键空间通知和键事件通知</li>
<li>AK 代表服务器发送所有类型的键空间通知</li>
<li>AE 代表服务器发送所有类型的键事件通知</li>
<li>K$ 代表服务器只发送和字符串键有关的键空间通知</li>
<li>EL 代表服务器只发送和列表键有关的键事件通知</li>
<li>…..</li>
</ul>
<p>发送数据库通知的功能是由 notifyKeyspaceEvent 函数实现的：</p>
<ul>
<li>如果给定的通知类型 type 不是服务器允许发送的通知类型，那么函数会直接返回</li>
<li>如果给定的通知是服务器允许发送的通知<ul>
<li>检测服务器是否允许发送键空间通知，允许就会构建并发送事件通知</li>
<li>检测服务器是否允许发送键事件通知，允许就会构建并发送事件通知</li>
</ul>
</li>
</ul>
<hr>
<h2 id="体系架构-1"><a href="#体系架构-1" class="headerlink" title="体系架构"></a>体系架构</h2><h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><h4 id="基本介绍-12"><a href="#基本介绍-12" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Redis 服务器是一个事件驱动程序，服务器需要处理两类事件</p>
<ul>
<li>文件事件 (file event)：服务器通过套接字与客户端（或其他 Redis 服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端的通信会产生相应的文件事件，服务器通过监听并处理这些事件完成一系列网络通信操作</li>
<li>时间事件 (time event)：Redis 服务器中的一些操作（比如 serverCron 函数）需要在指定时间执行，而时间事件就是服务器对这类定时操作的抽象</li>
</ul>
<hr>
<h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><h5 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h5><p>Redis 基于 Reactor 模式开发了网络事件处理器，这个处理器被称为文件事件处理器 (file event handler)</p>
<ul>
<li><p>使用 I&#x2F;O 多路复用 (multiplexing) 程序来同时监听多个套接字，并根据套接字执行的任务来为套接字关联不同的事件处理器</p>
</li>
<li><p>当被监听的套接字准备好执行连接应答 (accept)、 读取 (read)、 写入 (write)、 关闭 (close) 等操作时，与操作相对应的文件事件就会产生，这时文件事件分派器会调用套接字关联好的事件处理器来处理事件</p>
</li>
</ul>
<p>文件事件处理器<strong>以单线程方式运行</strong>，但通过使用  I&#x2F;O 多路复用程序来监听多个套接字， 既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，保持了 Redis 内部单线程设计的简单性</p>
<p>文件事件处理器的组成结构：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-文件事件处理器.png" style="zoom:80%;">

<p>尽管多个文件事件可能会并发出现，但是 I&#x2F;O 多路复用程序将所有产生事件的套接字处理请求放入一个<strong>单线程的执行队列</strong>中，通过队列有序、同步的向文件事件分派器传送套接字，上一个套接字产生的事件处理完后，才会继续向分派器传送下一个</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-IO多路复用程序.png" style="zoom: 67%;">

<p>Redis 单线程也能高效的原因：</p>
<ul>
<li>纯内存操作</li>
<li>核心是基于非阻塞的 IO 多路复用机制，单线程可以高效处理多个请求</li>
<li>底层使用 C 语言实现，C 语言实现的程序距离操作系统更近，执行速度相对会更快</li>
<li>单线程同时也<strong>避免了多线程的上下文频繁切换问题</strong>，预防了多线程可能产生的竞争问题</li>
</ul>
<hr>
<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>Redis 的 I&#x2F;O 多路复用程序的所有功能都是通过包装常见的 select 、epoll、 evport 和 kqueue 这些函数库来实现的，Redis 在 I&#x2F;O 多路复用程序的实现源码中用 #include 宏定义了相应的规则，编译时自动选择系统中<strong>性能最高的多路复用函数</strong>来作为底层实现</p>
<p>I&#x2F;O 多路复用程序监听多个套接字的 AE_READABLE 事件和 AE_WRITABLE 事件，这两类事件和套接字操作之间的对应关系如下：</p>
<ul>
<li>当套接字变得<strong>可读</strong>时（客户端对套接字执行 write 操作或者 close 操作），或者有新的<strong>可应答</strong>（acceptable）套接字出现时（客户端对服务器的监听套接字执行 connect 连接操作），套接字产生 AE_READABLE 事件</li>
<li>当套接字变得可写时（客户端对套接字执行 read 操作，对于服务器来说就是可以写了），套接字产生 AE_WRITABLE 事件</li>
</ul>
<p>I&#x2F;O 多路复用程序允许服务器同时监听套接字的 AE_READABLE 和 AE_WRITABLE 事件， 如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理 AE_READABLE  事件， 等 AE_READABLE 事件处理完之后才处理 AE_WRITABLE 事件</p>
<hr>
<h5 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h5><p>Redis 为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求：</p>
<ul>
<li>连接应答处理器，用于对连接服务器的各个客户端进行应答，Redis 服务器初始化时将该处理器与 AE_READABLE 事件关联</li>
<li>命令请求处理器，用于接收客户端传来的命令请求，执行套接字的读入操作，与 AE_READABLE 事件关联</li>
<li>命令回复处理器，用于向客户端返回命令的执行结果，执行套接字的写入操作，与 AE_WRITABLE 事件关联</li>
<li>复制处理器，当主服务器和从服务器进行复制操作时，主从服务器都需要关联该处理器</li>
</ul>
<p>Redis 客户端与服务器进行连接并发送命令的整个过程：</p>
<ul>
<li>Redis 服务器正在运作监听套接字的 AE_READABLE 事件，关联连接应答处理器</li>
<li>当 Redis 客户端向服务器发起连接，监听套接字将产生 AE_READABLE 事件，触发连接应答处理器执行，对客户端的连接请求进行应答，创建客户端套接字以及客户端状态，并将客户端套接字的 <strong>AE_READABLE 事件与命令请求处理器</strong>进行关联</li>
<li>客户端向服务器发送命令请求，客户端套接字产生 AE_READABLE 事件，引发命令请求处理器执行，读取客户端的命令内容传给相关程序去执行</li>
<li>执行命令会产生相应的命令回复，为了将这些命令回复传送回客户端，服务器会将客户端套接字的 <strong>AE_WRITABLE 事件与命令回复处理器</strong>进行关联</li>
<li>当客户端尝试读取命令回复时，客户端套接字产生 AE_WRITABLE 事件，触发命令回复处理器执行，在命令回复全部写入套接字后，服务器就会解除客户端套接字的 AE_WRITABLE 事件与命令回复处理器之间的关联</li>
</ul>
<hr>
<h4 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h4><p>Redis 的时间事件分为以下两类：</p>
<ul>
<li>定时事件：在指定的时间之后执行一次（Redis 中暂时未使用）</li>
<li>周期事件：每隔指定时间就执行一次</li>
</ul>
<p>一个时间事件主要由以下三个属性组成：</p>
<ul>
<li>id：服务器为时间事件创建的全局唯一 ID（标识号），从小到大顺序递增，新事件的 ID 比旧事件的 ID 号要大</li>
<li>when：毫秒精度的 UNIX 时间戳，记录了时间事件的到达（arrive）时间</li>
<li>timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理事件</li>
</ul>
<p>时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值：</p>
<ul>
<li>定时事件：事件处理器返回 AE_NOMORE，该事件在到达一次后就会被删除</li>
<li>周期事件：事件处理器返回非 AE_NOMORE 的整数值，服务器根据该值对事件的 when 属性更新，让该事件在一段时间后再次交付</li>
</ul>
<p>服务器将所有时间事件都放在一个<strong>无序链表</strong>中，新的时间事件插入到链表的表头：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-时间事件.png" style="zoom:67%;">

<p>无序链表指是链表不按 when 属性的大小排序，每当时间事件执行器运行时就必须遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器处理</p>
<p>无序链表并不影响时间事件处理器的性能，因为正常模式下的 Redis 服务器<strong>只使用 serverCron 一个时间事件</strong>，在 benchmark 模式下服务器也只使用两个时间事件，所以无序链表不会影响服务器的性能，几乎可以按照一个指针处理</p>
<p>服务器 → serverCron 详解该时间事件 </p>
<hr>
<h4 id="事件调度"><a href="#事件调度" class="headerlink" title="事件调度"></a>事件调度</h4><p>服务器中同时存在文件事件和时间事件两种事件类型，调度伪代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 事件调度伪代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aeProcessEvents</span>():</span><br><span class="line">	<span class="comment"># 获取到达时间离当前时间最接近的时间事件 </span></span><br><span class="line">    time_event = aeSearchNearestTime()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算最接近的时间事件距离到达还有多少亳秒</span></span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line">    <span class="comment"># 如果事件已到达，那么 remaind_ms 的值可能为负数，设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line">        remaind_ms = <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment"># 根据 remaind_ms 的值，创建 timeval 结构</span></span><br><span class="line">	timeval = create_timeval_with_ms(remaind_ms) </span><br><span class="line">    <span class="comment"># 【阻塞并等待文件事件】产生，最大阻塞时间由传入的timeval结构决定，remaind_ms的值为0时调用后马上返回，不阻塞</span></span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理所有已产生的文件事件</span></span><br><span class="line">	processFileEvents() </span><br><span class="line">	<span class="comment"># 处理所有已到达的时间事件</span></span><br><span class="line">	processTimeEvents()</span><br></pre></td></tr></table></figure>

<p>事件的调度和执行规则：</p>
<ul>
<li>aeApiPoll 函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，可以避免服务器对时间事件进行频繁的轮询（忙等待），也可以确保 aeApiPoll 函数不会阻塞过长时间</li>
<li>对文件事件和时间事件的处理都是<strong>同步、有序、原子地执行</strong>，服务器不会中途中断事件处理，也不会对事件进行抢占，所以两种处理器都要尽可地减少程序的阻塞时间，并在有需要时<strong>主动让出执行权</strong>，从而降低事件饥饿的可能性<ul>
<li>命令回复处理器在写入字节数超过了某个预设常量，就会主动用 break 跳出写入循环，将余下的数据留到下次再写</li>
<li>时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行</li>
</ul>
</li>
<li>时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间通常会比设定的到达时间稍晚</li>
</ul>
<hr>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，因为这是 Redis 的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络），多线程只是用来<strong>处理网络数据的读写和协议解析</strong>， 执行命令仍然是单线程顺序执行，因此不需要担心线程安全问题。</p>
<p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 <code>redis.conf</code> ：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">io-threads-do-reads yesCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>开启多线程后，还需要设置线程数，否则是不生效的，同样需要修改 redis 配置文件 :</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">io-threads 4 <span class="comment">#官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span></span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-多线程.png" style="zoom:80%;">



<p>参考文章：<a href="https://mp.weixin.qq.com/s/dqmiR0ECf4lB6Y2OyK-dyA">https://mp.weixin.qq.com/s/dqmiR0ECf4lB6Y2OyK-dyA</a></p>
<hr>
<h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><h4 id="基本介绍-13"><a href="#基本介绍-13" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Redis 服务器是典型的一对多程序，一个服务器可以与多个客户端建立网络连接，服务器对每个连接的客户端建立了相应的 redisClient 结构（客户端状态，<strong>在服务器端的存储结构</strong>），保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构</p>
<p>Redis 服务器状态结构的 clients 属性是一个链表，这个链表保存了所有与服务器连接的客户端的状态结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 一个链表，保存了所有客户端状态</span></span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%9C%8D%E5%8A%A1%E5%99%A8clients%E9%93%BE%E8%A1%A8.png"></p>
<hr>
<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="redisClient"><a href="#redisClient" class="headerlink" title="redisClient"></a>redisClient</h5><p>客户端的数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 套接字</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    robj *name;</span><br><span class="line">    <span class="comment">// 标志</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入缓冲区</span></span><br><span class="line">    sds querybuf;</span><br><span class="line">    <span class="comment">// 输出缓冲区 buf 数组</span></span><br><span class="line">    <span class="type">char</span> buf[REDIS_REPLY_CHUNK_BYTES];</span><br><span class="line">    <span class="comment">// 记录了 buf 数组目前已使用的字节数量</span></span><br><span class="line">    <span class="type">int</span> bufpos; </span><br><span class="line">    <span class="comment">// 可变大小的输出缓冲区，链表 + 字符串对象</span></span><br><span class="line">    <span class="built_in">list</span> *reply;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 命令数组</span></span><br><span class="line">    rboj **argv;</span><br><span class="line">    <span class="comment">// 命令数组的长度</span></span><br><span class="line">   	<span class="type">int</span> argc;</span><br><span class="line">    <span class="comment">// 命令的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span>  *<span class="title">cmd</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否通过身份验证</span></span><br><span class="line">    <span class="type">int</span> authenticated;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建客户端的时间</span></span><br><span class="line">    <span class="type">time_t</span> ctime;</span><br><span class="line">    <span class="comment">// 客户端与服务器最后一次进行交互的时间</span></span><br><span class="line">    <span class="type">time_t</span> lastinteraction;</span><br><span class="line">    <span class="comment">// 输出缓冲区第一次到达软性限制 (soft limit) 的时间</span></span><br><span class="line">    <span class="type">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端状态包括两类属性</p>
<ul>
<li>一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，都要用到这些属性</li>
<li>另一类是和特定功能相关的属性，比如操作数据库时用到的 db 属性和 dict id 属性，执行事务时用到的 mstate 属性，以及执行 WATCH 命令时用到的 watched_keys 属性等，代码中没有列出</li>
</ul>
<hr>
<h5 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h5><p>客户端状态的 fd 属性记录了客户端正在使用的套接字描述符，根据客户端类型的不同，fd 属性的值可以是 -1 或者大于 -1 的整数：</p>
<ul>
<li>伪客户端 (fake client) 的 fd 属性的值为 -1，命令请求来源于 AOF 文件或者 Lua 脚本，而不是网络，所以不需要套接字连接</li>
<li>普通客户端的 fd 属性的值为大于 -1 的整数，因为合法的套接字描述符不能是 -1</li>
</ul>
<p>执行 <code>CLIENT list</code> 命令可以列出目前所有连接到服务器的普通客户端，不包括伪客户端</p>
<hr>
<h5 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h5><p>在默认情况下，一个连接到服务器的客户端是没有名字的，使用 <code>CLIENT setname</code> 命令可以为客户端设置一个名字</p>
<hr>
<h5 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h5><p>客户端的标志属性 flags 记录了客户端的角色以及客户端目前所处的状态，每个标志使用一个常量表示</p>
<ul>
<li>flags 的值可以是单个标志：<code>flags = &lt;flag&gt; </code></li>
<li>flags 的值可以是多个标志的二进制：<code>flags = &lt;flagl&gt; | &lt;flag2&gt; | ... </code></li>
</ul>
<p>一部分标志记录<strong>客户端的角色</strong>：</p>
<ul>
<li>REDIS_MASTER 表示客户端是一个从服务器，REDIS_SLAVE 表示客户端是一个从服务器，在主从复制时使用</li>
<li>REDIS_PRE_PSYNC 表示客户端是一个版本低于 Redis2.8 的从服务器，主服务器不能使用 PSYNC 命令与该从服务器进行同步，这个标志只能在 REDIS_ SLAVE 标志处于打开状态时使用</li>
<li>REDIS_LUA_CLIENT 表示客户端是专门用于处理 Lua 脚本里面包含的 Redis 命令的伪客户端</li>
</ul>
<p>一部分标志记录目前<strong>客户端所处的状态</strong>：</p>
<ul>
<li>REDIS_UNIX_SOCKET 表示服务器使用 UNIX 套接字来连接客户端</li>
<li>REDIS_BLOCKED 表示客户端正在被 BRPOP、BLPOP 等命令阻塞</li>
<li>REDIS_UNBLOCKED 表示客户端已经从 REDIS_BLOCKED 所表示的阻塞状态脱离，在 REDIS_BLOCKED 标志打开的情况下使用</li>
<li>REDIS_MULTI 标志表示客户端正在执行事务</li>
<li>REDIS_DIRTY_CAS 表示事务使用 WATCH 命令监视的数据库键已经被修改</li>
<li>…..</li>
</ul>
<hr>
<h5 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h5><p>客户端状态的输入缓冲区用于保存客户端发送的命令请求，输入缓冲区的大小会根据输入内容动态地缩小或者扩大，但最大大小不能超过 1GB，否则服务器将关闭这个客户端，比如执行 <code>SET key value </code>，那么缓冲区 querybuf 的内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">*3\r\n<span class="variable">$3</span>\r\nSET\r\n<span class="variable">$3</span>\r\nkey\r\n<span class="variable">$5</span>\r\nvalue\r\n <span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p>输出缓冲区是服务器用于保存执行客户端命令所得的命令回复，每个客户端都有两个输出缓冲区可用：</p>
<ul>
<li>一个是固定大小的缓冲区，保存长度比较小的回复，比如 OK、简短的字符串值、整数值、错误回复等</li>
<li>一个是可变大小的缓冲区，保存那些长度比较大的回复， 比如一个非常长的字符串值或者一个包含了很多元素的集合等</li>
</ul>
<p>buf 是一个大小为 REDIS_REPLY_CHUNK_BYTES (常量默认 16*1024 &#x3D; 16KB) 字节的字节数组，bufpos 属性记录了 buf 数组目前已使用的字节数量，当 buf 数组的空间已经用完或者回复数据太大无法放进 buf 数组里，服务器就会开始使用可变大小的缓冲区</p>
<p>通过使用 reply 链表连接多个字符串对象，可以为客户端保存一个非常长的命令回复，而不必受到固定大小缓冲区 16KB 大小的限制</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8F%AF%E5%8F%98%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA.png"></p>
<hr>
<h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><p>服务器对 querybuf 中的命令请求的内容进行分析，得出的命令参数以及参数的数量分别保存到客户端状态的 argv 和 argc 属性</p>
<ul>
<li>argv 属性是一个数组，数组中的每项都是字符串对象，其中 argv[0] 是要执行的命令，而之后的其他项则是命令的参数</li>
<li>argc 属性负责记录 argv 数组的长度</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-命令数组.png" style="zoom: 67%;">

<p>服务器将根据项 argv[0] 的值，在命令表中查找命令所对应的命令的 redisCommand，将客户端状态的 cmd 指向该结构</p>
<p>命令表是一个字典结构，键是 SDS 结构保存命令的名字；值是命令所对应的 redisCommand 结构，保存了命令的实现函数、命令标志、 命令应该给定的参数个数、命令的总执行次数和总消耗时长等统计信息</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-命令查找.png" style="zoom:67%;">



<hr>
<h5 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h5><p>客户端状态的 authenticated 属性用于记录客户端是否通过了身份验证</p>
<ul>
<li>authenticated 值为 0，表示客户端未通过身份验证</li>
<li>authenticated 值为 1，表示客户端已通过身份验证</li>
</ul>
<p>当客户端 authenticated &#x3D; 0 时，除了 AUTH 命令之外， 客户端发送的所有其他命令都会被服务器拒绝执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; PING </span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">redis&gt; AUTH 123321 </span><br><span class="line">OK</span><br><span class="line">redis&gt; PING </span><br><span class="line">PONG </span><br></pre></td></tr></table></figure>



<hr>
<h5 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h5><p>ctime 属性记录了创建客户端的时间，这个时间可以用来计算客户端与服务器已经连接了多少秒，<code>CLIENT list</code> 命令的 age 域记录了这个秒数</p>
<p>lastinteraction 属性记录了客户端与服务器最后一次进行互动 (interaction) 的时间，互动可以是客户端向服务器发送命令请求，也可以是服务器向客户端发送命令回复。该属性可以用来计算客户端的空转 (idle) 时长， 就是距离客户端与服务器最后一次进行互动已经过去了多少秒，<code>CLIENT list</code> 命令的 idle 域记录了这个秒数</p>
<p>obuf_soft_limit_reached_time 属性记录了<strong>输出缓冲区第一次到达软性限制</strong> (soft limit) 的时间</p>
<hr>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p>服务器使用不同的方式来创建和关闭不同类型的客户端</p>
<p>如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端使用 connect 函数连接到服务器时，服务器就会调用连接应答处理器为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构 clients 链表的末尾</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%9C%8D%E5%8A%A1%E5%99%A8clients%E9%93%BE%E8%A1%A8.png"></p>
<p>服务器会在初始化时创建负责执行 Lua 脚本中包含的 Redis 命令的伪客户端，并将伪客户端关联在服务器状态的 lua_client 属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 保存伪客户端</span></span><br><span class="line">    redisClient *lua_client；</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>lua_client 伪客户端在服务器运行的整个生命周期会一直存在，只有服务器被关闭时，这个客户端才会被关闭</p>
<p>载入 AOF 文件时， 服务器会创建用于执行 AOF 文件包含的 Redis 命令的伪客户端，并在载入完成之后，关闭这个伪客户端</p>
<hr>
<h5 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h5><p>一个普通客户端可以因为多种原因而被关闭：</p>
<ul>
<li>客户端进程退出或者被杀死，那么客户端与服务器之间的网络连接将被关闭，从而造成客户端被关闭</li>
<li>客户端向服务器发送了带有不符合协议格式的命令请求，那么这个客户端会<strong>被服务器关闭</strong></li>
<li>客户端是 <code>CLIENT KILL</code> 命令的目标</li>
<li>如果用户为服务器设置了 timeout 配置选项，那么当客户端的空转时间超过该值时将被关闭，特殊情况不会被关闭：<ul>
<li>客户端是主服务器（REDIS_MASTER ）或者从服务器（打开了 REDIS_SLAVE 标志）</li>
<li>正在被 BLPOP 等命令阻塞（REDIS_BLOCKED）</li>
<li>正在执行 SUBSCRIBE、PSUBSCRIBE 等订阅命令</li>
</ul>
</li>
<li>客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为 1GB）</li>
<li>发送给客户端的命令回复的大小超过了输出缓冲区的限制大小</li>
</ul>
<p>理论上来说，可变缓冲区可以保存任意长的命令回复，但是为了回复过大占用过多的服务器资源，服务器会时刻检查客户端的输出缓冲区的大小，并在缓冲区的大小超出范围时，执行相应的限制操作：</p>
<ul>
<li>硬性限制 (hard limit)：输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器会关闭客户端（serverCron 函数中执行），积存在输出缓冲区中的所有内容会被<strong>直接释放</strong>，不会返回给客户端</li>
<li>软性限制 (soft limit)：输出缓冲区的大小超过了软性限制所设置的大小，小于硬性限制的大小，服务器的操作：<ul>
<li>用属性 obuf_soft_limit_reached_time 记录下客户端到达软性限制的起始时间，继续监视客户端</li>
<li>如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端</li>
<li>如果在指定时间内不再超出软性限制，那么客户端就不会被关闭，并且 o_s_l_r_t 属性清零</li>
</ul>
</li>
</ul>
<p>使用 client-output-buffer-limit 选项可以为普通客户端、从服务器客户端、执行发布与订阅功能的客户端分别设置不同的软性限制和硬性限制，格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">client-output-buffer-limit &lt;class&gt; &lt;hard <span class="built_in">limit</span>&gt; &lt;soft <span class="built_in">limit</span>&gt; &lt;soft seconds&gt;</span><br><span class="line"></span><br><span class="line">client-output-buffer-limit normal 0 0 0 </span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60 </span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行：将普通客户端的硬性限制和软性限制都设置为 0，表示不限制客户端的输出缓冲区大小</li>
<li>第二行：将从服务器客户端的硬性限制设置为 256MB，软性限制设置为 64MB，软性限制的时长为 60 秒</li>
<li>第三行：将执行发布与订阅功能的客户端的硬性限制设置为 32MB，软性限制设置为 8MB，软性限制的时长为 60 秒</li>
</ul>
<hr>
<h3 id="服务器-2"><a href="#服务器-2" class="headerlink" title="服务器"></a>服务器</h3><h4 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h4><p>Redis 服务器与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转，所以一个命令请求从发送到获得回复的过程中，客户端和服务器需要完成一系列操作</p>
<h5 id="命令请求"><a href="#命令请求" class="headerlink" title="命令请求"></a>命令请求</h5><p>Redis 服务器的命令请求来自 Redis 客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，通过连接到服务器的套接字，将协议格式的命令请求发送给服务器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SET KEY VALUE -&gt;	<span class="comment"># 命令</span></span><br><span class="line">*3\r\nS3\r\nSET\r\n<span class="variable">$3</span>\r\nKEY\r\n<span class="variable">$5</span>\r\nVALUE\r\n	<span class="comment"># 协议格式</span></span><br></pre></td></tr></table></figure>

<p>当客户端与服务器之间的连接套接字因为客户端的写入而变得可读，服务器调用<strong>命令请求处理器</strong>来执行以下操作：</p>
<ul>
<li>读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面</li>
<li>对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的 argv 属性和 argc 属性里</li>
<li>调用命令执行器，执行客户端指定的命令</li>
</ul>
<p>最后客户端接收到协议格式的命令回复之后，会将这些回复转换成用户可读的格式打印给用户观看，至此整体流程结束</p>
<hr>
<h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h5><p>命令执行器开始对命令操作：</p>
<ul>
<li><p>查找命令：首先根据客户端状态的 argv[0] 参数，在<strong>命令表 (command table)</strong> 中查找参数所指定的命令，并将找到的命令保存到客户端状态的 cmd 属性里面，是一个 redisCommand 结构</p>
<p>命令查找算法与字母的大小写无关，所以命令名字的大小写不影响命令表的查找结果</p>
</li>
<li><p>执行预备操作：</p>
<ul>
<li>检查客户端状态的 cmd 指针是否指向 NULL，根据 redisCommand 检查请求参数的数量是否正确</li>
<li>检查客户端是否通过身份验证</li>
<li>如果服务器打开了 maxmemory 功能，执行命令之前要先检查服务器的内存占用，在有需要时进行内存回收（<strong>逐出算法</strong>）</li>
<li>如果服务器上一次执行 BGSAVE 命令出错，并且服务器打开了 stop-writes-on-bgsave-error 功能，那么如果本次执行的是写命令，服务会拒绝执行，并返回错误</li>
<li>如果客户端当前正在用 SUBSCRIBE 或 PSUBSCRIBE 命令订阅频道，那么服务器会拒绝除了 SUBSCRIBE、SUBSCRIBE、 UNSUBSCRIBE、PUNSUBSCRIBE 之外的其他命令</li>
<li>如果服务器正在进行载入数据，只有 sflags 带有 1 标识（比如 INFO、SHUTDOWN、PUBLISH等）的命令才会被执行</li>
<li>如果服务器执行 Lua 脚本而超时并进入阻塞状态，那么只会执行客户端发来的 SHUTDOWN nosave 和 SCRIPT KILL 命令</li>
<li>如果客户端正在执行事务，那么服务器只会执行客户端发来的 EXEC、DISCARD、MULTI、WATCH 四个命令，其他命令都会被<strong>放进事务队列</strong>中</li>
<li>如果服务器打开了监视器功能，那么会将要执行的命令和参数等信息发送给监视器</li>
</ul>
</li>
<li><p>调用命令的实现函数：被调用的函数会执行指定的操作并产生相应的命令回复，回复会被保存在客户端状态的输出缓冲区里面（buf 和 reply 属性），然后实现函数还会<strong>为客户端的套接字关联命令回复处理器</strong>，这个处理器负责将命令回复返回给客户端</p>
</li>
<li><p>执行后续工作：</p>
<ul>
<li>如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志</li>
<li>根据执行命令所耗费的时长，更新命令的 redisCommand 结构的 milliseconds 属性，并将命令 calls 计数器的值增一</li>
<li>如果服务器开启了 AOF 持久化功能，那么 AOF 持久化模块会将执行的命令请求写入到 AOF 缓冲区里面</li>
<li>如果有其他从服务器正在复制当前这个服务器，那么服务器会将执行的命令传播给所有从服务器</li>
</ul>
</li>
<li><p>将命令回复发送给客户端：客户端<strong>套接字变为可写状态</strong>时，服务器就会执行命令回复处理器，将客户端输出缓冲区中的命令回复发送给客户端，发送完毕之后回复处理器会清空客户端状态的输出缓冲区，为处理下一个命令请求做好准备</p>
</li>
</ul>
<hr>
<h5 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h5><p>每个 redisCommand 结构记录了一个Redis 命令的实现信息，主要属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> &#123;</span></span><br><span class="line">    <span class="comment">// 命令的名字，比如&quot;set&quot;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数指针，指向命令的实现函数，比如setCommand</span></span><br><span class="line">    <span class="comment">// redisCommandProc 类型的定义为 typedef void redisCommandProc(redisClient *c)</span></span><br><span class="line">    redisCommandProc *proc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 命令参数的个数，用于检查命令请求的格式是否正确。如果这个值为负数-N, 那么表示参数的数量大于等于N。</span></span><br><span class="line">    <span class="comment">// 注意命令的名字本身也是一个参数，比如 SET msg &quot;hello&quot;，命令的参数是&quot;SET&quot;、&quot;msg&quot;、&quot;hello&quot; 三个</span></span><br><span class="line">	<span class="type">int</span> arity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串形式的标识值，这个值记录了命令的属性，，</span></span><br><span class="line">    <span class="comment">// 比如这个命令是写命令还是读命令，这个命令是否允许在载入数据时使用，是否允许在Lua脚本中使用等等</span></span><br><span class="line">    <span class="type">char</span> *sflags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对sflags标识进行分析得出的二进制标识，由程序自动生成。服务器对命令标识进行检查时使用的都是 flags 属性</span></span><br><span class="line">    <span class="comment">// 而不是sflags属性，因为对二进制标识的检查可以方便地通过&amp; ^ ~ 等操作来完成</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器总共执行了多少次这个命令</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> calls;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器执行这个命令所耗费的总时长</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> milliseconds;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="serverCron"><a href="#serverCron" class="headerlink" title="serverCron"></a>serverCron</h4><h5 id="基本介绍-14"><a href="#基本介绍-14" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>Redis 服务器以周期性事件的方式来运行 serverCron 函数，服务器初始化时读取配置 server.hz 的值，默认为 10，代表每秒钟执行 10 次，即<strong>每隔 100 毫秒执行一次</strong>，执行指令 info server 可以查看</p>
<p>serverCron 函数负责定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行</p>
<ul>
<li>更新服务器的各类统计信息，比如时间、内存占用、 数据库占用情况等</li>
<li>清理数据库中的过期键值对</li>
<li>关闭和清理连接失效的客户端</li>
<li>进行 AOF 或 RDB 持久化操作</li>
<li>如果服务器是主服务器，那么对从服务器进行定期同步</li>
<li>如果处于集群模式，对集群进行定期同步和连接测试</li>
</ul>
<hr>
<h5 id="时间缓存"><a href="#时间缓存" class="headerlink" title="时间缓存"></a>时间缓存</h5><p>Redis 服务器中有很多功能需要获取系统的当前时间，而每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的执行次数，服务器状态中的 unixtime 属性和 mstime 属性被用作当前时间的缓存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 保存了秒级精度的系统当前UNIX时间戳</span></span><br><span class="line">    <span class="type">time_t</span> unixtime;</span><br><span class="line">	<span class="comment">// 保存了毫秒级精度的系统当前UNIX时间戳 </span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mstime;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>serverCron 函数默认以每 100 毫秒一次的频率更新两个属性，所以属性记录的时间的精确度并不高</p>
<ul>
<li>服务器只会在打印日志、更新服务器的 LRU 时钟、决定是否执行持久化任务、计算服务器上线时间（uptime）这类对时间精确度要求不高的功能上</li>
<li>对于为键设置过期时间、添加慢查询日志这种需要高精确度时间的功能来说，服务器还是会再次执行系统调用，从而获得最准确的系统当前时间</li>
</ul>
<hr>
<h5 id="LRU-时钟"><a href="#LRU-时钟" class="headerlink" title="LRU 时钟"></a>LRU 时钟</h5><p>服务器状态中的 lruclock 属性保存了服务器的 LRU 时钟</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 默认每10秒更新一次的时钟缓存，用于计算键的空转(idle)时长。 </span></span><br><span class="line">    <span class="type">unsigned</span> lruclock:<span class="number">22</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个 Redis 对象都会有一个 lru 属性， 这个 lru 属性保存了对象最后一次被命令访问的时间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObiect</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> lru:<span class="number">22</span>; </span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>当服务器要计算一个数据库键的空转时间（即数据库键对应的值对象的空转时间），程序会用服务器的 lruclock 属性记录的时间减去对象的 lru 属性记录的时间</p>
<p>serverCron 函数默认以每 100 毫秒一次的频率更新这个属性，所以得出的空转时间也是模糊的</p>
<hr>
<h5 id="命令次数"><a href="#命令次数" class="headerlink" title="命令次数"></a>命令次数</h5><p>serverCron 中的 trackOperationsPerSecond 函数以每 100 毫秒一次的频率执行，函数功能是以<strong>抽样计算</strong>的方式，估算并记录服务器在最近一秒钟处理的命令请求数量，这个值可以通过 INFO status 命令的 instantaneous_ops_per_sec 域查看：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; INFO stats</span><br><span class="line"><span class="comment"># Stats </span></span><br><span class="line">instantaneous_ops_per_sec:6</span><br></pre></td></tr></table></figure>

<p>根据上一次抽样时间 ops_sec_last_sample_time 和当前系统时间，以及上一次已执行的命令数 ops_sec_last_sample_ops 和服务器当前已经执行的命令数，计算出两次函数调用期间，服务器平均每毫秒处理了多少个命令请求，该值乘以 1000 得到每秒内的执行命令的估计值，放入 ops_sec_samples 环形数组里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 上一次进行抽样的时间</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ops_sec_last_sample_time;</span><br><span class="line">    <span class="comment">// 上一次抽样时，服务器已执行命令的数量 </span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ops_sec_last_sample_ops;</span><br><span class="line">    <span class="comment">// REDIS_OPS_SEC_SAMPLES 大小（默认值为16)的环形数组，数组的每一项记录一次的抽样结果</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ops_sec_samples[REDIS_OPS_SEC_SAMPLES];</span><br><span class="line">    <span class="comment">// ops_sec_samples数组的索引值，每次抽样后将值自增一，值为16时重置为0，让数组成为一个环形数组</span></span><br><span class="line">    <span class="type">int</span> ops_sec_idx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<hr>
<h5 id="内存峰值"><a href="#内存峰值" class="headerlink" title="内存峰值"></a>内存峰值</h5><p>服务器状态里的 stat_peak_memory 属性记录了服务器内存峰值大小，循环函数每次执行时都会查看服务器当前使用的内存数量，并与 stat_peak_memory 保存的数值进行比较，设置为较大的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 已使用内存峰值</span></span><br><span class="line">    <span class="type">size_t</span> stat_peak_memory;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>INFO memory 命令的 used_memory_peak 和 used_memory_peak_human 两个域分别以两种格式记录了服务器的内存峰值：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; INFO memory </span><br><span class="line"><span class="comment"># Memory </span></span><br><span class="line">...</span><br><span class="line">used_memory_peak:501824 </span><br><span class="line">used_memory_peak_human:490.06K</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="SIGTERM"><a href="#SIGTERM" class="headerlink" title="SIGTERM"></a>SIGTERM</h5><p>服务器启动时，Redis 会为服务器进程的 SIGTERM 信号关联处理器 sigtermHandler 函数，该信号处理器负责在服务器接到 SIGTERM 信号时，打开服务器状态的 shutdown_asap 标识</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 关闭服务器的标识：值为1时关闭服务器，值为0时不做操作</span></span><br><span class="line">    <span class="type">int</span> shutdown_asap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每次 serverCron 函数运行时，程序都会对服务器状态的 shutdown_asap 属性进行检查，并根据属性的值决定是否关闭服务器</p>
<p>服务器在接到 SIGTERM 信号之后，关闭服务器并打印相关日志的过程：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[6794 | signal handler] (1384435690) Received SIGTERM, scheduling shutdown ... </span><br><span class="line">[6794] 14 Nov 21:28:10.108 <span class="comment"># User requested shutdown ... </span></span><br><span class="line">[6794] 14 Nov 21:28:10.108 * Saving the final RDB snapshot before exiting. </span><br><span class="line">[6794) 14 Nov 21:28:10.161 * DB saved on disk </span><br><span class="line">[6794) 14 Nov 21:28:10.161 <span class="comment"># Redisis now ready to exit, bye bye ... </span></span><br></pre></td></tr></table></figure>



<hr>
<h5 id="管理资源"><a href="#管理资源" class="headerlink" title="管理资源"></a>管理资源</h5><p>serverCron 函数每次执行都会调用 clientsCron 和 databasesCron 函数，进行管理客户端资源和数据库资源</p>
<p>clientsCron 函数对一定数量的客户端进行以下两个检查：</p>
<ul>
<li>如果客户端与服务器之间的连接巳经超时（很长一段时间客户端和服务器都没有互动），那么程序释放这个客户端</li>
<li>如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存</li>
</ul>
<p>databasesCron 函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时对字典进行收缩操作</p>
<hr>
<h5 id="持久状态"><a href="#持久状态" class="headerlink" title="持久状态"></a>持久状态</h5><p>服务器状态中记录执行 BGSAVE 命令和 BGREWRITEAOF 命令的子进程的 ID</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录执行BGSAVE命令的子进程的ID，如果服务器没有在执行BGSAVE，那么这个属性的值为-1</span></span><br><span class="line">    <span class="type">pid_t</span> rdb_child_pid;</span><br><span class="line">    <span class="comment">// 记录执行BGREWRITEAOF命令的子进程的ID，如果服务器没有在执行那么这个属性的值为-1</span></span><br><span class="line">    <span class="type">pid_t</span> aof_child_pid</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>serverCron 函数执行时，会检查两个属性的值，只要其中一个属性的值不为 -1，程序就会执行一次 wait3 函数，检查子进程是否有信号发来服务器进程：</p>
<ul>
<li>如果有信号到达，那么表示新的 RDB 文件已经生成或者 AOF 重写完毕，服务器需要进行相应命令的后续操作，比如用新的 RDB 文件替换现有的 RDB 文件，用重写后的 AOF 文件替换现有的 AOF 文件</li>
<li>如果没有信号到达，那么表示持久化操作未完成，程序不做动作</li>
</ul>
<p>如果两个属性的值都为 -1，表示服务器没有进行持久化操作</p>
<ul>
<li><p>查看是否有 BGREWRITEAOF 被延迟，然后执行 AOF 后台重写</p>
</li>
<li><p>查看服务器的自动保存条件是否已经被满足，并且服务器没有在进行持久化，就开始一次新的 BGSAVE 操作</p>
<p>因为条件 1 可能会引发一次 AOF，所以在这个检查中会再次确认服务器是否已经在执行持久化操作</p>
</li>
<li><p>检查服务器设置的 AOF 重写条件是否满足，条件满足并且服务器没有进行持久化，就进行一次 AOF 重写</p>
</li>
</ul>
<p>如果服务器开启了 AOF 持久化功能，并且 AOF 缓冲区里还有待写入的数据， 那么 serverCron 函数会调用相应的程序，将 AOF 缓冲区中的内容写入到 AOF 文件里</p>
<hr>
<h5 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h5><p>在服务器执行 BGSAVE 命令的期间，如果客户端发送 BGREWRITEAOF 命令，那么服务器会将 BGREWRITEAOF 命令的执行时间延迟到 BGSAVE 命令执行完毕之后，用服务器状态的 aof_rewrite_scheduled 属性标识延迟与否</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 如果值为1，那么表示有 BGREWRITEAOF命令被延迟了</span></span><br><span class="line">    <span class="type">int</span> aof_rewrite_scheduled;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>serverCron 函数会检查 BGSAVE 或者 BGREWRITEAOF 命令是否正在执行，如果这两个命令都没在执行，并且 aof_rewrite_scheduled 属性的值为 1，那么服务器就会执行之前被推延的 BGREWRITEAOF 命令</p>
<hr>
<h5 id="执行次数"><a href="#执行次数" class="headerlink" title="执行次数"></a>执行次数</h5><p>服务器状态的 cronloops 属性记录了 serverCron 函数执行的次数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// serverCron 函数每执行一次，这个属性的值就增 1</span></span><br><span class="line">    <span class="type">int</span> cronloops;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="缓冲限制"><a href="#缓冲限制" class="headerlink" title="缓冲限制"></a>缓冲限制</h5><p>服务器会关闭那些输入或者输出<strong>缓冲区大小超出限制</strong>的客户端</p>
<hr>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><h5 id="初始结构"><a href="#初始结构" class="headerlink" title="初始结构"></a>初始结构</h5><p>一个 Redis 服务器从启动到能够接受客户端的命令请求，需要经过一系列的初始化和设置过程</p>
<p>第一步：创建一个 redisServer 类型的实例变量 server 作为服务器的状态，并为结构中的各个属性设置默认值，由 initServerConfig 函数进行初始化一般属性：</p>
<ul>
<li>设置服务器的运行 ID、默认运行频率、默认配置文件路径、默认端口号、默认 RDB 持久化条件和 AOF 持久化条件</li>
<li>初始化服务器的 LRU 时钟，创建命令表</li>
</ul>
<p>第二步：载入配置选项，用户可以通过给定配置参数或者指定配置文件，对 server 变量相关属性的默认值进行修改</p>
<p>第三步：初始化服务器数据结构（除了命令表之外），因为服务器<strong>必须先载入用户指定的配置选项才能正确地对数据结构进行初始化</strong>，所以载入配置完成后才进性数据结构的初始化，服务器将调用 initServer 函数：</p>
<ul>
<li>server.clients 链表，记录了的客户端的状态结构；server.db 数组，包含了服务器的所有数据库</li>
<li>用于保存频道订阅信息的 server.pubsub_channels 字典， 以及保存模式订阅信息的 server.pubsub_patterns 链表</li>
<li>用于执行 Lua 脚本的 Lua 环境 server.lua </li>
<li>保存慢查询日志的 server.slowlog 属性</li>
</ul>
<p>initServer 还进行了非常重要的设置操作：</p>
<ul>
<li>为服务器设置进程信号处理器</li>
<li>创建共享对象，包含 OK、ERR、<strong>整数 1 到 10000 的字符串对象</strong>等</li>
<li><strong>打开服务器的监听端口</strong></li>
<li><strong>为 serverCron 函数创建时间事件</strong>， 等待服务器正式运行时执行 serverCron 函数</li>
<li>如果 AOF 持久化功能已经打开，那么打开现有的 AOF 文件，如果 AOF 文件不存在，那么创建并打开一个新的 AOF 文件 ，为 AOF 写入做好准备</li>
<li><strong>初始化服务器的后台 I&#x2F;O 模块</strong>（BIO）, 为将来的 I&#x2F;O 操作做好准备</li>
</ul>
<p>当 initServer 函数执行完毕之后， 服务器将用 ASCII 字符在日志中打印出 Redis 的图标， 以及 Redis 的版本号信息</p>
<hr>
<h5 id="还原状态"><a href="#还原状态" class="headerlink" title="还原状态"></a>还原状态</h5><p>在完成了对服务器状态的初始化之后，服务器需要载入RDB文件或者AOF 文件， 并根据文件记录的内容来还原服务器的数据库状态：</p>
<ul>
<li>如果服务器启用了 AOF 持久化功能，那么服务器使用 AOF 文件来还原数据库状态</li>
<li>如果服务器没有启用 AOF 持久化功能，那么服务器使用 RDB 文件来还原数据库状态</li>
</ul>
<p>当服务器完成数据库状态还原工作之后，服务器将在日志中打印出载入文件并还原数据库状态所耗费的时长</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[7171] 22 Nov 22:43:49.084 * DB loaded from disk: 0.071 seconds </span><br></pre></td></tr></table></figure>



<hr>
<h5 id="驱动循环"><a href="#驱动循环" class="headerlink" title="驱动循环"></a>驱动循环</h5><p>在初始化的最后一步，服务器将打印出以下日志，并开始<strong>执行服务器的事件循环</strong>（loop）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">7171</span>] <span class="number">22</span> Nov <span class="number">22</span>:<span class="number">43</span>:<span class="number">49.084</span> * The server is now ready to accept connections on pert <span class="number">6379</span></span><br></pre></td></tr></table></figure>

<p>服务器现在开始可以接受客户端的连接请求，并处理客户端发来的命令请求了</p>
<hr>
<h3 id="慢日志-1"><a href="#慢日志-1" class="headerlink" title="慢日志"></a>慢日志</h3><h4 id="基本介绍-15"><a href="#基本介绍-15" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Redis 的慢查询日志功能用于记录执行时间超过给定时长的命令请求，通过产生的日志来监视和优化查询速度</p>
<p>服务器配置有两个和慢查询日志相关的选项：</p>
<ul>
<li>slowlog-log-slower-than 选项指定执行时间超过多少微秒的命令请求会被记录到日志上</li>
<li>slowlog-max-len 选项指定服务器最多保存多少条慢查询日志</li>
</ul>
<p>服务器使用先进先出 FIFO 的方式保存多条慢查询日志，当服务器存储的慢查询日志数量等于 slowlog-max-len 选项的值时，在添加一条新的慢查询日志之前，会先将最旧的一条慢查询日志删除</p>
<p>配置选项可以通过 CONFIG SET option value 命令进行设置</p>
<p>常用命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SLOWLOG GET [n]	<span class="comment"># 查看 n 条服务器保存的慢日志</span></span><br><span class="line">SLOWLOG LEN		<span class="comment"># 查看日志数量</span></span><br><span class="line">SLOWLOG RESET	<span class="comment"># 清除所有慢查询日志</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="日志保存"><a href="#日志保存" class="headerlink" title="日志保存"></a>日志保存</h4><p>服务器状态中包含了慢查询日志功能有关的属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	<span class="comment">// 下一条慢查询日志的ID</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> slowlog_entry_id;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 保存了所有慢查询日志的链表</span></span><br><span class="line">	<span class="built_in">list</span> *slowlog;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 服务器配置选项的值 </span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> slowlog-<span class="built_in">log</span>-slower-than;</span><br><span class="line">	<span class="comment">// 服务器配置选项的值</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> slowlog_max_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>slowlog_entry_id 属性的初始值为 0，每当创建一条新的慢查询日志时，这个属性就会用作新日志的 id 值，之后该属性增一</p>
<p>slowlog 链表保存了服务器中的所有慢查询日志，链表中的每个节点是一个 slowlogEntry 结构， 代表一条慢查询日志：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slowlogEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 唯一标识符</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> id;</span><br><span class="line">   	<span class="comment">// 命令执行时的时间，格式为UNIX时间戳</span></span><br><span class="line">    <span class="type">time_t</span> time;</span><br><span class="line">	<span class="comment">// 执行命令消耗的时间，以微秒为单位 </span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> duration;</span><br><span class="line">	<span class="comment">// 命令与命令参数</span></span><br><span class="line">	robj **argv;</span><br><span class="line">	<span class="comment">// 命令与命令参数的数量</span></span><br><span class="line">	<span class="type">int</span> argc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="添加日志"><a href="#添加日志" class="headerlink" title="添加日志"></a>添加日志</h4><p>在每次执行命令的前后，程序都会记录微秒格式的当前 UNIX 时间戳，两个时间之差就是执行命令所耗费的时长，函数会检查命令的执行时长是否超过 slowlog-log-slower-than 选项所设置：</p>
<ul>
<li><p>如果是的话，就为命令创建一个新的日志，并将新日志添加到 slowlog 链表的表头</p>
</li>
<li><p>检查慢查询日志的长度是否超过 slowlog-max-len 选项所设置的长度，如果是将多出来的日志从 slowlog 链表中删除掉</p>
</li>
<li><p>将 redisServer. slowlog_entry_id 的值增 1</p>
</li>
</ul>
<hr>
<h2 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h4><p>Redis 构建了简单动态字符串（SDS）的数据类型，作为 Redis 的默认字符串表示，包含字符串的键值对在底层都是由 SDS 实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量，等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 【字节】数组，用于保存字符串（不是字符数组）</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SDS 遵循 C 字符串<strong>以空字符结尾</strong>的惯例，保存空字符的 1 字节不计算在 len 属性，SDS 会自动为空字符分配额外的 1 字节空间和添加空字符到字符串末尾，所以空字符对于 SDS 的使用者来说是完全透明的</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-SDS%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<hr>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>常数复杂度获取字符串长度：</p>
<ul>
<li>C 字符串不记录自身的长度，获取时需要遍历整个字符串，遇到空字符串为止，时间复杂度为 O(N)</li>
<li>SDS 获取字符串长度的时间复杂度为 O(1)，设置和更新 SDS 长度由函数底层自动完成</li>
</ul>
<p>杜绝缓冲区溢出：</p>
<ul>
<li><p>C 字符串调用 strcat 函数拼接字符串时，如果字符串内存不够容纳目标字符串，就会造成缓冲区溢出（Buffer Overflow）</p>
<p>s1 和 s2 是内存中相邻的字符串，执行 <code>strcat(s1, &quot; Cluster&quot;)</code>（有空格）：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98.png"></p>
</li>
<li><p>SDS 空间分配策略：当对 SDS 进行修改时，首先检查 SDS 的空间是否满足修改所需的要求， 如果不满足会自动将 SDS 的空间扩展至执行修改所需的大小，然后执行实际的修改操作， 避免了缓冲区溢出的问题</p>
</li>
</ul>
<p>二进制安全：</p>
<ul>
<li>C 字符串中的字符必须符合某种编码（比如 ASCII）方式，除了字符串末尾以外其他位置不能包含空字符，否则会被误认为是字符串的结尾，所以只能保存文本数据</li>
<li>SDS 的 API 都是二进制安全的，使用字节数组 buf 保存一系列的二进制数据，<strong>使用 len 属性来判断数据的结尾</strong>，所以可以保存图片、视频、压缩文件等二进制数据</li>
</ul>
<p>兼容 C 字符串的函数：SDS 会在为 buf 数组分配空间时多分配一个字节来保存空字符，所以可以重用一部分 C 字符串函数库的函数</p>
<hr>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>C 字符串<strong>每次</strong>增长或者缩短都会进行一次内存重分配，拼接操作通过重分配扩展底层数组空间，截断操作通过重分配释放不使用的内存空间，防止出现内存泄露</p>
<p>SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联，在 SDS 中 buf 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节，字节的数量由 free 属性记录</p>
<p>内存重分配涉及复杂的算法，需要执行<strong>系统调用</strong>，是一个比较耗时的操作，SDS 的两种优化策略：</p>
<ul>
<li><p>空间预分配：当 SDS 的 API 进行修改并且需要进行空间扩展时，程序不仅会为 SDS 分配修改所必需的空间， 还会为 SDS 分配额外的未使用空间</p>
<ul>
<li><p>对 SDS 修改之后，SDS 的长度（len 属性）小于 1MB，程序分配和 len 属性同样大小的未使用空间，此时 len 和 free 相等</p>
<p>s 为 Redis，执行 <code>sdscat(s, &quot; Cluster&quot;)</code> 后，len 变为 13 字节，所以也分配了 13 字节的 free 空间，总长度变为 27 字节（额外的一字节保存空字符，13 + 13 + 1 &#x3D; 27）</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-SDS%E5%86%85%E5%AD%98%E9%A2%84%E5%88%86%E9%85%8D.png"></p>
</li>
<li><p>对 SDS 修改之后，SDS 的长度大于等于 1MB，程序会分配 1MB 的未使用空间</p>
</li>
</ul>
<p>在扩展 SDS 空间前，API 会先检查 free 空间是否足够，如果足够就无需执行内存重分配，所以通过预分配策略，SDS 将连续增长 N 次字符串所需内存的重分配次数从<strong>必定 N 次降低为最多 N 次</strong></p>
</li>
<li><p>惰性空间释放：当 SDS 的 API 需要缩短字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些字节的数量记录起来，并等待将来使用</p>
<p>SDS 提供了相应的 API 来真正释放 SDS 的未使用空间，所以不用担心空间惰性释放策略造成的内存浪费问题</p>
</li>
</ul>
<hr>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表提供了高效的节点重排能力，C 语言并没有内置这种数据结构，所以 Redis 构建了链表数据类型</p>
<p>链表节点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="type">void</span> *value</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>多个 listNode 通过 prev 和 next 指针组成<strong>双端链表</strong>：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<p>list 链表结构：提供了表头指针 head 、表尾指针 tail 以及链表长度计数器 len</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点值复制函数，用于复制链表节点所保存的值</span></span><br><span class="line">    <span class="type">void</span> *(*dup) (<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数，用于释放链表节点所保存的值</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>) (<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数，用于对比链表节点所保存的值和另一个输入值是否相等</span></span><br><span class="line">    <span class="type">int</span> (*match) (<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E9%93%BE%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<p>Redis 链表的特性：</p>
<ul>
<li>双端：链表节点带有 prev 和 next 指针，获取某个节点的前置节点和后置节点的时间复杂度都是 O(1)</li>
<li>无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL，对链表的访问以 NULL 为终点</li>
<li>带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针，获取链表的表头节点和表尾节点的时间复杂度为 O(1)</li>
<li>带链表长度计数器：使用 len 属性来对 list 持有的链表节点进行计数，获取链表中节点数量的时间复杂度为 O(1)</li>
<li>多态：链表节点使用 void * 指针来保存节点值， 并且可以通过 dup、free 、match 三个属性为节点值设置类型特定函数，所以链表可以保存各种<strong>不同类型的值</strong></li>
</ul>
<hr>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>Redis 字典使用的哈希表结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组，数组中每个元素指向 dictEntry 结构</span></span><br><span class="line">	dictEntry **table;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 哈希表大小，数组的长度</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 哈希表大小掩码，用于计算索引值，总是等于 【size-1】</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 该哈希表已有节点的数量 </span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>哈希表节点结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">	<span class="type">void</span> *key;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 值，可以是一个指针，或者整数</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;	<span class="comment">// 指针</span></span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 指向下个哈希表节点，形成链表，用来解决冲突问题</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<hr>
<h4 id="字典结构"><a href="#字典结构" class="headerlink" title="字典结构"></a>字典结构</h4><p>字典，又称为符号表、关联数组、映射（Map），用于保存键值对的数据结构，字典中的每个键都是独一无二的。底层采用哈希表实现，一个哈希表包含多个哈希表节点，每个节点保存一个键值对</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表，数组中的每个项都是一个dictht哈希表，</span></span><br><span class="line">    <span class="comment">// 一般情况下字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rehash 索引，当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="type">int</span> rehashidx;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p>
<ul>
<li>type 属性是指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数</li>
<li>privdata 属性保存了需要传给那些类型特定函数的可选参数</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%AD%97%E5%85%B8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<hr>
<h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>Redis 使用 MurmurHash 算法来计算键的哈希值，这种算法的优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快</p>
<p>将一个新的键值对添加到字典里，需要先根据键 key 计算出哈希值，然后进行取模运算（取余）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask</span><br></pre></td></tr></table></figure>

<p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上时，就称这些键发生了哈希冲突（collision）</p>
<p>Redis 的哈希表使用链地址法（separate chaining）来解决键哈希冲突， 每个哈希表节点都有一个 next 指针，多个节点通过 next 指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题</p>
<p>dictEntry 节点组成的链表没有指向链表表尾的指针，为了速度考虑，程序总是将新节点添加到链表的表头位置（<strong>头插法</strong>），时间复杂度为 O(1)</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%AD%97%E5%85%B8%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81.png"></p>
<hr>
<h4 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h4><p>负载因子的计算方式：哈希表中的<strong>节点数量</strong> &#x2F; 哈希表的大小（<strong>长度</strong>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size</span><br></pre></td></tr></table></figure>

<p>为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时 ，程序会自动对哈希表的大小进行相应的扩展或者收缩</p>
<p>哈希表执行扩容的条件：</p>
<ul>
<li><p>服务器没有执行 BGSAVE 或者 BGREWRITEAOF 命令，哈希表的负载因子大于等于 1</p>
</li>
<li><p>服务器正在执行 BGSAVE 或者 BGREWRITEAOF 命令，哈希表的负载因子大于等于 5</p>
<p>原因：执行该命令的过程中，Redis 需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on­-write）技术来优化子进程的使用效率，通过提高执行扩展操作的负载因子，尽可能地避免在子进程存在期间进行哈希表扩展操作，可以避免不必要的内存写入操作，最大限度地节约内存</p>
</li>
</ul>
<p>哈希表执行收缩的条件：负载因子小于 0.1（自动执行，servreCron 中检测），缩小为字典中数据个数的 50% 左右</p>
<hr>
<h4 id="重新散列"><a href="#重新散列" class="headerlink" title="重新散列"></a>重新散列</h4><p>扩展和收缩哈希表的操作通过 rehash（重新散列）来完成，步骤如下：</p>
<ul>
<li>为字典的 ht[1] 哈希表分配空间，空间大小的分配情况：<ul>
<li>如果执行的是扩展操作，ht[1] 的大小为第一个大于等于 $ht[0].used * 2$ 的 $2^n$</li>
<li>如果执行的是收缩操作，ht[1] 的大小为第一个大于等于 $ht[0].used$ 的 $2^n$</li>
</ul>
</li>
<li>将保存在 ht[0] 中所有的键值对重新计算哈希值和索引值，迁移到 ht[1] 上</li>
<li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后（ht[0] 变为空表），释放 ht[0]，将 ht[1] 设置为 ht[0]，并在 ht[1] 创建一个新的空白哈希表，为下一次 rehash 做准备</li>
</ul>
<p>如果哈希表里保存的键值对数量很少，rehash 就可以在瞬间完成，但是如果哈希表里数据很多，那么要一次性将这些键值对全部 rehash 到 ht[1] 需要大量计算，可能会导致服务器在一段时间内停止服务</p>
<p>Redis 对 rehash 做了优化，使 rehash 的动作并不是一次性、集中式的完成，而是分多次，渐进式的完成，又叫<strong>渐进式 rehash</strong></p>
<ul>
<li>为 ht[1] 分配空间，此时字典同时持有 ht[0] 和 ht[1] 两个哈希表</li>
<li>在字典中维护了一个索引计数器变量 rehashidx，并将变量的值设为 0，表示 rehash 正式开始</li>
<li>在 rehash 进行期间，每次对字典执行增删改查操作时，程序除了执行指定的操作以外，还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]，rehash 完成之后<strong>将 rehashidx 属性的值增一</strong></li>
<li>随着字典操作的不断执行，最终在某个时间点上 ht[0] 的所有键值对都被 rehash 至 ht[1]，这时程序将 rehashidx 属性的值设为 -1，表示 rehash 操作已完成</li>
</ul>
<p>渐进式 rehash 采用<strong>分而治之</strong>的方式，将 rehash 键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式 rehash 带来的庞大计算量</p>
<p>渐进式 rehash 期间的哈希表操作：</p>
<ul>
<li>字典的查找、删除、更新操作会在两个哈希表上进行，比如查找一个键会先在 ht[0] 上查找，查找不到就去 ht[1] 继续查找</li>
<li>字典的添加操作会直接在 ht[1] 上添加，不在 ht[0] 上进行任何添加</li>
</ul>
<hr>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><h4 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h4><p>跳跃表（skiplist）是一种有序（<strong>默认升序</strong>）的数据结构，在链表的基础上<strong>增加了多级索引以提升查找的效率</strong>，索引是占内存的，所以是一个<strong>空间换时间</strong>的方案，跳表平均 O(logN)、最坏 O(N) 复杂度的节点查找，效率与平衡树相当但是实现更简单</p>
<p>原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，因此当节点本身比较大或者元素数量比较多的时候，其优势可以被放大，而缺点（占内存）则可以忽略</p>
<p>Redis 只在两个地方应用了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点，O(1) 的时间复杂度定位头尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skiplistNode</span> *<span class="title">head</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表的长度，也就是表内的节点数量 (表头节点不计算在内)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数 (表头节点的层高不计算在内)</span></span><br><span class="line">    <span class="type">int</span> level</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E8%B7%B3%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<hr>
<h4 id="属性分析"><a href="#属性分析" class="headerlink" title="属性分析"></a>属性分析</h4><p>层：level 数组包含多个元素，每个元素包含指向其他节点的指针。根据幕次定律（power law，越大的数出现的概率越小）<strong>随机</strong>生成一个介于 1 和 32 之间的值（Redis5 之后最大为 64）作为 level 数组的大小，这个大小就是层的高度，节点的第一层是 level[0] &#x3D; L1</p>
<p>前进指针：forward 用于从表头到表尾方向<strong>正序（升序）遍历节点</strong>，遇到 NULL 停止遍历</p>
<p>跨度：span 用于记录两个节点之间的距离，用来<strong>计算排位（rank）</strong>：</p>
<ul>
<li><p>两个节点之间的跨度越大相距的就越远，指向 NULL 的所有前进指针的跨度都为 0</p>
</li>
<li><p>在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，结果就是目标节点在跳跃表中的排位，按照上图所示：</p>
<p>查找分值为 3.0 的节点，沿途经历的层：查找的过程只经过了一个层，并且层的跨度为 3，所以目标节点在跳跃表中的排位为 3</p>
<p>查找分值为 2.0 的节点，沿途经历的层：经过了两个跨度为 1 的节点，因此可以计算出目标节点在跳跃表中的排位为 2</p>
</li>
</ul>
<p>后退指针：backward 用于从表尾到表头方向<strong>逆序（降序）遍历节点</strong></p>
<p>分值：score 属性一个 double 类型的浮点数，跳跃表中的所有节点都<strong>按分值从小到大来排序</strong></p>
<p>成员对象：obj 属性是一个指针，指向一个 SDS 字符串对象。同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值可以是相同的，分值相同的节点将按照成员对象在字典序中的大小来进行排序（从小到大）</p>
<p>个人笔记：JUC → 并发包 → ConcurrentSkipListMap 详解跳跃表</p>
<hr>
<h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><h4 id="底层结构-1"><a href="#底层结构-1" class="headerlink" title="底层结构"></a>底层结构</h4><p>整数集合（intset）是用于保存整数值的集合数据结构，是 Redis 集合键的底层实现之一</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">	<span class="comment">// 编码方式</span></span><br><span class="line">	<span class="type">uint32_t</span> encoding;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 集合包含的元素数量，也就是 contents 数组的长度</span></span><br><span class="line">	<span class="type">uint32_t</span> length;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>encoding 取值为三种：INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64</p>
<p>整数集合的每个元素都是 contents 数组的一个数组项（item），在数组中按值的大小从小到大<strong>有序排列</strong>，并且数组中<strong>不包含任何重复项</strong>。虽然 contents 属性声明为 int8_t 类型，但实际上数组并不保存任何 int8_t 类型的值， 真正类型取决于 encoding 属性</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<p>说明：底层存储结构是数组，所以为了保证有序性和不重复性，每次添加一个元素的时间复杂度是 O(N)</p>
<hr>
<h4 id="升级降级"><a href="#升级降级" class="headerlink" title="升级降级"></a>升级降级</h4><p>整数集合添加的新元素的类型比集合现有所有元素的类型都要长时，需要先进行升级（upgrade），升级流程：</p>
<ul>
<li><p>根据新元素的类型长度以及集合元素的数量（包括新元素在内），扩展整数集合底层数组的空间大小</p>
</li>
<li><p>将底层数组现有的所有元素都转换成与新元素相同的类型，并将转换后的元素放入正确的位置，放置过程保证数组的有序性</p>
<p>图示 32 * 4 &#x3D; 128 位，首先将 3 放入索引 2（64 位 - 95 位），然后将 2 放置索引 1，将 1 放置在索引 0，从后向前依次放置在对应的区间，最后放置 65535 元素到索引 3（96 位- 127 位），修改 length 属性为 4</p>
</li>
<li><p>将新元素添加到底层数组里</p>
</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E5%8D%87%E7%BA%A7.png"></p>
<p>每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为 O(N)</p>
<p>引发升级的新元素的长度总是比整数集合现有所有元素的长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素，升级之后新元素的摆放位置：</p>
<ul>
<li>在新元素小于所有现有元素的情况下，新元素会被放置在底层数组的最开头（索引 0）</li>
<li>在新元素大于所有现有元素的情况下，新元素会被放置在底层数组的最末尾（索引 length-1）</li>
</ul>
<p>整数集合升级策略的优点：</p>
<ul>
<li><p>提升整数集合的灵活性：C 语言是静态类型语言，为了避免类型错误通常不会将两种不同类型的值放在同一个数据结构里面，整数集合可以自动升级底层数组来适应新元素，所以可以随意的添加整数</p>
</li>
<li><p>节约内存：要让数组可以同时保存 int16、int32、int64 三种类型的值，可以直接使用 int64_t 类型的数组作为整数集合的底层实现，但是会造成内存浪费，整数集合可以确保升级操作只会在有需要的时候进行，尽量节省内存</p>
</li>
</ul>
<p>整数集合<strong>不支持降级操作</strong>，一旦对数组进行了升级，编码就会一直保持升级后的状态</p>
<hr>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><h4 id="底层结构-2"><a href="#底层结构-2" class="headerlink" title="底层结构"></a>底层结构</h4><p>压缩列表（ziplist）是 Redis 为了节约内存而开发的，是列表键和哈希键的底层实现之一。是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png"></p>
<ul>
<li>zlbytes：uint32_t 类型 4 字节，记录整个压缩列表占用的内存字节数，在对压缩列表进行内存重分配或者计算 zlend 的位置时使用</li>
<li>zltail：uint32_t 类型 4 字节，记录压缩列表表尾节点距离起始地址有多少字节，通过这个偏移量程序无须遍历整个压缩列表就可以确定表尾节点的地址</li>
<li>zllen：uint16_t 类型 2 字节，记录了压缩列表包含的节点数量，当该属性的值小于 UINT16_MAX (65535) 时，该值就是压缩列表中节点的数量；当这个值等于 UINT16_MAX 时节点的真实数量需要遍历整个压缩列表才能计算得出</li>
<li>entryX：列表节点，压缩列表中的各个节点，<strong>节点的长度由节点保存的内容决定</strong></li>
<li>zlend：uint8_t 类型 1 字节，是一个特殊值 0xFF (255)，用于标记压缩列表的末端</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%A4%BA%E4%BE%8B.png"></p>
<p>列表 zlbytes 属性的值为 0x50 (十进制 80)，表示压缩列表的总长为 80 字节，列表 zltail 属性的值为 0x3c (十进制 60)，假设表的起始地址为 p，计算得出表尾节点 entry3 的地址 p + 60</p>
<hr>
<h4 id="列表节点"><a href="#列表节点" class="headerlink" title="列表节点"></a>列表节点</h4><p>列表节点 entry 的数据结构：</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9.png"></p>
<p>previous_entry_length：以字节为单位记录了压缩列表中前一个节点的长度，程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址，完成<strong>从表尾向表头遍历</strong>操作</p>
<ul>
<li>如果前一节点的长度小于 254 字节，该属性的长度为 1 字节，前一节点的长度就保存在这一个字节里</li>
<li>如果前一节点的长度大于等于 254 字节，该属性的长度为 5 字节，其中第一字节会被设置为 0xFE（十进制 254），之后的四个字节则用于保存前一节点的长度</li>
</ul>
<p>encoding：记录了节点的 content 属性所保存的数据类型和长度</p>
<ul>
<li><p>长度为 1 字节、2 字节或者 5 字节，值的最高位为 00、01 或者 10 的是字节数组编码，数组的长度由编码除去最高两位之后的其他位记录，下划线 <code>_</code> 表示留空，而 <code>b</code>、<code>x</code> 等变量则代表实际的二进制数据</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E7%BC%96%E7%A0%81.png"></p>
</li>
<li><p>长度为 1 字节，值的最高位为 11 的是整数编码，整数值的类型和长度由编码除去最高两位之后的其他位记录</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E6%95%B4%E6%95%B0%E7%BC%96%E7%A0%81.png"></p>
</li>
</ul>
<p>content：每个压缩列表节点可以保存一个字节数组或者一个整数值</p>
<ul>
<li><p>字节数组可以是以下三种长度的其中一种：</p>
<ul>
<li><p>长度小于等于 $63 (2^6-1)$ 字节的字节数组</p>
</li>
<li><p>长度小于等于 $16383(2^{14}-1)$ 字节的字节数组</p>
</li>
<li><p>长度小于等于 $4294967295(2^{32}-1)$ 字节的字节数组</p>
</li>
</ul>
</li>
<li><p>整数值则可以是以下六种长度的其中一种：</p>
<ul>
<li><p>4 位长，介于 0 至 12 之间的无符号整数</p>
</li>
<li><p>1 字节长的有符号整数</p>
</li>
<li><p>3 字节长的有符号整数</p>
</li>
<li><p>int16_t 类型整数</p>
</li>
<li><p>int32_t 类型整数</p>
</li>
<li><p>int64_t 类型整数</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h4><p>Redis 将在特殊情况下产生的连续多次空间扩展操作称之为连锁更新（cascade update）</p>
<p>假设在一个压缩列表中，有多个连续的、长度介于 250 到 253 字节之间的节点 e1 至 eN。将一个长度大于等于 254 字节的新节点 new 设置为压缩列表的头节点，new 就成为 e1 的前置节点。e1 的 previous_entry_length 属性仅为 1 字节，无法保存新节点 new 的长度，所以要对压缩列表执行空间重分配操作，并将 e1 节点的 previous_entry_length 属性从 1 字节长扩展为 5 字节长。由于 e1 原本的长度介于 250 至 253 字节之间，所以扩展后 e1 的长度就变成了 254 至 257 字节之间，导致 e2 的  previous_entry_length 属性无法保存 e1 的长度，程序需要不断地对压缩列表执行空间重分配操作，直到 eN 为止</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B01.png"></p>
<p> 删除节点也可能会引发连锁更新，big.length &gt;&#x3D; 254，small.length &lt; 254，删除 small 节点</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B02.png"></p>
<p>连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配，每次重分配的最坏复杂度为 O(N)，所以连锁更新的最坏复杂度为 O(N^2)</p>
<p>说明：尽管连锁更新的复杂度较高，但出现的记录是非常低的，即使出现只要被更新的节点数量不多，就不会对性能造成影响</p>
<hr>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="redisObj"><a href="#redisObj" class="headerlink" title="redisObj"></a>redisObj</h3><h4 id="对象系统"><a href="#对象系统" class="headerlink" title="对象系统"></a>对象系统</h4><p>Redis 使用对象来表示数据库中的键和值，当在 Redis 数据库中新创建一个键值对时至少会创建两个对象，一个对象用作键值对的键（<strong>键对象</strong>），另一个对象用作键值对的值（<strong>值对象</strong>）</p>
<p>Redis 中对象由一个 redisObject 结构表示，该结构中和保存数据有关的三个属性分别是 type、 encoding、ptr：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObiect</span> &#123;</span></span><br><span class="line">	<span class="comment">// 类型</span></span><br><span class="line">	<span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">	<span class="comment">// 编码</span></span><br><span class="line">	<span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">	<span class="comment">// 指向底层数据结构的指针</span></span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>Redis 并没有直接使用数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，而每种对象又通过不同的编码映射到不同的底层数据结构</p>
<p>Redis 自身是一个 Map，其中所有的数据都是采用 key : value 的形式存储，<strong>键对象都是字符串对象</strong>，而值对象有五种基本类型和三种高级类型对象</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A0%81.png"></p>
<ul>
<li>对一个数据库键执行 TYPE 命令，返回的结果为数据库键对应的值对象的类型，而不是键对象的类型</li>
<li>对一个数据库键执行 OBJECT ENCODING 命令，查看数据库键对应的值对象的编码</li>
</ul>
<hr>
<h4 id="命令多态"><a href="#命令多态" class="headerlink" title="命令多态"></a>命令多态</h4><p>Redis 中用于操作键的命令分为两种类型：</p>
<ul>
<li>一种命令可以对任何类型的键执行，比如说 DEL 、EXPIRE、RENAME、 TYPE 等（基于类型的多态）</li>
<li>只能对特定类型的键执行，比如 SET 只能对字符串键执行、HSET 对哈希键执行、SADD 对集合键执行，如果类型步匹配会报类型错误： <code>(error) WRONGTYPE Operation against a key holding the wrong kind of value</code></li>
</ul>
<p>Redis 为了确保只有指定类型的键可以执行某些特定的命令，在执行类型特定的命令之前，先通过值对象 redisObject 结构 type 属性检查操作类型是否正确，然后再决定是否执行指定的命令</p>
<p>对于多态命令，比如列表对象有 ziplist 和 linkedlist 两种实现方式，通过 redisObject 结构 encoding 属性确定具体的编码类型，底层调用对应的 API 实现具体的操作（基于编码的多态）</p>
<hr>
<h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>对象的整个生命周期可以划分为创建对象、 操作对象、 释放对象三个阶段</p>
<p>C 语言没有自动回收内存的功能，所以 Redis 在对象系统中构建了引用计数（reference counting）技术实现的内存回收机制，程序可以跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObiect</span> &#123;</span></span><br><span class="line">	<span class="comment">// 引用计数</span></span><br><span class="line">	<span class="type">int</span> refcount;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>对象的引用计数信息会随着对象的使用状态而不断变化，创建时引用计数 refcount 初始化为 1，每次被一个新程序使用时引用计数加 1，当对象不再被一个程序使用时引用计数值会被减 1，当对象的引用计数值变为 0 时，对象所占用的内存会被释放</p>
<hr>
<h4 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h4><p>对象的引用计数属性带有对象共享的作用，共享对象机制更节约内存，数据库中保存的相同值对象越多，节约的内存就越多</p>
<p>让多个键共享一个对象的步骤：</p>
<ul>
<li><p>将数据库键的值指针指向一个现有的值对象</p>
</li>
<li><p>将被共享的值对象的引用计数增一</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-对象共享.png" style="zoom:67%;"></li>
</ul>
<p>Redis 在初始化服务器时创建一万个（配置文件可以修改）字符串对象，包含了<strong>从 0 到 9999 的所有整数值</strong>，当服务器需要用到值为 0 到 9999 的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象</p>
<p>比如创建一个值为 100 的键 A，并使用 OBJECT REFCOUNT 命令查看键 A 的值对象的引用计数，会发现值对象的引用计数为 2，引用这个值对象的两个程序分别是持有这个值对象的服务器程序，以及共享这个值对象的键 A</p>
<p>共享对象在嵌套了字符串对象的对象（linkedlist 编码的列表、hashtable 编码的哈希、zset 编码的有序集合）中也能使用</p>
<p>Redis 不共享包含字符串对象的原因：验证共享对象和目标对象是否相同的复杂度越高，消耗的 CPU 时间也会越多</p>
<ul>
<li>整数值的字符串对象， 验证操作的复杂度为 O(1)</li>
<li>字符串值的字符串对象， 验证操作的复杂度为 O(N)</li>
<li>如果共享对象是包含了多个值（或者对象的）对象，比如列表对象或者哈希对象，验证操作的复杂度为 O(N^2)</li>
</ul>
<hr>
<h4 id="空转时长"><a href="#空转时长" class="headerlink" title="空转时长"></a>空转时长</h4><p>redisObject 结构包含一个 lru 属性，该属性记录了对象最后一次被命令程序访问的时间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObiect</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> lru:<span class="number">22</span>; </span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>OBJECT IDLETIME 命令可以打印出给定键的空转时长，该值就是通过将当前时间减去键的值对象的 lru 时间计算得出的，这个命令在访问键的值对象时，不会修改值对象的 lru 属性</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"><span class="comment"># 等待一分钟</span></span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(<span class="built_in">integer</span>) 70</span><br><span class="line"><span class="comment"># 访问 msg</span></span><br><span class="line">redis&gt; GET msg</span><br><span class="line"><span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="comment"># 键处于活跃状态，空转时长为 0</span></span><br><span class="line">redis&gt; OBJECT IDLETIME msg</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p>空转时长的作用：如果服务器开启 maxmemory 选项，并且回收内存的算法为 volatile-lru 或者 allkeys-lru，那么当服务器占用的内存数超过了 maxmemory 所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存（LRU 算法）</p>
<hr>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型，实质上是存一个字符串，string 类型是二进制安全的，可以包含任何数据，比如图片或者序列化的对象</p>
<p>存储数据的格式：一个存储空间保存一个数据，每一个空间中只能保存一个字符串信息</p>
<p>存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-string结构图.png" style="zoom:50%;">

<p>Redis 所有操作都是<strong>原子性</strong>的，采用<strong>单线程</strong>机制，命令是单个顺序执行，无需考虑并发带来影响，原子性就是有一个失败则都失败</p>
<p>字符串对象可以是 int、raw、embstr 三种实现方式</p>
<hr>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>指令操作：</p>
<ul>
<li><p>数据操作：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> key value			<span class="comment">#添加/修改数据添加/修改数据</span></span><br><span class="line">del key					<span class="comment">#删除数据</span></span><br><span class="line">setnx key value			<span class="comment">#判定性添加数据，键值为空则设添加</span></span><br><span class="line">mset k1 v1 k2 v2...		<span class="comment">#添加/修改多个数据，m：Multiple</span></span><br><span class="line">append key value		<span class="comment">#追加信息到原始信息后部（如果原始信息存在就追加，否则新建）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查询操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">get key					<span class="comment">#获取数据，如果不存在，返回空（nil）</span></span><br><span class="line">mget key1 key2...		<span class="comment">#获取多个数据</span></span><br><span class="line">strlen key				<span class="comment">#获取数据字符个数（字符串长度）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置数值数据增加&#x2F;减少指定范围的值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">incr key					<span class="comment">#key++</span></span><br><span class="line">incrby key increment		<span class="comment">#key+increment</span></span><br><span class="line">incrbyfloat key increment	<span class="comment">#对小数操作</span></span><br><span class="line">decr key					<span class="comment">#key--</span></span><br><span class="line">decrby key increment		<span class="comment">#key-increment</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置数据具有指定的生命周期</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">setex key seconds value  		<span class="comment">#设置key-value存活时间，seconds单位是秒</span></span><br><span class="line">psetex key milliseconds value	<span class="comment">#毫秒级</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意事项：</p>
<ol>
<li><p>数据操作不成功的反馈与数据正常操作之间的差异</p>
<ul>
<li><p>表示运行结果是否成功</p>
<ul>
<li><p>(integer) 0  → false ，失败</p>
</li>
<li><p>(integer) 1  → true，成功</p>
</li>
</ul>
</li>
<li><p>表示运行结果值</p>
<ul>
<li><p>(integer) 3  → 3 个</p>
</li>
<li><p>(integer) 1  → 1 个</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数据未获取到时，对应的数据为（nil），等同于null</p>
</li>
<li><p><strong>数据最大存储量</strong>：512MB</p>
</li>
<li><p>string 在 Redis 内部存储默认就是一个字符串，当遇到增减类操作 incr，decr 时<strong>会转成数值型</strong>进行计算</p>
</li>
<li><p>按数值进行操作的数据，如果原始数据不能转成数值，或超越了Redis 数值上限范围，将报错<br>9223372036854775807（java 中 Long 型数据最大值，Long.MAX_VALUE）</p>
</li>
<li><p>Redis 可用于控制数据库表主键 ID，为数据库表主键提供生成策略，保障数据库表的主键唯一性</p>
</li>
</ol>
<p>单数据和多数据的选择：</p>
<ul>
<li>单数据执行 3 条指令的过程：3 次发送 + 3 次处理 + 3 次返回</li>
<li>多数据执行 1 条指令的过程：1 次发送 + 3 次处理 + 1 次返回（发送和返回的事件略高于单数据）</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/string单数据与多数据操作.png" style="zoom: 33%;">





<hr>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>字符串对象的编码可以是 int、raw、embstr 三种</p>
<ul>
<li><p>int：字符串对象保存的是<strong>整数值</strong>，并且整数值可以用 long 类型来表示，那么对象会将整数值保存在字符串对象结构的 ptr 属性面（将 void * 转换成 long)，并将字符串对象的编码设置为 int（浮点数用另外两种方式）</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-字符串对象int编码.png" style="zoom:67%;">
</li>
<li><p>raw：字符串对象保存的是一个字符串值，并且值的长度大于 39 字节，那么对象将使用简单动态字符串（SDS）来保存该值，并将对象的编码设置为 raw</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1raw%E7%BC%96%E7%A0%81.png"></p>
</li>
<li><p>embstr：字符串对象保存的是一个字符串值，并且值的长度小于等于 39 字节，那么对象将使用 embstr 编码的方式来保存这个字符串值，并将对象的编码设置为 embstr</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1embstr%E7%BC%96%E7%A0%81.png"></p>
<p>上图所示，embstr 与 raw 都使用了 redisObject 和 sdshdr 来表示字符串对象，但是 raw 需要调用两次内存分配函数分别创建两种结构，embstr 只需要一次内存分配来分配一块<strong>连续的空间</strong></p>
</li>
</ul>
<p>embstr 是用于保存短字符串的一种编码方式，对比 raw 的优点：</p>
<ul>
<li>内存分配次数从两次降低为一次，同样释放内存的次数也从两次变为一次</li>
<li>embstr 编码的字符串对象的数据都保存在同一块连续内存，所以比 raw 编码能够更好地利用缓存优势（局部性原理）</li>
</ul>
<p>int 和 embstr 编码的字符串对象在条件满足的情况下，会被转换为 raw 编码的字符串对象：</p>
<ul>
<li>int 编码的整数值，执行 APPEND 命令追加一个字符串值，先将整数值转为字符串然后追加，最后得到一个 raw 编码的对象</li>
<li>Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序，所以 embstr 对象实际上<strong>是只读的</strong>，执行修改命令会将对象的编码从 embstr 转换成 raw，操作完成后得到一个 raw 编码的对象</li>
</ul>
<p>某些情况下，程序会将字符串对象里面的字符串值转换回浮点数值，执行某些操作后再将浮点数值转换回字符串值：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SET pi 3.14 </span><br><span class="line">OK </span><br><span class="line">redis&gt; OBJECT ENCODING pi</span><br><span class="line"><span class="string">&quot;embstr&quot;</span> </span><br><span class="line">redis&gt; INCRBYFLOAT pi 2.0 <span class="comment"># 转为浮点数执行增加的操作</span></span><br><span class="line"><span class="string">&quot;5. 14&quot;</span> </span><br><span class="line">redis&gt; OBJECT ENCODING pi </span><br><span class="line"><span class="string">&quot;embstr&quot;</span> </span><br></pre></td></tr></table></figure>







<hr>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>主页高频访问信息显示控制，例如新浪微博大 V 主页显示粉丝数与微博数量</p>
<ul>
<li><p>在 Redis 中为大 V 用户设定用户信息，以用户主键和属性值作为 key，后台设定定时刷新策略</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> user:<span class="built_in">id</span>:3506728370:fans 12210947</span><br><span class="line"><span class="built_in">set</span> user:<span class="built_in">id</span>:3506728370:blogs 6164</span><br><span class="line"><span class="built_in">set</span> user:<span class="built_in">id</span>:3506728370:focuses 83</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 JSON 格式保存数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user:<span class="built_in">id</span>:3506728370 → &#123;<span class="string">&quot;fans&quot;</span>:12210947,<span class="string">&quot;blogs&quot;</span>:6164,<span class="string">&quot;focuses&quot;</span>:83&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>key的设置约定：表名 : 主键名 : 主键值 : 字段名</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>主键名</th>
<th>主键值</th>
<th>字段名</th>
</tr>
</thead>
<tbody><tr>
<td>order</td>
<td>id</td>
<td>29437595</td>
<td>name</td>
</tr>
<tr>
<td>equip</td>
<td>id</td>
<td>390472345</td>
<td>type</td>
</tr>
<tr>
<td>news</td>
<td>id</td>
<td>202004150</td>
<td>title</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>数据存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</p>
<p>数据存储结构：一个存储空间保存多个键值对数据</p>
<p>hash 类型：底层使用<strong>哈希表</strong>结构实现数据存储</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/hash结构图.png" style="zoom: 33%;">

<p>Redis 中的 hash 类似于 Java 中的  <code>Map&lt;String, Map&lt;Object,object&gt;&gt;</code>，左边是 key，右边是值，中间叫 field 字段，本质上 <strong>hash 存了一个 key-value 的存储空间</strong></p>
<p>hash 是指的一个数据类型，并不是一个数据</p>
<ul>
<li>如果 field 数量较少，存储结构优化为<strong>压缩列表结构</strong>（有序）</li>
<li>如果 field 数量较多，存储结构使用 HashMap 结构（无序）</li>
</ul>
<hr>
<h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><p>指令操作：</p>
<ul>
<li><p>数据操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hset key field value		<span class="comment">#添加/修改数据</span></span><br><span class="line">hdel key field1 [field2]	<span class="comment">#删除数据，[]代表可选</span></span><br><span class="line">hsetnx key field value		<span class="comment">#设置field的值，如果该field存在则不做任何操作</span></span><br><span class="line">hmset key f1 v1 f2 v2...	<span class="comment">#添加/修改多个数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查询操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hget key field				<span class="comment">#获取指定field对应数据</span></span><br><span class="line">hgetall key					<span class="comment">#获取指定key所有数据</span></span><br><span class="line">hmget key field1 field2...	<span class="comment">#获取多个数据</span></span><br><span class="line">hexists key field			<span class="comment">#获取哈希表中是否存在指定的字段</span></span><br><span class="line">hlen key					<span class="comment">#获取哈希表中字段的数量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取哈希表中所有的字段名或字段值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hkeys key					<span class="comment">#获取所有的field	</span></span><br><span class="line">hvals key					<span class="comment">#获取所有的value</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置指定字段的数值数据增加指定范围的值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hincrby key field increment		<span class="comment">#指定字段的数值数据增加指定的值，increment为负数则减少</span></span><br><span class="line">hincrbyfloat key field increment<span class="comment">#操作小数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意事项</p>
<ol>
<li>hash 类型中 value 只能存储字符串，不允许存储其他数据类型，不存在嵌套现象，如果数据未获取到，对应的值为（nil）</li>
<li>每个 hash 可以存储 2^32 - 1 个键值对</li>
<li>hash 类型和对象的数据存储形式相似，并且可以灵活添加删除对象属性。但 hash 设计初衷不是为了存储大量对象而设计的，不可滥用，不可将 hash 作为对象列表使用</li>
<li>hgetall 操作可以获取全部属性，如果内部 field 过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈</li>
</ol>
<hr>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>哈希对象的内部编码有两种：ziplist（压缩列表）、hashtable（哈希表、字典）</p>
<ul>
<li><p>压缩列表实现哈希对象：同一键值对的节点总是挨在一起，保存键的节点在前，保存值的节点在后</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1ziplist.png"></p>
</li>
<li><p>字典实现哈希对象：字典的每一个键都是一个字符串对象，每个值也是</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-哈希对象dict.png" style="zoom:67%;"></li>
</ul>
<p>当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型，具体需要满足两个条件：</p>
<ul>
<li>当键值对数量小于 hash-max-ziplist-entries 配置（默认 512 个）</li>
<li>所有键和值的长度都小于 hash-max-ziplist-value 配置（默认 64 字节）</li>
</ul>
<p>以上两个条件的上限值是可以通过配置文件修改的，当两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行</p>
<p>ziplist 使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比 hashtable 更加优秀，当 ziplist 无法满足哈希类型时，Redis 会使用 hashtable 作为哈希的内部实现，因为此时 ziplist 的读写效率会下降，而 hashtable 的读写时间复杂度为 O(1)</p>
<hr>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">user:<span class="built_in">id</span>:3506728370 → &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;春晚&quot;</span>,<span class="string">&quot;fans&quot;</span>:12210862,<span class="string">&quot;blogs&quot;</span>:83&#125;</span><br></pre></td></tr></table></figure>

<p>对于以上数据，使用单条去存的话，存的条数会很多。但如果用 json 格式，存一条数据就够了。</p>
<p>假如现在粉丝数量发生了变化，要把整个值都改变，但是用单条存就不存在这个问题，只需要改其中一个就可以</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/hash应用场景结构图.png" style="zoom: 33%;">

<p>可以实现购物车的功能，key 对应着每个用户，存储空间存储购物车的信息</p>
<hr>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</p>
<p>数据存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序，允许重复元素</p>
<p>list 类型：保存多个数据，底层使用<strong>双向链表</strong>存储结构实现，类似于 LinkedList</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/list结构图.png" style="zoom:33%;">

<p>如果两端都能存取数据的话，这就是双端队列，如果只能从一端进一端出，这个模型叫栈</p>
<hr>
<h4 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h4><p>指令操作：</p>
<ul>
<li><p>数据操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lpush key value1 [value2]...<span class="comment">#从左边添加/修改数据(表头)</span></span><br><span class="line">rpush key value1 [value2]...<span class="comment">#从右边添加/修改数据(表尾)</span></span><br><span class="line">lpop key					<span class="comment">#从左边获取并移除第一个数据，类似于出栈/出队</span></span><br><span class="line">rpop key					<span class="comment">#从右边获取并移除第一个数据</span></span><br><span class="line">lrem key count value		<span class="comment">#删除指定数据，count=2删除2个，该value可能有多个(重复数据)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查询操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lrange key start stop		<span class="comment">#从左边遍历数据并指定开始和结束索引，0是第一个索引，-1是终索引</span></span><br><span class="line">lindex key index			<span class="comment">#获取指定索引数据，没有则为nil，没有索引越界</span></span><br><span class="line">llen key					<span class="comment">#list中数据长度/个数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>规定时间内获取并移除数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">b							<span class="comment">#代表阻塞</span></span><br><span class="line">blpop key1 [key2] <span class="built_in">timeout</span>	<span class="comment">#在指定时间内获取指定key(可以多个)的数据，超时则为(nil)</span></span><br><span class="line">							<span class="comment">#可以从其他客户端写数据，当前客户端阻塞读取数据</span></span><br><span class="line">brpop key1 [key2] <span class="built_in">timeout</span>	<span class="comment">#从右边操作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>复制操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brpoplpush <span class="built_in">source</span> destination <span class="built_in">timeout</span>	<span class="comment">#从source获取数据放入destination，假如在指定时间内没有任何元素被弹出，则返回一个nil和等待时长。反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意事项</p>
<ol>
<li>list 中保存的数据都是 string 类型的，数据总容量是有限的，最多 2^32 - 1 个元素（4294967295）</li>
<li>list 具有索引的概念，但操作数据时通常以队列的形式进行入队出队，或以栈的形式进行入栈出栈</li>
<li>获取全部数据操作结束索引设置为 -1</li>
<li>list 可以对数据进行分页操作，通常第一页的信息来自于 list，第 2 页及更多的信息通过数据库的形式加载</li>
</ol>
<hr>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>在 Redis3.2 版本以前列表对象的内部编码有两种：ziplist（压缩列表）和 linkedlist（链表）</p>
<ul>
<li><p>压缩列表实现的列表对象：PUSH 1、three、5 三个元素</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1ziplist.png"></p>
</li>
<li><p>链表实现的列表对象：为了简化字符串对象的表示，使用了 StringObject 的结构，底层其实是 sdshdr 结构</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1linkedlist.png"></p>
</li>
</ul>
<p>列表中存储的数据量比较小的时候，列表就会使用一块连续的内存存储，采用压缩列表的方式实现的条件：</p>
<ul>
<li>列表对象保存的所有字符串元素的长度都小于 64 字节</li>
<li>列表对象保存的元素数量小于 512 个</li>
</ul>
<p>以上两个条件的上限值是可以通过配置文件修改的，当两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行</p>
<p>在 Redis3.2 版本 以后对列表数据结构进行了改造，使用 <strong>quicklist（快速列表）</strong>代替了 linkedlist，quicklist 实际上是 ziplist 和 linkedlist 的混合体，将 linkedlist 按段切分，每一段使用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针串接起来，既满足了快速的插入删除性能，又不会出现太大的空间冗余</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-快速列表数据结构.png" style="zoom: 50%;">



<hr>
<h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h4><p>企业运营过程中，系统将产生出大量的运营数据，如何保障多台服务器操作日志的统一顺序输出？</p>
<ul>
<li>依赖 list 的数据具有顺序的特征对信息进行管理，右进左查或者左近左查</li>
<li>使用队列模型解决多路信息汇总合并的问题</li>
<li>使用栈模型解决最新消息的问题</li>
</ul>
<p>微信文章订阅公众号：</p>
<ul>
<li>比如订阅了两个公众号，它们发布了两篇文章，文章 ID 分别为 666 和 888，可以通过执行 <code>LPUSH key 666 888</code> 命令推送给我</li>
</ul>
<hr>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>数据存储需求：存储大量的数据，在查询方面提供更高的效率</p>
<p>数据存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</p>
<p>set 类型：与 hash 存储结构哈希表完全相同，只是仅存储键不存储值（nil），所以添加，删除，查找的复杂度都是 O(1)，并且<strong>值是不允许重复且无序的</strong></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/set结构图.png" style="zoom: 33%;">



<hr>
<h4 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h4><p>指令操作：</p>
<ul>
<li><p>数据操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sadd key member1 [member2]	<span class="comment">#添加数据</span></span><br><span class="line">srem key member1 [member2]	<span class="comment">#删除数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查询操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">smembers key				<span class="comment">#获取全部数据</span></span><br><span class="line">scard key					<span class="comment">#获取集合数据总量</span></span><br><span class="line">sismember key member		<span class="comment">#判断集合中是否包含指定数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>随机操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">  spop key [count]			<span class="comment">#随机获取集中的某个数据并将该数据移除集合</span></span><br><span class="line">  srandmember key [count]		<span class="comment">#随机获取集合中指定(数量)的数据</span></span><br><span class="line"></span><br><span class="line">* 集合的交、并、差</span><br><span class="line"></span><br><span class="line">  ```sh</span><br><span class="line">  sinter key1 [key2...]  					<span class="comment">#两个集合的交集，不存在为(empty list or set)</span></span><br><span class="line">  sunion key1 [key2...]  					<span class="comment">#两个集合的并集</span></span><br><span class="line">  sdiff key1 [key2...]					<span class="comment">#两个集合的差集</span></span><br><span class="line">  </span><br><span class="line">  sinterstore destination key1 [key2...]	<span class="comment">#两个集合的交集并存储到指定集合中</span></span><br><span class="line">  sunionstore destination key1 [key2...]	<span class="comment">#两个集合的并集并存储到指定集合中</span></span><br><span class="line">  sdiffstore destination key1 [key2...]	<span class="comment">#两个集合的差集并存储到指定集合中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>复制</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">smove <span class="built_in">source</span> destination member			<span class="comment">#将指定数据从原始集合中移动到目标集合中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意事项</p>
<ol>
<li>set 类型不允许数据重复，如果添加的数据在 set 中已经存在，将只保留一份</li>
<li>set 虽然与 hash 的存储结构相同，但是无法启用 hash 中存储值的空间</li>
</ol>
<hr>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>集合对象的内部编码有两种：intset（整数集合）、hashtable（哈希表、字典）</p>
<ul>
<li><p>整数集合实现的集合对象：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-集合对象intset.png" style="zoom:67%;">
</li>
<li><p>字典实现的集合对象：键值对的值为 NULL</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-集合对象dict.png" style="zoom:80%;"></li>
</ul>
<p>当集合对象可以同时满足以下两个条件时，对象使用 intset 编码：</p>
<ul>
<li>集合中的元素都是整数值</li>
<li>集合中的元素数量小于 set-maxintset-entries配置（默认 512 个）</li>
</ul>
<p>以上两个条件的上限值是可以通过配置文件修改的</p>
<hr>
<h4 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h4><p>应用场景：</p>
<ol>
<li><p>黑名单：资讯类信息类网站追求高访问量，但是由于其信息的价值，往往容易被不法分子利用，通过爬虫技术，快速获取信息，个别特种行业网站信息通过爬虫获取分析后，可以转换成商业机密。</p>
<p>注意：爬虫不一定做摧毁性的工作，有些小型网站需要爬虫为其带来一些流量。</p>
</li>
<li><p>白名单：对于安全性更高的应用访问，仅仅靠黑名单是不能解决安全问题的，此时需要设定可访问的用户群体， 依赖白名单做更为苛刻的访问验证</p>
</li>
<li><p>随机操作可以实现抽奖功能</p>
</li>
<li><p>集合的交并补可以实现微博共同关注的查看，可以根据共同关注或者共同喜欢推荐相关内容</p>
</li>
</ol>
<hr>
<h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><p>数据存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式</p>
<p>数据存储结构：新的存储模型，可以保存可排序的数据</p>
<hr>
<h4 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a>操作</h4><p>指令操作：</p>
<ul>
<li><p>数据操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zadd key score1 member1 [score2 member2]	<span class="comment">#添加数据</span></span><br><span class="line">zrem key member [member ...]				<span class="comment">#删除数据</span></span><br><span class="line">zremrangebyrank key start stop 				<span class="comment">#删除指定索引范围的数据</span></span><br><span class="line">zremrangebyscore key min max				<span class="comment">#删除指定分数区间内的数据</span></span><br><span class="line">zscore key member							<span class="comment">#获取指定值的分数</span></span><br><span class="line">zincrby key increment member				<span class="comment">#指定值的分数增加increment</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查询操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zrange key start stop [WITHSCORES]		<span class="comment">#获取指定范围的数据，升序，WITHSCORES 代表显示分数</span></span><br><span class="line">zrevrange key start stop [WITHSCORES]	<span class="comment">#获取指定范围的数据，降序</span></span><br><span class="line"></span><br><span class="line">zrangebyscore key min max [WITHSCORES] [LIMIT offset count]	<span class="comment">#按条件获取数据，从小到大</span></span><br><span class="line">zrevrangebyscore key max min [WITHSCORES] [...]				<span class="comment">#从大到小</span></span><br><span class="line"></span><br><span class="line">zcard key										<span class="comment">#获取集合数据的总量</span></span><br><span class="line">zcount key min max								<span class="comment">#获取指定分数区间内的数据总量</span></span><br><span class="line">zrank key member								<span class="comment">#获取数据对应的索引（排名）升序</span></span><br><span class="line">zrevrank key member								<span class="comment">#获取数据对应的索引（排名）降序</span></span><br></pre></td></tr></table></figure>

<ul>
<li>min 与 max 用于限定搜索查询的条件</li>
<li>start 与 stop 用于限定查询范围，作用于索引，表示开始和结束索引</li>
<li>offset 与 count 用于限定查询范围，作用于查询结果，表示开始位置和数据总量</li>
</ul>
</li>
<li><p>集合的交、并操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zinterstore destination numkeys key [key ...]	<span class="comment">#两个集合的交集并存储到指定集合中</span></span><br><span class="line">zunionstore destination numkeys key [key ...]	<span class="comment">#两个集合的并集并存储到指定集合中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意事项：</p>
<ol>
<li>score 保存的数据存储空间是 64 位，如果是整数范围是 -9007199254740992~9007199254740992</li>
<li>score 保存的数据也可以是一个双精度的 double 值，基于双精度浮点数的特征可能会丢失精度，慎重使用</li>
<li>sorted_set 底层存储还是基于 set 结构的，因此数据不能重复，如果重复添加相同的数据，score 值将被反复覆盖，保留最后一次修改的结果</li>
</ol>
<hr>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>有序集合对象的内部编码有两种：ziplist（压缩列表）和 skiplist（跳跃表）</p>
<ul>
<li><p>压缩列表实现有序集合对象：ziplist 本身是有序、不可重复的，符合有序集合的特性</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1ziplist.png"></p>
</li>
<li><p>跳跃表实现有序集合对象：<strong>底层是 zset 结构，zset 同时包含字典和跳跃表的结构</strong>，图示字典和跳跃表中重复展示了各个元素的成员和分值，但实际上两者会<strong>通过指针来共享相同元素的成员和分值</strong>，不会产生空间浪费</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1zset.png"></p>
</li>
</ul>
<p>使用字典加跳跃表的优势：</p>
<ul>
<li>字典为有序集合创建了一个从成员到分值的映射，用 O(1) 复杂度查找给定成员的分值</li>
<li>排序操作使用跳跃表完成，节省每次重新排序带来的时间成本和空间成本</li>
</ul>
<p>使用 ziplist 格式存储需要满足以下两个条件：</p>
<ul>
<li>有序集合保存的元素个数要小于 128 个；</li>
<li>有序集合保存的所有元素大小都小于 64 字节</li>
</ul>
<p>当元素比较多时，此时 ziplist 的读写效率会下降，时间复杂度是 O(n)，跳表的时间复杂度是 O(logn)</p>
<hr>
<h4 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h4><ul>
<li>排行榜</li>
<li>对于基于时间线限定的任务处理，将处理时间记录为 score 值，利用排序功能区分处理的先后顺序</li>
<li>当任务或者消息待处理，形成了任务队列或消息队列时，对于高优先级的任务要保障对其优先处理，采用 score 记录权重</li>
</ul>
<hr>
<h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><h4 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h4><p>Bitmaps 是二进制位数组（bit array），底层使用 SDS 字符串表示，因为 SDS 是二进制安全的</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E4%BD%8D%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84.png"></p>
<p>buf 数组的每个字节用一行表示，buf[1] 是 <code>&#39;\0&#39;</code>，保存位数组的顺序和书写位数组的顺序是完全相反的，图示的位数组 0100 1101</p>
<p>数据结构的详解查看 Java → Algorithm → 位图</p>
<hr>
<h4 id="命令实现"><a href="#命令实现" class="headerlink" title="命令实现"></a>命令实现</h4><h5 id="GETBIT"><a href="#GETBIT" class="headerlink" title="GETBIT"></a>GETBIT</h5><p>GETBIT 命令获取位数组 bitarray 在 offset 偏移量上的二进制位的值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GETBIT &lt;bitarray&gt; &lt;offset&gt;</span><br></pre></td></tr></table></figure>

<p>执行过程：</p>
<ul>
<li>计算 <code>byte = offset/8</code>（向下取整）, byte 值记录数据保存在位数组中的索引</li>
<li>计算 <code>bit = (offset mod 8) + 1</code>，bit 值记录数据在位数组中的第几个二进制位</li>
<li>根据 byte 和 bit 值，在位数组 bitarray 中定位 offset 偏移量指定的二进制位，并返回这个位的值</li>
</ul>
<p>GETBIT 命令执行的所有操作都可以在常数时间内完成，所以时间复杂度为 O(1)</p>
<hr>
<h5 id="SETBIT"><a href="#SETBIT" class="headerlink" title="SETBIT"></a>SETBIT</h5><p>SETBIT 将位数组 bitarray 在 offset 偏移量上的二进制位的值设置为 value，并向客户端返回二进制位的旧值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SETBIT &lt;bitarray&gt; &lt;offset&gt; &lt;value&gt; </span><br></pre></td></tr></table></figure>

<p>执行过程：</p>
<ul>
<li>计算 <code>len = offset/8 + 1</code>，len 值记录了保存该数据至少需要多少个字节</li>
<li>检查 bitarray 键保存的位数组的长度是否小于 len，成立就会将 SDS 扩展为 len 字节（注意空间预分配机制），所有新扩展空间的二进制位的值置为 0</li>
<li>计算 <code>byte = offset/8</code>（向下取整）, byte 值记录数据保存在位数组中的索引</li>
<li>计算 <code>bit = (offset mod 8) + 1</code>，bit 值记录数据在位数组中的第几个二进制位</li>
<li>根据 byte 和 bit 值，在位数组 bitarray 中定位 offset 偏移量指定的二进制位，首先将指定位现存的值保存在 oldvalue 变量，然后将新值 value 设置为这个二进制位的值</li>
<li>向客户端返回 oldvalue 变量的值</li>
</ul>
<hr>
<h5 id="BITCOUNT"><a href="#BITCOUNT" class="headerlink" title="BITCOUNT"></a>BITCOUNT</h5><p>BITCOUNT 命令用于统计给定位数组中，值为 1 的二进制位的数量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">BITCOUNT &lt;bitarray&gt; [start end]</span><br></pre></td></tr></table></figure>

<p>二进制位统计算法：</p>
<ul>
<li>遍历法：遍历位数组中的每个二进制位</li>
<li>查表算法：读取每个字节（8 位）的数据，查表获取数值对应的二进制中有几个 1 </li>
<li>variable-precision SWAR算法：计算汉明距离</li>
<li>Redis 实现：<ul>
<li>如果二进制位的数量大于等于 128 位， 那么使用 variable-precision SWAR 算法来计算二进制位的汉明重量</li>
<li>如果二进制位的数量小于 128 位，那么使用查表算法来计算二进制位的汉明重量</li>
</ul>
</li>
</ul>
<hr>
<h5 id="BITOP"><a href="#BITOP" class="headerlink" title="BITOP"></a>BITOP</h5><p>BITOP 命令对指定 key 按位进行交、并、非、异或操作，并将结果保存到指定的键中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">BITOP OPTION destKey key1 [key2...]</span><br></pre></td></tr></table></figure>

<p>OPTION 有 AND（与）、OR（或）、 XOR（异或）和 NOT（非）四个选项</p>
<p>AND、OR、XOR 三个命令可以接受多个位数组作为输入，需要遍历输入的每个位数组的每个字节来进行计算，所以命令的复杂度为 O(n^2)；与此相反，NOT 命令只接受一个位数组输入，所以时间复杂度为 O(n)</p>
<hr>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><p><strong>解决 Redis 缓存穿透</strong>，判断给定数据是否存在， 防止缓存穿透</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-Bitmaps应用之缓存穿透.png" style="zoom: 67%;">
</li>
<li><p>垃圾邮件过滤，对每一个发送邮件的地址进行判断是否在布隆的黑名单中，如果在就判断为垃圾邮件</p>
</li>
<li><p>爬虫去重，爬给定网址的时候对已经爬取过的 URL 去重</p>
</li>
<li><p>信息状态统计</p>
</li>
</ul>
<hr>
<h3 id="Hyper"><a href="#Hyper" class="headerlink" title="Hyper"></a>Hyper</h3><p>基数是数据集去重后元素个数，HyperLogLog 是用来做基数统计的，运用了 LogLog 的算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>&#125; 	基数集： &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> ,<span class="number">7</span>, <span class="number">8</span>&#125; 	基数：<span class="number">5</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">1</span>&#125; 	基数集： &#123;<span class="number">1</span>,<span class="number">7</span>&#125; 				基数：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>相关指令：</p>
<ul>
<li><p>添加数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pfadd key element [element ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pfcount key [key ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pfmerge destkey sourcekey [sourcekey...]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>应用场景：</p>
<ul>
<li>用于进行基数统计，不是集合不保存数据，只记录数量而不是具体数据，比如网站的访问量</li>
<li>核心是基数估算算法，最终数值存在一定误差</li>
<li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li>
<li>耗空间极小，每个 hyperloglog key 占用了12K的内存用于标记基数</li>
<li>pfadd 命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大</li>
<li>Pfmerge 命令合并后占用的存储空间为12K，无论合并之前数据量多少</li>
</ul>
<hr>
<h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>GeoHash 是一种地址编码方法，把二维的空间经纬度数据编码成一个字符串</p>
<ul>
<li><p>添加坐标点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">geoadd key longitude latitude member [longitude latitude member ...]</span><br><span class="line">georadius key longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取坐标点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">geopos key member [member ...]</span><br><span class="line">georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算距离</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">geodist key member1 member2 [unit]	<span class="comment">#计算坐标点距离</span></span><br><span class="line">geohash key member [member ...]		<span class="comment">#计算经纬度</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>Redis 应用于地理位置计算</p>
<hr>
<h2 id="持久机制"><a href="#持久机制" class="headerlink" title="持久机制"></a>持久机制</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>持久化：利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化 </p>
<p>作用：持久化用于防止数据的意外丢失，确保数据安全性，因为 Redis 是内存级，所以需要持久化到磁盘</p>
<p>计算机中的数据全部都是二进制，保存一组数据有两种方式<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-持久化的两种方式.png" style="zoom: 33%;"></p>
<p>RDB：将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单</p>
<p>AOF：将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂</p>
<hr>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="文件创建"><a href="#文件创建" class="headerlink" title="文件创建"></a>文件创建</h4><p>RDB 持久化功能所生成的 RDB 文件 是一个经过压缩的紧凑二进制文件，通过该文件可以还原生成 RDB 文件时的数据库状态，有两个 Redis 命令可以生成 RDB 文件，一个是 SAVE，另一个是 BGSAVE</p>
<h5 id="SAVE"><a href="#SAVE" class="headerlink" title="SAVE"></a>SAVE</h5><p>SAVE 指令：手动执行一次保存操作，该指令的执行会阻塞当前 Redis 服务器，客户端发送的所有命令请求都会被拒绝，直到当前 RDB 过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用</p>
<p>工作原理：Redis 是个<strong>单线程的工作模式</strong>，会创建一个任务队列，所有的命令都会进到这个队列排队执行。当某个指令在执行的时候，队列后面的指令都要等待，所以这种执行方式会非常耗时</p>
<p>配置 redis.conf：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span> path				<span class="comment">#设置存储.rdb文件的路径，通常设置成存储空间较大的目录中，目录名称data</span></span><br><span class="line">dbfilename <span class="string">&quot;x.rdb&quot;</span>		<span class="comment">#设置本地数据库文件名，默认值为dump.rdb，通常设置为dump-端口号.rdb</span></span><br><span class="line">rdbcompression <span class="built_in">yes</span>|no	<span class="comment">#设置存储至本地数据库时是否压缩数据，默认yes，设置为no节省CPU运行时间</span></span><br><span class="line">rdbchecksum <span class="built_in">yes</span>|no		<span class="comment">#设置读写文件过程是否进行RDB格式校验，默认yes</span></span><br></pre></td></tr></table></figure>



<hr>
<h5 id="BGSAVE"><a href="#BGSAVE" class="headerlink" title="BGSAVE"></a>BGSAVE</h5><p>BGSAVE：bg 是 background，代表后台执行，命令的完成需要两个进程，<strong>进程之间不相互影响</strong>，所以持久化期间 Redis 正常工作</p>
<p>工作原理：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-bgsave工作原理.png" style="zoom:67%;">

<p>流程：客户端发出 BGSAVE 指令，Redis 服务器使用 fork 函数创建一个子进程，然后响应后台已经开始执行的信息给客户端。子进程会异步执行持久化的操作，持久化过程是先将数据写入到一个临时文件中，持久化操作结束再用这个临时文件<strong>替换</strong>上次持久化的文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建子进程</span></span><br><span class="line">pid = fork()</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 子进程负责创建 RDB 文件</span></span><br><span class="line">    rdbSave()</span><br><span class="line">    <span class="comment"># 完成之后向父进程发送信号</span></span><br><span class="line">    signal_parent()</span><br><span class="line"><span class="keyword">elif</span> pid &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 父进程继续处理命令请求，并通过轮询等待子进程的信号</span></span><br><span class="line">    handle_request_and_wait_signal()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 处理出错恃况</span></span><br><span class="line">    handle_fork_error() </span><br></pre></td></tr></table></figure>

<p>配置 redis.conf</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">stop-writes-on-bgsave-error <span class="built_in">yes</span>|no	<span class="comment">#后台存储过程中如果出现错误，是否停止保存操作，默认yes</span></span><br><span class="line">dbfilename filename  </span><br><span class="line"><span class="built_in">dir</span> path  </span><br><span class="line">rdbcompression <span class="built_in">yes</span>|no  </span><br><span class="line">rdbchecksum <span class="built_in">yes</span>|no</span><br></pre></td></tr></table></figure>

<p>注意：BGSAVE 命令是针对 SAVE 阻塞问题做的优化，Redis 内部所有涉及到 RDB 操作都采用 BGSAVE 的方式，SAVE 命令放弃使用</p>
<p>在 BGSAVE 命令执行期间，服务器处理 SAVE、BGSAVE、BGREWRITEAOF 三个命令的方式会和平时有所不同</p>
<ul>
<li>SAVE 命令会被服务器拒绝，服务器禁止 SAVE 和 BGSAVE 命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个 rdbSave 调用，产生竞争条件</li>
<li>BGSAVE 命令也会被服务器拒绝，也会产生竞争条件</li>
<li>BGREWRITEAOF 和 BGSAVE 两个命令不能同时执行<ul>
<li>如果 BGSAVE 命令正在执行，那么 BGREWRITEAOF 命令会被<strong>延迟</strong>到 BGSAVE 命令执行完毕之后执行</li>
<li>如果 BGREWRITEAOF 命令正在执行，那么 BGSAVE 命令会被服务器拒绝</li>
</ul>
</li>
</ul>
<hr>
<h5 id="特殊指令"><a href="#特殊指令" class="headerlink" title="特殊指令"></a>特殊指令</h5><p>RDB 特殊启动形式的指令（客户端输入）</p>
<ul>
<li><p>服务器运行过程中重启</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">debug reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭服务器时指定保存数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">shutdown save</span><br></pre></td></tr></table></figure>

<p>默认情况下执行 shutdown 命令时，自动执行 bgsave（如果没有开启 AOF 持久化功能）</p>
</li>
<li><p>全量复制：主从复制部分详解</p>
</li>
</ul>
<hr>
<h4 id="文件载入"><a href="#文件载入" class="headerlink" title="文件载入"></a>文件载入</h4><p>RDB 文件的载入工作是在服务器启动时自动执行，期间 Redis 会一直处于阻塞状态，直到载入完成</p>
<p>Redis 并没有专门用于载入 RDB 文件的命令，只要服务器在启动时检测到 RDB 文件存在，就会自动载入 RDB 文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[7379] 30 Aug 21:07:01.289 * DB loaded from disk: 0.018 seconds  <span class="comment"># 服务器在成功载入 RDB 文件之后打印</span></span><br></pre></td></tr></table></figure>

<p>AOF 文件的更新频率通常比 RDB 文件的更新频率高：</p>
<ul>
<li>如果服务器开启了 AOF 持久化功能，那么会优先使用 AOF 文件来还原数据库状态</li>
<li>只有在 AOF 持久化功能处于关闭状态时，服务器才会使用 RDB 文件来还原数据库状态</li>
</ul>
<hr>
<h4 id="自动保存"><a href="#自动保存" class="headerlink" title="自动保存"></a>自动保存</h4><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>Redis 支持通过配置服务器的 save 选项，让服务器每隔一段时间自动执行一次 BGSAVE 命令</p>
<p>配置 redis.conf：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">save second changes <span class="comment">#设置自动持久化条件，满足限定时间范围内key的变化数量就进行持久化(bgsave)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>second：监控时间范围</li>
<li>changes：监控 key 的变化量</li>
</ul>
<p>默认三个条件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">save 900 1		<span class="comment"># 900s内1个key发生变化就进行持久化</span></span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>判定 key 变化的依据：</p>
<ul>
<li>对数据产生了影响，不包括查询</li>
<li>不进行数据比对，比如 name 键存在，重新 set name seazean 也算一次变化</li>
</ul>
<p>save 配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的</p>
<hr>
<h5 id="自动原理"><a href="#自动原理" class="headerlink" title="自动原理"></a>自动原理</h5><p>服务器状态相关的属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录了保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改计数器</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dirty;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上一次执行保存的时间 </span></span><br><span class="line">    <span class="type">time_t</span> lastsave;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Redis 服务器启动时，可以通过指定配置文件或者传入启动参数的方式设置 save 选项， 如果没有自定义就设置为三个默认值（上节提及），设置服务器状态 redisServe.saveparams 属性，该数组每一项为一个 saveparam 结构，代表 save 的选项设置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> &#123;</span></span><br><span class="line">    <span class="comment">// 秒数</span></span><br><span class="line">    <span class="type">time_t</span> seconds</span><br><span class="line">    <span class="comment">// 修改数</span></span><br><span class="line">    <span class="type">int</span> changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>dirty 计数器记录距离上一次成功执行 SAVE 或者 BGSAVE 命令之后，服务器中的所有数据库进行了多少次修改（包括写入、删除、更新等操作），当服务器成功执行一个修改指令，该命令修改了多少次数据库， dirty 的值就增加多少</p>
</li>
<li><p>lastsave 属性是一个 UNIX 时间戳，记录了服务器上一次成功执行 SAVE 或者 BGSAVE 命令的时间</p>
</li>
</ul>
<p>Redis 的服务器周期性操作函数 serverCron 默认每隔 100 毫秒就会执行一次，该函数用于对正在运行的服务器进行维护</p>
<p>serverCron 函数的其中一项工作是检查 save 选项所设置的保存条件是否满足，会遍历 saveparams 数组中的<strong>所有保存条件</strong>，只要有任意一个条件被满足服务器就会执行 BGSAVE 命令</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-BGSAVE%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86.png"></p>
<hr>
<h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><p>RDB 的存储结构：图示全大写单词标示常量，用全小写单词标示变量和数据</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-RDB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png"></p>
<ul>
<li>REDIS：长度为 5 字节，保存着 <code>REDIS</code> 五个字符，是 RDB 文件的开头，在载入文件时可以快速检查所载入的文件是否 RDB 文件</li>
<li>db_version：长度为 4 字节，是一个用字符串表示的整数，记录 RDB 的版本号</li>
<li>database：包含着零个或任意多个数据库，以及各个数据库中的键值对数据</li>
<li>EOF：长度为 1 字节的常量，标志着 RDB 文件正文内容的结束，当读入遇到这个值时，代表所有数据库的键值对都已经载入完毕</li>
<li>check_sum：长度为 8 字节的无符号整数，保存着一个校验和，该值是通过 REDIS、db_version、databases、EOF 四个部分的内容进行计算得出。服务器在载入 RDB 文件时，会将载入数据所计算出的校验和与 check_sum 所记录的校验和进行对比，来检查 RDB 文件是否有出错或者损坏</li>
</ul>
<p>Redis 本身带有 RDB 文件检查工具 redis-check-dump</p>
<hr>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h4 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h4><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令（不记录读）来记录数据库状态，<strong>增量保存</strong>只许追加文件但不可以改写文件，<strong>与 RDB 相比可以理解为由记录数据改为记录数据的变化</strong></p>
<p>AOF 主要作用是解决了<strong>数据持久化的实时性</strong>，目前已经是 Redis 持久化的主流方式</p>
<p>AOF 写数据过程：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-AOF工作原理.png" style="zoom:67%;">

<p>Redis 只会将对数据库进行了修改的命令写入到 AOF 文件，并复制到各个从服务器，但是 PUBSUB 和 SCRIPT LOAD 命令例外：</p>
<ul>
<li>PUBSUB 命令虽然没有修改数据库，但 PUBSUB 命令向频道的所有订阅者发送消息这一行为带有副作用，接收到消息的所有客户端的状态都会因为这个命令而改变，所以服务器需要使用 REDIS_FORCE_AOF 标志强制将这个命令写入 AOF 文件。这样在将来载入 AOF 文件时，服务器就可以再次执行相同的 PUBSUB 命令，并产生相同的副作用</li>
<li>SCRIPT LOAD  命令虽然没有修改数据库，但它修改了服务器状态，所以也是一个带有副作用的命令，需要使用 REDIS_FORCE_AOF</li>
</ul>
<hr>
<h4 id="持久实现"><a href="#持久实现" class="headerlink" title="持久实现"></a>持久实现</h4><p>AOF 持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤</p>
<h5 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h5><p>启动 AOF 的基本配置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">appendonly <span class="built_in">yes</span>|no				<span class="comment">#开启AOF持久化功能，默认no，即不开启状态</span></span><br><span class="line">appendfilename filename			<span class="comment">#AOF持久化文件名，默认appendonly.aof，建议设置appendonly-端口号.aof</span></span><br><span class="line"><span class="built_in">dir</span>								<span class="comment">#AOF持久化文件保存路径，与RDB持久化文件路径保持一致即可</span></span><br></pre></td></tr></table></figure>

<p>当 AOF 持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令<strong>追加</strong>到服务器状态的 aof_buf 缓冲区的末尾</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// AOF 缓冲区</span></span><br><span class="line">    sds aof_buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h5><p>服务器在处理文件事件时会执行<strong>写命令，追加一些内容到 aof_buf 缓冲区</strong>里，所以服务器每次结束一个事件循环之前，就会执行 flushAppendOnlyFile 函数，判断是否需要<strong>将 aof_buf 缓冲区中的内容写入和保存到 AOF 文件</strong>里</p>
<p>flushAppendOnlyFile 函数的行为由服务器配置的 appendfsync 选项的值来决定</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">appendfsync always|everysec|no	<span class="comment">#AOF写数据策略：默认为everysec</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>always：每次写入操作都将 aof_buf 缓冲区中的所有内容<strong>写入并同步</strong>到 AOF 文件</p>
<p>特点：安全性最高，数据零误差，但是性能较低，不建议使用</p>
</li>
<li><p>everysec：先将 aof_buf 缓冲区中的内容写入到 AOF 文件，判断上次同步 AOF 文件的时间距离现在超过一秒钟，再次对 AOF 文件进行同步，这个同步操作是由一个（子）线程专门负责执行的</p>
<p>特点：在系统突然宕机的情况下丢失 1 秒内的数据，准确性较高，性能较高，建议使用，也是默认配置</p>
</li>
<li><p>no：将 aof_buf 缓冲区中的内容写入到 AOF 文件，但并不对 AOF 文件进行同步，何时同步由操作系统来决定</p>
<p>特点：<strong>整体不可控</strong>，服务器宕机会丢失上次同步 AOF 后的所有写指令</p>
</li>
</ul>
<hr>
<h5 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h5><p>在现代操作系统中，当用户调用 write 函数将数据写入文件时，操作系统通常会将写入数据暂时保存在一个内存缓冲区空间，等到缓冲区<strong>写满或者到达特定时间周期</strong>，才真正地将缓冲区中的数据写入到磁盘里面（刷脏）</p>
<ul>
<li>优点：提高文件的写入效率</li>
<li>缺点：为写入数据带来了安全问题，如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失</li>
</ul>
<p>系统提供了 fsync 和 fdatasync 两个同步函数做<strong>强制硬盘同步</strong>，可以让操作系统立即将缓冲区中的数据写入到硬盘里面，函数会阻塞到写入硬盘完成后返回，保证了数据持久化</p>
<p>异常恢复：AOF 文件损坏，通过 redis-check-aof–fix appendonly.aof 进行恢复，重启 Redis，然后重新加载</p>
<hr>
<h4 id="文件载入-1"><a href="#文件载入-1" class="headerlink" title="文件载入"></a>文件载入</h4><p>AOF 文件里包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍 AOF 文件里的命令，就还原服务器关闭之前的数据库状态，服务器在启动时，还原数据库状态打印的日志：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[8321] 05 Sep 11:58:50.449 * DB loaded from append only file: 0.000 seconds </span><br></pre></td></tr></table></figure>

<p>AOF 文件里面除了用于指定数据库的 SELECT 命令是服务器自动添加的，其他都是通过客户端发送的命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">* 2\r\n<span class="variable">$6</span>\r\nSELECT\r\n<span class="variable">$1</span>\r\n0\r\n	<span class="comment"># 服务器自动添加</span></span><br><span class="line">* 3\r\n<span class="variable">$3</span>\r\nSET\r\n<span class="variable">$3</span>\r\nmsg\r\n<span class="variable">$5</span>\r\nhello\r\n</span><br><span class="line">* 5\r\n<span class="variable">$4</span>\r\nSADD\r\n<span class="variable">$6</span>\r\nfruits\r\n<span class="variable">$5</span>\r\napple\r\n<span class="variable">$6</span>\r\nbanana\r\n<span class="variable">$6</span>\r\ncherry\r\n</span><br></pre></td></tr></table></figure>

<p>Redis 读取 AOF 文件并还原数据库状态的步骤：</p>
<ul>
<li>创建一个<strong>不带网络连接的伪客户端</strong>（fake client）执行命令，因为 Redis 的命令只能在客户端上下文中执行， 而载入 AOF 文件时所使用的命令来源于本地 AOF 文件而不是网络连接</li>
<li>从 AOF 文件分析并读取一条写命令</li>
<li>使用伪客户端执行被读出的写命令，然后重复上述步骤</li>
</ul>
<hr>
<h4 id="重写实现"><a href="#重写实现" class="headerlink" title="重写实现"></a>重写实现</h4><h5 id="重写策略"><a href="#重写策略" class="headerlink" title="重写策略"></a>重写策略</h5><p>AOF 重写：读取服务器当前的数据库状态，<strong>生成新 AOF 文件来替换旧 AOF 文件</strong>，不会对现有的 AOF 文件进行任何读取、分析或者写入操作，而是直接原子替换。新 AOF 文件不会包含任何浪费空间的冗余命令，所以体积通常会比旧 AOF 文件小得多</p>
<p>AOF 重写规则：</p>
<ul>
<li><p>进程内具有时效性的数据，并且数据已超时将不再写入文件 </p>
</li>
<li><p>对同一数据的多条写命令合并为一条命令，因为会读取当前的状态，所以直接将当前状态转换为一条命令即可。为防止数据量过大造成客户端缓冲区溢出，对 list、set、hash、zset 等集合类型，<strong>单条指令</strong>最多写入 64 个元素</p>
<p>如 lpushlist1 a、lpush list1 b、lpush list1 c 可以转化为：lpush list1 a b c</p>
</li>
<li><p>非写入类的无效指令将被忽略，只保留最终数据的写入命令，但是 select 指令虽然不更改数据，但是更改了数据的存储位置，此类命令同样需要记录</p>
</li>
</ul>
<p>AOF 重写作用：</p>
<ul>
<li>降低磁盘占用量，提高磁盘利用率</li>
<li>提高持久化效率，降低持久化写时间，提高 IO 性能</li>
<li>降低数据恢复的用时，提高数据恢复效率</li>
</ul>
<hr>
<h5 id="重写原理"><a href="#重写原理" class="headerlink" title="重写原理"></a>重写原理</h5><p>AOF 重写程序 aof_rewrite 函数可以创建一个新 AOF 文件， 但是该函数会进行大量的写入操作，调用这个函数的线程将被长时间阻塞，所以 Redis 将 AOF 重写程序放到 fork 的子进程里执行，不会阻塞父进程，重写命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bgrewriteaof</span><br></pre></td></tr></table></figure>

<ul>
<li><p>子进程进行 AOF 重写期间，服务器进程（父进程）可以继续处理命令请求</p>
</li>
<li><p>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下， 保证数据的安全性</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-AOF%E6%89%8B%E5%8A%A8%E9%87%8D%E5%86%99%E5%8E%9F%E7%90%86.png"></p>
</li>
</ul>
<p>子进程在进行 AOF 重写期间，服务器进程还需要继续处理命令请求，而新命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的 AOF 文件所保存的数据库状态不一致，所以 Redis 设置了 AOF 重写缓冲区</p>
<p>工作流程：</p>
<ul>
<li>Redis 服务器执行完一个写命令，会同时将该命令追加到 AOF 缓冲区和 AOF 重写缓冲区（从创建子进程后才开始写入）</li>
<li>当子进程完成 AOF 重写工作之后，会向父进程发送一个信号，父进程在接到该信号之后， 会调用一个信号处理函数，该函数执行时会<strong>对服务器进程（父进程）造成阻塞</strong>（影响很小，类似 JVM STW），主要工作：<ul>
<li>将 AOF 重写缓冲区中的所有内容写入到新 AOF 文件中， 这时新 AOF 文件所保存的状态将和服务器当前的数据库状态一致</li>
<li>对新的 AOF 文件进行改名，<strong>原子地（atomic）覆盖</strong>现有的 AOF 文件，完成新旧两个 AOF 文件的替换</li>
</ul>
</li>
</ul>
<hr>
<h5 id="自动重写"><a href="#自动重写" class="headerlink" title="自动重写"></a>自动重写</h5><p>触发时机：Redis 会记录上次重写时的 AOF 大小，默认配置是当 AOF 文件大小是上次重写后大小的一倍且文件大于 64M 时触发</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-min-size size		<span class="comment">#设置重写的基准值，最小文件 64MB，达到这个值开始重写</span></span><br><span class="line">auto-aof-rewrite-percentage percent	<span class="comment">#触发AOF文件执行重写的增长率，当前AOF文件大小超过上一次重写的AOF文件大小的百分之多少才会重写，比如文件达到 100% 时开始重写就是两倍时触发</span></span><br></pre></td></tr></table></figure>

<p>自动重写触发比对参数（ 运行指令 <code>info Persistence</code> 获取具体信息 ）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">aof_current_size					<span class="comment">#AOF文件当前尺寸大小（单位:字节）</span></span><br><span class="line">aof_base_size						<span class="comment">#AOF文件上次启动和重写时的尺寸大小（单位:字节）</span></span><br></pre></td></tr></table></figure>

<p>自动重写触发条件公式：</p>
<ul>
<li>aof_current_size &gt; auto-aof-rewrite-min-size</li>
<li>(aof_current_size - aof_base_size) &#x2F; aof_base_size &gt;&#x3D; auto-aof-rewrite-percentage</li>
</ul>
<hr>
<h3 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h3><p>RDB 的特点</p>
<ul>
<li><p>RDB 优点：</p>
<ul>
<li>RDB 是一个紧凑压缩的二进制文件，存储效率较高，但存储数据量较大时，存储效率较低</li>
<li>RDB 内部存储的是 Redis 在某个时间点的数据快照，非常<strong>适合用于数据备份，全量复制、灾难恢复</strong></li>
<li>RDB 恢复数据的速度要比 AOF 快很多，因为是快照，直接恢复</li>
</ul>
</li>
<li><p>RDB 缺点：</p>
<ul>
<li>BGSAVE 指令每次运行要执行 fork 操作创建子进程，会牺牲一些性能</li>
<li>RDB 方式无论是执行指令还是利用配置，无法做到实时持久化，具有丢失数据的可能性，最后一次持久化后的数据可能丢失</li>
<li>Redis 的众多版本中未进行 RDB 文件格式的版本统一，可能出现各版本之间数据格式无法兼容</li>
</ul>
</li>
</ul>
<p>AOF 特点：</p>
<ul>
<li>AOF 的优点：数据持久化有较好的实时性，通过 AOF 重写可以降低文件的体积</li>
<li>AOF 的缺点：文件较大时恢复较慢</li>
</ul>
<p>AOF 和 RDB 同时开启，系统默认取 AOF 的数据（数据不会存在丢失）</p>
<p>应用场景：</p>
<ul>
<li><p>对数据<strong>非常敏感</strong>，建议使用默认的 AOF 持久化方案，AOF 持久化策略使用 everysecond，每秒钟 fsync 一次，该策略 Redis 仍可以保持很好的处理性能</p>
<p>注意：AOF 文件存储体积较大，恢复速度较慢，因为要执行每条指令</p>
</li>
<li><p>数据呈现<strong>阶段有效性</strong>，建议使用 RDB 持久化方案，可以做到阶段内无丢失，且恢复速度较快</p>
<p>注意：利用 RDB 实现紧凑的数据持久化，存储数据量较大时，存储效率较低</p>
</li>
</ul>
<p>综合对比：</p>
<ul>
<li>RDB 与 AOF 的选择实际上是在做一种权衡，每种都有利有弊</li>
<li>灾难恢复选用 RDB</li>
<li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用 AOF；如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用 RDB</li>
<li>双保险策略，同时开启 RDB 和 AOF，重启后 Redis 优先使用 AOF 来恢复数据，降低丢失数据的量</li>
<li>不建议单独用 AOF，因为可能会出现 Bug，如果只是做纯内存缓存，可以都不用</li>
</ul>
<hr>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>fork() 函数创建一个子进程，子进程与父进程几乎是完全相同的进程，系统先给子进程分配资源，然后把父进程的所有数据都复制到子进程中，只有少数值与父进程的值不同，相当于克隆了一个进程</p>
<p>在完成对其调用之后，会产生 2 个进程，且每个进程都会<strong>从 fork() 的返回处开始执行</strong>，这两个进程将执行相同的程序段，但是拥有各自不同的堆段，栈段，数据段，每个子进程都可修改各自的数据段，堆段，和栈段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 父进程返回子进程的pid，子进程返回0，错误返回负值，根据返回值的不同进行对应的逻辑处理</span></span><br></pre></td></tr></table></figure>

<p>fork 调用一次，却能够<strong>返回两次</strong>，可能有三种不同的返回值：</p>
<ul>
<li>在父进程中，fork 返回新创建子进程的进程 ID</li>
<li>在子进程中，fork 返回 0</li>
<li>如果出现错误，fork 返回一个负值，错误原因：<ul>
<li>当前的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN</li>
<li>系统内存不足，这时 errno 的值被设置为 ENOMEM</li>
</ul>
</li>
</ul>
<p>fpid 的值在父子进程中不同：进程形成了链表，父进程的 fpid 指向子进程的进程 id，因为子进程没有子进程，所以其 fpid 为0</p>
<p>创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的调度策略</p>
<p>每个进程都有一个独特（互不相同）的进程标识符 process ID，可以通过 getpid() 函数获得；还有一个记录父进程 pid 的变量，可以通过 getppid() 函数获得变量的值</p>
<hr>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>基本使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>   </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>   </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">pid_t</span> fpid; <span class="comment">// fpid表示fork函数返回的值  </span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;  </span><br><span class="line">    fpid = fork();   </span><br><span class="line">    <span class="keyword">if</span> (fpid &lt; <span class="number">0</span>)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error in fork!&quot;</span>);   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am the child process, my process id is %d/n&quot;</span>, getpid());    </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am the parent process, my process id is %d/n&quot;</span>, getpid());   </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;count: %d/n&quot;</span>,count);<span class="comment">// 1  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/* 输出内容：</span></span><br><span class="line"><span class="comment">    i am the child process, my process id is 5574</span></span><br><span class="line"><span class="comment">    count: 1</span></span><br><span class="line"><span class="comment">    i am the parent process, my process id is 5573</span></span><br><span class="line"><span class="comment">    count: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>进阶使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line">   <span class="comment">// ppid 指当前进程的父进程pid  </span></span><br><span class="line">   <span class="comment">// pid 指当前进程的pid,  </span></span><br><span class="line">   <span class="comment">// fpid 指fork返回给当前进程的值，在这可以表示子进程</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;  </span><br><span class="line">       <span class="type">pid_t</span> fpid = fork();  </span><br><span class="line">       <span class="keyword">if</span>(fpid == <span class="number">0</span>)  </span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%d child  %4d %4d %4d/n&quot;</span>,i, getppid(), getpid(), fpid);  </span><br><span class="line">       <span class="keyword">else</span>  </span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%d parent %4d %4d %4d/n&quot;</span>,i, getppid(), getpid(),fpid);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*输出内容：</span></span><br><span class="line"><span class="comment">	i        父id  id  子id</span></span><br><span class="line"><span class="comment">	0 parent 2043 3224 3225</span></span><br><span class="line"><span class="comment">    0 child  3224 3225    0</span></span><br><span class="line"><span class="comment">    1 parent 2043 3224 3226</span></span><br><span class="line"><span class="comment">    1 parent 3224 3225 3227</span></span><br><span class="line"><span class="comment">    1 child     1 3227    0</span></span><br><span class="line"><span class="comment">    1 child     1 3226    0 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-fork函数使用演示.png" style="zoom: 80%;">

<p>在 p3224 和 p3225 执行完第二个循环后，main 函数退出，进程死亡。所以 p3226，p3227 就没有父进程了，成为孤儿进程，所以 p3226 和 p3227 的父进程就被置为 ID 为 1的 init 进程（笔记 Tool → Linux → 进程管理详解）</p>
<p>参考文章：<a href="https://blog.csdn.net/love_gaohz/article/details/41727415">https://blog.csdn.net/love_gaohz/article/details/41727415</a></p>
<hr>
<h4 id="内存-1"><a href="#内存-1" class="headerlink" title="内存"></a>内存</h4><p>fork() 调用之后父子进程的内存关系</p>
<p>早期 Linux 的 fork() 实现时，就是全部复制，这种方法效率太低，而且造成了很大的内存浪费，现在 Linux 实现采用了两种方法：</p>
<ul>
<li><p>父子进程的代码段是相同的，所以代码段是没必要复制的，只需内核将代码段标记为只读，父子进程就共享此代码段。fork() 之后在进程创建代码段时，子进程的进程级页表项都指向和父进程相同的物理页帧</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-fork以后内存关系1.png" style="zoom: 67%;">
</li>
<li><p>对于父进程的数据段，堆段，栈段中的各页，由于父子进程相互独立，采用<strong>写时复制 COW</strong> 的技术，来提高内存以及内核的利用率</p>
<p>在 fork 之后两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，<strong>两者的虚拟空间不同，但其对应的物理空间是同一个</strong>，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。如果两者的代码完全相同，代码段继续共享父进程的物理空间；而如果两者执行的代码不同，子进程的代码段也会分配单独的物理空间。   </p>
<p>fork 之后内核会将子进程放在队列的前面，让子进程先执行，以免父进程执行导致写时复制，而后子进程再执行，因无意义的复制而造成效率的下降</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-fork以后内存关系2.png" style="zoom:67%;"></li>
</ul>
<p>补充知识：</p>
<p>vfork（虚拟内存 fork virtual memory fork）：调用 vfork() 父进程被挂起，子进程使用父进程的地址空间。不采用写时复制，如果子进程修改父地址空间的任何页面，这些修改过的页面对于恢复的父进程是可见的</p>
<p>参考文章：<a href="https://blog.csdn.net/Shreck66/article/details/47039937">https://blog.csdn.net/Shreck66/article/details/47039937</a></p>
<hr>
<h2 id="事务机制-1"><a href="#事务机制-1" class="headerlink" title="事务机制"></a>事务机制</h2><h3 id="事务特征"><a href="#事务特征" class="headerlink" title="事务特征"></a>事务特征</h3><p>Redis 事务就是将多个命令请求打包，然后<strong>一次性、按顺序</strong>地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务去执行其他的命令请求，会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求，Redis 事务的特性：</p>
<ul>
<li>Redis 事务<strong>没有隔离级别</strong>的概念，队列中的命令在事务没有提交之前都不会实际被执行</li>
<li>Redis 单条命令式保存原子性的，但是事务<strong>不保证原子性</strong>，事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li>
</ul>
<hr>
<h3 id="工作流程-3"><a href="#工作流程-3" class="headerlink" title="工作流程"></a>工作流程</h3><p>事务的执行流程分为三个阶段：</p>
<ul>
<li><p>事务开始：MULTI 命令的执行标志着事务的开始，通过在客户端状态的 flags 属性中打开 REDIS_MULTI 标识，将执行该命令的客户端从非事务状态切换至事务状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MULTI	<span class="comment"># 设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>命令入队：事务队列以先进先出（FIFO）的方式保存入队的命令，每个 Redis 客户端都有事务状态，包含着事务队列：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">	<span class="comment">// 事务状态</span></span><br><span class="line">    multiState mstate;	<span class="comment">/* MULTI/EXEC state */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 事务队列，FIFO顺序</span></span><br><span class="line">    multiCmd *commands; </span><br><span class="line">    </span><br><span class="line">   	<span class="comment">// 已入队命令计数</span></span><br><span class="line">    <span class="type">int</span> count；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果命令为 EXEC、DISCARD、WATCH、MULTI 四个命中的一个，那么服务器立即执行这个命令</li>
<li>其他命令服务器不执行，而是将命令放入一个事务队列里面，然后向客户端返回 QUEUED 回复</li>
</ul>
</li>
<li><p>事务执行：EXEC 提交事务给服务器执行，服务器会遍历这个客户端的事务队列，执行队列中的命令并将执行结果返回</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">EXEC	<span class="comment"># Commit 提交，执行事务，与multi成对出现，成对使用</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>事务取消的方法：</p>
<ul>
<li><p>取消事务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">DISCARD	<span class="comment"># 终止当前事务的定义，发生在multi之后，exec之前</span></span><br></pre></td></tr></table></figure>

<p>一般用于事务执行过程中输入了错误的指令，直接取消这次事务，类似于回滚</p>
</li>
</ul>
<hr>
<h3 id="WATCH"><a href="#WATCH" class="headerlink" title="WATCH"></a>WATCH</h3><h4 id="监视机制"><a href="#监视机制" class="headerlink" title="监视机制"></a>监视机制</h4><p>WATCH 命令是一个乐观锁（optimistic locking），可以在 EXEC 命令执行之前，监视任意数量的数据库键，并在 EXEC 命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复</p>
<ul>
<li><p>添加监控锁</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">WATCH key1 [key2……]	<span class="comment">#可以监控一个或者多个key</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>取消对所有 key 的监视</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">UNWATCH</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><p>每个 Redis 数据库都保存着一个 watched_keys 字典，键是某个被 WATCH 监视的数据库键，值则是一个链表，记录了所有监视相应数据库键的客户端：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">	<span class="comment">// 正在被 WATCH 命令监视的键</span></span><br><span class="line">    dict *watched_keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有对数据库进行修改的命令，在执行后都会调用 <code>multi.c/touchWatchKey</code> 函数对 watched_keys 字典进行检查，是否有客户端正在监视刚被命令修改过的数据库键，如果有的话函数会将监视被修改键的客户端的 REDIS_DIRTY_CAS 标识打开，表示该客户端的事务安全性已经被破坏</p>
<p>服务器接收到个客户端 EXEC 命令时，会根据这个客户端是否打开了 REDIS_DIRTY_CAS 标识，如果打开了说明客户端提交事务不安全，服务器会拒绝执行</p>
<hr>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>事务具有原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</p>
<p>原子性指事务队列中的命令要么就全部都执行，要么一个都不执行，但是在命令执行出错时，不会保证原子性（下一节详解）</p>
<p>Redis 不支持事务回滚机制（rollback），即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止</p>
<p>回滚需要程序员在代码中实现，应该尽可能避免：</p>
<ul>
<li><p>事务操作之前记录数据的状态</p>
<ul>
<li><p>单数据：string</p>
</li>
<li><p>多数据：hash、list、set、zset</p>
</li>
</ul>
</li>
<li><p>设置指令恢复所有的被修改的项</p>
<ul>
<li><p>单数据：直接 set（注意周边属性，例如时效）</p>
</li>
<li><p>多数据：修改对应值或整体克隆复制</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>事务具有一致性指的是，数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的</p>
<p>一致是数据符合数据库的定义和要求，没有包含非法或者无效的错误数据，Redis 通过错误检测和简单的设计来保证事务的一致性：</p>
<ul>
<li><p>入队错误：命令格式输入错误，出现语法错误造成，<strong>整体事务中所有命令均不会执行</strong>，包括那些语法正确的命令</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-命令的语法错误.png" style="zoom:80%;">
</li>
<li><p>执行错误：命令执行出现错误，例如对字符串进行 incr 操作，事务中正确的命令会被执行，运行错误的命令不会被执行</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-事务中执行错误.png" style="zoom:80%;">
</li>
<li><p>服务器停机：</p>
<ul>
<li>如果服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据库是一致的</li>
<li>如果服务器运行在持久化模式下，重启之后将数据库还原到一致的状态</li>
</ul>
</li>
</ul>
<hr>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>Redis 是一个单线程的执行原理，所以对于隔离性，分以下两种情况：</p>
<ul>
<li>并发操作在 EXEC 命令前执行，隔离性的保证要使用 WATCH 机制来实现，否则隔离性无法保证</li>
<li>并发操作在 EXEC 命令后执行，隔离性可以保证</li>
</ul>
<hr>
<h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p>Redis 并没有为事务提供任何额外的持久化功能，事务的持久性由 Redis 所使用的持久化模式决定</p>
<p>配置选项 <code>no-appendfsync-on-rewrite</code> 可以配合 appendfsync 选项在 AOF 持久化模式使用：</p>
<ul>
<li>选项打开时在执行 BGSAVE 或者 BGREWRITEAOF 期间，服务器会暂时停止对 AOF 文件进行同步，从而尽可能地减少 I&#x2F;O 阻塞</li>
<li>选项打开时运行在 always 模式的 AOF 持久化，事务也不具有持久性，所以该选项默认关闭</li>
</ul>
<p>在一个事务的最后加上 SAVE 命令总可以保证事务的耐久性</p>
<hr>
<h2 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="Lua 脚本"></a>Lua 脚本</h2><h3 id="环境创建"><a href="#环境创建" class="headerlink" title="环境创建"></a>环境创建</h3><h4 id="基本介绍-16"><a href="#基本介绍-16" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>Redis 对 Lua 脚本支持，通过在服务器中嵌入 Lua 环境，客户端可以使用 Lua 脚本直接在服务器端<strong>原子地执行</strong>多个命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">EVAL &lt;script&gt; &lt;numkeys&gt; [key ...] [arg ...]</span><br><span class="line">EVALSHA &lt;sha1&gt; &lt;numkeys&gt; [key ...] [arg ...]</span><br></pre></td></tr></table></figure>

<p>EVAL 命令可以直接对输入的脚本计算：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; EVAL <span class="string">&quot;return 1 + 1&quot;</span> 0	<span class="comment"># 0代表需要的参数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2 </span><br></pre></td></tr></table></figure>

<p>EVALSHA 命令根据脚本的 SHA1 校验和来对脚本计算：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; EVALSHA <span class="string">&quot;2f3lba2bb6d6a0f42ccl59d2e2dad55440778de3&quot;</span> 0</span><br><span class="line">(<span class="built_in">integer</span>) 2 </span><br></pre></td></tr></table></figure>

<p>应用场景：Redis 只保证单条命令的原子性，所以为了实现原子操作，将多条的对 Redis 的操作整合到一个脚本里，但是避免把不需要做并发控制的操作写入脚本中</p>
<p>Lua 语法特点：</p>
<ul>
<li>声明变量的时候无需指定数据类型，而是用 local 来声明变量为局部变量</li>
<li>数组下标是从 1 开始</li>
</ul>
<hr>
<h4 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h4><p>Redis 服务器创建并修改 Lua 环境的整个过程：</p>
<ul>
<li><p>创建一个基础的 Lua 环境，调用 Lua 的 API 函数 lua_open</p>
</li>
<li><p>载入多个函数库到 Lua 环境里面，让 Lua 脚本可以使用这些函数库来进行数据操作，包括基础核心函数</p>
</li>
<li><p>创建全局变量 redis 表格，表格包含以下函数：</p>
<ul>
<li>执行 Redis 命令的 redis.call 和 redis.pcall 函数</li>
<li>记录 Redis 日志的 redis.log 函数，以及相应的日志级别 (level) 常量 redis.LOG_DEBUG 等</li>
<li>计算 SHAl 校验和的 redis.shalhex 函数</li>
<li>返回错误信息的 redis.error_reply 函数和 redis.status_reply 函数</li>
</ul>
</li>
<li><p>使用 Redis 自制的随机函数来替换 Lua 原有的带有副作用的随机函数，从而避免在脚本中引入副作用</p>
<p>Redis 要求所有传入服务器的 Lua 脚本，以及 Lua 环境中的所有函数，都必须是无副作用（side effect）的纯函数（pure function），所以对有副作用的随机函数 <code>math.random</code> 和 <code>math.randornseed</code> 进行替换</p>
</li>
<li><p>创建排序辅助函数 <code> _redis_compare_helper</code>，使用辅助函数来对一部分 Redis 命令的结果进行排序，从而消除命令的不确定性</p>
<p>比如集合元素的排列是无序的， 所以即使两个集合的元素完全相同，输出结果也不一定相同，Redis 将 SMEMBERS 这类在相同数据集上产生不同输出的命令称为带有不确定性的命令</p>
</li>
<li><p>创建 redis.pcall 函数的错误报告辅助函数 <code>_redis_err_handler </code>，这个函数可以打印出错代码的来源和发生错误的行数</p>
</li>
<li><p>对 Lua 环境中的全局环境进行保护，确保传入服务器的脚本不会因忘记使用 local 关键字，而将额外的全局变量添加到 Lua 环境</p>
</li>
<li><p>将完成修改的 Lua 环境保存到服务器状态的 lua 属性中，等待执行服务器传来的 Lua 脚本</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    Lua *lua;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Redis 使用串行化的方式来执行 Redis 命令，所以在任何时间里最多都只会有一个脚本能够被放进 Lua 环境里面运行，因此整个 Redis 服务器只需要创建一个 Lua 环境即可</p>
<hr>
<h3 id="协作组件"><a href="#协作组件" class="headerlink" title="协作组件"></a>协作组件</h3><h4 id="伪客户端"><a href="#伪客户端" class="headerlink" title="伪客户端"></a>伪客户端</h4><p>Redis 服务器为 Lua 环境创建了一个伪客户端负责处理 Lua 脚本中包含的所有 Redis 命令，工作流程：</p>
<ul>
<li>Lua 环境将 redis.call 或者 redis.pcall 函数想要执行的命令传给伪客户端</li>
<li>伪客户端将命令传给命令执行器</li>
<li>命令执行器执行命令并将命令的执行结果返回给伪客户端</li>
<li>伪客户端接收命令执行器返回的命令结果，并将结果返回给 Lua 环境</li>
<li>Lua 将命令结果返回给 redis.call 函数或者 redis.pcall 函数</li>
<li>redis.call 函数或者 redis.pcall 函数会将命令结果作为返回值返回给脚本的调用者</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-Lua%E4%BC%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%89%A7%E8%A1%8C.png"></p>
<hr>
<h4 id="脚本字典"><a href="#脚本字典" class="headerlink" title="脚本字典"></a>脚本字典</h4><p>Redis 服务器为 Lua 环境创建 lua_scripts 字典，键为某个 Lua 脚本的 SHA1 校验和（checksum），值则是校验和对应的 Lua 脚本</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    dict *lua_scripts;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>服务器会将所有被 EVAL 命令执行过的 Lua 脚本，以及所有被 SCRIPT LOAD 命令载入过的 Lua 脚本都保存到 lua_scripts 字典</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SCRIPT LOAD <span class="string">&quot;return &#x27;hi&#x27;&quot;</span></span><br><span class="line"><span class="string">&quot;2f3lba2bb6d6a0f42ccl59d2e2dad55440778de3&quot;</span> <span class="comment"># 字典的键，SHA1 校验和</span></span><br></pre></td></tr></table></figure>





<hr>
<h3 id="命令实现-1"><a href="#命令实现-1" class="headerlink" title="命令实现"></a>命令实现</h3><h4 id="脚本函数"><a href="#脚本函数" class="headerlink" title="脚本函数"></a>脚本函数</h4><p>EVAL 命令的执行的第一步是为传入的脚本定义一个相对应的 Lua 函数，Lua 函数的名字由 f_ 前缀加上脚本的 SHA1 校验和（四十个字符长）组成，而函数的体（body）则是脚本本身</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">EVAL <span class="string">&quot;return &#x27;hello world&#x27;&quot;</span> 0 </span><br><span class="line"><span class="comment"># 命令将会定义以下的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">f_533203lc6b470dc5a0dd9b4bf2030dea6d65de91</span></span>() &#123;</span><br><span class="line">	<span class="built_in">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用函数来保存客户端传入的脚本有以下优点：</p>
<ul>
<li>通过函数的局部性来让 Lua 环境保持清洁，减少了垃圾回收的工作最， 并且避免了使用全局变量</li>
<li>如果某个脚本在 Lua 环境中被定义过至少一次，那么只需要 SHA1 校验和，服务器就可以在不知道脚本本身的情况下，直接通过调用 Lua 函数来执行脚本</li>
</ul>
<p>EVAL 命令第二步是将客户端传入的脚本保存到服务器的 lua_scripts 字典里，在字典中新添加一个键值对</p>
<hr>
<h4 id="执行函数"><a href="#执行函数" class="headerlink" title="执行函数"></a>执行函数</h4><p>EVAL 命令第三步是执行脚本函数</p>
<ul>
<li><p>将 EVAL 命令中传入的<strong>键名参数和脚本参数</strong>分别保存到 KEYS 数组和 ARGV 数组，将这两个数组作为<strong>全局变量</strong>传入到 Lua 环境</p>
</li>
<li><p>为 Lua 环境装载超时处理钩子（hook），这个钩子可以在脚本出现超时运行情况时，让客户端通过 <code>SCRIPT KILL</code> 命令停止脚本，或者通过 SHUTDOWN 命令直接关闭服务器</p>
<p>因为 Redis 是单线程的执行命令，当 Lua 脚本阻塞时需要兜底策略，可以中断执行</p>
</li>
<li><p>执行脚本函数</p>
</li>
<li><p>移除之前装载的超时钩子</p>
</li>
<li><p>将执行脚本函数的结果保存到客户端状态的输出缓冲区里，等待服务器将结果返回给客户端</p>
</li>
</ul>
<hr>
<h4 id="EVALSHA"><a href="#EVALSHA" class="headerlink" title="EVALSHA"></a>EVALSHA</h4><p>EVALSHA 命令的实现原理就是根据脚本的 SHA1 校验和来调用<strong>脚本对应的函数</strong>，如果函数在 Lua 环境中不存在，找不到 f_ 开头的函数，就会返回 <code>SCRIPT NOT FOUND</code></p>
<hr>
<h3 id="管理命令"><a href="#管理命令" class="headerlink" title="管理命令"></a>管理命令</h3><p>Redis 中与 Lua 脚本有关的管理命令有四个：</p>
<ul>
<li><p>SCRIPT FLUSH：用于清除服务器中所有和 Lua 脚本有关的信息，会释放并重建 lua_scripts 字典，关闭现有的 Lua 环境并重新创建一个新的 Lua 环境</p>
</li>
<li><p>SCRIPT EXISTS：根据输入的 SHA1 校验和（允许一次传入多个校验和），检查校验和对应的脚本是否存在于服务器中，通过检查 lua_scripts 字典实现</p>
</li>
<li><p>SCRIPT LOAD：在 Lua 环境中为脚本创建相对应的函数，然后将脚本保存到 lua_scripts字典里</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; SCRIPT LOAD <span class="string">&quot;return &#x27;hi&#x27;&quot;</span></span><br><span class="line"><span class="string">&quot;2f3lba2bb6d6a0f42ccl59d2e2dad55440778de3&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SCRIPT KILL：停止脚本</p>
</li>
</ul>
<p>如果服务器配置了 lua-time-li­mit 选项，那么在每次执行 Lua 脚本之前，都会设置一个超时处理的钩子。钩子会在脚本运行期间会定期检查运行时间是否超过配置时间，如果超时钩子将定期在脚本运行的间隙中，查看是否有 SCRIPT KILL 或者 SHUTDOWN 到达：</p>
<ul>
<li>如果超时运行的脚本没有执行过写入操作，客户端可以通过 SCRIPT KILL 来停止这个脚本</li>
<li>如果执行过写入操作，客户端只能用 SHUTDOWN nosave 命令来停止服务器，防止不合法的数据被写入数据库中</li>
</ul>
<hr>
<h3 id="脚本复制"><a href="#脚本复制" class="headerlink" title="脚本复制"></a>脚本复制</h3><h4 id="命令复制"><a href="#命令复制" class="headerlink" title="命令复制"></a>命令复制</h4><p>当服务器运行在复制模式时，具有写性质的脚本命令也会被复制到从服务器，包括 EVAL、EVALSHA、SCRIPT FLUSH，以及 SCRIPT LOAD 命令</p>
<p>Redis 复制 EVAL、SCRIPT FLUSH、SCRIPT LOAD 三个命令的方法和复制普通 Redis 命令的方法一样，当主服务器执行完以上三个命令的其中一个时，会直接将被执行的命令传播（propagate）给所有从服务器，在从服务器中产生相同的效果</p>
<hr>
<h4 id="EVALSHA-1"><a href="#EVALSHA-1" class="headerlink" title="EVALSHA"></a>EVALSHA</h4><p>EVALSHA 命令的复制操作相对复杂，因为多个从服务器之间载入 Lua 脚本的清况各有不同，一个在主服务器被成功执行的 EVALSHA 命令，在从服务器执行时可能会出现脚本未找到（not found）错误</p>
<p>Redis 要求主服务器在传播 EVALSHA 命令时，必须确保 EVALSHA 命令要执行的脚本已经被所有从服务器载入过，如果不能确保主服务器会<strong>将 EVALSHA 命令转换成一个等价的 EVAL 命令</strong>，然后通过传播 EVAL 命令来代替 EVALSHA 命令</p>
<p>主服务器使用服务器状态的 repl_scriptcache_dict 字典记录已经将哪些脚本传播给了<strong>所有从服务器</strong>，当一个校验和出现在字典时，说明校验和对应的 Lua 脚本已经传播给了所有从服务器，主服务器可以直接传播 EVALSHA 命令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键是一个个 Lua 脚本的 SHA1 校验和，值则全部都是 NULL</span></span><br><span class="line">    dict *repl_scriptcache_dict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：每当主服务器添加一个新的从服务器时，都会清空 repl_scriptcache_dict 字典，因为字典里面记录的脚本已经不再被所有从服务器载入过，所以服务器以清空字典的方式，强制重新向所有从服务器传播脚本</p>
<p>通过使用 EVALSHA 命令指定的 SHA1 校验和，以及 lua_scripts 字典保存的 Lua 脚本，可以将一个 EVALSHA 命令转化为 EVAL 命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">EVALSHA <span class="string">&quot;533203lc6b470dc5a0dd9b4bf2030dea6d65de91&quot;</span> 0 </span><br><span class="line"><span class="comment"># -&gt; 转换</span></span><br><span class="line">EVAL <span class="string">&quot;return&#x27;hello world&#x27;&quot;</span> 0 </span><br></pre></td></tr></table></figure>

<p>脚本内容 <code>&quot;return&#39;hello world&#39;&quot;</code> 来源于 lua_scripts 字典 533203lc6b470dc5a0dd9b4bf2030dea6d65de91 键的值</p>
<hr>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="基本操作-4"><a href="#基本操作-4" class="headerlink" title="基本操作"></a>基本操作</h3><p>在分布式场景下，锁变量需要由一个共享存储系统来维护，多个客户端才可以通过访问共享存储系统来访问锁变量，加锁和释放锁的操作就变成了读取、判断和设置共享存储系统中的锁变量值多步操作</p>
<p>Redis 分布式锁的基本使用，悲观锁</p>
<ul>
<li><p>使用 SETNX 设置一个公共锁</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SETNX lock-key value	<span class="comment"># value任意数，返回为1设置成功，返回为0设置失败</span></span><br></pre></td></tr></table></figure>

<p><code>NX</code>：只在键不存在时，才对键进行设置操作，<code>SET key value NX</code> 效果等同于 <code>SETNX key value</code></p>
<p><code>XX</code> ：只在键已经存在时，才对键进行设置操作</p>
<p><code>EX</code>：设置键 key 的过期时间，单位时秒</p>
<p><code>PX</code>：设置键 key 的过期时间，单位时毫秒</p>
<p>说明：由于 <code>SET</code> 命令加上选项已经可以完全取代 SETNX、SETEX、PSETEX 的功能，Redis 不推荐使用这几个命令</p>
</li>
<li><p>操作完毕通过 DEL 操作释放锁</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">DEL lock-key </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 EXPIRE 为锁 key 添加存活（持有）时间，过期自动删除（放弃）锁，防止线程出现异常，无法释放锁</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">EXPIRE lock-key second </span><br><span class="line">PEXPIRE lock-key milliseconds</span><br></pre></td></tr></table></figure>

<p>通过 EXPIRE 设置过期时间缺乏原子性，如果在 SETNX 和 EXPIRE 之间出现异常，锁也无法释放</p>
</li>
<li><p>在 SET 时指定过期时间，保证原子性</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">  SET key value NX [EX seconds | PX milliseconds]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">****</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 防误删</span></span><br><span class="line"></span><br><span class="line">场景描述：线程 A 正在执行，但是业务阻塞，在锁的过期时间内未执行完成，过期删除后线程 B 重新获取到锁，此时线程 A 执行完成，删除锁，导致线程 B 的锁被线程 A 误删</span><br><span class="line"></span><br><span class="line">SETNX 获取锁时，设置一个指定的唯一值（UUID），释放前获取这个值，判断是否自己的锁，防止出现线程之间误删了其他线程的锁</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">// 加锁, unique_value作为客户端唯一性的标识，</span><br><span class="line">// PX 10000 则表示 lock_key 会在 10s 后过期，以免客户端在这期间发生异常而无法释放锁</span><br><span class="line">SET lock_key unique_value NX PX 10000</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Lua 脚本（unlock.script）实现的释放锁操作的伪代码：key 类型参数会放入 KEYS 数组，其它参数会放入 ARGV 数组，在脚本中通过 KEYS 和 ARGV 传递参数，<strong>保证判断标识和释放锁这两个操作的原子性</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">EVAL <span class="string">&quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[1])&quot;</span> 1 lock_key unique_value <span class="comment"># 1 代表需要一个参数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放锁，KEYS[1] 就是锁的 key，ARGV[1] 就是标识值，避免误释放</span></span><br><span class="line"><span class="comment">// 获取标识值，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="优化锁-1"><a href="#优化锁-1" class="headerlink" title="优化锁"></a>优化锁</h3><h4 id="不可重入"><a href="#不可重入" class="headerlink" title="不可重入"></a>不可重入</h4><p>不可重入：同一个线程无法多次获取同一把锁</p>
<p>使用 hash 键，filed 是加锁的线程标识， value 是<strong>锁重入次数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">|</span>    key    <span class="operator">|</span>       <span class="keyword">value</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>           <span class="operator">|</span>  filed  <span class="operator">|</span>  <span class="keyword">value</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-------------------------------|</span></span><br><span class="line"><span class="operator">|</span>  lock_key <span class="operator">|</span> thread1 <span class="operator">|</span>    <span class="number">1</span>    <span class="operator">|</span></span><br></pre></td></tr></table></figure>

<p>锁重入：</p>
<ul>
<li>加锁时判断锁的 filed 属性是否是当前线程，如果是将 value 加 1</li>
<li>解锁时判断锁的 filed 属性是否是当前线程，首先将 value 减一，如果 value 为 0 直接释放锁</li>
</ul>
<p>使用 Lua 脚本保证多条命令的原子性</p>
<hr>
<h4 id="不可重试"><a href="#不可重试" class="headerlink" title="不可重试"></a>不可重试</h4><p>不可重试：获取锁只尝试一次就返回 false，没有重试机制</p>
<ul>
<li>利用 Lua 脚本尝试获取锁，获取失败获取锁的剩余超时时间 ttl，或者通过参数传入线程抢锁允许等待的时间</li>
<li>利用订阅功能订阅锁释放的信息，然后线程挂起等待 ttl 时间</li>
<li>利用 Lua 脚本在释放锁时，发布一条锁释放的消息</li>
</ul>
<hr>
<h4 id="超时释放"><a href="#超时释放" class="headerlink" title="超时释放"></a>超时释放</h4><p>超时释放：锁超时释放可以避免死锁，但如果是业务执行耗时较长，需要进行锁续时，防止业务未执行完提前释放锁</p>
<p>看门狗 Watch Dog 机制：</p>
<ul>
<li>获取锁成功后，提交周期任务，每隔一段时间（Redisson 中默认为过期时间 &#x2F; 3），重置一次超时时间</li>
<li>如果服务宕机，Watch Dog 机制线程就停止，就不会再延长 key 的过期时间</li>
<li>释放锁后，终止周期任务</li>
</ul>
<hr>
<h4 id="主从一致"><a href="#主从一致" class="headerlink" title="主从一致"></a>主从一致</h4><p>主从一致性：集群模式下，主从同步存在延迟，当加锁后主服务器宕机时，从服务器还没同步主服务器中的锁数据，此时从服务器升级为主服务器，其他线程又可以获取到锁</p>
<p>将服务器升级为多主多从，：</p>
<ul>
<li>获取锁需要从所有主服务器 SET 成功才算获取成功</li>
<li>某个 master 宕机，slave 还没有同步锁数据就升级为 master，其他线程尝试加锁会加锁失败，因为其他 master 上已经存在该锁</li>
</ul>
<hr>
<h2 id="主从复制-1"><a href="#主从复制-1" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="基本操作-5"><a href="#基本操作-5" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="主从介绍"><a href="#主从介绍" class="headerlink" title="主从介绍"></a>主从介绍</h4><p>主从复制：一个服务器去复制另一个服务器，被复制的服务器为主服务器 master，复制的服务器为从服务器 slave</p>
<ul>
<li>master 用来<strong>写数据</strong>，执行写操作时，将出现变化的数据自动同步到 slave，很少会进行读取操作</li>
<li>slave 用来读数据，禁止在 slave 服务器上进行读操作</li>
</ul>
<p>进行复制中的主从服务器双方的数据库将保存相同的数据，将这种现象称作<strong>数据库状态一致</strong></p>
<p>主从复制的特点：</p>
<ul>
<li><p><strong>薪火相传</strong>：一个 slave 可以是下一个 slave 的 master，slave 同样可以接收其他 slave 的连接和同步请求，那么该 slave 作为了链条中下一个的 master，可以有效减轻 master 的写压力，去中心化降低风险</p>
<p>注意：主机挂了，从机还是从机，无法写数据了</p>
</li>
<li><p><strong>反客为主</strong>：当一个 master 宕机后，后面的 slave 可以立刻升为 master，其后面的 slave 不做任何修改</p>
</li>
</ul>
<p>主从复制的作用：</p>
<ul>
<li><strong>读写分离</strong>：master 写、slave 读，提高服务器的读写负载能力</li>
<li><strong>负载均衡</strong>：基于主从结构，配合读写分离，由 slave 分担 master 负载，并根据需求的变化，改变 slave 的数量，通过多个从节点分担数据读取负载，大大提高 Redis 服务器并发量与数据吞吐量</li>
<li>故障恢复：当 master 出现问题时，由 slave 提供服务，实现快速的故障恢复</li>
<li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li>
<li>高可用基石：基于主从复制，构建哨兵模式与集群，实现 Redis 的高可用方案</li>
</ul>
<p><strong>三高</strong>架构：</p>
<ul>
<li><p>高并发：应用提供某一业务要能支持很多客户端同时访问的能力，称为并发</p>
</li>
<li><p>高性能：性能最直观的感受就是速度快，时间短</p>
</li>
<li><p>高可用：</p>
<ul>
<li>可用性：应用服务在全年宕机的时间加在一起就是全年应用服务不可用的时间</li>
<li>业界可用性目标 5 个 9，即 99.999%，即服务器年宕机时长低于 315 秒，约 5.25 分钟</li>
</ul>
</li>
</ul>
<hr>
<h4 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h4><p>系统状态指令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">INFO replication</span><br></pre></td></tr></table></figure>

<p>master 和 slave 互连：</p>
<ul>
<li><p>方式一：客户端发送命令，设置 slaveof 选项，产生主从结构</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slaveof masterip masterport</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：服务器带参启动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server --slaveof masterip masterport</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式三：服务器配置（主流方式）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slaveof masterip masterport</span><br></pre></td></tr></table></figure></li>
</ul>
<p>主从断开连接：</p>
<ul>
<li><p>slave 断开连接后，不会删除已有数据，只是不再接受 master 发送的数据，可以作<strong>为从服务器升级为主服务器的指令</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slaveof no one	</span><br></pre></td></tr></table></figure></li>
</ul>
<p>授权访问：master 有服务端和客户端，slave 也有服务端和客户端，不仅服务端之间可以发命令，客户端也可以</p>
<ul>
<li><p>master 客户端发送命令设置密码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">requirepass password</span><br></pre></td></tr></table></figure>

<p>master 配置文件设置密码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">config <span class="built_in">set</span> requirepass password</span><br><span class="line">config get requirepass</span><br></pre></td></tr></table></figure>
</li>
<li><p>slave 客户端发送命令设置密码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">auth password</span><br></pre></td></tr></table></figure>

<p>slave 配置文件设置密码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">masterauth password</span><br></pre></td></tr></table></figure>

<p>slave 启动服务器设置密码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server –a password</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="复制流程"><a href="#复制流程" class="headerlink" title="复制流程"></a>复制流程</h3><h4 id="旧版复制"><a href="#旧版复制" class="headerlink" title="旧版复制"></a>旧版复制</h4><p>Redis 的复制功能分为同步（sync）和命令传播（command propagate）两个操作，主从库间的复制是<strong>异步进行的</strong></p>
<p>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态，该过程又叫全量复制：</p>
<ul>
<li>从服务器向主服务器发送 SYNC 命令来进行同步</li>
<li>收到 SYNC 的主服务器执行 BGSAVE 命令，在后台生成一个 RDB 文件，并使用一个<strong>缓冲区</strong>记录从现在开始执行的所有<strong>写命令</strong></li>
<li>当 BGSAVE 命令执行完毕时，主服务器会将 RDB 文件发送给从服务器</li>
<li>从服务接收并载入 RDB 文件（从服务器会<strong>清空原有数据</strong>）</li>
<li>缓冲区记录了 RDB 文件所在状态后的所有写命令，主服务器将在缓冲区的所有命令发送给从服务器，从服务器执行这些写命令</li>
<li>至此从服务器的数据库状态和主服务器一致</li>
</ul>
<p>命令传播用于在主服务器的数据库状态被修改，导致主从数据库状态出现不一致时， 让主从服务器的数据库重新回到一致状态</p>
<ul>
<li>主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器</li>
<li>从服务器接受命令并执行，主从服务器将再次回到一致状态</li>
</ul>
<hr>
<h4 id="功能缺陷"><a href="#功能缺陷" class="headerlink" title="功能缺陷"></a>功能缺陷</h4><p>SYNC 本身就是一个非常消耗资源的操作，每次执行 SYNC 命令，都需要执行以下动作：</p>
<ul>
<li>生成 RDB 文件，耗费主服务器大量 CPU 、内存和磁盘 I&#x2F;O 资源</li>
<li>RDB 文件发送给从服务器，耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响</li>
<li>从服务器载入 RDB 文件，期间会因为阻塞而没办法处理命令请求</li>
</ul>
<p>SYNC 命令下的从服务器对主服务器的复制分为两种情况：</p>
<ul>
<li>初次复制：从服务器没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同</li>
<li>断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，自动重连后并继续复制主服务器</li>
</ul>
<p>旧版复制在断线后重复制时，也会创建 RDB 文件进行<strong>全量复制</strong>，但是从服务器只需要断线时间内的这部分数据，所以旧版复制的实现方式非常浪费资源</p>
<hr>
<h4 id="新版复制"><a href="#新版复制" class="headerlink" title="新版复制"></a>新版复制</h4><p>Redis 从 2.8 版本开始，使用 PSYNC 命令代替 SYNC 命令来执行复制时的<strong>同步操作</strong>（命令传播阶段相同），解决了旧版复制在处理断线重复制情况的低效问题</p>
<p>PSYNC 命令具有完整重同步（full resynchronization）和<strong>部分重同步</strong>（partial resynchronization）两种模式：</p>
<ul>
<li>完整重同步：处理初次复制情况，执行步骤和 SYNC命令基本一样</li>
<li>部分重同步：处理断线后重复制情况，主服务器可以将主从连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态，该过程又叫<strong>部分复制</strong></li>
</ul>
<hr>
<h3 id="部分同步"><a href="#部分同步" class="headerlink" title="部分同步"></a>部分同步</h3><p>部分重同步功能由以下三个部分构成：</p>
<ul>
<li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量</li>
<li>主服务器的复制积压缓冲区（replication backlog）</li>
<li>服务器的运行 ID (run ID)</li>
</ul>
<h4 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h4><p>主服务器和从服务器会分别维护一个复制偏移量：</p>
<ul>
<li><p>主服务器每次向从服务器传播 N 个字节的数据时，就将自己的复制偏移量的值加上 N</p>
</li>
<li><p>从服务器每次收到主服务器传播来的 N 个字节的数据时，就将自己的复制偏移量的值加上 N</p>
</li>
</ul>
<p>通过对比主从服务器的复制偏移量，可以判断主从服务器是否处于一致状态</p>
<ul>
<li>主从服务器的偏移量是相同的，说明主从服务器处于一致状态</li>
<li>主从服务器的偏移量是不同的，说明主从服务器处于不一致状态</li>
</ul>
<hr>
<h4 id="缓冲区-1"><a href="#缓冲区-1" class="headerlink" title="缓冲区"></a>缓冲区</h4><p>复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为 1MB</p>
<ul>
<li>出队规则跟普通的先进先出队列一样</li>
<li>入队规则是当入队元素的数量大于队列长度时，最先入队的元素会被弹出，然后新元素才会被放入队列</li>
</ul>
<p>当主服务器进行<strong>命令传播时，不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区</strong>，缓冲区会保存着一部分最近传播的写命令，并且缓冲区会为队列中的每个字节记录相应的复制偏移量</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%A4%8D%E5%88%B6%E7%A7%AF%E5%8E%8B%E7%BC%93%E5%86%B2%E5%8C%BA.png"></p>
<p>从服务器会通过 PSYNC 命令将自己的复制偏移量 offset 发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：</p>
<ul>
<li>offset 之后的数据（即 offset+1）仍然存在于复制积压缓冲区里，那么主服务器将对从服务器执行部分重同步操作</li>
<li>offset 之后的数据已经不在复制积压缓冲区，说明部分数据已经丢失，那么主服务器将对从服务器执行完整重同步操作</li>
</ul>
<p>复制缓冲区大小设定不合理，会导致<strong>数据溢出</strong>。比如主服务器需要执行大量写命令，又或者主从服务器断线后重连接所需的时间较长，导致缓冲区中的数据已经丢失，则必须进行完整重同步</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">repl-backlog-size ?mb</span><br></pre></td></tr></table></figure>

<p>建议设置如下，这样可以保证绝大部分断线情况都能用部分重同步来处理：</p>
<ul>
<li>从服务器断线后重新连接上主服务器所需的平均时间 second</li>
<li>获取 master 平均每秒产生写命令数据总量 write_size_per_second</li>
<li>最优复制缓冲区空间 &#x3D; 2 * second * write_size_per_second</li>
</ul>
<hr>
<h4 id="运行ID"><a href="#运行ID" class="headerlink" title="运行ID"></a>运行ID</h4><p>服务器运行 ID（run ID）：是每一台服务器每次运行的身份识别码，在服务器启动时自动生成，由 40 位随机的十六进制字符组成，一台服务器多次运行可以生成多个运行 ID</p>
<p>作用：服务器间进行传输识别身份，如果想两次操作均对同一台服务器进行，<strong>每次必须操作携带对应的运行 ID</strong>，用于对方识别</p>
<p>从服务器对主服务器进行初次复制时，主服务器将自己的运行 ID 传送给从服务器，然后从服务器会将该运行 ID 保存。当从服务器断线并重新连上一个主服务器时，会向当前连接的主服务器发送之前保存的运行 ID：</p>
<ul>
<li>如果运行 ID 和当前连接的主服务器的运行 ID 相同，说明从服务器断线之前复制的就是当前连接的这个主服务器，执行部分重同步</li>
<li>如果不同，需要执行完整重同步操作</li>
</ul>
<hr>
<h4 id="PSYNC"><a href="#PSYNC" class="headerlink" title="PSYNC"></a>PSYNC</h4><p>PSYNC 命令的调用方法有两种</p>
<ul>
<li>如果从服务器之前没有复制过任何主服务器，或者执行了 <code>SLAVEOF no one</code>，开始一次新的复制时将向主服务器发送 <code>PSYNC ? -1</code> 命令，主动请求主服务器进行完整重同步</li>
<li>如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code> 命令，runid 是上一次复制的主服务器的运行 ID，offset 是复制的偏移量</li>
</ul>
<p>接收到 PSYNC 命令的主服务器会向从服务器返回以下三种回复的其中一种：</p>
<ul>
<li>执行完整重同步操作：返回 <code>+FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code>，runid 是主服务器的运行 ID，offset 是主服务器的复制偏移量</li>
<li>执行部分重同步操作：返回 <code>+CONTINUE</code>，从服务器收到该回复说明只需要等待主服务器发送缺失的部分数据即可</li>
<li>主服务器的版本低于 Redis2.8：返回 <code>-ERR</code>，版本过低识别不了 PSYNC，从服务器将向主服务器发送 SYNC 命令</li>
</ul>
<hr>
<h3 id="复制实现"><a href="#复制实现" class="headerlink" title="复制实现"></a>复制实现</h3><h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><p>通过向从服务器发送 SLAVEOF 命令，可以让从服务器去复制一个主服务器</p>
<ul>
<li><p>设置主服务器的地址和端口：将 SLAVEOF 命令指定的 ip 和 port 保存到服务器状态 redisServer</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	<span class="comment">// 主服务器的地址 </span></span><br><span class="line">    <span class="type">char</span> *masterhost; </span><br><span class="line">	 <span class="comment">//主服务器的端口 </span></span><br><span class="line">    <span class="type">int</span> masterport; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SLAVEOF 命令是一个<strong>异步命令</strong>，在完成属性的设置后服务器直接返回 OK，而实际的复制工作将在 OK 返回之后才真正开始执行</p>
</li>
<li><p>建立套接字连接：</p>
<ul>
<li>从服务器 connect 主服务器建立套接字连接，成功后从服务器将为这个套接字关联一个用于复制工作的文件事件处理器，负责执行后续的复制工作，如接收 RDB 文件、接收主服务器传播来的写命令等</li>
<li>主服务器在接受 accept 从务器的套接字连接后，将为该套接字创建相应的客户端状态，将从服务器看作一个客户端，从服务器将同时具有 server 和 client（可以发命令）两个身份</li>
</ul>
</li>
<li><p>发送 PING 命令：从服务器向主服务器发送一个 PING 命令，检查主从之间的通信是否正常、主服务器处理命令的能力是否正常</p>
<ul>
<li>返回错误，表示主服务器无法处理从服务器的命令请求（忙碌），从服务器断开并重新创建连向主服务器的套接字</li>
<li>返回命令回复，但从服务器不能在规定的时间内读取出命令回复的内容，表示主从之间的网络状态不佳，需要断开重连</li>
<li>读取到 PONG，表示一切状态正常，可以执行复制</li>
</ul>
</li>
<li><p>身份验证：如果从服务器设置了 masterauth 选项就进行身份验证，将向主服务器发送一条 AUTH 命令，命令参数为从服务器 masterauth 选项的值，如果主从设置的密码不相同，那么主将返回一个 invalid password 错误</p>
</li>
<li><p>发送端口信息：身份验证后</p>
<ul>
<li>从服务器执行命令 <code>REPLCONF listening-port &lt;port­number&gt;</code>， 向主服务器发送从服务器的监听端口号</li>
<li>主服务器在接收到这个命令后，会将端口号记录在对应的客户端状态 redisClient.slave_listening_port 属性中：</li>
</ul>
</li>
<li><p>同步：从服务器将向主服务器发送 PSYNC 命令，在同步操作执行之后，<strong>主从服务器双方都是对方的客户端</strong>，可以相互发送命令</p>
<ul>
<li><p>完整重同步：主服务器需要成为从服务器的客户端，才能将保存在缓冲区里面的写命令发送给从服务器执行</p>
</li>
<li><p>部分重同步：主服务器需要成为从服务器的客户端，才能向从服务器发送保存在复制积压缓冲区里面的写命令</p>
</li>
</ul>
</li>
<li><p>命令传播：主服务器将写命令发送给从服务器，保持数据库的状态一致</p>
</li>
</ul>
<hr>
<h4 id="复制图示"><a href="#复制图示" class="headerlink" title="复制图示"></a>复制图示</h4><p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B%E6%9B%B4%E6%96%B0.png"></p>
<hr>
<h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><h4 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h4><p>心跳机制：进入命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：<code>REPLCONF ACK &lt;replication_offset&gt;</code>，re_offset 是从服务器当前的复制偏移量</p>
<p>心跳的作用：</p>
<ul>
<li>检测主从服务器的网络连接状态</li>
<li>辅助实现 min-slaves 选项</li>
<li>检测命令丢失</li>
</ul>
<hr>
<h4 id="网络状态"><a href="#网络状态" class="headerlink" title="网络状态"></a>网络状态</h4><p>如果主服务器超过一秒钟没有收到从服务器发来的 REPLCONF ACK 命令，主服务就认为主从服务器之间的连接出现问题</p>
<p>向主服务器发送 <code>INFO replication</code> 命令，lag 一栏表示从服务器最后一次向主服务器发送 ACK 命令距离现在多少秒：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INFO replication </span><br><span class="line"><span class="comment"># Replication </span></span><br><span class="line">role:master </span><br><span class="line">connected_slaves:2 </span><br><span class="line">slave0: ip=127.0.0.1,port=11111,state=online,offset=123,lag=0 <span class="comment"># 刚刚发送过 REPLCONF ACK </span></span><br><span class="line">slavel: ip=127.0.0.1,port=22222,state=online,offset=456,lag=3 <span class="comment"># 3秒之前发送过REPLCONF ACK </span></span><br></pre></td></tr></table></figure>

<p>在一般情况下，lag 的值应该在 0 或者 1 秒之间跳动，如果超过 1 秒说明主从服务器之间的连接出现了故障</p>
<hr>
<h4 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h4><p>Redis 的 min-slaves-to-write 和 min-slaves-max-lag 两个选项可以防止主服务器在<strong>不安全的情况下</strong>执行写命令</p>
<p>比如向主服务器设置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">min-slaves-to-write 5</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>

<p>那么在从服务器的数少于 5 个，或者 5 个从服务器的延迟（lag）值都大于或等于10 秒时，主服务器将拒绝执行写命令</p>
<hr>
<h4 id="命令丢失"><a href="#命令丢失" class="headerlink" title="命令丢失"></a>命令丢失</h4><p>检测命令丢失：由于网络或者其他原因，主服务器传播给从服务器的写命令丢失，那么当从服务器向主服务器发送 REPLCONF ACK 命令时，主服务器会检查从服务器的复制偏移量是否小于自己的，然后在复制积压缓冲区里找到从服务器缺少的数据，并将这些数据重新发送给从服务器</p>
<p>说明：REPLCONF ACK 命令和复制积压缓冲区都是 Redis 2.8 版本新增的，在 Redis 2.8 版本以前，即使命令在传播过程中丢失，主从服务器都不会注意到，也不会向从服务器补发丢失的数据，所以为了保证<strong>主从复制的数据一致性</strong>，最好使用 2.8 或以上版本的 Redis</p>
<hr>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="重启恢复"><a href="#重启恢复" class="headerlink" title="重启恢复"></a>重启恢复</h4><p>系统不断运行，master 的数据量会越来越大，一旦 <strong>master 重启</strong>，runid 将发生变化，会导致全部 slave 的全量复制操作</p>
<p>解决方法：本机保存上次 runid，重启后恢复该值，使所有 slave 认为还是之前的 master</p>
<p>优化方案：</p>
<ul>
<li><p>master 内部创建 master_replid 变量，使用 runid 相同的策略生成，并发送给所有 slave</p>
</li>
<li><p>在 master 关闭时执行命令 <code>shutdown save</code>，进行 RDB 持久化，将 runid 与 offset 保存到 RDB 文件中</p>
<p><code>redis-check-rdb dump.rdb</code> 命令可以查看该信息，保存为 repl-id 和 repl-offset</p>
</li>
<li><p>master 重启后加载 RDB 文件，恢复数据，将 RDB 文件中保存的 repl-id 与 repl-offset 加载到内存中，master_repl_id &#x3D; repl-id，master_repl_offset &#x3D; repl-offset</p>
</li>
<li><p>通过 info 命令可以查看该信息</p>
</li>
</ul>
<hr>
<h4 id="网络中断"><a href="#网络中断" class="headerlink" title="网络中断"></a>网络中断</h4><p>master 的 CPU 占用过高或 slave 频繁断开连接</p>
<ul>
<li><p>出现的原因：</p>
<ul>
<li>slave 每 1 秒发送 REPLCONF ACK 命令到 master</li>
<li>当 slave 接到了慢查询时（keys * ，hgetall等），会大量占用 CPU 性能</li>
<li>master 每 1 秒调用复制定时函数 replicationCron()，比对 slave 发现长时间没有进行响应</li>
</ul>
<p>最终导致 master 各种资源（输出缓冲区、带宽、连接等）被严重占用</p>
</li>
<li><p>解决方法：通过设置合理的超时时间，确认是否释放 slave</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">repl-timeout	<span class="comment"># 该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>slave 与 master 连接断开</p>
<ul>
<li><p>出现的原因：</p>
<ul>
<li>master 发送 ping 指令频度较低</li>
<li>master 设定超时时间较短</li>
<li>ping 指令在网络中存在丢包</li>
</ul>
</li>
<li><p>解决方法：提高 ping 指令发送的频度</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">repl-ping-slave-period	</span><br></pre></td></tr></table></figure>

<p>超时时间 repl-time 的时间至少是 ping 指令频度的5到10倍，否则 slave 很容易判定超时</p>
</li>
</ul>
<hr>
<h4 id="一致性-1"><a href="#一致性-1" class="headerlink" title="一致性"></a>一致性</h4><p>网络信息不同步，数据发送有延迟，导致多个 slave 获取相同数据不同步</p>
<p>解决方案：</p>
<ul>
<li><p><strong>优化主从间的网络环境</strong>，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象</p>
</li>
<li><p>监控主从节点延迟（通过offset）判断，如果 slave 延迟过大，<strong>暂时屏蔽程序对该 slave 的数据访问</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slave-serve-stale-data <span class="built_in">yes</span>|no</span><br></pre></td></tr></table></figure>

<p>开启后仅响应 info、slaveof 等少数命令（慎用，除非对数据一致性要求很高）</p>
</li>
<li><p>多个 slave 同时对 master 请求数据同步，master 发送的 RDB 文件增多，会对带宽造成巨大冲击，造成 master 带宽不足，因此数据同步需要根据业务需求，适量错峰</p>
</li>
</ul>
<hr>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><h3 id="哨兵概述"><a href="#哨兵概述" class="headerlink" title="哨兵概述"></a>哨兵概述</h3><p>Sentinel（哨兵）是 Redis 的高可用性（high availability）解决方案，由一个或多个 Sentinel 实例 instance 组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器，并在被监视的主服务器下线时进行故障转移</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-哨兵系统.png" style="zoom:67%;">

<ul>
<li>双环图案表示主服务器</li>
<li>单环图案表示三个从服务器</li>
</ul>
<p>哨兵的作用：</p>
<ul>
<li><p>监控：监控 master 和 slave，不断的检查 master 和 slave 是否正常运行，master 存活检测、master 与 slave 运行情况检测</p>
</li>
<li><p>通知：当被监控的服务器出现问题时，向其他哨兵发送通知</p>
</li>
<li><p>自动故障转移：断开 master 与 slave 连接，选取一个 slave 作为 master，将其他 slave 连接新的 master，并告知客户端新的服务器地址</p>
</li>
</ul>
<hr>
<h3 id="启用哨兵"><a href="#启用哨兵" class="headerlink" title="启用哨兵"></a>启用哨兵</h3><h4 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h4><p>配置三个哨兵 sentinel.conf：一般多个哨兵配置相同、端口不同，特殊需求可以配置不同的属性</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">port 26401</span><br><span class="line"><span class="built_in">dir</span> <span class="string">&quot;/redis/data&quot;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6401 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 20000</span><br><span class="line">sentinel parallel-sync mymaster 1</span><br><span class="line">sentinel deny-scripts-reconfig <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>配置说明：</p>
<ul>
<li><p>设置哨兵监听的主服务器信息，判断主观下线所需要的票数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;master_ip&gt; &lt;master_port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定哨兵在监控 Redis 服务时，设置判定服务器宕机的时长，该设置控制是否进行主从切换</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sentinel down-after-milliseconds &lt;master-name&gt; &lt;million_seconds&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>出现故障后，故障切换的最大超时时间，超过该值，认定切换失败，默认 3 分钟</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sentinel failover-timeout &lt;master_name&gt; &lt;million_seconds&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>故障转移时，同时进行主从同步的 slave 数量，数值越大，要求网络资源越高</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sentinel parallel-syncs &lt;master_name&gt; &lt;sync_slave_number&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>启动哨兵：服务端命令（Linux 命令）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-sentinel filename</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>Sentinel 本质上只是一个运行在特殊模式下的 Redis 服务器，当一个 Sentinel 启动时，首先初始化 Redis 服务器，但是初始化过程和普通 Redis 服务器的初始化过程并不完全相同，哨兵<strong>不提供数据相关服务</strong>，所以不会载入 RDB、AOF 文件</p>
<p>整体流程：</p>
<ul>
<li><p>初始化服务器</p>
</li>
<li><p>将普通 Redis 服务器使用的代码替换成 Sentinel 专用代码</p>
</li>
<li><p>初始化 Sentinel 状态</p>
</li>
<li><p>根据给定的配置文件，初始化 Sentinel 的监视主服务器列表</p>
</li>
<li><p>创建连向主服务器的网络连接</p>
</li>
</ul>
<hr>
<h4 id="代码替换"><a href="#代码替换" class="headerlink" title="代码替换"></a>代码替换</h4><p>将一部分普通 Redis服务器使用的代码替换成 Sentinel 专用代码</p>
<p>Redis 服务器端口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> REDIS_SERVERPORT 6379 		<span class="comment">// 普通服务器端口</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REDIS_SENTINEL_PORT 26379 	<span class="comment">// 哨兵端口</span></span></span><br></pre></td></tr></table></figure>

<p>服务器的命令表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通 Redis 服务器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">redisCommandTable</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;get&quot;</span>, getCommand, <span class="number">2</span>, <span class="string">&quot;r&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;set&quot;</span>, setCommand, <span class="number">-3</span>, <span class="string">&quot;wm&quot;</span>, <span class="number">0</span>, noPreloadGetKeys, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 哨兵</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">sentinelcmds</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;ping&quot;</span>, pingCommand, <span class="number">1</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;sentinel&quot;</span>, sentinelCommand, <span class="number">-2</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;subscribe&quot;</span>,...&#125;, &#123;<span class="string">&quot;unsubscribe&quot;</span>,...O&#125;, &#123;<span class="string">&quot;psubscribe&quot;</span>,...&#125;, &#123;<span class="string">&quot;punsubscribe&quot;</span>,...&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;info&quot;</span>,...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述表是哨兵模式下客户端可以执行的命令，所以对于 GET、SET 等命令，服务器根本就没有载入</p>
<hr>
<h4 id="哨兵状态"><a href="#哨兵状态" class="headerlink" title="哨兵状态"></a>哨兵状态</h4><p>服务器会初始化一个 sentinelState 结构，又叫 Sentinel 状态，结构保存了服务器中所有和 Sentinel 功能有关的状态（服务器的一般状态仍然由 redisServer 结构保存）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sentinelState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前纪元，用于实现故障转移</span></span><br><span class="line">    <span class="type">uint64_t</span> current_epoch; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存了所有被这个sentinel监视的主服务器</span></span><br><span class="line">    dict *masters;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否进入了 TILT 模式</span></span><br><span class="line">    <span class="type">int</span> tilt;</span><br><span class="line">    <span class="comment">// 进入 TILT 模式的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> tilt_start_time;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后一次执行时间处理的事件</span></span><br><span class="line">    <span class="type">mstime_t</span> previous_time;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 目前正在执行的脚本数量</span></span><br><span class="line">    <span class="type">int</span> running_scripts;</span><br><span class="line">    <span class="comment">// 一个FIFO队列，包含了所有需要执行的用户脚本</span></span><br><span class="line">    <span class="built_in">list</span> *scripts_queue;</span><br><span class="line">    </span><br><span class="line">&#125; sentinel;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="监控列表"><a href="#监控列表" class="headerlink" title="监控列表"></a>监控列表</h4><p>Sentinel 状态的初始化将 masters 字典的初始化，根据被载入的 Sentinel 配置文件 conf 来进行属性赋值</p>
<p>Sentinel 状态中的 masters 字典记录了所有被 Sentinel 监视的<strong>主服务器的相关信息</strong>，字典的键是被监视主服务器的名字，值是主服务器对应的实例结构</p>
<p>实例结构是一个 sentinelRedisinstance 数据类型，代表被 Sentinel 监视的实例，这个实例可以是主、从服务器，或者其他 Sentinel</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisinstance</span> &#123;</span></span><br><span class="line">    <span class="comment">// 标识值，记录了实例的类型，以及该实例的当前状态</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例的名字，主服务器的名字由用户在配置文件中设置，</span></span><br><span class="line">    <span class="comment">// 从服务器和哨兵的名字由 Sentinel 自动设置，格式为 ip:port，例如 127.0.0.1:6379</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例运行的 ID</span></span><br><span class="line">    <span class="type">char</span> *runid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="type">uint64_t</span> config_epoch;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例地址</span></span><br><span class="line">    sentinelAddr *addr; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前实例时主服务器，该字段保存从服务器信息，键是名字格式为 ip:port，值是实例结构</span></span><br><span class="line">    dict *slaves;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所有监视当前服务器的 Sentinel 实例，键是名字格式为 ip:port，值是实例结构</span></span><br><span class="line">    dict *sentinels;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sentinel down-after-milliseconds 的值，表示实例无响应多少毫秒后会被判断为主观下线(subjectively down) </span></span><br><span class="line">    <span class="type">mstime_t</span> down_after_period;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sentinel monitor 选项中的quorum参数，判断这个实例为客观下线(objectively down)所需的支持投票数量</span></span><br><span class="line">    <span class="type">int</span> quorum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sentinel parallel-syncs 的值，在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量</span></span><br><span class="line">    <span class="type">int</span> parallel-syncs;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sentinel failover-timeout的值，刷新故障迁移状态的最大时限</span></span><br><span class="line">    <span class="type">mstime_t</span> failover_timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addr 属性是一个指向 sentinelAddr 的指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelAddr</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *ip;</span><br><span class="line">    <span class="type">int</span> port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h4><p>初始化 Sentinel 的最后一步是创建连向被监视主服务器的网络连接，Sentinel 将成为主服务器的客户端，可以向主服务器发送命令，并从命令回复中获取相关的信息</p>
<p>每个被 Sentinel 监视的主服务器，Sentinel 会创建两个连向主服务器的<strong>异步网络连接</strong>：</p>
<ul>
<li>命令连接：用于向主服务器发送命令，并接收命令回复</li>
<li>订阅连接：用于订阅主服务器的 <code>_sentinel_:hello</code> 频道</li>
</ul>
<p>建立两个连接的原因：</p>
<ul>
<li><p>在 Redis 目前的发布与订阅功能中，被发送的信息都不会保存在 Redis 服务器里， 如果在信息发送时接收信息的客户端离线或断线，那么这个客户端就会丢失这条信息，为了不丢失 hello 频道的任何信息，Sentinel 必须用一个订阅连接来接收该频道的信息</p>
</li>
<li><p>Sentinel 还必须向主服务器发送命令，以此来与主服务器进行通信，所以 Sentinel 还必须向主服务器创建命令连接</p>
</li>
</ul>
<p>说明：断线的意思就是网络连接断开</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%93%A8%E5%85%B5%E7%B3%BB%E7%BB%9F%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png"></p>
<hr>
<h3 id="信息交互"><a href="#信息交互" class="headerlink" title="信息交互"></a>信息交互</h3><h4 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h4><h5 id="主服务器"><a href="#主服务器" class="headerlink" title="主服务器"></a>主服务器</h5><p>Sentinel 默认会以每十秒一次的频率，通过命令连接向被监视的主服务器发送 INFO 命令，来获取主服务器的当前信息</p>
<ul>
<li>一部分是主服务器本身的信息，包括 runid 域记录的服务器运行 ID，以及 role 域记录的服务器角色</li>
<li>另一部分是服务器属下所有从服务器的信息，每个从服务器都由一个 slave 字符串开头的行记录，根据这些 IP 地址和端口号，Sentinel 无须用户提供从服务器的地址信息，就可以自动发现从服务器</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Server </span></span><br><span class="line">run_id:76llc59dc3a29aa6fa0609f84lbb6al019008a9c</span><br><span class="line">...</span><br><span class="line"><span class="comment"># Replication </span></span><br><span class="line">role:master </span><br><span class="line">...</span><br><span class="line">slave0: ip=l27.0.0.1, port=11111, state=online, offset=22, lag=0</span><br><span class="line">slave1: ip=l27.0.0.1, port=22222, state=online, offset=22, lag=0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>根据 run_id 和 role 记录的信息 Sentinel 将对主服务器的实例结构进行更新，比如主服务器重启之后，运行 ID 就会和实例结构之前保存的运行 ID 不同，哨兵检测到这一情况之后就会对实例结构的运行 ID 进行更新</p>
<p>对于主服务器返回的从服务器信息，用实例结构的 slaves 字典记录了从服务器的信息：</p>
<ul>
<li>如果从服务器对应的实例结构已经存在，那么 Sentinel 对从服务器的实例结构进行更新</li>
<li>如果不存在，为这个从服务器新创建一个实例结构加入字典，字典键为 <code>ip:port</code></li>
</ul>
<hr>
<h5 id="从服务器"><a href="#从服务器" class="headerlink" title="从服务器"></a>从服务器</h5><p>当 Sentinel 发现主服务器有新的从服务器出现时，会为这个新的从服务器创建相应的实例结构，还会创建到从服务器的命令连接和订阅连接，所以 Sentinel 对所有的从服务器之间都可以进行命令操作</p>
<p>Sentinel 默认会以每十秒一次的频率，向从服务器发送 INFO 命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Server </span></span><br><span class="line">run_id:76llc59dc3a29aa6fa0609f84lbb6al019008a9c	<span class="comment">#从服务器的运行 id</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># Replication </span></span><br><span class="line">role:slave 				<span class="comment"># 从服务器角色</span></span><br><span class="line">...</span><br><span class="line">master_host:127.0.0.1 	<span class="comment"># 主服务器的 ip</span></span><br><span class="line">master_port:6379 		<span class="comment"># 主服务器的 port</span></span><br><span class="line">master_link_status:up 	<span class="comment"># 主从服务器的连接状态</span></span><br><span class="line">slave_repl_offset:11111	<span class="comment"># 从服务器的复制偏移蜇</span></span><br><span class="line">slave_priority:100 		<span class="comment"># 从服务器的优先级</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优先级属性</strong>在故障转移时会用到</li>
</ul>
<p>根据这些信息，Sentinel 会对从服务器的实例结构进行更新</p>
<hr>
<h4 id="发送信息"><a href="#发送信息" class="headerlink" title="发送信息"></a>发送信息</h4><p>Sentinel 在默认情况下，会以每两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送以下格式的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUBLISH _sentinel_:hello <span class="string">&quot;&lt;s_ip&gt;, &lt;s_port&gt;, &lt;s_runid&gt;, &lt;s_epoch&gt;, &lt;m_name&gt;, &lt;m_ip&gt;, &lt;m_port&gt;, &lt;m_epoch&gt;</span></span><br></pre></td></tr></table></figure>

<p>这条命令向服务器的 <code>_sentinel_:hello</code> 频道发送了一条信息，信息的内容由多个参数组成：</p>
<ul>
<li>以 s_ 开头的参数记录的是 Sentinel 本身的信息</li>
<li>以 m_ 开头的参数记录的则是主服务器的信息</li>
</ul>
<p>说明：<strong>通过命令连接发送的频道信息</strong></p>
<hr>
<h4 id="接受信息"><a href="#接受信息" class="headerlink" title="接受信息"></a>接受信息</h4><h5 id="订阅频道"><a href="#订阅频道" class="headerlink" title="订阅频道"></a>订阅频道</h5><p>Sentinel 与一个主或从服务器建立起订阅连接之后，就会通过订阅连接向服务器发送订阅命令，频道的订阅会一直持续到 Sentinel 与服务器的连接断开为止</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SUBSCRIBE _sentinel_:hello</span><br></pre></td></tr></table></figure>

<p>订阅成功后，Sentinel 就可以通过订阅连接从服务器的 <code>_sentinel_:hello</code> 频道接收信息，对消息分析：</p>
<ul>
<li>如果信息中记录的 Sentinel 运行 ID 与自己的相同，不做进一步处理</li>
<li>如果不同，将根据信息中的各个参数，对相应主服务器的实例结构进行更新</li>
</ul>
<p>对于监视同一个服务器的多个 Sentinel 来说，<strong>一个 Sentinel 发送的信息会被其他 Sentinel 接收到</strong>，这些信息会被用于更新其他 Sentinel 对发送信息 Sentinel 的认知，也会被用于更新其他 Sentinel 对被监视的服务器的认知</p>
<p>哨兵实例之间可以相互发现，要归功于 Redis 提供发布订阅机制</p>
<hr>
<h5 id="更新字典"><a href="#更新字典" class="headerlink" title="更新字典"></a>更新字典</h5><p>Sentinel 为主服务器创建的实例结构的 sentinels 字典保存所有同样监视这个<strong>主服务器的 Sentinel 信息</strong>（包括 Sentinel 自己），字典的键是 Sentinel 的名字，格式为 <code>ip:port</code>，值是键所对应 Sentinel 的实例结构</p>
<p>当 Sentinel 接收到其他 Sentinel 发来的信息时（发送信息的为源 Sentinel，接收信息的为目标 Sentinel），目标 Sentinel 会分析提取参数，在自己的 Sentinel 状态 sentinelState.masters 中查找相应的主服务器实例结构，检查主服务器实例结构的 sentinels 字典中，源 Sentinel 的实例结构是否存在</p>
<ul>
<li>如果源 Sentinel 的实例结构存在，那么对源 Sentinel 的实例结构进行更新</li>
<li>如果源 Sentinel 的实例结构不存在，说明源 Sentinel 是刚开始监视主服务器，目标 Sentinel 会为源 Sentinel 创建一个新的实例结构，并将这个结构添加到 sentinels 字典里面</li>
</ul>
<p>因为 Sentinel 可以接收到的频道信息来获知其他 Sentinel 的存在，并通过发送频道信息来让其他 Sentinel 知道自己的存在，所以用户在使用 Sentinel 时并不需要提供各个 Sentinel 的地址信息，<strong>监视同一个主服务器的多个 Sentinel 可以自动发现对方</strong></p>
<hr>
<h5 id="命令连接"><a href="#命令连接" class="headerlink" title="命令连接"></a>命令连接</h5><p>Sentinel 通过频道信息发现新的 Sentinel，除了创建实例结构，还会创建一个连向新 Sentinel 的命令连接，而新 Sentinel 也同样会创建连向这个 Sentinel 的命令连接，最终监视同一主服务器的多个 Sentinel 将形成相互连接的网络</p>
<p>作用：<strong>通过命令连接相连的各个 Sentinel</strong> 可以向其他 Sentinel 发送命令请求来进行信息交换</p>
<p>Sentinel 之间不会创建订阅连接：</p>
<ul>
<li>Sentinel 需要通过接收主服务器或者从服务器发来的频道信息来发现未知的新 Sentinel，所以才创建订阅连接</li>
<li>相互已知的 Sentinel 只要使用命令连接来进行通信就足够了</li>
</ul>
<hr>
<h3 id="下线检测"><a href="#下线检测" class="headerlink" title="下线检测"></a>下线检测</h3><h4 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h4><p>Sentinel 在默认情况下会以每秒一次的频率向所有与它创建了命令连接的实例（包括主从服务器、其他 Sentinel）发送 PING 命令，通过实例返回的 PING 命令回复来判断实例是否在线</p>
<ul>
<li>有效回复：实例返回 +PONG、-LOADING、-MASTERDOWN 三种回复的其中一种</li>
<li>无效回复：实例返回除上述三种以外的任何数据</li>
</ul>
<p>Sentinel 配置文件中 down-after-milliseconds 选项指定了判断实例进入主观下线所需的时长，如果主服务器在该时间内一直向 Sentinel 返回无效回复，Sentinel 就会在该服务器对应实例结构的 flags 属性打开 SRI_S_DOWN 标识，表示该主服务器进入主观下线状态</p>
<p>配置的 down-after-milliseconds 值不仅适用于主服务器，还会被用于当前 Sentinel 判断主服务器属下的所有从服务器，以及所有同样监视这个主服务器的其他 Sentinel 的主观下线状态</p>
<p>注意：对于监视同一个主服务器的多个 Sentinel 来说，设置的 down-after-milliseconds 选项的值可能不同，所以当一个 Sentinel 将主服务器判断为主观下线时，其他 Sentinel 可能仍然会认为主服务器处于在线状态</p>
<hr>
<h4 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h4><p>当 Sentinel 将一个主服务器判断为主观下线之后，会向同样监视这一主服务器的其他 Sentinel 进行询问</p>
<p>Sentinel 使用命令询问其他 Sentinel 是否同意主服务器已下线：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>ip：被 Sentinel 判断为主观下线的主服务器的 IP 地址</li>
<li>port：被 Sentinel 判断为主观下线的主服务器的端口号</li>
<li>current_epoch：Sentinel 当前的配置纪元，用于选举领头 Sentinel</li>
<li>runid：取值为 * 符号代表命令仅仅用于检测主服务器的客观下线状态；取值为 Sentinel 的运行 ID 则用于选举领头 Sentinel</li>
</ul>
<p>目标 Sentinel 接收到源 Sentinel 的命令时，会根据参数的 lP 和端口号，检查主服务器是否已下线，然后返回一条包含三个参数的 Multi Bulk 回复：</p>
<ul>
<li>down_state：返回目标 Sentinel 对服务器的检查结果，1 代表主服务器已下线，0 代表未下线</li>
<li>leader_runid：取值为 * 符号代表命令仅用于检测服务器的下线状态；而局部领头 Sentinel 的运行 ID 则用于选举领头 Sentinel</li>
<li>leader_epoch：目标 Sentinel 的局部领头 Sentinel 的配置纪元</li>
</ul>
<p>源 Sentinel 将统计其他 Sentinel 同意主服务器已下线的数量，当这一数量达到配置指定的判断客观下线所需的数量（quorum）时，Sentinel 会将主服务器对应实例结构 flags 属性的 SRI_O_DOWN 标识打开，代表客观下线，并对主服务器执行故障转移操作</p>
<p>注意：不同 Sentinel 判断客观下线的条件可能不同，因为载入的配置文件中的属性（quorum）可能不同</p>
<hr>
<h3 id="领头选举"><a href="#领头选举" class="headerlink" title="领头选举"></a>领头选举</h3><p>主服务器被判断为客观下线时，监视这个主服务器的各个 Sentinel 会进行协商，选举出一个领头 Sentinel 对下线服务器执行故障转移</p>
<p>Redis 选举领头 Sentinel 的规则：</p>
<ul>
<li><p>所有在线的 Sentinel 都有被选为领头 Sentinel 的资格</p>
</li>
<li><p>每个发现主服务器进入客观下线的 Sentinel 都会要求其他 Sentinel 将自己设置为局部领头 Sentinel</p>
</li>
<li><p>在一个配置纪元里，所有 Sentinel 都只有一次将某个 Sentinel 设置为局部领头 Sentinel 的机会，并且局部领头一旦设置，在这个配置纪元里就不能再更改</p>
</li>
<li><p>Sentinel 设置局部领头 Sentinel 的规则是先到先得，最先向目标 Sentinel 发送设置要求的源 Sentinel 将成为目标 Sentinel 的局部领头 Sentinel，之后接收到的所有设置要求都会被目标 Sentinel 拒绝</p>
</li>
<li><p>领头 Sentinel 的产生需要半数以上 Sentinel 的支持，并且每个 Sentinel 只有一票，所以一个配置纪元只会出现一个领头 Sentinel，比如 10 个 Sentinel 的系统中，至少需要 <code>10/2 + 1 = 6</code> 票</p>
</li>
</ul>
<p>选举过程：</p>
<ul>
<li>一个 Sentinel 向目标 Sentinel 发送 <code>SENTINEL is-master-down-by-addr</code> 命令，命令中的 runid 参数不是＊符号而是源 Sentinel 的运行 ID，表示源 Sentinel 要求目标 Sentinel 将自己设置为它的局部领头 Sentinel</li>
<li>目标 Sentinel 接受命令处理完成后，将返回一条命令回复，回复中的 leader_runid 和 leader_epoch 参数分别记录了目标 Sentinel 的局部领头 Sentinel 的运行 ID 和配置纪元</li>
<li>源 Sentinel 接收目标 Sentinel 命令回复之后，会判断 leader_epoch 是否和自己的相同，相同就继续判断 leader_runid 是否和自己的运行 ID 一致，成立表示目标 Sentinel 将源 Sentinel 设置成了局部领头 Sentinel，即获得一票</li>
<li>如果某个 Sentinel 被半数以上的 Sentinel 设置成了局部领头 Sentinel，那么这个 Sentinel 成为领头 Sentinel</li>
<li>如果在给定时限内，没有一个 Sentinel 被选举为领头 Sentinel，那么各个 Sentinel 将在一段时间后再次选举，直到选出领头</li>
<li>每次进行领头 Sentinel 选举之后，不论选举是否成功，所有 Sentinel 的配置纪元（configuration epoch）都要自增一次</li>
</ul>
<p>Sentinel 集群至少 3 个节点的原因：</p>
<ul>
<li>如果 Sentinel 集群只有 2 个 Sentinel 节点，则领头选举需要 <code>2/2 + 1 = 2</code> 票，如果一个节点挂了，那就永远选不出领头</li>
<li>Sentinel 集群允许 1 个 Sentinel 节点故障则需要 3 个节点的集群，允许 2 个节点故障则需要 5 个节点集群</li>
</ul>
<hr>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><h4 id="执行流程-2"><a href="#执行流程-2" class="headerlink" title="执行流程"></a>执行流程</h4><p>领头 Sentinel 将对已下线的主服务器执行故障转移操作，该操作包含以下三个步骤</p>
<ul>
<li><p>从下线主服务器属下的所有从服务器里面，挑选出一个从服务器，执行 <code>SLAVEOF no one</code>，将从服务器升级为主服务器</p>
<p>在发送 SLAVEOF no one 命令后，领头 Sentinel 会以<strong>每秒一次的频率</strong>（一般是 10s&#x2F;次）向被升级的从服务器发送 INFO 命令，观察命令回复中的角色信息，当被升级服务器的 role 从 slave 变为 master 时，说明从服务器已经顺利升级为主服务器</p>
</li>
<li><p>将已下线的主服务器的所有从服务器改为复制新的主服务器，通过向从服务器发送 SLAVEOF 命令实现</p>
</li>
<li><p>将已经下线的主服务器设置为新的主服务器的从服务器，设置是保存在服务器对应的实例结构中，当旧的主服务器重新上线时，Sentinel 就会向它发送 SLAVEOF 命令，成为新的主服务器的从服务器</p>
</li>
</ul>
<p>示例：sever1 是主，sever2、sever3、sever4 是从服务器，sever1 故障后选中 sever2 升级</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%93%A8%E5%85%B5%E6%89%A7%E8%A1%8C%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB.png"></p>
<hr>
<h4 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h4><p>领头 Sentinel 会将已下线主服务器的所有从服务器保存到一个列表里，然后按照以下规则对列表进行过滤，最后挑选出一个<strong>状态良好、数据完整</strong>的从服务器</p>
<ul>
<li><p>删除列表中所有处于下线或者断线状态的从服务器，保证列表中的从服务器都是正常在线的</p>
</li>
<li><p>删除列表中所有最近五秒内没有回复过领头 Sentinel 的 INFO 命令的从服务器，保证列表中的从服务器最近成功进行过通信</p>
</li>
<li><p>删除所有与已下线主服务器连接断开超过 <code>down-after-milliseconds * 10</code> 毫秒的从服务器，保证列表中剩余的从服务器都没有过早地与主服务器断开连接，保存的数据都是比较新的</p>
<p>down-after-milliseconds 时间用来判断是否主观下线，其余的时间完全可以完成客观下线和领头选举</p>
</li>
<li><p>根据从服务器的优先级，对列表中剩余的从服务器进行排序，并选出其中<strong>优先级最高</strong>的从服务器</p>
</li>
<li><p>如果有多个具有相同最高优先级的从服务器，领头 Sentinel 将对这些相同优先级的服务器按照复制偏移量进行排序，选出其中偏移量最大的从服务器，也就是保存着最新数据的从服务器</p>
</li>
<li><p>如果还没选出来，就按照运行 ID 对这些从服务器进行排序，并选出其中运行 ID 最小的从服务器</p>
</li>
</ul>
<hr>
<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><h3 id="集群节点"><a href="#集群节点" class="headerlink" title="集群节点"></a>集群节点</h3><h4 id="节点概述"><a href="#节点概述" class="headerlink" title="节点概述"></a>节点概述</h4><p>Redis 集群是 Redis 提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享， 并提供复制和故障转移功能，一个 Redis 集群通常由多个节点（node）组成，将各个独立的节点连接起来，构成一个包含多节点的集群</p>
<p>一个节点就是一个<strong>运行在集群模式下的 Redis 服务器</strong>，Redis 在启动时会根据配置文件中的 <code>cluster-enabled</code> 配置选项是否为 yes 来决定是否开启服务器的集群模式</p>
<p>节点会继续使用所有在单机模式中使用的服务器组件，使用 redisServer 结构来保存服务器的状态，使用 redisClient 结构来保存客户端的状态，也有集群特有的数据结构</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F.png"></p>
<hr>
<h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><p>每个节点都保存着一个集群状态 clusterState 结构，这个结构记录了在当前节点的视角下，集群目前所处的状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 指向当前节点的指针</span></span><br><span class="line">	clusterNode *myself;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 集群当前的配置纪元，用于实现故障转移</span></span><br><span class="line">	<span class="type">uint64_t</span> currentEpoch;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 集群当前的状态，是在线还是下线</span></span><br><span class="line">	<span class="type">int</span> state;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 集群中至少处理着一个槽的节点的数量，为0表示集群目前没有任何节点在处理槽</span></span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群节点名单（包括 myself 节点），字典的键为节点的名字，字典的值为节点对应的clusterNode结构 </span></span><br><span class="line">    dict *nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个节点都会使用 clusterNode 结构记录当前状态，并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的 clusterNode 结构，以此来记录其他节点的状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 创建节点的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> ctime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点的名字，由 40 个十六进制字符组成</span></span><br><span class="line">    <span class="type">char</span> name[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点标识，使用各种不同的标识值记录节点的角色（比如主节点或者从节点）以及节点目前所处的状态（比如在线或者下线）</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="type">uint64_t</span> configEpoch;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点的IP地址</span></span><br><span class="line">    <span class="type">char</span> ip[REDIS_IP_STR_LEN];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点的端口号</span></span><br><span class="line">    <span class="type">int</span> port;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存连接节点所需的有关信息</span></span><br><span class="line">    clusterLink *link;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clusterNode 结构的 link 属性是一个 clusterLink 结构，该结构保存了连接节点所需的有关信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterLink</span> &#123;</span></span><br><span class="line">    <span class="comment">// 连接的创建时间 </span></span><br><span class="line">    <span class="type">mstime_t</span> ctime;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// TCP套接字描述符</span></span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 输出缓冲区，保存着等待发送给其他节点的消息(message)。 </span></span><br><span class="line">    sds sndbuf;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 输入缓冲区，保存着从其他节点接收到的消息。</span></span><br><span class="line">	sds rcvbuf;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 与这个连接相关联的节点，如果没有的话就为NULL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>redisClient 结构中的套接宇和缓冲区是用于连接客户端的</li>
<li>clusterLink 结构中的套接宇和缓冲区则是用于连接节点的</li>
</ul>
<hr>
<h4 id="MEET"><a href="#MEET" class="headerlink" title="MEET"></a>MEET</h4><p>CLUSTER MEET 命令用来将 ip 和 port 所指定的节点添加到接受命令的节点所在的集群中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CLUSTER MEET &lt;ip&gt; &lt;port&gt; </span><br></pre></td></tr></table></figure>

<p>假设向节点 A 发送 CLUSTER MEET 命令，让节点 A 将另一个节点 B 添加到节点 A 当前所在的集群里，收到命令的节点 A 将与根据 ip 和 port 向节点 B 进行握手（handshake）：</p>
<ul>
<li>节点 A 会为节点 B 创建一个 clusterNode 结构，并将该结构添加到自己的 clusterState.nodes 字典里，然后节点 A 向节点 B <strong>发送 MEET 消息</strong>（message）</li>
<li>节点 B 收到 MEET 消息后，节点 B 会为节点 A 创建一个 clusterNode 结构，并将该结构添加到自己的 clusterState.nodes 字典里，之后节点 B 将向节点 A <strong>返回一条 PONG 消息</strong></li>
<li>节点 A 收到 PONG 消息后，代表节点 A 可以知道节点 B 已经成功地接收到了自已发送的 MEET 消息，此时节点 A 将向节点 B <strong>返回一条 PING 消息</strong></li>
<li>节点 B 收到 PING 消息后， 代表节点 B 可以知道节点 A 已经成功地接收到了自己返回的 PONG 消息，握手完成</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E6%8F%A1%E6%89%8B.png"></p>
<p>节点 A 会将节点 B 的信息通过 Gossip 协议传播给集群中的其他节点，让其他节点也与节点 B 进行握手，最终经过一段时间之后，节点 B 会被集群中的所有节点认识</p>
<hr>
<h3 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h3><h4 id="基本操作-6"><a href="#基本操作-6" class="headerlink" title="基本操作"></a>基本操作</h4><p>Redis 集群通过分片的方式来保存数据库中的键值对，集群的整个数据库被分为16384 个槽（slot），数据库中的每个键都属于 16384 个槽中的一个，集群中的每个节点可以处理 0 个或最多 16384 个槽（<strong>每个主节点存储的数据并不一样</strong>）</p>
<ul>
<li>当数据库中的 16384 个槽都有节点在处理时，集群处于上线状态（ok）</li>
<li>如果数据库中有任何一个槽得到处理，那么集群处于下线状态（fail）</li>
</ul>
<p>通过向节点发送 CLUSTER ADDSLOTS 命令，可以将一个或多个槽指派（assign）给节点负责</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CLUSTER ADDSLOTS &lt;slot&gt; [slot ... ] </span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">127.0.0.1:7000&gt; CLUSTER ADDSLOTS 0 1 2 3 4 ... 5000 <span class="comment"># 将槽0至槽5000指派给节点7000负责</span></span><br><span class="line">OK </span><br></pre></td></tr></table></figure>

<p>命令执行细节：</p>
<ul>
<li>如果命令参数中有一个槽已经被指派给了某个节点，那么会向客户端返回错误，并终止命令执行</li>
<li>将 slots 数组中的索引 i 上的二进制位设置为 1，就代表指派成功</li>
</ul>
<hr>
<h4 id="节点指派"><a href="#节点指派" class="headerlink" title="节点指派"></a>节点指派</h4><p>clusterNode 结构的 slots 属性和 numslot 属性记录了节点负责处理哪些槽：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 处理信息，一字节等于 8 位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> slots[l6384/<span class="number">8</span>];</span><br><span class="line">    <span class="comment">// 记录节点负责处理的槽的数量，就是 slots 数组中值为 1 的二进制位数量</span></span><br><span class="line">    <span class="type">int</span> numslots;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>slots 是一个二进制位数组（bit array），长度为 <code>16384/8 = 2048</code> 个字节，包含 16384 个二进制位，Redis 以 0 为起始索引，16383 为终止索引，对 slots 数组的 16384 个二进制位进行编号，并根据索引 i 上的二进制位的值来判断节点是否负责处理槽 i：</p>
<ul>
<li>在索引 i 上的二进制位的值为 1，那么表示节点负责处理槽 i</li>
<li>在索引 i 上的二进制位的值为 0，那么表示节点不负责处理槽 i</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E9%9B%86%E7%BE%A4%E6%A7%BD%E6%8C%87%E6%B4%BE%E4%BF%A1%E6%81%AF.png"></p>
<p>取出和设置 slots 数组中的任意一个二进制位的值的**复杂度仅为 O(1)**，所以对于一个给定节点的 slots 数组来说，检查节点是否负责处理某个槽或者将某个槽指派给节点负责，这两个动作的复杂度都是 O(1)</p>
<p><strong>传播节点的槽指派信息</strong>：一个节点除了会将自己负责处理的槽记录在 clusterNode 中，还会将自己的 slots 数组通过消息发送给集群中的其他节点，每个接收到 slots 数组的节点都会将数组保存到相应节点的 clusterNode 结构里面，因此集群中的<strong>每个节点</strong>都会知道数据库中的 16384 个槽分别被指派给了集群中的哪些节点</p>
<hr>
<h4 id="集群指派"><a href="#集群指派" class="headerlink" title="集群指派"></a>集群指派</h4><p>集群状态 clusterState 结构中的 slots 数组记录了集群中所有 16384 个槽的指派信息，数组每一项都是一个指向 clusterNode 的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    clusterNode *slots[<span class="number">16384</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 slots[i] 指针指向 NULL，那么表示槽 i 尚未指派给任何节点</li>
<li>如果 slots[i] 指针指向一个 clusterNode 结构，那么表示槽 i 已经指派给该节点所代表的节点</li>
</ul>
<p>通过该节点，程序检查槽 i 是否已经被指派或者取得负责处理槽 i 的节点，只需要访问 clusterState. slots[i] 即可，时间复杂度仅为 O(1)</p>
<hr>
<h4 id="集群数据"><a href="#集群数据" class="headerlink" title="集群数据"></a>集群数据</h4><p>集群节点保存键值对以及键值对过期时间的方式，与单机 Redis 服务器保存键值对以及键值对过期时间的方式完全相同，但是集群节点只能使用 0 号数据库，单机服务器可以任意使用</p>
<p>除了将键值对保存在数据库里面之外，节点还会用 clusterState 结构中的 slots_to_keys 跳跃表来<strong>保存槽和键之间的关系</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    zskiplist *slots_to_keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>slots_to_keys 跳跃表每个节点的分值（score）都是一个槽号，而每个节点的成员（member）都是一个数据库键（按槽号升序）</p>
<ul>
<li>当节点往数据库中添加一个新的键值对时，节点就会将这个键以及键的槽号关联到 slots_to_keys 跳跃表</li>
<li>当节点删除数据库中的某个键值对时，节点就会在 slots_to_keys 跳跃表解除被删除键与槽号的关联</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E6%A7%BD%E5%92%8C%E9%94%AE%E8%B7%B3%E8%B7%83%E8%A1%A8.png"></p>
<p>通过在 slots_to_keys 跳跃表中记录各个数据库键所属的槽，可以很方便地对属于某个或某些槽的所有数据库键进行批量操作，比如 <code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code> 命令返回最多 count 个属于槽 slot 的数据库键，就是通过该跳表实现</p>
<hr>
<h3 id="集群命令"><a href="#集群命令" class="headerlink" title="集群命令"></a>集群命令</h3><h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><p>集群处于上线状态，客户端就可以向集群中的节点发送命令（16384 个槽全部指派就进入上线状态）</p>
<p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令该键属于哪个槽，并检查这个槽是否指派给了自己</p>
<ul>
<li>如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令</li>
<li>反之，节点会向客户端返回一个 MOVED 错误，指引客户端转向（redirect）至正确的节点，再次发送该命令</li>
</ul>
<p>计算键归属哪个槽的<strong>寻址算法</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">slot_number</span><span class="params">(key)</span>: 			<span class="comment">// CRC16(key) 语句计算键 key 的 CRC-16 校验和</span></span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">CRC16</span><span class="params">(key)</span> &amp; 16383;	<span class="comment">// 取模，十进制对16384的取余</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>CLUSTER KEYSLOT &lt;key&gt;</code> 命令可以查看一个给定键属于哪个槽，底层实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">CLUSTER_KEYSLOT</span><span class="params">(key)</span>:</span><br><span class="line">	<span class="comment">// 计算槽号</span></span><br><span class="line">	slot = slot_number(key);</span><br><span class="line">	<span class="comment">// 将槽号返回给客户端</span></span><br><span class="line">	reply_client(slot);</span><br></pre></td></tr></table></figure>

<p>判断槽是否由当前节点负责处理：如果 clusterState.slots[i] 不等于 clusterState.myself，那么说明槽 i 并非由当前节点负责，节点会根据 clusterState.slots[i] 指向的 clusterNode 结构所记录的节点 IP 和端口号，向客户端返回 MOVED 错误</p>
<hr>
<h4 id="MOVED"><a href="#MOVED" class="headerlink" title="MOVED"></a>MOVED</h4><p>MOVED 错误的格式为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port＞</span><br></pre></td></tr></table></figure>

<p>参数 slot 为键所在的槽，ip 和 port 是负责处理槽 slot 的节点的 ip 地址和端口号</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MOVED 12345 127.0.0.1:6380 <span class="comment"># 表示槽 12345 正由 IP地址为 127.0.0.1, 端口号为 6380 的节点负责</span></span><br></pre></td></tr></table></figure>

<p>当客户端接收到节点返回的 MOVED 错误时，客户端会根据 MOVED 错误中提供的 IP 地址和端口号，转至负责处理槽 slot 的节点重新发送执行的命令</p>
<ul>
<li><p>一个集群客户端通常会与集群中的多个节点创建套接字连接，节点转向实际上就是换一个套接字来发送命令</p>
</li>
<li><p>如果客户端尚未与转向的节点创建套接字连接，那么客户端会先根据 IP 地址和端口号来连接节点，然后再进行转向</p>
</li>
</ul>
<p>集群模式的 redis-cli 在接收到 MOVED 错误时，并不会打印出 MOVED 错误，而是根据错误<strong>自动进行节点转向</strong>，并打印出转向信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ redis-cli -c -p 6379 	<span class="comment">#集群模式</span></span><br><span class="line">127.0.0.1:6379&gt; SET msg <span class="string">&quot;happy&quot;</span> </span><br><span class="line">-&gt; Redirected to slot [6257] located at 127.0.0.1:6380</span><br><span class="line">OK </span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<p>使用单机（stand alone）模式的 redis-cli 会打印错误，因为单机模式客户端不清楚 MOVED 错误的作用，不会进行自动转向：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ redis-cli -c -p 6379 	<span class="comment">#集群模式</span></span><br><span class="line">127.0.0.1:6379&gt; SET msg <span class="string">&quot;happy&quot;</span> </span><br><span class="line">(error) MOVED 6257 127.0.0.1:6380</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><p>Redis 集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽的键值对也会从源节点被移动到目标节点，该操作是可以在线（online）进行，在重新分片的过程中源节点和目标节点都可以处理命令请求</p>
<p>Redis 的集群管理软件 redis-trib 负责执行重新分片操作，redis-trib 通过向源节点和目标节点发送命令来进行重新分片操作</p>
<ul>
<li>向目标节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code> 命令，准备好从源节点导入属于槽 slot 的键值对</li>
<li>向源节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code> 命令，让源节点准备好将属于槽 slot 的键值对迁移</li>
<li>redis-trib 向源节点发送 <code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code> 命令，获得最多 count 个属于槽 slot 的键值对的键名</li>
<li>对于每个 key，redis-trib 都向源节点发送一个 <code>MIGRATE &lt;target_ip&gt; &lt;target_port&gt; &lt;key_name&gt; 0 &lt;timeout＞</code> 命令，将被选中的键<strong>原子地</strong>从源节点迁移至目标节点</li>
<li>重复上述步骤，直到源节点保存的所有槽 slot 的键值对都被迁移至目标节点为止</li>
<li>redis-trib 向集群中的任意一个节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target _id&gt;</code> 命令，将槽 slot 指派给目标节点，这一指派信息会通过消息传播至整个集群，最终集群中的所有节点都直到槽 slot 已经指派给了目标节点</li>
</ul>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E9%9B%86%E7%BE%A4%E9%87%8D%E6%96%B0%E5%88%86%E7%89%87.png"></p>
<p>如果重新分片涉及多个槽，那么 redis-trib 将对每个给定的槽分别执行上面给出的步骤</p>
<hr>
<h4 id="命令原理"><a href="#命令原理" class="headerlink" title="命令原理"></a>命令原理</h4><p>clusterState 结构的 importing_slots_from 数组记录了当前节点正在从其他节点导入的槽，migrating_slots_to 数组记录了当前节点正在迁移至其他节点的槽：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 如果 importing_slots_from[i] 的值不为 NULL，而是指向一个 clusterNode 结构，</span></span><br><span class="line">    <span class="comment">// 那么表示当前节点正在从 clusterNode 所代表的节点导入槽 i</span></span><br><span class="line">    clusterNode *importing_slots_from[<span class="number">16384</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表示当前节点正在将槽 i 迁移至 clusterNode 所代表的节点</span></span><br><span class="line">    clusterNode *migrating_slots_to[<span class="number">16384</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code> 命令：将目标节点 <code>clusterState.importing_slots_from[slot]</code> 的值设置为  source_id 所代表节点的 clusterNode 结构</p>
<p><code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code> 命令：将源节点 <code>clusterState.migrating_slots_to[slot]</code> 的值设置为target_id 所代表节点的 clusterNode 结构</p>
<hr>
<h4 id="ASK-错误"><a href="#ASK-错误" class="headerlink" title="ASK 错误"></a>ASK 错误</h4><p>重新分片期间，源节点向目标节点迁移一个槽的过程中，可能出现被迁移槽的一部分键值对保存在源节点，另一部分保存在目标节点</p>
<p>客户端向源节点发送命令请求，并且命令要处理的数据库键属于被迁移的槽：</p>
<ul>
<li><p>源节点会先在数据库里面查找指定键，如果找到的话，就直接执行客户端发送的命令</p>
</li>
<li><p>未找到会检查 clusterState.migrating_slots_to[slot]，看键 key 所属的槽 slot 是否正在进行迁移</p>
</li>
<li><p>槽 slot 正在迁移则源节点将向客户端返回一个 ASK 错误，指引客户端转向正在导入槽的目标节点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ASK &lt;slot&gt; &lt;ip:port&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接到 ASK 错误的客户端，会根据错误提供的 IP 地址和端口号转向目标节点，首先向目标节点发送一个 ASKING 命令，再重新发送原本想要执行的命令</p>
</li>
</ul>
<p>和 MOVED 错误情况类似，集群模式的 redis-cli 在接到 ASK 错误时不会打印错误进行自动转向；单机模式的 redis-cli 会打印错误</p>
<p>对比 MOVED 错误：</p>
<ul>
<li><p>MOVED 错误代表槽的负责权已经从一个节点转移到了另一个节点，转向是一种持久性的转向</p>
</li>
<li><p>ASK 错误只是两个节点在迁移槽的过程中使用的一种临时措施，ASK 的转向不会对客户端今后发送关于槽 slot 的命令请求产生任何影响，客户端仍然会将槽 slot 的命令请求发送至目前负责处理槽 slot 的节点，除非 ASK 错误再次出现</p>
</li>
</ul>
<hr>
<h4 id="ASKING"><a href="#ASKING" class="headerlink" title="ASKING"></a>ASKING</h4><p>客户端不发送 ASKING 命令，而是直接发送执行的命令，那么客户端发送的命令将被节点拒绝执行，并返回 MOVED 错误</p>
<p>ASKING 命令作用是打开发送该命令的客户端的 REDIS_ASKING 标识，该命令的伪代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">ASKING</span> <span class="params">()</span>:</span><br><span class="line">    <span class="comment">// 打开标识</span></span><br><span class="line">    client.flags |= REDIS_ASKING </span><br><span class="line">    <span class="comment">// 向客户端返回OK回复</span></span><br><span class="line">    reply(<span class="string">&quot;OK&quot;</span>) </span><br></pre></td></tr></table></figure>

<p>当前节点正在导入槽 slot，并且发送命令的客户端带有 REDIS_ASKING 标识，那么节点将破例执行这个关于槽 slot 的命令一次</p>
<p>客户端的 REDIS_ASKING 标识是一次性标识，当节点执行了一个带有 REDIS_ASKING 标识的客户端发送的命令之后，该客户端的 REDIS_ASKING 标识就会被移除</p>
<hr>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><h4 id="节点复制"><a href="#节点复制" class="headerlink" title="节点复制"></a>节点复制</h4><p>Redis 集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CLUSTER REPLICATE &lt;node_id&gt; </span><br></pre></td></tr></table></figure>

<p>向一个节点发送命令可以让接收命令的节点成为 node_id 所指定节点的从节点，并开始对主节点进行复制</p>
<ul>
<li><p>接受命令的节点首先会在的 clusterState.nodes 字典中找到 node_id 所对应节点的 clusterNode 结构，并将自己的节点中的 clusterState.myself.slaveof 指针指向这个结构，记录这个节点正在复制的主节点</p>
</li>
<li><p>节点会修改 clusterState.myself.flags 中的属性，关闭 REDIS_NODE_MASTER 标识，打开 REDIS_NODE_SLAVE 标识</p>
</li>
<li><p>节点会调用复制代码，对主节点进行复制（节点的复制功能和单机 Redis 服务器的使用了相同的代码）</p>
</li>
</ul>
<p>一个节点成为从节点，并开始复制某个主节点这一信息会通过消息发送给集群中的其他节点，最终集群中的所有节点都会知道某个从节点正在复制某个主节点</p>
<p>主节点的 clusterNode 结构的 slaves 属性和 numslaves 属性中记录正在复制这个主节点的从节点名单：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 正在复制这个主节点的从节点数量</span></span><br><span class="line">    <span class="type">int</span> numslaves;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组项指向一个正在复制这个主节点的从节点的clusterNode结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> **<span class="title">slaves</span>;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><p>集群中的每个节点都会定期地向集群中的其他节点发送 PING 消息，来检测对方是否在线，如果接收 PING 的节点没有在规定的时间内返回 PONG 消息，那么发送消息节点就会将接收节点标记为<strong>疑似下线</strong>（probable fail, PFAIL）</p>
<p>集群中的节点会互相发送消息，来<strong>交换集群中各个节点的状态信息</strong>，当一个主节点 A 通过消息得知主节点 B 认为主节点 C 进入了疑似下线状态时，主节点 A 会在 clusterState.nodes 字典中找到主节点 C 所对应的节点，并将主节点 B 的下线报告（failure report）添加到 clusterNode.fail_reports 链表里面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 一个链表，记录了所有其他节点对该节点的下线报告 </span></span><br><span class="line">    <span class="built_in">list</span> *fail_reports;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每个下线报告由一个 clusterNodeFailReport 结构表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNodeFailReport</span> &#123;</span></span><br><span class="line">    <span class="comment">// 报告目标节点巳经下线的节点 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后一次从node节点收到下线报告的时间</span></span><br><span class="line">    <span class="comment">// 程序使用这个时间戳来检查下线报告是否过期，与当前时间相差太久的下线报告会被删除 </span></span><br><span class="line">    <span class="type">mstime_t</span> time; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>集群里<strong>半数以上</strong>负责处理槽的主节点都将某个主节点 X 报告为疑似下线，那么 X 将被标记为<strong>已下线</strong>（FAIL），将 X 标记为已下线的节点会向集群广播一条关于主节点 X 的 FAIL 消息，所有收到消息的节点都会将 X 标记为已下线</p>
<hr>
<h4 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h4><p>当一个从节点发现所属的主节点进入了已下线状态，从节点将开始对下线主节点进行故障转移，执行步骤：</p>
<ul>
<li>下属的从节点通过选举产生一个节点</li>
<li>被选中的从节点会执行 <code>SLAVEOF no one</code> 命令，成为新的主节点</li>
<li>新的主节点会<strong>撤销所有对已下线主节点的槽指派</strong>，并将这些槽全部指派给自己</li>
<li>新的主节点向集群广播一条 PONG 消息，让集群中的其他节点知道当前节点变成了主节点，并且接管了下线节点负责处理的槽</li>
<li>新的主节点开始接收有关的命令请求，故障转移完成</li>
</ul>
<hr>
<h4 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h4><p>集群选举新的主节点的规则：</p>
<ul>
<li>集群的配置纪元是一个自增的计数器，初始值为 0</li>
<li>当集群里某个节点开始一次故障转移，集群的配置纪元就是增加一</li>
<li>每个配置纪元里，集群中每个主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得该主节点的投票</li>
<li>具有投票权的主节点是必须具有正在处理的槽</li>
<li>集群里有 N 个具有投票权的主节点，那么当一个从节点收集到大于等于 <code>N/2+1</code> 张支持票时，从节点就会当选</li>
<li>每个配置纪元里，具有投票权的主节点只能投一次票，所以获得一半以上票的节点只会有一个</li>
</ul>
<p>选举流程：</p>
<ul>
<li>当某个从节点发现正在复制的主节点进入已下线状态时，会向集群广播一条 <code>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</code> 消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票</li>
<li>如果主节点尚未投票给其他从节点，将向要求投票的从节点返回一条 <code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code> 消息，表示这个主节点支持从节点成为新的主节点</li>
<li>如果从节点获取到了半数以上的选票，则会当选新的主节点</li>
<li>如果一个配置纪元里没有从节点能收集到足够多的支待票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点</li>
</ul>
<p>选举新主节点的方法和选举领头 Sentinel 的方法非常相似，两者都是基于 Raft 算法的领头选举（eader election）方法实现的</p>
<hr>
<h3 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h3><h4 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h4><p>集群中的各个节点通过发送和接收消息（message）来进行通信，将发送消息的节点称为发送者（sender），接收消息的节点称为接收者（receiver）</p>
<p>节点发送的消息主要有：</p>
<ul>
<li><p>MEET 消息：当发送者接到客户端发送的 CLUSTER MEET 命令时，会向接收者发送 MEET 消息，请求接收者加入到发送者当前所处的集群里</p>
</li>
<li><p>PING 消息：集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个，然后对这五个节点中最长时间没有发送过 PING 消息的节点发送 PING，以此来<strong>随机检测</strong>被选中的节点是否在线</p>
<p>如果节点 A 最后一次收到节点 B 发送的 PONG 消息的时间，距离当前已经超过了节点 A 的 cluster-node­-timeout 设置时长的一半，那么 A 也会向 B 发送 PING 消息，防止 A 因为长时间没有随机选中 B 发送 PING，而导致对节点 B 的信息更新滞后</p>
</li>
<li><p>PONG 消息：当接收者收到 MEET 消息或者 PING 消息时，为了让发送者确认已经成功接收消息，会向发送者返回一条 PONG；节点也可以通过向集群广播 PONG 消息来让集群中的其他节点立即刷新关于这个节点的认识（从升级为主）</p>
</li>
<li><p>FAIL 消息：当一个主节点 A 判断另一个主节点 B 已经进入 FAIL 状态时，节点 A 会向集群广播一条 B 节点的 FAIL 信息</p>
</li>
<li><p>PUBLISH 消息：当节点接收到一个 PUBLISH 命令时，节点会执行这个命令并向集群广播一条 PUBLISH 消息，接收到 PUBLISH 消息的节点都会执行相同的 PUBLISH 命令</p>
</li>
</ul>
<hr>
<h4 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h4><p>节点发送的所有消息都由一个消息头包裹，消息头除了包含消息正文之外，还记录了消息发送者自身的一些信息</p>
<p>消息头：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterMsg</span> &#123;</span></span><br><span class="line">    <span class="comment">// 消息的长度（包括这个消息头的长度和消息正文的长度）</span></span><br><span class="line">	<span class="type">uint32_t</span> totlen;</span><br><span class="line">	<span class="comment">// 消息的类型</span></span><br><span class="line">	<span class="type">uint16_t</span> type;</span><br><span class="line">    <span class="comment">// 消息正文包含的节点信息数量，只在发送MEET、PING、PONG这三种Gossip协议消息时使用 </span></span><br><span class="line">    <span class="type">uint16_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送者所处的配置纪元</span></span><br><span class="line">    <span class="type">uint64_t</span> currentEpoch;</span><br><span class="line">    <span class="comment">// 如果发送者是一个主节点，那么这里记录的是发送者的配置纪元</span></span><br><span class="line">    <span class="comment">// 如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的配置纪元</span></span><br><span class="line">    <span class="type">uint64_t</span> configEpoch;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送者的名字(ID)</span></span><br><span class="line">	<span class="type">char</span> sender[REDIS CLUSTER NAMELEN];</span><br><span class="line">	<span class="comment">// 发送者目前的槽指派信息</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> myslots[REDIS_CLUSTER_SLOTS/<span class="number">8</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的名字</span></span><br><span class="line">    <span class="comment">// 如果发送者是一个主节点，那么这里记录的是 REDIS_NODE_NULL_NAME，一个 40 宇节长值全为 0 的字节数组</span></span><br><span class="line">    <span class="type">char</span> slaveof[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 发送者的端口号</span></span><br><span class="line">	<span class="type">uint16_t</span> port;</span><br><span class="line">	<span class="comment">// 发送者的标识值</span></span><br><span class="line">    <span class="type">uint16_t</span> flags; </span><br><span class="line">	<span class="comment">//发送者所处集群的状态</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> state;</span><br><span class="line">	<span class="comment">// 消息的正文（或者说， 内容） </span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">clusterMsgData</span> <span class="title">data</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clusterMsg 结构的 currentEpoch、sender、myslots 等属性记录了发送者的节点信息，接收者会根据这些信息在 clusterState.nodes 字典里找到发送者对应的 clusterNode 结构，并对结构进行更新，比如<strong>传播节点的槽指派信息</strong></p>
<p>消息正文：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">clusterMsgData</span> &#123;</span></span><br><span class="line">    <span class="comment">// MEET、PING、PONG 消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">// 每条 MEET、PING、PONG 消息都包含两个 clusterMsgDataGossip 结构</span></span><br><span class="line">        clusterMsgDataGossip gossip[<span class="number">1</span>];</span><br><span class="line">    &#125; ping;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// FAIL 消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">		clusterMsgDataFail about;</span><br><span class="line">    &#125; fail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// PUBLISH 消息的正文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    	clusterMsgDataPublish msg;</span><br><span class="line">    &#125; publish;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他消息正文...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a>Gossip</h4><p>Redis 集群中的各个节点通过 Gossip 协议来交换各自关于不同节点的状态信息，其中 Gossip 协议由 MEET、PING、PONG 消息实现，三种消息使用相同的消息正文，所以节点通过消息头的 type 属性来判断消息的具体类型</p>
<p>发送者发送这三种消息时，会从已知节点列表中<strong>随机选出两个节点</strong>（主从都可以），将两个被选中节点信息保存到两个 Gossip 结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterMsgDataGossip</span> &#123;</span></span><br><span class="line">    <span class="comment">// 节点的名字</span></span><br><span class="line">	<span class="type">char</span> nodename[REDIS CLUSTER NAMELEN];</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 最后一次向该节点发送PING消息的时间戳</span></span><br><span class="line">    <span class="type">uint32_t</span> ping_sent;</span><br><span class="line">	<span class="comment">// 最后一次从该节点接收到PONG消息的时间戳</span></span><br><span class="line">    <span class="type">uint32_t</span> pong_received;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 节点的IP地址</span></span><br><span class="line">	<span class="type">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="comment">// 节点的端口号</span></span><br><span class="line">    <span class="type">uint16_t</span> port;</span><br><span class="line">	<span class="comment">// 节点的标识值</span></span><br><span class="line">    <span class="type">uint16_t</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当接收者收到消息时，会访问消息正文中的两个数据结构，来进行相关操作</p>
<ul>
<li>如果被选中节点不存在于接收者的已知节点列表，接收者将根据结构中记录的 IP 地址和端口号，与节点进行握手</li>
<li>如果存在，根据 Gossip 结构记录的信息对节点所对应的 clusterNode 结构进行更新</li>
</ul>
<hr>
<h4 id="FAIL"><a href="#FAIL" class="headerlink" title="FAIL"></a>FAIL</h4><p>在集群的节点数量比较大的情况下，使用 Gossip 协议来传播节点的已下线信息会带来一定延迟，因为 Gossip 协议消息通常需要一段时间才能传播至整个集群，所以通过发送 FAIL消息可以让集群里的所有节点立即知道某个主节点已下线，从而尽快进行其他操作</p>
<p>FAIL 消息的正文由 clusterMsgDataFail 结构表示，该结构只有一个属性，记录了已下线节点的名字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterMsgDataFail</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> nodename[REDIS_CLUSTER_NAMELEN)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为传播下线信息不需要其他属性，所以节省了传播的资源</p>
<hr>
<h4 id="PUBLISH"><a href="#PUBLISH" class="headerlink" title="PUBLISH"></a>PUBLISH</h4><p>当客户端向集群中的某个节点发送命令，接收到 PUBLISH 命令的节点不仅会向 channel 频道发送消息 message，还会向集群广播一条 PUBLISH 消息，所有接收到这条 PUBLISH 消息的节点都会向 channel 频道发送 message 消息，最终集群中所有节点都发了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUBLISH &lt;channel&gt; &lt;message&gt; </span><br></pre></td></tr></table></figure>

<p>PUBLISH 消息的正文由 clusterMsgDataPublish 结构表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterMsgDataPublish</span> &#123;</span></span><br><span class="line">    <span class="comment">// channel参数的长度</span></span><br><span class="line">    <span class="type">uint32_t</span> channel_len;</span><br><span class="line">    <span class="comment">// message参数的长度</span></span><br><span class="line">    <span class="type">uint32_t</span> message_len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义为8字节只是为了对齐其他消息结构，实际的长度由保存的内容决定</span></span><br><span class="line">    <span class="comment">// bulk_data 的 0 至 channel_len-1 字节保存的是channel参数</span></span><br><span class="line">    <span class="comment">// bulk_data的 channel_len 字节至 channel_len + message_len-1 字节保存的则是message参数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> bulk_data[<span class="number">8</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让集群的所有节点执行相同的 PUBLISH 命令，最简单的方法就是向所有节点广播相同的 PUBLISH 命令，这也是 Redis 复制 PUBLISH 命令时所使用的，但是这种做法并不符合 Redis 集群的各<strong>个节点通过发送和接收消息来进行通信</strong>的规则</p>
<hr>
<h3 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a>脑裂问题</h3><p>脑裂指在主从集群中，同时有两个相同的主节点能接收写请求，导致客户端不知道应该往哪个主节点写入数据，导致不同客户端往不同的主节点上写入数据</p>
<ul>
<li>原主节点并没有真的发生故障，由于某些原因无法处理请求（CPU 利用率很高、自身阻塞），无法按时响应心跳请求，被哨兵&#x2F;集群主节点错误的判断为下线</li>
<li>在被判断下线之后，原主库又重新开始处理请求了，哨兵&#x2F;集群主节点还没有完成主从切换，客户端仍然可以和原主库通信，客户端发送的写操作就会在原主库上写入数据，造成脑裂问题</li>
</ul>
<p>数据丢失问题：从库一旦升级为新主库，哨兵就会让原主库执行 slave of 命令，和新主库重新进行全量同步，原主库需要清空本地的数据，加载新主库发送的 RDB 文件，所以原主库在主从切换期间保存的新写数据就丢失了</p>
<p>预防脑裂：在主从集群部署时，合理地配置参数 min-slaves-to-write 和 min-slaves-max-lag</p>
<ul>
<li>假设从库有 K 个，可以将 min-slaves-to-write 设置为 K&#x2F;2+1（如果 K 等于 1，就设为 1）</li>
<li>将 min-slaves-max-lag 设置为十几秒（例如 10～20s）</li>
</ul>
<hr>
<h3 id="结构搭建"><a href="#结构搭建" class="headerlink" title="结构搭建"></a>结构搭建</h3><p>整体框架：</p>
<ul>
<li>配置服务器（3 主 3 从）</li>
<li>建立通信（Meet）</li>
<li>分槽（Slot）</li>
<li>搭建主从（master-slave）</li>
</ul>
<p>创建集群 conf 配置文件：</p>
<ul>
<li><p>redis-6501.conf</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">port 6501</span><br><span class="line"><span class="built_in">dir</span> <span class="string">&quot;/redis/data&quot;</span></span><br><span class="line">dbfilename <span class="string">&quot;dump-6501.rdb&quot;</span></span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line">cluster-config-file <span class="string">&quot;cluster-6501.conf&quot;</span></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"></span><br><span class="line"><span class="comment">#其他配置文件参照上面的修改端口即可，内容完全一样</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端启动：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-server config_file_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端启动：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli -p 6504 -c</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>cluster 配置：</strong></p>
<ul>
<li><p>是否启用 cluster，加入 cluster 节点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster-enabled <span class="built_in">yes</span>|no</span><br></pre></td></tr></table></figure>
</li>
<li><p>cluster 配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster-config-file filename</span><br></pre></td></tr></table></figure>
</li>
<li><p>节点服务响应超时时间，用于判定该节点是否下线或切换为从节点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster-node-timeout milliseconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>master 连接的 slave 最小数量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster-migration-barrier min_slave_number</span><br></pre></td></tr></table></figure></li>
</ul>
<p>客户端启动命令：</p>
<p><strong>cluster 节点操作命令（客户端命令）：</strong></p>
<ul>
<li><p>查看集群节点信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改 slave 指向新的 master</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster replicate master-id</span><br></pre></td></tr></table></figure>
</li>
<li><p>发现一个新节点，新增 master</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster meet ip:port</span><br></pre></td></tr></table></figure>
</li>
<li><p>忽略一个没有 solt 的节点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster forget server_id</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动故障转移</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster failover</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>集群操作命令（Linux）：</strong></p>
<ul>
<li><p>创建集群</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli –-cluster create masterhost1:masterport1 masterhost2:masterport2  masterhost3:masterport3 [masterhostn:masterportn …] slavehost1:slaveport1  slavehost2:slaveport2 slavehost3:slaveport3 -–cluster-replicas n</span><br></pre></td></tr></table></figure>

<p>注意：master 与 slave 的数量要匹配，一个 master 对应 n 个 slave，由最后的参数 n 决定。master 与 slave 的匹配顺序为第一个 master 与前 n 个 slave 分为一组，形成主从结构</p>
</li>
<li><p>添加 master 到当前集群中，连接时可以指定任意现有节点地址与端口</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node new-master-host:new-master-port now-host:now-port</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加 slave</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node new-slave-host:new-slave-port master-host:master-port --cluster-slave --cluster-master-id masterid</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除节点，如果删除的节点是 master，必须保障其中没有槽 slot</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster del-node del-slave-host:del-slave-port del-slave-id</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新分槽，分槽是从具有槽的 master 中划分一部分给其他 master，过程中不创建新的槽</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster reshard new-master-host:new-master:port --cluster-from src-  master-id1, src-master-id2, src-master-idn --cluster-to target-master-id --  cluster-slots slots</span><br></pre></td></tr></table></figure>

<p>注意：将需要参与分槽的所有 masterid 不分先后顺序添加到参数中，使用 <code>,</code> 分隔，指定目标得到的槽的数量，所有的槽将平均从每个来源的 master 处获取</p>
</li>
<li><p>重新分配槽，从具有槽的 master 中分配指定数量的槽到另一个 master 中，常用于清空指定 master 中的槽</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster reshard src-master-host:src-master-port --cluster-from src-  master-id --cluster-to target-master-id --cluster-slots slots --cluster-yes</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><h4 id="基本指令-1"><a href="#基本指令-1" class="headerlink" title="基本指令"></a>基本指令</h4><p>Redis 发布订阅（pub&#x2F;sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息</p>
<p>Redis 客户端可以订阅任意数量的频道，每当有客户端向被订阅的频道发送消息（message）时，频道的<strong>所有订阅者都会收到消息</strong></p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85.png"></p>
<p>操作过程：</p>
<ul>
<li><p>打开一个客户端订阅 channel1：<code>SUBSCRIBE channel1</code></p>
</li>
<li><p>打开另一个客户端，给 channel1 发布消息 hello：<code>PUBLISH channel1 hello</code></p>
</li>
<li><p>第一个客户端可以看到发送的消息</p>
</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-发布订阅指令操作.png" style="zoom:67%;">

<p>客户端还可以通过 PSUBSCRIBE 命令订阅一个或多个模式，每当有其他客户端向某个频道发送消息时，消息不仅会被发送给这个频道的所有订阅者，还会被<strong>发送给所有与这个频道相匹配的模式的订阅者</strong>，比如 <code>PSUBSCRIBE channel*</code> 订阅模式，与 channel1 匹配</p>
<p>注意：发布的消息没有持久化，所以订阅的客户端只能收到订阅后发布的消息</p>
<hr>
<h4 id="频道操作"><a href="#频道操作" class="headerlink" title="频道操作"></a>频道操作</h4><p>Redis 将所有频道的订阅关系都保存在服务器状态的 pubsub_channels 字典里，键是某个被订阅的频道，值是一个记录所有订阅这个频道的客户端链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	<span class="comment">// 保存所有频道的订阅关系，</span></span><br><span class="line">	dict *pubsub_channels;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端执行 SUBSCRIBE 命令订阅某个或某些频道，服务器会将客户端与频道进行关联：</p>
<ul>
<li>频道已经存在，直接将客户端添加到链表末尾</li>
<li>频道还未有任何订阅者，在字典中为频道创建一个键值对，再将客户端添加到链表</li>
</ul>
<p>UNSUBSCRIBE 命令用来退订某个频道，服务器将从 pubsub_channels 中解除客户端与被退订频道之间的关联</p>
<hr>
<h4 id="模式操作"><a href="#模式操作" class="headerlink" title="模式操作"></a>模式操作</h4><p>Redis 服务器将所有模式的订阅关系都保存在服务器状态的 pubsub_patterns 属性里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	<span class="comment">// 保存所有模式订阅关系，链表中每个节点是一个 pubsubPattern</span></span><br><span class="line">	<span class="built_in">list</span> *pubsub_patterns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span> &#123;</span></span><br><span class="line">    <span class="comment">// 订阅的客户端</span></span><br><span class="line">    redisClient *client;</span><br><span class="line">	<span class="comment">// 被订阅的模式，比如  channel*</span></span><br><span class="line">    robj *pattern; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端执行 PSUBSCRIBE 命令订阅某个模式，服务器会新建一个 pubsubPattern 结构并赋值，放入 pubsub_patterns 链表结尾</p>
<p>模式的退订命令 PUNSUBSCRIBE 是订阅命令的反操作，服务器在 pubsub_patterns 链表中查找并删除对应的结构</p>
<hr>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>Redis 客户端执行 <code>PUBLISH &lt;channel&gt; &lt;message&gt;</code> 命令将消息 message发送给频道 channel，服务器会执行：</p>
<ul>
<li>在 pubsub_channels 字典里找到频道 channel 的订阅者名单，将消息 message 发送给所有订阅者</li>
<li>遍历整个 pubsub_patterns 链表，查找与 channel 频道相<strong>匹配的模式</strong>，并将消息发送给所有订阅了这些模式的客户端</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果频道和模式相匹配</span></span><br><span class="line"><span class="keyword">if</span> <span class="title function_">match</span><span class="params">(channel, pubsubPattern.pattern)</span> &#123;</span><br><span class="line">    <span class="comment">// 将消息发送给订阅该模式的客户端</span></span><br><span class="line">    send_message(pubsubPattern.client, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h4 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h4><p>PUBSUB 命令用来查看频道或者模式的相关信息</p>
<p><code>PUBSUB CHANNELS [pattern]</code> 返回服务器当前被订阅的频道，其中 pattern 参数是可选的</p>
<ul>
<li>如果不给定 pattern  参数，那么命令返回服务器当前被订阅的所有频道</li>
<li>如果给定 pattern 参数，那么命令返回服务器当前被订阅的频道中与 pattern 模式相匹配的频道</li>
</ul>
<p><code>PUBSUB NUMSUB [channel-1 channel-2 ... channel-n]</code>  命令接受任意多个频道作为输入参数，并返回这些频道的订阅者数量</p>
<p><code>PUBSUB NUMPAT</code> 命令用于返回服务器当前被订阅模式的数量</p>
<hr>
<h3 id="ACL-指令"><a href="#ACL-指令" class="headerlink" title="ACL 指令"></a>ACL 指令</h3><p>Redis ACL 是 Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-ACL%E6%8C%87%E4%BB%A4.png"></p>
<ul>
<li><p>acl cat：查看添加权限指令类别</p>
</li>
<li><p>acl whoami：查看当前用户</p>
</li>
<li><p>acl setuser username on &gt;password ~cached:* +get：设置有用户名、密码、ACL 权限（只能 get）</p>
</li>
</ul>
<hr>
<h3 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h3><p>MONITOR 命令，可以将客户端变为一个监视器，实时地接收并打印出服务器当前处理的命令请求的相关信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现原理</span></span><br><span class="line">def <span class="title function_">MONITOR</span><span class="params">()</span>:</span><br><span class="line">	<span class="comment">// 打开客户端的监视器标志</span></span><br><span class="line">	client.flags |= REDIS_MONITOR</span><br><span class="line">        </span><br><span class="line">  	<span class="comment">// 将客户端添加到服务器状态的 redisServer.monitors链表的末尾</span></span><br><span class="line">   	server.monitors.append(client)</span><br><span class="line">  	<span class="comment">// 向客户端返回 ok</span></span><br><span class="line">	send_reply(<span class="string">&quot;OK&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>服务器每次处理命令请求都会调用 replicationFeedMonitors 函数，函数将被处理的命令请求的相关信息<strong>发送给各个监视器</strong></p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-监视器.png" style="zoom:50%;">

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis&gt; MONITOR </span><br><span class="line">OK </span><br><span class="line">1378822099.421623 [0 127.0.0.1:56604] <span class="string">&quot;PING&quot;</span> </span><br><span class="line">1378822105.089572 [0 127.0.0.1:56604] <span class="string">&quot;SET&quot;</span> <span class="string">&quot;msg&quot;</span> <span class="string">&quot;hello world&quot;</span> </span><br><span class="line">1378822109.036925 [0 127.0.0.1:56604] <span class="string">&quot;SET&quot;</span> <span class="string">&quot;number&quot;</span> <span class="string">&quot;123&quot;</span> </span><br><span class="line">1378822140.649496 (0 127.0.0.1:56604] <span class="string">&quot;SADD&quot;</span> <span class="string">&quot;fruits&quot;</span> <span class="string">&quot;Apple&quot;</span> <span class="string">&quot;Banana&quot;</span> <span class="string">&quot;Cherry&quot;</span> </span><br><span class="line">1378822154.117160 [0 127.0.0.1:56604] <span class="string">&quot;EXPIRE&quot;</span> <span class="string">&quot;msg&quot;</span> <span class="string">&quot;10086&quot;</span> </span><br><span class="line">1378822257.329412 [0 127.0.0.1:56604] <span class="string">&quot;KEYS&quot;</span> <span class="string">&quot;*&quot;</span> </span><br><span class="line">1378822258.690131 [0 127.0.0.1:56604] <span class="string">&quot;DBSIZE&quot;</span> </span><br></pre></td></tr></table></figure>





<hr>
<h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>Redis 的管道 Pipeline 机制可以一次处理多条指令</p>
<ul>
<li>Pipeline 中的多条命令非原子性，因为在向管道内添加命令时，其他客户端的发送的命令仍然在执行</li>
<li>原生批命令（mset 等）是服务端实现，而 pipeline 需要服务端与客户端共同完成</li>
</ul>
<p>使用 Pipeline 封装的命令数量不能太多，数据量过大会增加客户端的等待时间，造成网络阻塞，Jedis 中的 Pipeline 使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建管道</span></span><br><span class="line"><span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 放入命令到管道</span></span><br><span class="line">    pipeline.set(<span class="string">&quot;key_&quot;</span> + i, <span class="string">&quot;value_&quot;</span> + i);</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 每放入1000条命令，批量执行</span></span><br><span class="line">        pipeline.sync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集群下模式下，批处理命令的多个 key 必须落在一个插槽中，否则就会导致执行失败，N 条批处理命令的优化方式：</p>
<ul>
<li>串行命令：for 循环遍历，依次执行每个命令</li>
<li>串行 slot：在客户端计算每个 key 的 slot，将 slot 一致的分为一组，每组都利用 Pipeline 批处理，串行执行各组命令</li>
<li>并行 slot：在客户端计算每个 key 的 slot，将 slot 一致的分为一组，每组都利用 Pipeline 批处理，<strong>并行执行各组命令</strong></li>
<li>hash_tag：将所有 key 设置相同的 hash_tag，则所有 key 的 slot 一定相同</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>耗时</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>串行命令</td>
<td>N 次网络耗时 + N 次命令耗时</td>
<td>实现简单</td>
<td>耗时久</td>
</tr>
<tr>
<td>串行 slot</td>
<td>m 次网络耗时 + N 次命令耗时，m &#x3D; key 的 slot 个数</td>
<td>耗时较短</td>
<td>实现稍复杂</td>
</tr>
<tr>
<td>并行 slot</td>
<td>1 次网络耗时 + N 次命令耗时</td>
<td>耗时非常短</td>
<td>实现复杂</td>
</tr>
<tr>
<td>hash_tag</td>
<td>1 次网络耗时 + N 次命令耗时</td>
<td>耗时非常短、实现简单</td>
<td>容易出现<strong>数据倾斜</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="缓存方案"><a href="#缓存方案" class="headerlink" title="缓存方案"></a>缓存方案</h3><h4 id="缓存模式"><a href="#缓存模式" class="headerlink" title="缓存模式"></a>缓存模式</h4><h5 id="旁路缓存"><a href="#旁路缓存" class="headerlink" title="旁路缓存"></a>旁路缓存</h5><p>缓存本质：弥补 CPU 的高算力和 IO 的慢读写之间巨大的鸿沟</p>
<p>旁路缓存模式 Cache Aside Pattern 是平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景</p>
<p>Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准</p>
<ul>
<li>写操作：先更新 DB，然后直接删除 cache</li>
<li>读操作：从 cache 中读取数据，读取到就直接返回；读取不到就从 DB 中读取数据返回，并放到 cache</li>
</ul>
<p>时序导致的不一致问题：</p>
<ul>
<li><p>在写数据的过程中，不能先删除 cache 再更新 DB，因为会造成缓存的不一致。比如请求 1 先写数据 A，请求 2 随后读数据 A，当请求 1 删除 cache 后，请求 2 直接读取了 DB，此时请求 1 还没写入 DB（延迟双删）</p>
</li>
<li><p>在写数据的过程中，先更新 DB 再删除 cache 也会出现问题，但是概率很小，因为缓存的写入速度非常快</p>
</li>
</ul>
<p>旁路缓存的缺点：</p>
<ul>
<li>首次请求数据一定不在 cache 的问题，一般采用缓存预热的方法，将热点数据可以提前放入 cache 中</li>
<li>写操作比较频繁的话导致 cache 中的数据会被频繁被删除，影响缓存命中率</li>
</ul>
<p><strong>删除缓存而不是更新缓存的原因</strong>：每次更新数据库都更新缓存，造成无效写操作较多（懒惰加载，需要的时候再放入缓存）</p>
<hr>
<h5 id="读写穿透"><a href="#读写穿透" class="headerlink" title="读写穿透"></a>读写穿透</h5><p>读写穿透模式 Read&#x2F;Write Through Pattern：服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中，cache 负责将此数据同步写入 DB，从而减轻了应用程序的职责</p>
<ul>
<li><p>写操作：先查 cache，cache 中不存在，直接更新 DB；cache 中存在则先更新 cache，然后 cache 服务更新 DB（同步更新 cache 和 DB）</p>
</li>
<li><p>读操作：从 cache 中读取数据，读取到就直接返回 ；读取不到先从 DB 加载，写入到 cache 后返回响应</p>
<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，对客户端是透明的</p>
</li>
</ul>
<p>Read-Through Pattern 也存在首次不命中的问题，采用缓存预热解决</p>
<hr>
<h5 id="异步缓存"><a href="#异步缓存" class="headerlink" title="异步缓存"></a>异步缓存</h5><p>异步缓存写入 Write Behind Pattern 由 cache 服务来负责 cache 和 DB 的读写，对比读写穿透不同的是 Write Behind Caching 是只更新缓存，不直接更新 DB，改为<strong>异步批量</strong>的方式来更新 DB，可以减小写的成本</p>
<p>缺点：这种模式对数据一致性没有高要求，可能出现 cache 还没异步更新 DB，服务就挂掉了</p>
<p>应用：</p>
<ul>
<li><p>DB 的写性能非常高，适合一些数据经常变化又对数据一致性要求不高的场景，比如浏览量、点赞量</p>
</li>
<li><p>MySQL 的 InnoDB Buffer Pool 机制用到了这种策略</p>
</li>
</ul>
<hr>
<h4 id="缓存一致"><a href="#缓存一致" class="headerlink" title="缓存一致"></a>缓存一致</h4><p>使用缓存代表不需要强一致性，只需要最终一致性</p>
<p>缓存不一致的方法：</p>
<ul>
<li><p>数据库和缓存数据强一致场景：</p>
<ul>
<li><p>同步双写：更新 DB 时同样更新 cache，保证在一个事务中，通过加锁来保证更新 cache 时不存在线程安全问题</p>
</li>
<li><p>延迟双删：先淘汰缓存再写数据库，休眠 1 秒再次淘汰缓存，可以将 1 秒内造成的缓存脏数据再次删除</p>
</li>
<li><p>异步通知：</p>
<ul>
<li>基于 MQ 的异步通知：对数据的修改后，代码需要发送一条消息到 MQ 中，缓存服务监听 MQ 消息</li>
<li>Canal 订阅 MySQL binlog 的变更上报给 Kafka，系统监听 Kafka 消息触发缓存失效，或者直接将变更发送到处理服务，<strong>没有任何代码侵入</strong></li>
</ul>
<p>低耦合，可以同时通知多个缓存服务，但是时效性一般，可能存在中间不一致状态</p>
</li>
</ul>
</li>
<li><p>低一致性场景：</p>
<ul>
<li>更新 DB 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样就可以保证即使数据不一致影响也比较小</li>
<li>使用 Redis 自带的内存淘汰机制</li>
</ul>
</li>
</ul>
<hr>
<h4 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h4><h5 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h5><p>场景：宕机，服务器启动后迅速宕机</p>
<p>问题排查：</p>
<ol>
<li><p>请求数量较高，大量的请求过来之后都需要去从缓存中获取数据，但是缓存中又没有，此时从数据库中查找数据然后将数据再存入缓存，造成了短期内对 redis 的高强度操作从而导致问题</p>
</li>
<li><p>主从之间数据吞吐量较大，数据同步操作频度较高</p>
</li>
</ol>
<p>解决方案：</p>
<ul>
<li><p>前置准备工作：</p>
<ol>
<li><p>日常例行统计数据访问记录，统计访问频度较高的热点数据</p>
</li>
<li><p>利用 LRU 数据删除策略，构建数据留存队列例如：storm 与 kafka 配合</p>
</li>
</ol>
</li>
<li><p>准备工作：</p>
<ol>
<li><p>将统计结果中的数据分类，根据级别，redis 优先加载级别较高的热点数据</p>
</li>
<li><p>利用分布式多服务器同时进行数据读取，提速数据加载过程</p>
</li>
<li><p>热点数据主从同时预热</p>
</li>
</ol>
</li>
<li><p>实施：</p>
<ol start="4">
<li><p>使用脚本程序固定触发数据预热过程</p>
</li>
<li><p>如果条件允许，使用了 CDN（内容分发网络），效果会更好</p>
</li>
</ol>
</li>
</ul>
<p>总的来说：缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据</p>
<hr>
<h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><p>场景：数据库服务器崩溃，一连串的问题会随之而来</p>
<p>问题排查：在一个较短的时间内，<strong>缓存中较多的 key 集中过期</strong>，此周期内请求访问过期的数据 Redis 未命中，Redis 向数据库获取数据，数据库同时收到大量的请求无法及时处理。</p>
<p>解决方案：</p>
<ol>
<li>加锁，慎用</li>
<li>设置热点数据永远不过期，如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中</li>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生</li>
<li>构建<strong>多级缓存</strong>架构，Nginx 缓存 + Redis 缓存 + ehcache 缓存</li>
<li>灾难预警机制，监控 Redis 服务器性能指标，CPU 使用率、内存容量、平均响应时间、线程数</li>
<li><strong>限流、降级</strong>：短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li>
</ol>
<p>总的来说：缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现（约 40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p>
<hr>
<h5 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h5><p>缓存击穿也叫热点 Key 问题</p>
<ol>
<li><p><strong>Redis 中某个 key 过期，该 key 访问量巨大</strong></p>
</li>
<li><p>多个数据请求从服务器直接压到 Redis 后，均未命中</p>
</li>
<li><p>Redis 在短时间内发起了大量对数据库中同一数据的访问</p>
</li>
</ol>
<p>解决方案：</p>
<ol>
<li><p>预先设定：以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息 key 的过期时长 注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</p>
</li>
<li><p>现场调整：监控访问量，对自然流量激增的数据<strong>延长过期时间或设置为永久性 key</strong></p>
</li>
<li><p>后台刷新数据：启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</p>
</li>
<li><p><strong>二级缓存</strong>：设置不同的失效时间，保障不会被同时淘汰就行</p>
</li>
<li><p>加锁：分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重</p>
</li>
</ol>
<p>总的来说：缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中 Redis 后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个 key 的过期监控难度较高，配合雪崩处理策略即可</p>
<hr>
<h5 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h5><p>场景：系统平稳运行过程中，应用服务器流量随时间增量较大，Redis 服务器命中率随时间逐步降低，Redis 内存平稳，内存无压力，Redis 服务器 CPU 占用激增，数据库服务器压力激增，数据库崩溃</p>
<p>问题排查：</p>
<ol>
<li><p>Redis 中大面积出现未命中</p>
</li>
<li><p>出现非正常 URL 访问</p>
</li>
</ol>
<p>问题分析：</p>
<ul>
<li>访问了不存在的数据，跳过了 Redis 缓存，数据库页查询不到对应数据</li>
<li>Redis 获取到 null 数据未进行持久化，直接返回</li>
<li>出现黑客攻击服务器</li>
</ul>
<p>解决方案：</p>
<ol>
<li><p>缓存 null：对查询结果为 null 的数据进行缓存，设定短时限，例如 30-60 秒，最高 5 分钟</p>
</li>
<li><p>白名单策略：提前预热各种分类<strong>数据 id 对应的 bitmaps</strong>，id 作为 bitmaps 的 offset，相当于设置了数据白名单。当加载正常数据时放行，加载异常数据时直接拦截（效率偏低），也可以使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）</p>
</li>
<li><p>实时监控：实时监控 Redis 命中率（业务正常范围时，通常会有一个波动值）与 null 数据的占比</p>
<ul>
<li>非活动时段波动：通常检测 3-5 倍，超过 5 倍纳入重点排查对象</li>
<li>活动时段波动：通常检测10-50 倍，超过 50 倍纳入重点排查对象</li>
</ul>
<p>根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控</p>
</li>
<li><p>key 加密：临时启动防灾业务 key，对 key 进行业务层传输加密服务，设定校验程序，过来的 key 校验；例如每天随机分配 60 个加密串，挑选 2 到 3 个，混淆到页面数据 id 中，发现访问 key 不满足规则，驳回数据访问</p>
</li>
</ol>
<p>总的来说：缓存击穿是指访问了不存在的数据，跳过了合法数据的 Redis 数据缓存阶段，<strong>每次访问数据库</strong>，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除</p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV15y4y1r7X3">https://www.bilibili.com/video/BV15y4y1r7X3</a></p>
<hr>
<h3 id="Key-设计"><a href="#Key-设计" class="headerlink" title="Key 设计"></a>Key 设计</h3><p>大 Key：通常以 Key 的大小和 Key 中成员的数量来综合判定，引发的问题：</p>
<ul>
<li>客户端执行命令的时长变慢</li>
<li>Redis 内存达到 maxmemory 定义的上限引发操作阻塞或重要的 Key 被逐出，甚至引发内存溢出（OOM）</li>
<li>集群架构下，某个数据分片的内存使用率远超其他数据分片，使<strong>数据分片的内存资源不均衡</strong></li>
<li>对大 Key 执行读请求，会使 Redis 实例的带宽使用率被占满，导致自身服务变慢，同时易波及相关的服务</li>
<li>对大 Key 执行删除操作，会造成主库较长时间的阻塞，进而可能引发同步中断或主从切换</li>
</ul>
<p>热 Key：通常以其接收到的 Key 被请求频率来判定，引发的问题：</p>
<ul>
<li>占用大量的 CPU 资源，影响其他请求并导致整体性能降低</li>
<li>分布式集群架构下，产生<strong>访问倾斜</strong>，即某个数据分片被大量访问，而其他数据分片处于空闲状态，可能引起该数据分片的连接数被耗尽，新的连接建立请求被拒绝等问题</li>
<li>在抢购或秒杀场景下，可能因商品对应库存 Key 的请求量过大，超出 Redis 处理能力造成超卖</li>
<li>热 Key 的请求压力数量超出 Redis 的承受能力易造成缓存击穿，即大量请求将被直接指向后端的存储层，导致存储访问量激增甚至宕机，从而影响其他业务</li>
</ul>
<p>参考文档：<a href="https://help.aliyun.com/document_detail/353223.html">https://help.aliyun.com/document_detail/353223.html</a></p>
<hr>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p>Redis 中的监控指标如下：</p>
<ul>
<li><p>性能指标：Performance</p>
<p>响应请求的平均时间：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">latency</span><br></pre></td></tr></table></figure>

<p>平均每秒处理请求总数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">instantaneous_ops_per_sec</span><br></pre></td></tr></table></figure>

<p>缓存查询命中率（通过查询总次数与查询得到非nil数据总次数计算而来）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hit_rate(calculated)</span><br></pre></td></tr></table></figure>
</li>
<li><p>内存指标：Memory</p>
<p>当前内存使用量：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">used_memory</span><br></pre></td></tr></table></figure>

<p>内存碎片率（关系到是否进行碎片整理）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mem_fragmentation_ratio</span><br></pre></td></tr></table></figure>

<p>为避免内存溢出删除的key的总数量：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">evicted_keys</span><br></pre></td></tr></table></figure>

<p>基于阻塞操作（BLPOP等）影响的客户端数量：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">blocked_clients</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本活动指标：Basic_activity</p>
<p>当前客户端连接总数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">connected_clients</span><br></pre></td></tr></table></figure>

<p>当前连接 slave 总数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">connected_slaves</span><br></pre></td></tr></table></figure>

<p>最后一次主从信息交换距现在的秒：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">master_last_io_seconds_ago</span><br></pre></td></tr></table></figure>

<p>key 的总数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">keyspace</span><br></pre></td></tr></table></figure>
</li>
<li><p>持久性指标：Persistence</p>
<p>当前服务器其最后一次 RDB 持久化的时间：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rdb_last_save_time</span><br></pre></td></tr></table></figure>

<p>当前服务器最后一次 RDB 持久化后数据变化总量：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rdb_changes_since_last_save</span><br></pre></td></tr></table></figure>
</li>
<li><p>错误指标：Error</p>
<p>被拒绝连接的客户端总数（基于达到最大连接值的因素）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rejected_connections</span><br></pre></td></tr></table></figure>

<p>key未命中的总次数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">keyspace_misses</span><br></pre></td></tr></table></figure>

<p>主从断开的秒数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">master_link_down_since_seconds</span><br></pre></td></tr></table></figure></li>
</ul>
<p>要对 Redis 的相关指标进行监控，我们可以采用一些用具：</p>
<ul>
<li>CloudInsight Redis</li>
<li>Prometheus</li>
<li>Redis-stat</li>
<li>Redis-faina</li>
<li>RedisLive</li>
<li>zabbix</li>
</ul>
<p>命令工具：</p>
<ul>
<li><p>benchmark</p>
<p>测试当前服务器的并发性能：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-benchmark [-h ] [-p ] [-c ] [-n &lt;requests]&gt; [-k ]</span><br></pre></td></tr></table></figure>

<p>范例：100 个连接，5000 次请求对应的性能</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-benchmark -c 100 -n 5000</span><br></pre></td></tr></table></figure>

<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-redis-benchmark%E6%8C%87%E4%BB%A4.png"></p>
</li>
<li><p>redis-cli</p>
<p>monitor：启动服务器调试信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">monitor</span><br></pre></td></tr></table></figure>

<p>slowlog：慢日志</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slowlog [operator]    <span class="comment">#获取慢查询日志</span></span><br></pre></td></tr></table></figure>

<ul>
<li>get ：获取慢查询日志信息</li>
<li>len ：获取慢查询日志条目数</li>
<li>reset ：重置慢查询日志</li>
</ul>
<p>相关配置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">slowlog-log-slower-than 1000 <span class="comment">#设置慢查询的时间下线，单位：微妙</span></span><br><span class="line">slowlog-max-len 100	<span class="comment">#设置慢查询命令对应的日志显示长度，单位：命令数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>JDBC（Java DataBase Connectivity，Java 数据库连接）是一种用于执行 SQL 语句的 Java API，可以为多种关系型数据库提供统一访问，是由一组用 Java 语言编写的类和接口组成的。</p>
<p>JDBC 是 Java 官方提供的一套规范（接口），用于帮助开发人员快速实现不同关系型数据库的连接</p>
<hr>
<h3 id="功能类"><a href="#功能类" class="headerlink" title="功能类"></a>功能类</h3><h4 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h4><p>DriverManager：驱动管理对象</p>
<ul>
<li><p>注册驱动：</p>
<ul>
<li><p>注册给定的驱动：<code>public static void registerDriver(Driver driver)</code></p>
</li>
<li><p>代码实现语法：<code>Class.forName(&quot;com.mysql.jdbc.Driver)</code></p>
</li>
<li><p>com.mysql.jdbc.Driver 中存在静态代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不需要通过 DriverManager 调用静态方法 registerDriver，因为 Driver 类被使用，则自动执行静态代码块完成注册驱动</p>
</li>
<li><p>jar 包中 META-INF 目录下存在一个 java.sql.Driver 配置文件，文件中指定了 com.mysql.jdbc.Driver</p>
</li>
</ul>
</li>
<li><p>获取数据库连接并返回连接对象：</p>
<p>方法：<code>public static Connection getConnection(String url, String user, String password)</code></p>
<ul>
<li>url：指定连接的路径，语法为 <code>jdbc:mysql://ip地址(域名):端口号/数据库名称</code></li>
<li>user：用户名</li>
<li>password：密码</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>Connection：数据库连接对象</p>
<ul>
<li>获取执行者对象<ul>
<li>获取普通执行者对象：<code>Statement createStatement()</code></li>
<li>获取预编译执行者对象：<code>PreparedStatement prepareStatement(String sql)</code></li>
</ul>
</li>
<li>管理事务<ul>
<li>开启事务：<code>setAutoCommit(boolean autoCommit)</code>，false 开启事务，true 自动提交模式（默认）</li>
<li>提交事务：<code>void commit()</code></li>
<li>回滚事务：<code>void rollback()</code></li>
</ul>
</li>
<li>释放资源<ul>
<li>释放此 Connection 对象的数据库和 JDBC 资源：<code>void close()</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h4><p>Statement：执行 sql 语句的对象</p>
<ul>
<li>执行 DML 语句：<code>int executeUpdate(String sql)</code><ul>
<li>返回值 int：返回影响的行数</li>
<li>参数 sql：可以执行 insert、update、delete 语句</li>
</ul>
</li>
<li>执行 DQL 语句：<code>ResultSet executeQuery(String sql)</code><ul>
<li>返回值 ResultSet：封装查询的结果</li>
<li>参数 sql：可以执行 select 语句</li>
</ul>
</li>
<li>释放资源<ul>
<li>释放此 Statement 对象的数据库和 JDBC 资源：<code>void close()</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h4><p>ResultSet：结果集对象，ResultSet 对象维护了一个游标，指向当前的数据行，初始在第一行</p>
<ul>
<li>判断结果集中是否有数据：<code>boolean next()</code><ul>
<li>有数据返回 true，并将索引<strong>向下移动一行</strong></li>
<li>没有数据返回 false</li>
</ul>
</li>
<li>获取结果集中<strong>当前行</strong>的数据：<code>XXX getXxx(&quot;列名&quot;)</code><ul>
<li>XXX 代表数据类型（要获取某列数据，这一列的数据类型）</li>
<li>例如：String getString(“name”);   int getInt(“age”);</li>
</ul>
</li>
<li>释放资源<ul>
<li>释放 ResultSet 对象的数据库和 JDBC 资源：<code>void close()</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>数据准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建db14数据库</span><br><span class="line">CREATE DATABASE db14;</span><br><span class="line"></span><br><span class="line">-- 使用db14数据库</span><br><span class="line">USE db14;</span><br><span class="line"></span><br><span class="line">-- 创建student表</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">	sid INT PRIMARY KEY AUTO_INCREMENT,	-- 学生id</span><br><span class="line">	NAME VARCHAR(20),					-- 学生姓名</span><br><span class="line">	age INT,							-- 学生年龄</span><br><span class="line">	birthday DATE,						-- 学生生日</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO student VALUES (NULL,&#x27;张三&#x27;,23,&#x27;1999-09-23&#x27;),(NULL,&#x27;李四&#x27;,24,&#x27;1998-08-10&#x27;),</span><br><span class="line">(NULL,&#x27;王五&#x27;,25,&#x27;1996-06-06&#x27;),(NULL,&#x27;赵六&#x27;,26,&#x27;1994-10-20&#x27;);</span><br></pre></td></tr></table></figure>

<p>JDBC 连接代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.导入jar包</span></span><br><span class="line">        <span class="comment">//2.注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://192.168.2.184:3306/db2&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取执行者对象</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stat</span> <span class="operator">=</span> con.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.执行sql语句，并且接收结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user&quot;</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stat.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.处理结果</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            System.out.println(rs.getInt(<span class="string">&quot;id&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.释放资源</span></span><br><span class="line">        con.close();</span><br><span class="line">        stat.close();</span><br><span class="line">        con.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<hr>
<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul>
<li><p>配置文件（在 src 下创建 config.properties）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://192.168.2.184:3306/db14</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtils</span> &#123;</span><br><span class="line">    <span class="comment">//1.私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">JDBCUtils</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明配置信息变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driverClass;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection con;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.静态代码块中实现加载配置文件和注册驱动</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//通过类加载器返回配置文件的字节流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> JDBCUtils.class.getClassLoader().</span><br><span class="line">                	getResourceAsStream(<span class="string">&quot;config.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建Properties集合，加载流对象的信息</span></span><br><span class="line">            <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            prop.load(is);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取信息为变量赋值</span></span><br><span class="line">            driverClass = prop.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line">            url = prop.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            username = prop.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">            password = prop.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//注册驱动</span></span><br><span class="line">            Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.获取数据库连接的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con = DriverManager.getConnection(url,username,password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.释放资源的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection con, Statement stat, ResultSet rs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(con != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stat != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stat.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//方法重载，可能没有返回值对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection con, Statement stat)</span> &#123;</span><br><span class="line">        close(con,stat,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p>从数据库读取数据并封装成 Student 对象，需要：</p>
<ul>
<li><p>Student 类成员变量对应表中的列</p>
</li>
<li><p>所有的基本数据类型需要使用包装类，<strong>以防 null 值无法赋值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer sid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    ........</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建db14数据库</span><br><span class="line">CREATE DATABASE db14;</span><br><span class="line"></span><br><span class="line">-- 使用db14数据库</span><br><span class="line">USE db14;</span><br><span class="line"></span><br><span class="line">-- 创建student表</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">	sid INT PRIMARY KEY AUTO_INCREMENT,	-- 学生id</span><br><span class="line">	NAME VARCHAR(20),					-- 学生姓名</span><br><span class="line">	age INT,							-- 学生年龄</span><br><span class="line">	birthday DATE						-- 学生生日</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO student VALUES (NULL,&#x27;张三&#x27;,23,&#x27;1999-09-23&#x27;),(NULL,&#x27;李四&#x27;,24,&#x27;1998-08-10&#x27;),(NULL,&#x27;王五&#x27;,25,&#x27;1996-06-06&#x27;),(NULL,&#x27;赵六&#x27;,26,&#x27;1994-10-20&#x27;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作数据库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDaoImpl</span>&#123;</span><br><span class="line">	<span class="comment">//查询所有学生信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Student&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. </span></span><br><span class="line">        ArrayList&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//2.获取数据库连接</span></span><br><span class="line">			con = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">           	<span class="comment">//3.获取执行者对象</span></span><br><span class="line">           	stat = con.createStatement();</span><br><span class="line"></span><br><span class="line">           	<span class="comment">//4.执行sql语句，并且接收返回的结果集</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM student&quot;</span>;</span><br><span class="line">           	rs = stat.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">          	<span class="comment">//5.处理结果集</span></span><br><span class="line">           	<span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">sid</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;sid&quot;</span>);</span><br><span class="line">               	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">               	<span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">               	<span class="type">Date</span> <span class="variable">birthday</span> <span class="operator">=</span> rs.getDate(<span class="string">&quot;birthday&quot;</span>);</span><br><span class="line"></span><br><span class="line">               	<span class="comment">//封装Student对象</span></span><br><span class="line">               	<span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(sid,name,age,birthday);</span><br><span class="line">               	<span class="comment">//将student对象保存到集合中</span></span><br><span class="line">               	list.add(stu);</span><br><span class="line">           	&#125;</span><br><span class="line">       	&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">           	e.printStackTrace();</span><br><span class="line">       	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           	<span class="comment">//6.释放资源</span></span><br><span class="line">           	JDBCUtils.close(con,stat,rs);</span><br><span class="line">       	&#125;</span><br><span class="line">		<span class="comment">//将集合对象返回</span></span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加学生信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            con = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.获取执行者对象</span></span><br><span class="line">            stat = con.createStatement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.执行sql语句，并且接收返回的结果集</span></span><br><span class="line">            <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> stu.getBirthday();</span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">birthday</span> <span class="operator">=</span> sdf.format(d);</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO student VALUES (&#x27;&quot;</span>+stu.getSid()+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+stu.getName()+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+stu.getAge()+<span class="string">&quot;&#x27;,&#x27;&quot;</span>+birthday+<span class="string">&quot;&#x27;)&quot;</span>;</span><br><span class="line">            result = stat.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//6.释放资源</span></span><br><span class="line">            JDBCUtils.close(con,stat);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将结果返回</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="注入攻击"><a href="#注入攻击" class="headerlink" title="注入攻击"></a>注入攻击</h3><h4 id="攻击演示"><a href="#攻击演示" class="headerlink" title="攻击演示"></a>攻击演示</h4><p>SQL 注入攻击演示</p>
<ul>
<li><p>在登录界面，输入一个错误的用户名或密码，也可以登录成功 </p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E6%BC%94%E7%A4%BA.png"></p>
</li>
<li><p>原理：我们在密码处输入的所有内容，都应该认为是密码的组成，但是 Statement 对象在执行 SQL 语句时，将一部分内容当做查询条件来执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user WHERE loginname=&#x27;aaa&#x27; AND password=&#x27;aaa&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="攻击解决"><a href="#攻击解决" class="headerlink" title="攻击解决"></a>攻击解决</h4><p>PreparedStatement：预编译 sql 语句的执行者对象，继承 <code>PreparedStatement extends Statement</code></p>
<ul>
<li>在执行 sql 语句之前，将 sql 语句进行提前编译，<strong>明确 sql 语句的格式</strong>，剩余的内容都会认为是参数</li>
<li>sql 语句中的参数使用 ? 作为<strong>占位符</strong></li>
</ul>
<p>为 ? 占位符赋值的方法：<code>setXxx(int parameterIndex, xxx data)</code></p>
<ul>
<li><p>参数1：? 的位置编号（编号从 1 开始）</p>
</li>
<li><p>参数2：? 的实际参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user WHERE loginname=? AND password=?&quot;</span>;</span><br><span class="line">pst = con.prepareStatement(sql);</span><br><span class="line">pst.setString(<span class="number">1</span>,loginName);</span><br><span class="line">pst.setString(<span class="number">2</span>,password);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>执行 sql 语句的方法</p>
<ul>
<li>执行 insert、update、delete 语句：<code>int executeUpdate()</code></li>
<li>执行 select 语句：<code>ResultSet executeQuery()</code></li>
</ul>
<hr>
<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>数据库连接背景：数据库连接是一种关键的、有限的、昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。</p>
<p>数据库连接池：<strong>数据库连接池负责分配、管理和释放数据库连接</strong>，它允许应用程序<strong>重复使用</strong>一个现有的数据库连接，而不是再重新建立一个，这项技术能明显提高对数据库操作的性能。</p>
<p>数据库连接池原理</p>
<p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3.png"></p>
<hr>
<h4 id="自定义池"><a href="#自定义池" class="headerlink" title="自定义池"></a>自定义池</h4><p>DataSource 接口概述：</p>
<ul>
<li>java.sql.DataSource 接口：数据源（数据库连接池）</li>
<li>Java 中 DataSource 是一个标准的数据源接口，官方提供的数据库连接池规范，连接池类实现该接口</li>
<li>获取数据库连接对象：<code>Connection getConnection()</code></li>
</ul>
<p>自定义连接池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDataSource</span> <span class="keyword">implements</span> <span class="title class_">DataSource</span>&#123;</span><br><span class="line">    <span class="comment">//1.定义集合容器，用于保存多个数据库连接对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Connection&gt; pool = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Connection&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.静态代码块，生成10个数据库连接保存到集合中</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line">            pool.add(con);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.返回连接池的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pool.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.从池中返回一个数据库连接</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pool.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//从池中获取数据库连接</span></span><br><span class="line">            <span class="keyword">return</span> pool.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;连接数量已用尽&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试连接池功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDataSourceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建数据库连接池对象</span></span><br><span class="line">        <span class="type">MyDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDataSource</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用之前连接池数量：&quot;</span> + dataSource.getSize());<span class="comment">//10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取数据库连接对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(con.getClass());<span class="comment">// JDBC4Connection</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询学生表全部信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM student&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pst.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            System.out.println(rs.getInt(<span class="string">&quot;sid&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getString(<span class="string">&quot;name&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getInt(<span class="string">&quot;age&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getDate(<span class="string">&quot;birthday&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        rs.close();</span><br><span class="line">        pst.close();</span><br><span class="line">		<span class="comment">//目前的连接对象close方法，是直接关闭连接，而不是将连接归还池中</span></span><br><span class="line">        con.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用之后连接池数量：&quot;</span> + dataSource.getSize());<span class="comment">//9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：释放资源并没有把连接归还给连接池</p>
<hr>
<h4 id="归还连接"><a href="#归还连接" class="headerlink" title="归还连接"></a>归还连接</h4><p>归还数据库连接的方式：继承方式、装饰者设计者模式、适配器设计模式、动态代理方式</p>
<h5 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h5><p>继承（无法解决）</p>
<ul>
<li>通过打印连接对象，发现 DriverManager 获取的连接实现类是 JDBC4Connection</li>
<li>自定义一个类，继承 JDBC4Connection 这个类，重写 close() 方法</li>
<li>查看 JDBC 工具类获取连接的方法发现：虽然自定义了一个子类，完成了归还连接的操作。但是 DriverManager 获取的还是 JDBC4Connection 这个对象，并不是我们的子类对象</li>
</ul>
<p>代码实现</p>
<ul>
<li><p>自定义继承连接类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义一个类，继承JDBC4Connection</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConnection1</span> <span class="keyword">extends</span> <span class="title class_">JDBC4Connection</span>&#123;</span><br><span class="line">    <span class="comment">//2.定义Connection连接对象和容器对象的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> Connection con;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Connection&gt; pool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通过有参构造方法为成员变量赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyConnection1</span><span class="params">(String hostToConnectTo, <span class="type">int</span> portToConnectTo, Properties info, String databaseToConnectTo, String url,Connection con,List&lt;Connection&gt; pool)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="built_in">super</span>(hostToConnectTo, portToConnectTo, info, databaseToConnectTo, url);</span><br><span class="line">        <span class="built_in">this</span>.con = con;</span><br><span class="line">        <span class="built_in">this</span>.pool = pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.重写close方法，完成归还连接</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        pool.add(con);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义连接池类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将之前的连接对象换成自定义的子类对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> MyConnection1 con;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.获取数据库连接的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//等效于：MyConnection1 con = new JDBC4Connection();  语法错误！</span></span><br><span class="line">        con = DriverManager.getConnection(url,username,password);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="装饰者"><a href="#装饰者" class="headerlink" title="装饰者"></a>装饰者</h5><p>自定义类实现 Connection 接口，通过装饰设计模式，实现和 mysql 驱动包中的 Connection 实现类相同的功能</p>
<p>在实现类对每个获取的 Connection 进行装饰：把连接和连接池参数传递进行包装</p>
<p>特点：通过装饰设计模式连接类我们发现，有很多需要重写的方法，代码太繁琐</p>
<ul>
<li><p>装饰设计模式类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义一个类，实现Connection接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConnection2</span> <span class="keyword">implements</span> <span class="title class_">Connection</span> &#123;</span><br><span class="line">    <span class="comment">//2.定义Connection连接对象和连接池容器对象的变量</span></span><br><span class="line">    <span class="keyword">private</span> Connection con;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Connection&gt; pool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyConnection2</span><span class="params">(Connection con,List&lt;Connection&gt; pool)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.con = con;</span><br><span class="line">        <span class="built_in">this</span>.pool = pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.在close()方法中，完成连接的归还</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        pool.add(con);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.剩余方法，只需要调用mysql驱动包的连接对象完成即可</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Statement <span class="title function_">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> con.createStatement();</span><br><span class="line">    &#125;</span><br><span class="line">    ..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义连接池类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(pool.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//从池中获取数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> pool.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//通过自定义连接对象进行包装</span></span><br><span class="line">        <span class="type">MyConnection2</span> <span class="variable">mycon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyConnection2</span>(con,pool);</span><br><span class="line">        <span class="comment">//返回包装后的连接对象</span></span><br><span class="line">        <span class="keyword">return</span> mycon;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;连接数量已用尽&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h5><p>使用适配器设计模式改进，提供一个适配器类，实现 Connection 接口，将所有功能进行实现（除了 close 方法），自定义连接类只需要继承这个适配器类，重写需要改进的 close() 方法即可。</p>
<p>特点：自定义连接类中很简洁。剩余所有的方法抽取到了适配器类中，但是适配器这个类还是我们自己编写。</p>
<ul>
<li><p>适配器类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MyAdapter</span> <span class="keyword">implements</span> <span class="title class_">Connection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义数据库连接对象的变量</span></span><br><span class="line">    <span class="keyword">private</span> Connection con;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造方法赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAdapter</span><span class="params">(Connection con)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.con = con;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的方法，均调用mysql的连接对象实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Statement <span class="title function_">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> con.createStatement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义连接类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConnection3</span> <span class="keyword">extends</span> <span class="title class_">MyAdapter</span> &#123;</span><br><span class="line">    <span class="comment">//2.定义Connection连接对象和连接池容器对象的变量</span></span><br><span class="line">    <span class="keyword">private</span> Connection con;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Connection&gt; pool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供有参构造方法，接收连接对象和连接池对象，对变量赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyConnection3</span><span class="params">(Connection con,List&lt;Connection&gt; pool)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(con);    <span class="comment">// 将接收的数据库连接对象给适配器父类传递</span></span><br><span class="line">        <span class="built_in">this</span>.con = con;</span><br><span class="line">        <span class="built_in">this</span>.pool = pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.在close()方法中，完成连接的归还</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        pool.add(con);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义连接池类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从池中返回一个数据库连接</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(pool.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//从池中获取数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> pool.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//通过自定义连接对象进行包装</span></span><br><span class="line">        <span class="type">MyConnection3</span> <span class="variable">mycon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyConnection3</span>(con,pool);</span><br><span class="line">        <span class="comment">//返回包装后的连接对象</span></span><br><span class="line">        <span class="keyword">return</span> mycon;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;连接数量已用尽&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>使用动态代理的方式来改进</p>
<p>自定义数据库连接池类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDataSource</span> <span class="keyword">implements</span> <span class="title class_">DataSource</span> &#123;</span><br><span class="line">    <span class="comment">//1.准备一个容器。用于保存多个数据库连接对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Connection&gt; pool = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.定义静态代码块,获取多个连接对象保存到容器中</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line">            pool.add(con);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.提供一个获取连接池大小的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pool.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//动态代理方式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">if</span>(pool.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> pool.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">proxyCon</span> <span class="operator">=</span> (Connection) Proxy.newProxyInstance(</span><br><span class="line">                con.getClass().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Connection.class&#125;, </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    执行Connection实现类连接对象所有的方法都会经过invoke</span></span><br><span class="line"><span class="comment">                    如果是close方法，归还连接</span></span><br><span class="line"><span class="comment">                    如果不是，直接执行连接对象原有的功能即可</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;close&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">//归还连接</span></span><br><span class="line">                        pool.add(con);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> method.invoke(con,args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> proxyCon;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;连接数量已用尽&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h4><h5 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h5><p>使用 C3P0 连接池：</p>
<ul>
<li><p>配置文件名称：c3p0-config.xml，必须放在 src 目录下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用默认的配置读取连接池对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!--  连接参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql://192.168.2.184:3306/db14<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 连接池参数 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--初始化数量--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--最大连接数量--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--超时时间 3000ms--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;checkoutTimeout&quot;</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;otherc3p0&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--  连接参数 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池参数 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C3P0Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.创建c3p0的数据库连接池对象</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.通过连接池对象获取数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.执行操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM student&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.执行sql语句，接收结果集</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pst.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.处理结果集</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            System.out.println(rs.getInt(<span class="string">&quot;sid&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getString(<span class="string">&quot;name&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getInt(<span class="string">&quot;age&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getDate(<span class="string">&quot;birthday&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.释放资源</span></span><br><span class="line">        rs.close();   pst.close();   con.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h5><p>Druid 连接池：</p>
<ul>
<li><p>配置文件：druid.properties，必须放在 src 目录下</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://192.168.2.184:3306/db14</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取配置文件的流对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> DruidTest1.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.通过Properties集合，加载配置文件</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        prop.load(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.通过Druid连接池工厂类获取数据库连接池对象</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过连接池对象获取数据库连接进行使用</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//4.执行sql语句，接收结果集</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM student&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pst.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.处理结果集</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            System.out.println(rs.getInt(<span class="string">&quot;sid&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getString(<span class="string">&quot;name&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getInt(<span class="string">&quot;age&quot;</span>) + <span class="string">&quot;\t&quot;</span> + rs.getDate(<span class="string">&quot;birthday&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.释放资源</span></span><br><span class="line">        rs.close();   pst.close();   con.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="工具类-1"><a href="#工具类-1" class="headerlink" title="工具类"></a>工具类</h4><p>数据库连接池的工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceUtils</span> &#123;</span><br><span class="line">    <span class="comment">//1.私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DataSourceUtils</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明数据源变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供静态代码块，完成配置文件的加载和获取数据库连接池对象</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//完成配置文件的加载</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> DataSourceUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            prop.load(is);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取数据库连接池对象</span></span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.提供一个获取数据库连接的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con = dataSource.getConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.提供一个获取数据库连接池对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.释放资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection con, Statement stat, ResultSet rs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(con != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stat != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stat.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//方法重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection con, Statement stat)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(con != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stat != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stat.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Jedis 用于 Java 语言连接 Redis 服务，并提供对应的操作 API</p>
<ul>
<li><p>jar 包导入</p>
<p>下载地址：<a href="https://mvnrepository.com/artifact/redis.clients/jedis">https://mvnrepository.com/artifact/redis.clients/jedis</a></p>
<p>基于 maven：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端连接 Redis：API 文档 <a href="http://xetorthio.github.io/jedis/">http://xetorthio.github.io/jedis/</a></p>
<p>连接 redis：<code>Jedis jedis = new Jedis(&quot;192.168.0.185&quot;, 6379)</code></p>
<p>操作 redis：<code>jedis.set(&quot;name&quot;, &quot;seazean&quot;);  jedis.get(&quot;name&quot;)</code></p>
<p>关闭 redis：<code>jedis.close()</code></p>
</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取连接对象</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.2.185&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//2.执行操作</span></span><br><span class="line">        jedis.set(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;39&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(hello);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;list1&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list1 = jedis.lrange(<span class="string">&quot;list1&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s:list1 ) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.sadd(<span class="string">&quot;set1&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;poi&quot;</span>,<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">len</span> <span class="operator">=</span> jedis.scard(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line">        System.out.println(len);</span><br><span class="line">        <span class="comment">//3.关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="工具类-2"><a href="#工具类-2" class="headerlink" title="工具类"></a>工具类</h3><p>连接池对象：</p>
<ul>
<li>JedisPool：Jedis 提供的连接池技术</li>
<li>poolConfig：连接池配置对象 </li>
<li>host：Redis 服务地址</li>
<li>port：Redis 服务端口号</li>
</ul>
<p>JedisPool 的构造器如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">JedisPool</span><span class="params">(GenericObjectPoolConfig poolConfig, String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>(poolConfig, host, port, <span class="number">2000</span>, (String)<span class="literal">null</span>, <span class="number">0</span>, (String)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建配置文件 redis.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">redis.maxTotal</span>=<span class="string">50</span></span><br><span class="line"><span class="attr">redis.maxIdel</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">redis.host</span>=<span class="string">192.168.2.185</span></span><br><span class="line"><span class="attr">redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> maxTotal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> maxIdel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPoolConfig jpc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">bundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;redis&quot;</span>);</span><br><span class="line">        <span class="comment">//最大连接数</span></span><br><span class="line">        maxTotal = Integer.parseInt(bundle.getString(<span class="string">&quot;redis.maxTotal&quot;</span>));</span><br><span class="line">        <span class="comment">//活动连接数</span></span><br><span class="line">        maxIdel = Integer.parseInt(bundle.getString(<span class="string">&quot;redis.maxIdel&quot;</span>));</span><br><span class="line">        host = bundle.getString(<span class="string">&quot;redis.host&quot;</span>);</span><br><span class="line">        port = Integer.parseInt(bundle.getString(<span class="string">&quot;redis.port&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Jedis连接配置</span></span><br><span class="line">        jpc = <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        jpc.setMaxTotal(maxTotal);</span><br><span class="line">        jpc.setMaxIdle(maxIdel);</span><br><span class="line">        <span class="comment">//连接池对象</span></span><br><span class="line">        jp = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jpc, host, port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外访问接口，提供jedis连接对象，连接从连接池获取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jp.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>DataSource</category>
      </categories>
      <tags>
        <tag>DataSource</tag>
      </tags>
  </entry>
</search>
